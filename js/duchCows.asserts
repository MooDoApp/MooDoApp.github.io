{"x_jsVersion":1403041791456,"map":{"lib/almond":{"path":"F:/p/bce/Duchess/public/js/lib/almond.js","data":"/**\n * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n","asserts":[]},"main":{"path":"F:/p/bce/Duchess/public/js/main.js","data":"if (typeof DEBUG === 'undefined') { DEBUG = true; }\r\nif (typeof REPORT_ACTIONS === 'undefined') { REPORT_ACTIONS = DEBUG; }\r\n\r\nError.stackTraceLimit = 150;\r\n\r\ntry\r\n{\r\n\r\nwindow.__checkpoints |= 0x1;\r\n\r\nwindow.__SESSION_ID = (Math.round(Math.random() * 10000) + '|' + Date.now());\r\nwindow.appEvents = window.appEvents || {\r\n    kbsize: function(){},\r\n    enterBackground: function(){},\r\n    enterForeground: function(){},\r\n    statusBarTap: function(){},\r\n    undo: function(){},\r\n    redo: function(){},\r\n    reportLowMemory: function(){}\r\n};\r\n\r\n//if (DEBUG)\r\n{\r\n    window.log = (DEBUG && (window.location.hash.indexOf('phantom=true') >= 0)) ? function () { } : console.log.bind(console);\r\n    //window.logTable = console.table ? console.table.bind(console) : console.log.bind(console);\r\n\r\n    if (!window.performance || !window.performance.now)\r\n    {\r\n        window.performance = { now: function() { return Date.now() - window.performance.start; } };\r\n        window.performance.start = Date.now();\r\n        window.log.now = performance.now;\r\n    }\r\n    else\r\n    {\r\n        window.performance.start = window.performance.now();\r\n        window.log.now = function()\r\n        {\r\n            return window.performance.now() - window.performance.start;\r\n        };\r\n    }\r\n\r\n    if (!console.timeStamp)\r\n    {\r\n        console.timeStamp = function () { };\r\n    }\r\n\r\n    if (!console.time)\r\n    {\r\n        console.time = function () { };\r\n    }\r\n\r\n    if (!console.timeEnd)\r\n    {\r\n        console.timeEnd = function () { };\r\n    }\r\n\r\n    if (!console.trace)\r\n    {\r\n        console.trace = function () { };\r\n    }\r\n\r\n    window.LogLevels = {\r\n        Off:        0x00000,\r\n        Error:      0x00001,\r\n        Warning:    0x00002,\r\n        Timing:     0x00004,\r\n        Data:       0x00008,\r\n        Status:     0x00010,\r\n        Search:     0x00020,\r\n        Timeline:   0x00040,\r\n        Input:      0x00080,\r\n        Tracker:    0x00100,\r\n        Profile:    0x00200,\r\n        PageLoad:   0x00400,\r\n        Toolbar:    0x00800,\r\n        Picker:     0x01000,\r\n        Intro:      0x02000,\r\n        Import:     0x04000,\r\n        Version:    0x08000,\r\n        Settings:   0x10000,\r\n        Selection:  0x20000,\r\n        Verbose:    0x40000,\r\n    };\r\n\r\n    window.LogLevel = LogLevels.Error | LogLevels.Warning;\r\n\r\n    window.ShouldLog = function(mask)\r\n    {\r\n        return ((window.DEBUG) === mask);\r\n    };\r\n\r\n    window.logIf = function()\r\n    {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if(ShouldLog)\r\n        {\r\n            args.splice(0, 1);\r\n            window.log.apply(this, args);\r\n        }\r\n    };\r\n\r\n    function makeLogger(i)\r\n    {\r\n        window.log[i] = function()\r\n        {\r\n            if(window.DEBUG)\r\n            {\r\n                log.apply(console, arguments);\r\n            }\r\n        };\r\n    };\r\n\r\n    for(var i in LogLevels)\r\n    {\r\n        makeLogger(i);\r\n    }\r\n\r\n    //if (DEBUG)\r\n    {\r\n        // window.inspectRemote = function(input)\r\n        // {\r\n        //     if (!input)\r\n        //     {\r\n        //         log('Must specify either an item ID or item object to inspect');\r\n        //         return;\r\n        //     }\r\n\r\n        //     if (!window.remoteDoc)\r\n        //     {\r\n        //         log('Must have a remote doc loaded to inspect an item');\r\n        //         return;\r\n        //     }\r\n\r\n        //     var lookupTable = window.remoteDoc.b.b.a.e.R.n;\r\n\r\n        //     var item = input;\r\n        //     if ((typeof input) == \"string\")\r\n        //     {\r\n        //         item = lookupTable[':' + input];\r\n        //     }\r\n\r\n        //     // On Remote Item:\r\n        //     // Item ID: M\r\n        //     // Type: Jb\r\n        //     // Collab Children: v.o\r\n        //     // Collab Child Count: v.i\r\n        //     // Non-Collab Children: f.o\r\n        //     // Non-Collab Child Count: f.i\r\n        //     //\r\n        //     // On Lookup Entry:\r\n        //     // ParentID(s): ua.p??\r\n        //     // Has Event Listeners: item.p\r\n        //     // Event Listeners: item.g\r\n        //     //\r\n\r\n        //     //var type = item.Ib;\r\n        //     var type = (lookupTable[':' + item.r].hasOwnProperty('n') ? \"List\" : (lookupTable[':' + item.r].hasOwnProperty('i') ? \"Map\" : \"EditableString\"));\r\n        //     log('---- Inspecting Item:', item.r, '----');\r\n        //     log('  Type: ', item.f);\r\n\r\n        //     // log('  Collaborative Children: [', item.v.i, ']');\r\n        //     // var collabKeys = Object.keys(item.v.o);\r\n        //     // for (var i = 0; i < collabKeys.length; ++i)\r\n        //     // {\r\n        //     //     var keyValue = item.v.o[collabKeys[i]];\r\n        //     //     log('    [', collabKeys[i].substring(1), ']: ', keyValue);\r\n        //     // }\r\n\r\n        //     if (type === \"Map\")\r\n        //     {\r\n        //         log('  Properties: [', item.i.i, ']');\r\n        //         var nonCollabKeys = Object.keys(item.i.n);\r\n        //         for (var i = 0; i < nonCollabKeys.length; ++i)\r\n        //         {\r\n        //             var ncKey = nonCollabKeys[i].substring(1);\r\n        //             var ncKeyTrans = window.fieldTranslation[ncKey];\r\n\r\n        //             var keyValue = item.i.n[':' + ncKey];\r\n        //             var keyType = (keyValue.Ib ? keyValue.Ib : undefined);\r\n\r\n        //             if (keyType === \"EditableString\")\r\n        //             {\r\n        //                 log('    [', ncKeyTrans, '- \\\"' + keyValue.L +'\\\"]: ', keyValue.e.a.a);\r\n        //             }\r\n        //             else if (keyType === \"List\")\r\n        //             {\r\n        //                 log('    [', ncKeyTrans, '- \\\"' + keyValue.L +'\\\"]: ', keyValue);\r\n\r\n        //                 for (var j = 0; j < keyValue.f.a.length; ++j)\r\n        //                 {\r\n        //                     var child = keyValue.f.a[j];\r\n        //                     log('        [', j, ']: ', child.a);\r\n        //                 }\r\n        //             }\r\n        //             else\r\n        //             {\r\n        //                 var displayValue = keyValue.a;\r\n\r\n        //                 if (ncKeyTrans === \"date\" || ncKeyTrans === \"dateCreated\")\r\n        //                 {\r\n        //                     displayValue = new Date(parseInt(displayValue));\r\n        //                 }\r\n\r\n        //                 log('    [', ncKeyTrans, ']: ', displayValue);\r\n        //             }\r\n        //         }\r\n        //     }\r\n        //     else if (type === \"List\")\r\n        //     {\r\n        //         log('  Children: [', item.f.e, ']');\r\n        //         for (var i = 0; i < item.f.a.length; ++i)\r\n        //         {\r\n        //             var child = item.f.a[i];\r\n        //             log('    [', i, ']: ', child);\r\n        //         }\r\n        //     }\r\n        //     else if (type === \"EditableString\")\r\n        //     {\r\n        //         log('  Value: ', item.e.a.a);\r\n        //     }\r\n\r\n        //     log('--------------------------------------------');\r\n\r\n        //     return item;\r\n        // };\r\n\r\n        window.inspectLocal = function(input)\r\n        {\r\n            if (!input)\r\n            {\r\n                log('Must specify either an item ID or item object to inspect');\r\n                return;\r\n            }\r\n\r\n            var item = input;\r\n            if ((typeof input) == \"string\")\r\n            {\r\n                item = window.getModel(input);\r\n            }\r\n\r\n            log('---- Inspecting Item:', item.id, '----');\r\n            log('  RawText:', item.getRawText());\r\n            log('  ParsedText:', item.getParsedText());\r\n            log('  StyledText:', item.getStyledText());\r\n            log('  Parent: \\\"' + item.parent().id + '\\\"');\r\n            log('  Date:', item.date());\r\n            log('  AllDayDate:', item.allDayDate);\r\n            //log('  LastModified:', item.lastModified);\r\n            log('--------------------------------------------');\r\n\r\n            return item;\r\n        }\r\n    }\r\n}\r\n\r\n}\r\ncatch (err)\r\n{\r\n    log('Error in main header');\r\n\r\n    window.__ERRORINMAINHEADER = err;\r\n}\r\n\r\n/////////////////////////////////////////\r\n/////////////////////////////////////////\r\n/////////////////////////////////////////\r\nif (DEBUG && DEBUG) console.profile('Page Load');\r\n/////////////////////////////////////////\r\n/////////////////////////////////////////\r\n/////////////////////////////////////////\r\n\r\n(function (){\r\nif (DEBUG)\r\n{\r\n    if (window.location.protocol !== 'chrome-extension:')\r\n    {\r\n        var rqConfig = {\r\n            paths: {\r\n                \"ko\": \"lib/knockout-2.3.0.custom.debug\",\r\n                \"date\": \"lib/date\",\r\n                'FileSaver': 'lib/FileSaver',\r\n                'IndexedDBShim': 'lib/IndexedDBShim',\r\n                'db': 'lib/db'\r\n            },\r\n            waitSeconds: 0\r\n        };\r\n    }\r\n    else\r\n    {\r\n        var rqConfig = {\r\n            paths: {\r\n                \"ko\": \"lib/knockout-latest.debug\",\r\n                \"kos\": \"lib/knockout-secure-binding\",\r\n                \"date\": \"lib/date\",\r\n                'FileSaver': 'lib/FileSaver',\r\n                'IndexedDBShim': 'lib/IndexedDBShim',\r\n                'db': 'lib/db'\r\n            },\r\n            waitSeconds: 0\r\n        };\r\n    }\r\n}\r\nelse\r\n{\r\n    var rqConfig = {\r\n        paths: {\r\n            \"ko\": \"lib/knockout-2.3.0.custom\",\r\n            \"date\": \"lib/date\",\r\n            'FileSaver': 'lib/FileSaver',\r\n            'IndexedDBShim': 'lib/IndexedDBShim.min',\r\n            'db': 'lib/db'\r\n        },\r\n        waitSeconds: 15\r\n    };\r\n}\r\n\r\nrequire.config(rqConfig);\r\n\r\n})();\r\n\r\nwindow.gapiKey = \"AIzaSyB9HEdSJ-nhLJG_ssSSqhI2DX74GSiKSao\";\r\n\r\nif (DEBUG || window.location.hash.indexOf('gtest=true') >= 0)\r\n{\r\n    log('Loading DEBUG version of RealtimeAPI');\r\n\r\n    window['___gcfg'] = { 'drive-realtime': { 'server': 'https://drive.sandbox.google.com/otservice' } };\r\n}\r\n\r\n//\r\n// Google API callback\r\n//\r\nvar gapiCalled = false;\r\nvar gapiLoadError = false;\r\nfunction GoogleApiLoaded()\r\n{\r\n    if (gapiCalled)\r\n    {\r\n        //console.error('GAPI Init function expection to be called exactly once');\r\n        return;\r\n    }\r\n\r\n    gapiCalled = true;\r\n    gapi.auth.init(); // Always call init on load so popup doesn't get blocked later\r\n\r\n    if (window.location.hash.indexOf('offline=true') >= 0 ||\r\n        window.location.hash.indexOf('offline%22:true') >= 0 ||\r\n        window.location.hash.indexOf('offline\":true') >= 0 ||\r\n        window.location.hash.indexOf('demo=true') >= 0 ||\r\n        (DEBUG && DEBUG))\r\n    {\r\n        log('%cOffline', 'color: pink');\r\n\r\n        return;\r\n    }\r\n\r\n    if (DEBUG) log('GAPI Callback - Loaded:', log.now());\r\n\r\n    gapi.client.setApiKey(window.gapiKey);\r\n\r\n    // Simulate bad/slow internet connection by delaying the loading of gapi.\r\n    // setTimeout(function ()\r\n    // {\r\n        gapi.load('drive-realtime', function()\r\n        {\r\n            if (DEBUG) log('Drive-Realtime API - Loaded: ', window.performance.now());\r\n\r\n            // We received a couple error reports of crashing after the drive api was not loaded properly. Try to harden\r\n            // calls so we don't crash and instead go offline and collect additional data.\r\n            if (!gapi || !gapi.drive || !gapi.drive.realtime)\r\n            {\r\n                var loadArgs = arguments;\r\n\r\n                require(['globals', 'platform'], function (g, platform)\r\n                {\r\n                    var errorString;\r\n                    if (gapi)\r\n                    {\r\n                        if (gapi.drive)\r\n                        {\r\n                            if (gapi.drive.realtime)\r\n                            {\r\n                                errorString = 'all exist';\r\n                            }\r\n                            else\r\n                            {\r\n                                errorString = 'gapi.drive.realtime';\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            errorString = 'gapi.drive';\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        errorString = 'gapi';\r\n                    }\r\n\r\n                    // Reset gapi status\r\n                    gapiCalled = false;\r\n                    gapiLoadError = true;\r\n\r\n                    g.reportError(new Error('Drive returned load, but unable to load ' + errorString));\r\n\r\n                    var msgEle = document.getElementById('blockedMessage');\r\n                    if (platform.app)\r\n                    {\r\n                        msgEle.innerText = 'There was an error loading the Google APIs, ' + platform.actionVerb() + ' to try again.';\r\n                    }\r\n                    else\r\n                    {\r\n                        msgEle.innerText = 'You are running an extension that blocked drive.google.com from loading, Moo.do requires access to function correctly.';\r\n                    }\r\n\r\n                    document.getElementById('blockedError').classList.remove('none');\r\n\r\n                    if (g.vmMain)\r\n                    {\r\n                        g.vmMain.gdriveStatus(DriveStatus.Offline);\r\n                    }\r\n                });\r\n            }\r\n            else\r\n            {\r\n                require(['globals', 'goog'], function (g, goog)\r\n                {\r\n                    goog.loadClientDefaultFile();\r\n\r\n                    g.removeDOM('blockedError');\r\n                });\r\n            }\r\n        });\r\n\r\n        require(['globals', 'util', 'platform', 'goog', 'VMSetup'], function (g, util, platform, goog, VMSetup)\r\n        {\r\n            if (DEBUG) log('Goog Callback - Loaded: ', log.now());\r\n\r\n            var setTokenFromHash = false;\r\n            if (!platform.ie || platform.mobile)\r\n            {\r\n                setTokenFromHash = goog.checkTokenInHash();\r\n            }\r\n\r\n            var doLogin = setTokenFromHash || util.hasURLParam('login', 'true') || g.getLoginState() == LoginState.LOGGED_IN;\r\n\r\n            // Request scopes that have been previously authorized for the user, if these scopes are not authenticated,\r\n            // show the login screen to get the user to re-authenticate with the required set of OAuth scopes.\r\n            goog.runAuthenticate(goog.requestScopes, /*immediate*/true, /*retry*/false, function (token)\r\n            {\r\n                if (DEBUG) log('Goog Authorized - Callback: ', log.now());\r\n\r\n                util.removeURLParam('login', true);\r\n\r\n                if (token && !token.error)\r\n                {\r\n                    if (doLogin)\r\n                    {\r\n                        g.vmSetup ? g.vmSetup.setLoginState(LoginState.LOGGED_IN) : g.setLoginState(LoginState.LOGGED_IN);\r\n\r\n                        goog.loadClientDefaultFile();\r\n\r\n                        g.openMainPage();\r\n                    }\r\n\r\n                    goog.ensureRequiredScopesAreRequested();\r\n                }\r\n                else\r\n                {\r\n                    if (goog.requiredScopes !== goog.requestScopes)\r\n                    {\r\n                        g.settings.reset(Settings.authScopes);\r\n\r\n                        goog.runAuthenticate(goog.requiredScopes, /*immediate*/true, /*retry*/false, function (token2)\r\n                        {\r\n                            if (token2 && !token2.error)\r\n                            {\r\n                                if (doLogin)\r\n                                {\r\n                                    g.vmSetup ? g.vmSetup.setLoginState(LoginState.LOGGED_IN) : g.setLoginState(LoginState.LOGGED_IN);\r\n\r\n                                    goog.loadClientDefaultFile();\r\n\r\n                                    g.openMainPage();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                g.vmSetup ? g.vmSetup.setLoginState(LoginState.LOGGED_OUT) : g.setLoginState(LoginState.LOGGED_OUT);\r\n\r\n                                g.openSetupPage();\r\n                            }\r\n                        });\r\n                    }\r\n                    else\r\n                    {\r\n                        g.vmSetup ? g.vmSetup.setLoginState(LoginState.LOGGED_OUT) : g.setLoginState(LoginState.LOGGED_OUT);\r\n\r\n                        g.openSetupPage();\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    // }, 3000);\r\n}\r\n\r\nrequirejs(['ko', 'kos', 'data', 'globals', 'util', 'gdata', 'goog', 'platform', 'edit', 'VMMain', 'VMSetup', 'VMDebug', 'VMTimeline', 'VMSearch', 'VMMessageQueue', 'TemplateCache', 'VMAutocomplete', 'VMMenus', 'ScreenManager', 'VMTooltip', 'AppCache', 'DuchessHelpers'],\r\nfunction(ko, kos, d, g, util, gdata, goog, platform, edit, VMMain, VMSetup, VMDebug, VMTimeline, VMSearch, VMMessageQueue, TemplateCache, VMAutocomplete, VMMenus, ScreenManager, VMTooltip, AppCache)\r\n{\r\n\r\ng.checkpoint(Checkpoint.RequireLoaded);\r\n\r\nif (window.__ERRORINMAINHEADER)\r\n{\r\n    g.reportError(window.__ERRORINMAINHEADER);\r\n}\r\n\r\nif (DEBUG && platform.packagedApp)\r\n{\r\n    var options = {\r\n        attribute: \"data-bind\",       // include legacy data-bind values\r\n        globals: window,              // globals\r\n        bindings: ko.bindingHandlers, // still use default binding handlers\r\n        noVirtualElements: false      // virtual elements\r\n    };\r\n\r\n    ko.bindingProvider.instance = new kos(options);\r\n}\r\n\r\ng.runOnLoad(function ()\r\n{\r\ntry\r\n{\r\n    g.checkpoint(Checkpoint.PageLoad);\r\n\r\n    g.Assert(document.readyState !== 'loading', 'Should only be calling mainjs after document is loaded' + document.readyState);\r\n\r\n    if (document.readyState === 'loading')\r\n    {\r\n        var errString = 'ERROR: MainJS running before document load! ' + document.readyState;\r\n        if (ShouldLog(LogLevels.Error)) log(errString);\r\n\r\n        g.reportError(new Error(errString));\r\n    }\r\n\r\n    // Handle Script Load Errors\r\n    for (var scriptError in window.scriptErrors)\r\n    {\r\n        g.fireCustomEvent('scriptLoadError', { src: scriptError, id: window.scriptErrors[scriptError], firstChance: true });\r\n    }\r\n\r\n    window.handleLoadError = function handleLoadErrorSecondChanceFn(e)\r\n    {\r\n        try\r\n        {\r\n            window.scriptErrors[e.target.src] = e.target.id;\r\n\r\n            g.fireCustomEvent('scriptLoadError', { src: e.target.src, id: e.target.id, firstChance: false });\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n    }\r\n\r\n    if (DEBUG && platform.mobile && !platform.android && !platform.ie)\r\n    {\r\n        window.onclick = function(e)\r\n        {\r\n            g.Assert(false, 'Click should not be getting through to the window on mobile', e);\r\n        };\r\n    }\r\n\r\n    // TODO: Do we actually want to do this?\r\n    if (!DEBUG)\r\n    {\r\n        window.oncontextmenu = function(e)\r\n        {\r\n            e.preventDefault();\r\n        };\r\n    }\r\n\r\n    if (platform.demo)\r\n    {\r\n        if (!g.messageQueue)\r\n        {\r\n            g.messageQueue = new VMMessageQueue();\r\n        }\r\n\r\n        g.enableDemoMode();\r\n    }\r\n\r\n    //g.enableMinMode(DisplayMode.FullMin);\r\n    if (g.isDemoMode() && platform.script)\r\n    {\r\n        var dmode = util.getURLParam('dmode');\r\n        if (dmode)\r\n        {\r\n            g.enableMinMode(dmode);\r\n        }\r\n\r\n        var panesStart = util.getURLParam('panes');\r\n\r\n        if (panesStart)\r\n        {\r\n            g.demoPanes = panesStart.split(':');\r\n        }\r\n    }\r\n    else if (!DEBUG)\r\n    {\r\n        g.removeDOM('preventInteraction');\r\n    }\r\n\r\n    setTimeout(function ()\r\n    {\r\n        g.sendEvent('PageLoad', 'NewPage');\r\n    }, 0);\r\n\r\n    {\r\n        function setupEvent(name)\r\n        {\r\n            document.documentElement.addEventListener(name, function (e)\r\n            {\r\n                if (DEBUG && DEBUG)\r\n                {\r\n                    console.log('CAPTURE: ' + name + ': ' + g.elementToString(e.target) + g.elementToString(e.relatedTarget));\r\n                }\r\n\r\n                g.reportEvent(e);\r\n            }, true);\r\n\r\n            document.documentElement.addEventListener(name, function (e)\r\n            {\r\n                if (DEBUG && DEBUG)\r\n                {\r\n                    console.log('BUBBLE: ' + name + ': ' + g.elementToString(e.target) + g.elementToString(e.relatedTarget));\r\n                }\r\n\r\n                //g.reportEvent(e);\r\n            }, false);\r\n        }\r\n\r\n        // setupEvent('textInput');\r\n        // setupEvent('input');\r\n        setupEvent('keydown');\r\n        setupEvent('keyup');\r\n        setupEvent('keypress');\r\n\r\n        setupEvent('MSPointerDown');\r\n        //setupEvent('MSPointerMove');\r\n        setupEvent('MSPointerUp');\r\n        //setupEvent('MSPointerOver');\r\n        //setupEvent('MSPointerOut');\r\n        setupEvent('MSPointerHover');\r\n        setupEvent('MSPointerCancel');\r\n        setupEvent('mousedown');\r\n        //setupEvent('mousemove');\r\n        setupEvent('mouseup');\r\n        //setupEvent('mouseover');\r\n        setupEvent('touchstart');\r\n        //setupEvent('touchmove');\r\n        setupEvent('touchend');\r\n\r\n        // setupEvent('focusin');\r\n        // setupEvent('focusout');\r\n    }\r\n\r\n\r\n    if (!g.messageQueue)\r\n    {\r\n        g.messageQueue = new VMMessageQueue();\r\n    }\r\n\r\n    g.tooltip = new VMTooltip();\r\n\r\n    // AppCache needs to be created before calling blockClient which may result in an early out. If this is\r\n    // not called first, then each time the app is updated, the cached page will remain out of date unless\r\n    // the app is refreshed. This is due to the AppCache being responsible for automatically updating the page\r\n    // which would not happen when the app sends a new app version.\r\n    g.AppCache = new AppCache();\r\n\r\n    g.StartSpinner();\r\n\r\n    var erroredPlatform = platform.blockClient();\r\n\r\n    if (erroredPlatform !== undefined)\r\n    {\r\n        var text;\r\n        var showSignup = false;\r\n        if (erroredPlatform.platform)\r\n        {\r\n            if (erroredPlatform.update)\r\n            {\r\n                if(erroredPlatform.platform == 'Firefox')\r\n                {\r\n                    text = 'Please update your Firefox browser to use Moo.do. Moo.do requires at least Firefox 16. See <a href=\"https://support.mozilla.org/en-US/kb/update-firefox-latest-version\">https://support.mozilla.org/en-US/kb/update-firefox-latest-version</a> for more information.';\r\n                }\r\n                else if(erroredPlatform.platform == 'Chrome')\r\n                {\r\n                    text = 'Please update your Chrome browser to use Moo.do. Moo.do requires at least Chrome 26. See <a href=\"https://support.google.com/chrome/answer/95414\">https://support.google.com/chrome/answer/95414</a> for more information.';\r\n                }\r\n                else if(erroredPlatform.platform == 'Native Android')\r\n                {\r\n                    // What to do?\r\n                    text = 'Please update your Android device to use Moo.do. Moo.do requires at least Android 2.1.';\r\n                }\r\n                else if(erroredPlatform.platform == 'Internet Explorer')\r\n                {\r\n                    text = 'Please update your Internet Explorer browser to use Moo.do. Moo.do requires at least Internet Explorer 10. See <a href=\"http://windows.microsoft.com/en-us/internet-explorer/download-ie\">http://windows.microsoft.com/en-us/internet-explorer/download-ie</a> for more information.';\r\n                }\r\n                else if(erroredPlatform.platform == 'Safari')\r\n                {\r\n                    if(platform.mobile)\r\n                    {\r\n                        text = 'Please update your ' + platform.OSName + ' to use Moo.do. Moo.do requires at least iOS 6.';\r\n                    }\r\n                    else\r\n                    {\r\n                        text = 'Please update your Safari browser to use Moo.do. Moo.do requires at least Safari 6.1. See <a href=\"http://support.apple.com/kb/HT6103\">http://support.apple.com/kb/HT6103</a> for more information.';\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    text = 'Please update your browser to use Moo.do. If you are unable to update your browser, please let us know. Thanks!';\r\n                    showSignup = true;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                showSignup = true;\r\n\r\n                text = \"Sorry, we don't support \" + erroredPlatform.platform +\r\n                    \" yet. Please let us know that you're interested in using \" + erroredPlatform.platform +\r\n                    \" and we will make it a higher priority. Thanks!\";\r\n            }\r\n        }\r\n        else if (erroredPlatform.version)\r\n        {\r\n            text = \"Please update to the latest version of this app by opening the TestFlight app and installing the latest version. Thanks!\";\r\n        }\r\n        else if (erroredPlatform.cacheUpdate)\r\n        {\r\n            text = \"There was an issue while updating the app, \" + platform.actionVerb() + \" to try again.\";\r\n\r\n            g.AppCache.update();\r\n\r\n            if (erroredPlatform.error)\r\n            {\r\n                g.AppCache.runOnFinish(function ()\r\n                {\r\n                    util.insertURLParam('cacheError', true);\r\n                }, /*isTerminal*/true);\r\n            }\r\n        }\r\n\r\n        if (text)\r\n        {\r\n            function submitFn()\r\n            {\r\n                return g.requestNotification(navigator.userAgent);\r\n            }\r\n\r\n            function refreshFn()\r\n            {\r\n                g.AppCache.runOnFinish(function ()\r\n                {\r\n                    g.reload();\r\n                }, /*isTerminal*/true);\r\n            }\r\n\r\n            g.applyBindings({ platformError: text, showSignup: showSignup, onTapRefresh: refreshFn, onTapSubmit: submitFn }, 'OSError');\r\n        }\r\n\r\n        g.StopSpinner();\r\n\r\n        g.removeDOM('outerWrapper');\r\n        g.removeDOM('setupWrapper');\r\n        g.removeDOM('templates');\r\n\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        util.removeURLParam('cacheError', /*noReload*/true);\r\n\r\n        g.removeDOM('OSError');\r\n    }\r\n\r\n    // IE fire localStorage change events for the tab that made the change. We shouldn't display an error message\r\n    // when the user is simply changing files in IE.\r\n    g.localDocChangeRequested = false;\r\n\r\n    g.settings.initEvents(function (e)\r\n    {\r\n        //log('Storage Event: ', e);\r\n\r\n        if (e.key === 'localSettings')\r\n        {\r\n            var oldValue;\r\n            if (e.oldValue)\r\n            {\r\n                oldValue = JSON.parse(e.oldValue);\r\n            }\r\n\r\n            var newValue;\r\n            if (e.newValue)\r\n            {\r\n                newValue = JSON.parse(e.newValue);\r\n            }\r\n\r\n            if (oldValue && newValue)\r\n            {\r\n                // When switching between documents, it is essential that no further modifications are done\r\n                // in other tabs. Immedietly refresh the page.\r\n                if (!g.localDocChangeRequested && oldValue.gdocId && oldValue.gdocId !== newValue.gdocId)\r\n                {\r\n                    g.messageQueue.pushMessage(MessageID.DocChange);\r\n\r\n                    setTimeout(function ()\r\n                    {\r\n                        // Refresh the page after 10 seconds automatically\r\n                        g.reload();\r\n                    }, 10000);\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    g.ScreenManager = new ScreenManager(document.getElementById('main'));\r\n    g.menus = new VMMenus();\r\n    g.vmDebug = new VMDebug();\r\n\r\n    window.addEventListener('remoteDataLoaded', function ()\r\n    {\r\n        var fileForceID = util.getURLParam('file');\r\n\r\n        var stateInfo = util.getURLParam('state');\r\n\r\n        if (fileForceID || stateInfo)\r\n        {\r\n            if (!fileForceID)\r\n            {\r\n                try\r\n                {\r\n                    var stateObj = JSON.parse(stateInfo);\r\n\r\n                    if (stateObj.action === 'open')\r\n                    {\r\n                        if (stateObj.ids && stateObj.ids.length >= 0)\r\n                        {\r\n                            fileForceID = stateObj.ids[0];\r\n                        }\r\n                    }\r\n                }\r\n                catch (err)\r\n                {\r\n                    g.reportError(err);\r\n                }\r\n            }\r\n\r\n            var currentDocID = goog.getDocId();\r\n\r\n            if (fileForceID && currentDocID !== fileForceID)\r\n            {\r\n                g.messageQueue.pushMessage({\r\n                    text: 'You have requested to view another document, ' + platform.actionVerb() + ' here to open it.',\r\n                    type: MessageType.Info,\r\n                    action: function ()\r\n                    {\r\n                        g.Assert(g.vmMain && g.vmMain.vmPicker, 'VMMain must be initialized before loading another doc');\r\n\r\n                        g.vmMain.vmPicker.requestOpenDocument(fileForceID);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    var windowResize = function (e)\r\n    {\r\n        var w = window.innerWidth;\r\n        var h = window.innerHeight;\r\n\r\n        var oldWidth = platform.windowWidth();\r\n        var oldHeight = platform.windowHeight();\r\n\r\n        if (DEBUG) { log('Old Height: ' + oldHeight + '  New Height: ' + h); }\r\n\r\n        if (w == oldWidth && (h == oldHeight || h == oldHeight + 60))\r\n        {\r\n            return;\r\n        }\r\n\r\n        g.smallMode = (w <= 480);\r\n\r\n        platform.windowWidth(w);\r\n        platform.windowHeight(h);\r\n\r\n        // if(!g.windowHeightStart)\r\n        // {\r\n        //     g.windowHeightStart = h;\r\n        // }\r\n\r\n        g.documentHeight = h;\r\n\r\n        // if (g.menus && !platform.mobile)\r\n        // {\r\n        //     g.menus.updateHoverMenu();\r\n        // }\r\n\r\n        // In android and IE< if the new height is larger than the old height, it means that the\r\n        // software keyboard has closed. Due to the ways that the user can close the software keyboard\r\n        // this end sup being the only indication that it was closed and the keyboard toolbar needs\r\n        // to be hidden and editing stopped.\r\n        if ((platform.android || platform.mobileie) && h > oldHeight && g.vmMain && g.vmMain.isLoaded)\r\n        {\r\n            g.blurActiveElement();\r\n        }\r\n\r\n        // Ensure address bar is hidden on iphones.\r\n        if (platform.iphone && !platform.bodyscroll && !platform.standalone && !platform.app && !platform.ios7)\r\n        {\r\n            var height = document.documentElement.clientHeight + 60;\r\n            document.documentElement.style.height = height + 'px';\r\n            setTimeout(g.enforceScroll, 0);\r\n        }\r\n\r\n        if (g.autocomplete)\r\n        {\r\n            g.autocomplete.hide();\r\n        }\r\n\r\n        // On a page resize, ensure that snap points are recomputed\r\n        // e is to check that it's on an event, not from first load\r\n        if (oldWidth !== w && e && platform.mobile)\r\n        {\r\n            if (g.ScreenManager)\r\n            {\r\n                g.ScreenManager.onResize();\r\n            }\r\n\r\n            if (g.menus)\r\n            {\r\n                g.menus.onResize();\r\n            }\r\n        }\r\n\r\n        if (!platform.mobile)\r\n        {\r\n            g.fireCustomEvent('windowResize');\r\n        }\r\n    };\r\n\r\n    function onorientationchange()\r\n    {\r\n        platform.updateOrientation();\r\n\r\n        // if(platform.orientation === Orientation.Landscape)\r\n        // {\r\n        //     g.addClass(document.body, 'landscape');\r\n        // }\r\n        // else\r\n        // {\r\n        //     g.removeClass(document.body, 'landscape');\r\n        // }\r\n\r\n        if(platform.mobile && !platform.app)\r\n        {\r\n            if(g.keyboardToolbar && g.keyboardToolbar.isVisible())\r\n            {\r\n                g.keyboardToolbar.updatePosition(true);\r\n            }\r\n            document.body.scrollTop = 0;\r\n        }\r\n        if(platform.mobile)\r\n        {\r\n            if(g.keyboardToolbar)\r\n            {\r\n                g.keyboardToolbar.hideTopBarIfLandscape();\r\n            }\r\n        }\r\n    }\r\n\r\n    windowResize();\r\n    onorientationchange();\r\n\r\n    // setTimeout(function ()\r\n    // {\r\n    //     g.messageQueue.pushMessage({\r\n    //         text: 'This is a test message. Click to reload the page.',\r\n    //         type: MessageType.Info,\r\n    //         action: MessageAction.Reload\r\n    //     });\r\n\r\n    //     setTimeout(function ()\r\n    //     {\r\n    //         g.messageQueue.pushMessage({\r\n    //             text: 'Changes are not being saved in this demo. Click to log in.',\r\n    //             type: MessageType.Warning,\r\n    //             action: MessageAction.Login,\r\n    //             timeout: 2000\r\n    //         });\r\n    //     }, 2000);\r\n    // }, 0);\r\n\r\n    if (DEBUG) log('Running main.js: ', log.now());\r\n\r\n    if (!g.isDemoMode())\r\n    {\r\n        if (!platform.offline && window.gapi && window.gapi.auth && !gapiCalled)\r\n        {\r\n            GoogleApiLoaded();\r\n        }\r\n\r\n        // Show a message if running from the iphone browser\r\n        if(platform.ios && !platform.app && !platform.standalone)\r\n        {\r\n            if(!g.settings.get(Settings.shownInstallInfo))\r\n            {\r\n                g.messageQueue.pushMessage({\r\n                    text: 'To add this app to the home screen: tap <span class=\"ath-action-icon\">icon</span> then <strong>Add to Home Screen</strong>.',\r\n                    type: MessageType.InfoGray,\r\n                    bottom: true\r\n                });\r\n                g.settings.set(Settings.shownInstallInfo, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (platform.mobile)\r\n    {\r\n        g.removeDOM('desktopMenu');\r\n        g.removeDOM('desktopSidebar');\r\n        g.removeDOM('contextMenuItem');\r\n        g.removeDOM('contextMenuLink');\r\n        g.removeDOM('exportData');\r\n    }\r\n    else\r\n    {\r\n        g.removeDOM('phoneMenu');\r\n        g.removeDOM('mobileKeyboardToolbar');\r\n        g.removeDOM('paneSettings');\r\n\r\n        if (!platform.touch)\r\n        {\r\n            g.removeDOM('itemMenuPhone');\r\n            g.removeDOM('rightMenuPhone');\r\n        }\r\n    }\r\n\r\n    // g.setupClick($(document.getElementById('syncButton')), undefined,\r\n    // {\r\n    //     onClick: function(e) {\r\n    //         g.clearSelection();\r\n\r\n    //         // If there is an export calendar, do not bother running sync separately\r\n    //         var calendarsImport = g.settings.get(Settings.calendarsImport);\r\n    //         var calendarExport = g.settings.get(Settings.calendarExport);\r\n    //         if (!(calendarsImport.length == 1 && calendarsImport[0] == calendarExport))\r\n    //         {\r\n    //             goog.syncCalendarEvents(/*skipExport*/true);\r\n    //         }\r\n\r\n    //         goog.exportCalendarEvents();\r\n    //     }\r\n    // });\r\n\r\n    window.onblur = function ()\r\n    {\r\n        g.hasFocus = false;\r\n    };\r\n\r\n    window.onfocus = function ()\r\n    {\r\n        g.hasFocus = true;\r\n        goog.onFocusHandler();\r\n    };\r\n\r\n    g.vmMain = new VMMain();\r\n    g.timeline = new VMTimeline();\r\n\r\n    window.addEventListener('resize', windowResize);\r\n    window.addEventListener('orientationchange', windowResize);\r\n    window.addEventListener('orientationchange', onorientationchange);\r\n\r\n    // Prevent the user from dragging selected text.\r\n    window.addEventListener('dragstart', function (dragEvent)\r\n    {\r\n        dragEvent.preventDefault();\r\n        return false;\r\n    });\r\n\r\n    // Prevent the user from dropping text from external sources.\r\n    window.addEventListener('drop', function (dragEvent)\r\n    {\r\n        dragEvent.preventDefault();\r\n        return false;\r\n    });\r\n\r\n    var initializeCalled = false;\r\n    function initialize()\r\n    {\r\n        if (initializeCalled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        initializeCalled = true;\r\n\r\n        g.checkpoint(Checkpoint.InitializeMain);\r\n\r\n        g.openMainPage();\r\n\r\n\r\n        g.registerEvent('ItemCreated', 'ItemAction', 'Create');\r\n        g.registerEvent('ItemCompleted', 'ItemAction', 'Complete');\r\n\r\n        d.initData(onInitializedData);\r\n\r\n        onInitializedData();\r\n    }\r\n\r\n    var initializeDataCalled = false;\r\n    function onInitializedData()\r\n    {\r\n        try\r\n        {\r\n            if (initializeDataCalled || !initializeCalled || !d.localDataLoaded())\r\n            {\r\n                return;\r\n            }\r\n\r\n            initializeDataCalled = true;\r\n\r\n            g.checkpoint(Checkpoint.OnInitializedData);\r\n\r\n            goog.loadClientDefaultFile();\r\n\r\n            // Setup parse callbacks for date rollver before local data is loaded to ensure we don't miss\r\n            // a rollover in case the client is opened exactly at midnight\r\n            if (!g.isDemoMode())\r\n            {\r\n                g.vmMain.setupDateRollover();\r\n            }\r\n            else if (!platform.script && (!DEBUG || !DEBUG))\r\n            {\r\n                g.vmMain.openSidebar();\r\n\r\n                setTimeout(function ()\r\n                {\r\n                    g.highlightElement(document.getElementById('logoutButton'), 0.6, 1.0);\r\n                }, 0);\r\n            }\r\n\r\n            // Load local data\r\n            g.vmMain.loadData();\r\n            g.timeline.load();\r\n\r\n            g.StopSpinner();\r\n\r\n            if (DEBUG) log('Data done loading: ', log.now());\r\n\r\n            //console.timeStamp('Finished Data Init');\r\n\r\n            setTimeout(function ()\r\n            {\r\n                if (g.menus)\r\n                {\r\n                    g.menus.bind();\r\n                }\r\n\r\n                if (!g.autocomplete)\r\n                {\r\n                    g.autocomplete = new VMAutocomplete();\r\n                }\r\n            });\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n    }\r\n\r\n    //\r\n    // Create and bind setup data\r\n    //\r\n    g.vmSetup = new VMSetup();\r\n\r\n    g.vmSetup.loginState.subscribe(function (loginState)\r\n    {\r\n        if (loginState == LoginState.LOGGED_IN)\r\n        {\r\n            initialize();\r\n\r\n            g.openMainPage();\r\n        }\r\n        else if (loginState == LoginState.LOGGED_OUT)\r\n        {\r\n            if (!g.isSetupPageOpen)\r\n            {\r\n                g.isSetupPageOpen = true;\r\n\r\n                if (!util.hasURLParam('login', 'true'))\r\n                {\r\n                    g.openSetupPage();\r\n                }\r\n\r\n                g.vmSetup.openLogin();\r\n            }\r\n        }\r\n\r\n        if (platform.offline || !navigator.onLine)\r\n        {\r\n            g.vmMain.setGDriveStatus(DriveStatus.Offline);\r\n        }\r\n        else\r\n        {\r\n            g.vmMain.setGDriveStatus(DriveStatus.Connecting);\r\n        }\r\n    });\r\n\r\n    g.vmSetup.init();\r\n\r\n    if (g.isDemoMode())\r\n    {\r\n        initialize();\r\n    }\r\n\r\n    var loginState = g.getLoginState();\r\n    if (loginState != LoginState.LOGGED_OUT)\r\n    {\r\n        d.initData(initialize);\r\n    }\r\n\r\n    if (!platform.mobile)\r\n    {\r\n        var hotkeys = {};\r\n\r\n        var hotkeySearch = function()\r\n        {\r\n            if (!g.focusedPane.vmSearch.isFocused())\r\n            {\r\n                g.saveSelection('StoredSearch');\r\n            }\r\n\r\n            g.selectElement(g.focusedPane.vmSearch.elSearch, /*selectEnd*/false);\r\n\r\n            g.sendEvent('Hotkey', 'Search');\r\n            // g.vmSearch.selectedButton('searchSearch');\r\n        };\r\n        var hotkeyOutline = function()\r\n        {\r\n            g.focusedPane.toggleOutlineVisibility();\r\n\r\n            g.sendEvent('Hotkey', 'Outline');\r\n        };\r\n        var hotkeyGoto = function()\r\n        {\r\n            var item = g.getSelectedItem();\r\n\r\n            if (item)\r\n            {\r\n                for (var i = 0; i < item.elements.length; ++i)\r\n                {\r\n                    g.scrollIntoView(item.getSpan(i), 200);\r\n                }\r\n\r\n                item.highlight();\r\n            }\r\n\r\n            g.sendEvent('Hotkey', 'GoTo');\r\n        };\r\n        // var hotkeySwitchView = function()\r\n        // {\r\n        // };\r\n        // var hotkeyNew = function()\r\n        // {\r\n        //     // g.vmSearch.elSearch.focus();\r\n        //     // g.vmSearch.selectedButton('searchPlus');\r\n        // };\r\n\r\n        // var hotkeyHeader = function()\r\n        // {\r\n        //     // g.vmMain.applyPrefixToSelection(HeaderPrefix);\r\n        // };\r\n        // var hotkeyComment = function()\r\n        // {\r\n        //     g.vmMain.applyPrefixToSelection(CommentPrefix);\r\n        //     g.sendEvent('Hotkey', 'Comment');\r\n        // };\r\n        var hotkeyP0 = function()\r\n        {\r\n            g.vmMain.applyPriorityToSelection(VMLIFlag.P0, /*toggle*/true);\r\n\r\n            g.sendEvent('Hotkey', 'Important');\r\n        };\r\n        var hotkeyP1 = function()\r\n        {\r\n            g.vmMain.applyPriorityToSelection(VMLIFlag.P1, /*toggle*/true);\r\n\r\n            g.sendEvent('Hotkey', 'Important');\r\n        };\r\n        var hotkeyP2 = function()\r\n        {\r\n            g.vmMain.applyPriorityToSelection(VMLIFlag.P2, /*toggle*/true);\r\n\r\n            g.sendEvent('Hotkey', 'Important');\r\n        };\r\n        // var hotkeyQuestion = function()\r\n        // {\r\n        //     // g.vmMain.applyPrefixToSelection(QuestionPrefix);\r\n        // };\r\n        var hotkeyStar = function()\r\n        {\r\n            g.vmMain.applyFnToSelection('isFlagged', /*toggle*/true);\r\n\r\n            g.sendEvent('Hotkey', 'Star');\r\n        };\r\n        var hotkeyComplete = function()\r\n        {\r\n            g.vmMain.applyFnToSelection('isComplete', /*toggle*/true);\r\n\r\n            g.sendEvent('Hotkey', 'Complete');\r\n        };\r\n        // var hotkeyBold = function(e)\r\n        // {\r\n        //     e.preventDefault();\r\n        //     return false;\r\n        //     g.vmMain.applyFormatToSelection('b');\r\n\r\n        //     g.sendEvent('Hotkey', 'Bold');\r\n        // };\r\n        // var hotkeyItalic = function()\r\n        // {\r\n        //     e.preventDefault();\r\n        //     return false;\r\n        //     g.vmMain.applyFormatToSelection('i');\r\n\r\n        //     g.sendEvent('Hotkey', 'Italic');\r\n        // };\r\n        // var hotkeyUnderline = function()\r\n        // {\r\n        //     e.preventDefault();\r\n        //     return false;\r\n        //     g.vmMain.applyFormatToSelection('u');\r\n\r\n        //     g.sendEvent('Hotkey', 'Underline');\r\n        // };\r\n        var hotkeyZoomIn = function()\r\n        {\r\n            g.vmMain.applyToSelection(function(item)\r\n            {\r\n                g.vmMain.zoomin(item);\r\n                return false;\r\n            });\r\n\r\n            g.sendEvent('Hotkey', 'ZoomIn');\r\n        };\r\n        var hotkeyZoomOut = function()\r\n        {\r\n            if (g.focusedItem && g.focusedItem.parent())\r\n            {\r\n                var item = g.focusedItem;\r\n                g.vmMain.zoomout(item.parent(), item);\r\n            }\r\n\r\n            g.sendEvent('Hotkey', 'ZoomOut');\r\n        };\r\n        var hotkeyCollapse = function()\r\n        {\r\n            g.vmMain.applyToSelection(function(item)\r\n            {\r\n                item.toggleCollapsed();\r\n            });\r\n\r\n            g.sendEvent('Hotkey', 'Collapse');\r\n        };\r\n\r\n        var hotkeyIndent = function(e)\r\n        {\r\n            if(e.target != document.body)\r\n            {\r\n                g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: false});\r\n\r\n                g.sendEvent('Hotkey', 'Indent');\r\n            }\r\n        };\r\n\r\n        var hotkeyUnindent = function(e)\r\n        {\r\n            if(e.target != document.body)\r\n            {\r\n                g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: true});\r\n\r\n                g.sendEvent('Hotkey', 'Unindent');\r\n            }\r\n        };\r\n\r\n        var hotkeyNOP = function(e)\r\n        {\r\n            // Do Nothing\r\n        };\r\n\r\n        var hotkeyBackspace = function(e)\r\n        {\r\n            // Only prevent default if backspace is on body\r\n            if(e.target != document.body)\r\n            {\r\n                return false;\r\n            }\r\n        };\r\n\r\n        var hotkeyFireEvent = function(e)\r\n        {\r\n            var name = g.enumToString(KeyCode, e.normCode);\r\n            if(name)\r\n            {\r\n                return g.fireCustomEvent('key' + name);\r\n            }\r\n\r\n            g.sendEvent('Hotkey', 'FireEvent_' + name);\r\n        };\r\n\r\n        // 0: Ctrl, 1: Opt, 2: Meta, 3: Alt, 4: Shift\r\n        // Search hotkeys\r\n        hotkeys[KeyCode.E] =\r\n        hotkeys[KeyCode.F] = [{mods: {0: true}, call: hotkeySearch},\r\n                              {mods: {2: true}, call: hotkeySearch}];\r\n\r\n        hotkeys[KeyCode.G] = [{mods: {0: true}, call: hotkeyGoto},\r\n                              {mods: {2: true}, call: hotkeyGoto}];\r\n\r\n        hotkeys[KeyCode.O] = [{mods: {0: true}, call: hotkeyOutline},\r\n                              {mods: {2: true}, call: hotkeyOutline}];\r\n\r\n        // hotkeys[KeyCode.Tilde] = [{mods: {0: true}, call: hotkeySwitchView}];\r\n        // hotkeys[KeyCode.N] =\r\n        // hotkeys[KeyCode.NumPlus] =\r\n        // hotkeys[KeyCode.Equals] = [{mods: {0: true}, call: hotkeyNew}];\r\n        // Formatting hotkeys\r\n        hotkeys[KeyCode.Slash] = [{mods: {0: true}, call: hotkeyComplete},\r\n                                  {mods: {2: true}, call: hotkeyComplete}];\r\n        // hotkeys[KeyCode.D3] = [{mods: {0: true}, call: hotkeyHeader},\r\n        //                        {mods: {2: true}, call: hotkeyHeader}];\r\n        // hotkeys[KeyCode.Slash] = [{mods: {0: true, 4: true}, call: hotkeyQuestion},\r\n        //                           {mods: {2: true, 4: true}, call: hotkeyQuestion},\r\n        //                           {mods: {0: true}, call: hotkeyComment},\r\n        //                           {mods: {2: true}, call: hotkeyComment}];\r\n\r\n        hotkeys[KeyCode.D1] = [{mods: {0: true}, call: hotkeyP0},\r\n                               {mods: {2: true}, call: hotkeyP0}];\r\n        hotkeys[KeyCode.D2] = [{mods: {0: true}, call: hotkeyP1},\r\n                               {mods: {2: true}, call: hotkeyP1}];\r\n        hotkeys[KeyCode.D3] = [{mods: {0: true}, call: hotkeyP2},\r\n                               {mods: {2: true}, call: hotkeyP2}];\r\n        hotkeys[KeyCode.Apos] = [{mods: {0: true}, call: hotkeyStar},\r\n                                 {mods: {2: true}, call: hotkeyStar}];\r\n\r\n        // hotkeys[KeyCode.D8] = [{mods: {0: true}, call: hotkeyStar},\r\n        //                        {mods: {2: true}, call: hotkeyStar}];\r\n\r\n        // hotkeys[KeyCode.B] = [{mods: {0: true}, call: hotkeyBold},\r\n        //                       {mods: {2: true}, call: hotkeyBold}];\r\n        // hotkeys[KeyCode.I] = [{mods: {0: true}, call: hotkeyItalic},\r\n        //                       {mods: {2: true}, call: hotkeyItalic}];\r\n        // hotkeys[KeyCode.U] = [{mods: {0: true}, call: hotkeyUnderline},\r\n        //                       {mods: {2: true}, call: hotkeyUnderline}];\r\n\r\n        hotkeys[KeyCode.S] = [{mods: {0: true}, call: hotkeyNOP},\r\n                              {mods: {2: true}, call: hotkeyNOP}];\r\n\r\n        hotkeys[KeyCode.Enter] = [{mods: {0: true, 4: true}, call: hotkeyZoomOut},\r\n                                  {mods: {2: true, 4: true}, call: hotkeyZoomOut},\r\n                                  {mods: {0: true}, call: hotkeyZoomIn},\r\n                                  {mods: {2: true}, call: hotkeyZoomIn}];\r\n\r\n        hotkeys[KeyCode.Comma] = [{mods: {0: true}, call: hotkeyCollapse},\r\n                                  {mods: {2: true}, call: hotkeyCollapse}];\r\n        hotkeys[KeyCode.Period] = [{mods: {0: true}, call: hotkeyCollapse},\r\n                                   {mods: {2: true}, call: hotkeyCollapse}];\r\n\r\n        hotkeys[KeyCode.LBracket] = [{mods: {0: true}, call: hotkeyUnindent},\r\n                                     {mods: {2: true}, call: hotkeyUnindent}];\r\n        hotkeys[KeyCode.RBracket] = [{mods: {0: true}, call: hotkeyIndent},\r\n                                     {mods: {2: true}, call: hotkeyIndent}];\r\n\r\n        hotkeys[KeyCode.Escape] = [{call: hotkeyFireEvent}];\r\n\r\n        hotkeys[KeyCode.BackSpace] = [{call: hotkeyBackspace}];\r\n\r\n        function ignoreKeyOnBody(e)\r\n        {\r\n            return (((platform.mac && e.metaKey) || (!platform.mac && e.ctrlKey)) && e.normCode == KeyCode.A); // Select all\r\n        }\r\n\r\n        g.globalKeyDown = function(e)\r\n        {\r\n            var result = hotkeys[e.normCode];\r\n            if (result)\r\n            {\r\n                if (g.isFunction(result))\r\n                {\r\n                    result(e);\r\n                }\r\n                else\r\n                {\r\n                    var valid;\r\n                    for (var i = 0; i < result.length; i ++)\r\n                    {\r\n                        if( !result[i].mods ||\r\n                          ((!result[i].mods[0] || e.ctrlKey) &&\r\n                           (!result[i].mods[1] || e.optKey) &&\r\n                           (!result[i].mods[2] || e.metaKey) &&\r\n                           (!result[i].mods[3] || e.altKey) &&\r\n                           (!result[i].mods[4] || e.shiftKey)))\r\n                        {\r\n                            valid = result[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (valid)\r\n                    {\r\n                        var ret = valid.call(e);\r\n\r\n                        if (ret !== false)\r\n                        {\r\n                            e.handled = true;\r\n                            e.preventDefault();\r\n\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (e.normCode === KeyCode.Ctrl)\r\n            {\r\n                g.vmMain.updateCursor(true)\r\n            }\r\n\r\n            if (platform.android && e.srcElement === document.body)\r\n            {\r\n                if (ignoreKeyOnBody(e))\r\n                {\r\n                    e.preventDefault();\r\n\r\n                    return false;\r\n                }\r\n                else\r\n                {\r\n                    edit.keydown(null, e);\r\n                }\r\n            }\r\n        };\r\n\r\n        g.globalKeyUp = function(e)\r\n        {\r\n            platform.normalizeKeys(e);\r\n\r\n            if (e.normCode === KeyCode.Ctrl)\r\n            {\r\n                g.vmMain.updateCursor(false);\r\n            }\r\n        };\r\n\r\n        document.addEventListener('keydown', g.globalKeyDown);\r\n        document.addEventListener('keyup', g.globalKeyUp, true);\r\n    }\r\n\r\n    if (DEBUG)\r\n    {\r\n        var testFn = (DEBUG === true) ? util.getURLParam('test') : DEBUG;\r\n\r\n        require(['test'], function(test)\r\n        {\r\n            test.run(testFn);\r\n        });\r\n    }\r\n\r\n/* // Commenting out notifications temporarily - will add back in a later release\r\n    var notificationsButton = document.getElementById(\"allowNotification\");\r\n    if(window.webkitNotifications)\r\n    {\r\n        var permissionState = window.webkitNotifications.checkPermission();\r\n        if(permissionState === 0)\r\n        {\r\n            $(notificationsButton).remove();\r\n            g.notificationsEnabled = true;\r\n        }\r\n        else\r\n        {\r\n            notificationsButton.onclick=function()\r\n            {\r\n                window.webkitNotifications.requestPermission(function()\r\n                {\r\n                    if (window.webkitNotifications.checkPermission() === 0)\r\n                    {\r\n                        window.webkitNotifications.createNotification(\r\n                            null,\r\n                            'Basketcase',\r\n                            'Notifications are enabled.'\r\n                        ).show();\r\n                    }\r\n                    else\r\n                    {\r\n                        alert('Boo! You should allow notifications.');\r\n                    }\r\n                });\r\n            };\r\n        }\r\n    }\r\n    else\r\n    {\r\n         $(notificationsButton).remove();\r\n    }\r\n*/\r\n\r\n    // var themes = ['light', 'dark'];\r\n    // var $body = $(document.documentElement);\r\n\r\n    // function setTheme(theme)\r\n    // {\r\n    //     g.settings.set(Settings.theme, theme);\r\n\r\n    //     $body.addClass('changingTheme');\r\n\r\n    //     for(var i = 0; i < themes.length; i ++)\r\n    //     {\r\n    //         $body.removeClass('theme-' + themes[i]);\r\n    //     }\r\n    //     $body.addClass('theme-' + theme);\r\n\r\n    //     setTimeout(function(){\r\n    //         $body.removeClass('changingTheme');\r\n    //     }, 1000);\r\n    // }\r\n\r\n    // $('#themes input').each(function(e){\r\n    //     g.setupClick(this, undefined,\r\n    //     {\r\n    //         onClick: function(e) {\r\n    //             setTheme(e.target.value.toLowerCase());\r\n    //         }\r\n    //     });\r\n    // });\r\n\r\n    if (DEBUG && platform.live)\r\n    {\r\n        var liveReloadAddress = 'http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1';\r\n        g.addScript(liveReloadAddress);\r\n    }\r\n}\r\ncatch (mainErr)\r\n{\r\n    g.reportError(mainErr);\r\n\r\n    g.handleCriticalError();\r\n}\r\n});\r\n});\r\n","asserts":[{"tag":1480,"offset":17586},{"tag":1481,"offset":18714},{"tag":1482,"offset":28948}]},"globals":{"path":"F:/p/bce/Duchess/public/js/globals.js","data":"define(['ko', 'platform', 'util', 'date'],\nfunction (ko, platform, util) {\n\nvar self = {\n    vmMain: undefined,\n    vmDebug: undefined,\n    topBarHeight: 40,\n    phoneMainY: 40,\n    topBoxHeight: platform.phone ? 50 : 150,\n    keyboardToolbarHeight: 40,\n    hasFocus: true,\n    zoomTime: 0,\n    demoMode: false,\n    intro: undefined,\n    focusedPaneID: undefined,\n    focusedPane: undefined,\n    focusedItem: undefined,\n    //events: new EventEmitter(),\n    isScrolling: false,\n    ClickThreshold: 5,\n\n    noLocalWrites: false,\n    isLoadingRemote: false,\n\n    revealingMenu: false,\n    isKeyboardOpen: false,\n\n    // Drag/Drop Helpers\n    dragging: undefined,\n    draggingHidden: undefined,\n    dragStartInfo: { x: 0, y: 0 },\n    dragStartTimeout: undefined,\n    startDrag: undefined,\n\n    // Item Menu\n    itemMenuOpenedOn: undefined,\n\n    tempUL: document.getElementById('tempUL'),\n\n    elements: { },\n};\n\nvar g = self;\nvar android = { isEnabled: function () { return !!platform.android; } };\n\nrequire(['android'], function (droidLoad)\n{\n    android = droidLoad;\n});\n\nvar VMLI;\nrequire(['VMLI'], function (VMLILoad)\n{\n    VMLI = VMLILoad;\n});\n\n\n// window.UpdateType = {\n//     None: 0,\n//     Update: 1,\n//     Insert: 2\n// };\n\n// window.AnimationTime = {\n//     Slow: 2000,\n//     Normal: 1000,\n//     Fast: 500,\n//     VeryFast: 200\n// };\n\nwindow.KeyCode = {\n    BackSpace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    Escape: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    // TODO: What is end then?\n    // End: 35,\n    Hash: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Delete: 46,\n    D1: 49,\n    D2: 50,\n    D3: 51,\n    D4: 52,\n    D5: 53,\n    D6: 54,\n    D8: 56,\n    LAngle: 60,\n    RAngle: 62,\n    At: 64,\n    A: 65,\n    B: 66,\n    E: 69,\n    F: 70,\n    G: 71,\n    I: 73,\n    N: 78,\n    O: 79,\n    S: 83,\n    U: 85,\n    V: 86,\n    Y: 89,\n    Z: 90,\n    LeftMeta: 91,\n    RightMeta: 93,\n    NumPlus: 107,\n    Equals: 187,\n    Comma: 188,\n    Dash: 189,\n    Period: 190,\n    Slash: 191,\n    Tilde: 192,\n    LBracket: 219,\n    RBracket: 221,\n    Apos: 222\n};\n\n// window.ButtonCode = {\n//     None:   -1,\n//     Left:    0,\n//     Middle:  1,\n//     Right:   2\n// };\n\nwindow.TextSpace = '\\uFEFF';\n\nself.PhoneWidth = 480;\n\nwindow.DriveStatus = {\n    Offline:    0,\n    Connecting: 1,\n    Saving:     2,\n    Saved:      3,\n};\n\nwindow.PaneMode = {\n    Normal:   1,\n    Timeline: 2,\n};\n\nwindow.MessageAction = {\n    Default:     0,\n    Reload:      1,\n    Login:       2,\n    Demo:        3,\n    ResetClient: 4,\n    None:        5,\n};\n\nwindow.MessageType = {\n    Info:           0,\n    Warning:        1,\n    Error:          2,\n    Fatal:          3,\n    Subtitle:       4,\n    Intro:          5,\n    RequiredUpdate: 6,\n    InfoGray:       7,\n    MobileOffline:  8,\n};\n\nwindow.MessageID = {\n    Undefined:        0,\n    ConnectionError:  1,\n    OfflineUndo:      2,\n    FatalError:       3,\n    DocChange:        4,\n    OfflineWarn:      5,\n    OnlineInfo:       6,\n    CacheReset:       7,\n    RequiredUpdate:   8,\n    Updated:          9,\n    MobileOffline:    10,\n    ApplicationError: 11,\n    DriveError:       12\n};\n\nwindow.VMLIFlag = {\n    None:        0x0000,\n\n    Header:      0x0001,\n    Collapsed:   0x0002,\n    Selected:    0x0004,\n    Highlighted: 0x0008,\n    NumList:     0x0010,\n\n    // LSNormal:    0x00000,\n    Complete:    0x01000,\n\n    P2:          0x02000,\n    P1:          0x04000,\n    P0:          0x08000,\n\n    Flagged:     0x10000\n    //LSNumList:   0x20000\n};\n\nwindow.VersionType = {\n    Structure:  0x1,\n    Text:       0x2\n};\n\nwindow.SaveFlag = {\n    None:       0x0,\n    Prop:       0x1,\n    Text:       0x2,\n    All:        0x3\n};\n\nwindow.PropChangeType = {\n    None:       0x00,\n    // Delete:     0x01,\n    // Add:        0x01,\n    Date:       0x02,\n    Complete:   0x04,\n    Archive:    0x08,\n    Flagged:    0x10,\n    Priority:   0x20,\n    All:        0x3F,\n}\n\nwindow.LoginState = {\n    NONE: 0,\n    LOGGED_OUT : 1,\n    LOGGED_IN : 2\n    //OFFLINE: 3\n};\n\nself.isFlagSet = function(data, mask)\n{\n    return ((data & mask) === mask);\n};\n\nself.isAtLeastOneFlagSet = function(data, mask)\n{\n    return ((data & mask) !== 0x0);\n};\n\n// window.MenuState = {\n//     Main: 0,\n//     Outline: 1,\n//     Settings: 2\n// };\n\n// self.LSMask = VMLIFlag.LSComplete | VMLIFlag.Flag;\n\nself.PCFMask = VMLIFlag.P0 | VMLIFlag.P1 | VMLIFlag.P2 | VMLIFlag.Complete | VMLIFlag.Flagged;\nself.PCMask = VMLIFlag.P0 | VMLIFlag.P1 | VMLIFlag.P2 | VMLIFlag.Complete;\nself.PFMask = VMLIFlag.P0 | VMLIFlag.P1 | VMLIFlag.P2 | VMLIFlag.Flagged;\nself.PMask = VMLIFlag.P0 | VMLIFlag.P1 | VMLIFlag.P2;\n\nself.fieldMapIn = {\n    'id': 'id',\n    'items': 'i',\n    'archivedItems': 'ai',\n    'text': 't',\n    'modifiedOffline': 'l',\n    'modifiedOfflineText': 'o',\n    'versionText': 'u',\n    'version': 'v',\n    'formats': 'f',\n    'isArchived': 'a',\n    'isDeleted': 'x',\n    'isCollapsed': 'm',\n    'date': 'd',\n    'dateText': 's',\n    'allDayDate': 'ad',\n    'dateCreated': 'c',\n    //'createdBy': 'b',\n    'dateCompleted': '^',\n    'priority': 'p',\n    'isComplete': 'z',\n    'isFlagged': '*'\n    //'lastModified': 'k'\n};\n\n// self.flagMapIn = {\n//     'pComment ': VMLIFlag.LSComment,\n//     'pImportant ': VMLIFlag.LSImportant,\n//     'pQuestion ': VMLIFlag.LSQuestion,\n//     'pStar ': VMLIFlag.LSStar,\n//     'pComplete ': VMLIFlag.LSComplete,\n//     'pNumList ': VMLIFlag.LSNumList,\n//     'pNormal ': VMLIFlag.LSNormal\n// };\n\n// self.flagMapOut = { };\n// self.flagMapOut[VMLIFlag.LSComplete] = 'pComplete';\n// self.flagMapOut[VMLIFlag.LSNumList] = 'pNumList';\n// self.flagMapOut[VMLIFlag.LSNumList] = 'pNumList';\n// self.flagMapOut[VMLIFlag.LSNormal] = ' ';\n// self.flagMapOut[VMLIFlag.Flag] = ' pStar';\n\nself.priorityMapOut = { };\nself.priorityMapOut[VMLIFlag.None] = ' ';\nself.priorityMapOut[VMLIFlag.P0] = ' p0';\nself.priorityMapOut[VMLIFlag.P1] = ' p1';\nself.priorityMapOut[VMLIFlag.P2] = ' p2';\n\nif (DEBUG)\n{\n    self.verifyFields = function ()\n    {\n        var fields = { };\n        for (var field in self.fieldMapIn)\n        {\n            self.Assert(fields[self.fieldMapIn[field]] === undefined, 'Duplicate field definition found!');\n\n            fields[self.fieldMapIn[field]] = true;\n        }\n    }\n\n    window.__globals = function()\n    {\n        return self;\n    };\n}\n\nwindow.NumListPrefix = \"#.\";\nwindow.NumListPrefixOther = \"1.\";\nwindow.DatePrefix = '@';\nwindow.ContactPrefix = '+';\n\nwindow.cmdChar = (platform.windows ? 'ctrl' : '');\n\n// self.TouchPhase = {\n//     None:    0,\n//     Start:   1,\n//     Move:    2,\n//     End:     3\n// };\n\nself.getTransitionClass = function(time)\n{\n    var trans;\n    // Use the correct css class for this animation time\n    switch(time)\n    {\n        case 50:\n            trans = 'trans05';\n            break;\n        case 100:\n            trans = 'trans1';\n            break;\n        case 200:\n            trans = 'trans2';\n            break;\n        case 300:\n            trans = 'trans3';\n            break;\n        case 400:\n            trans = 'trans4';\n            break;\n        case 500:\n            trans = 'trans5';\n            break;\n        case 1000:\n            trans = 'trans10';\n            break;\n        default:\n            console.log('ERROR: no time for ', time);\n            break;\n    }\n    return trans;\n};\n\nself.setTransformStyle = function(element, x, y)\n{\n    self.Assert(element, 'Must provide a valid element');\n\n    if (element)\n    {\n        self.Assert(x !== undefined, 'Must supply a valid X offset');\n        self.Assert(y !== undefined, 'Must supply a valid Y offset');\n\n        if (!platform.ie)\n        {\n            element.style[platform.transform.style] = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';\n        }\n        else\n        {\n            element.style[platform.transform.style] = 'translate('+ x + 'px' + ', ' + y + 'px)';\n        }\n    }\n};\n\nself.setTransitionStyle = function(element, property, time, easing)\n{\n    self.Assert(element, 'Must provide a valid element');\n\n    if (element)\n    {\n        easing = easing || 'ease';\n\n        element.style[platform.transition.style] = property + ' ' + time + 'ms ' + easing;\n\n        setTimeout(function()\n        {\n            element.style[platform.transition.style] = '';\n        }, time);\n    }\n};\n\nvar IE_ANIM_WORKAROUND = platform.ie;\n\nself.setTransform = function(element, x, y, time, easing)\n{\n    if (time > 0)\n    {\n        if (IE_ANIM_WORKAROUND)\n        {\n            setTransformStyle(element, x, y);\n        }\n        else\n        {\n            self.setTransitionStyle(element, platform.transform.prop, time, easing);\n\n            self.setTransformStyle(element, x, y);\n        }\n    }\n    else\n    {\n        if (x || y)\n        {\n            self.setTransformStyle(element, x, y);\n        }\n        else\n        {\n            element.style[platform.transform.style] = 'none';\n        }\n    }\n};\n\nself.reload = function()\n{\n    self.Assert(!appCacheUpdating, 'Page should not be reloaded while waiting for an appcache update to finish.');\n\n    if (appCacheUpdating)\n    {\n        self.reportError(new Error('Page requesting reload while waiting for AppCache update.'));\n    }\n\n    window.location.reload();\n};\n\nself.isSetupPageOpen = false;\nself.isMainPageOpen = false;\nself.openMainPage = function()\n{\n    // TODO: This function should only set CSS classes if they need to change. As it is now,\n    //       we generally set classes even when not necessary multiple times on page load.\n\n    if (self.isSetupPageOpen)\n    {\n        self.isSetupPageOpen = false;\n    }\n\n    if (!self.isMainPageOpen)\n    {\n        self.isMainPageOpen = true;\n    }\n\n    var outer = document.getElementById('outerWrapper');\n    var setup = document.getElementById('setupWrapper')\n\n    if (outer && setup)\n    {\n        self.removeClass(outer, 'none');\n        self.addClass(setup, 'none');\n    }\n};\n\nself.openSetupPage = function()\n{\n    // TODO: This function should only set CSS classes if they need to change. As it is now,\n    //       we generally set classes even when not necessary multiple times on page load.\n\n    if (self.isMainPageOpen)\n    {\n        self.isMainPageOpen = false;\n    }\n\n    self.addClass(document.getElementById('outerWrapper'), 'none');\n    self.removeClass(document.getElementById('setupWrapper'), 'none');\n};\n\nvar wasAppCacheUpdated = false;\nvar appCacheUpdating = false;\nself.setAppCacheUpdateState = function(state)\n{\n    appCacheUpdating = state;\n\n    if (state)\n    {\n        wasAppCacheUpdated = true;\n    }\n};\n\n// self.contextX = function ()\n// {\n//     return platform.windowWidth() * 0.8;\n// };\n\nself.isEmpty = function (object)\n{\n    for (var i in object)\n    {\n        return false;\n    }\n\n    return true;\n};\n\nself.isEmail = function(string)\n{\n    var regex = new RegExp(/.+@.+\\..+/i);\n    var results = regex.exec(string);\n    return !!results;\n};\n\nself.removeDOM = function (id)\n{\n    var domElem = document.getElementById(id);\n    self.Assert(domElem, 'DOM Element must exist to remove it');\n\n    if (domElem)\n    {\n        domElem.parentNode.removeChild(domElem);\n    }\n};\n\nself.isRunningScript = function ()\n{\n    return self.AScript && self.AScript.isRunning;\n};\n\nvar isOffline = false;\nself.goOnline = function()\n{\n    if (self.noLocalWrites && !self.isDemoMode())\n    {\n        self.messageQueue.clearMessage(MessageID.OfflineWarn);\n        self.messageQueue.pushMessage(MessageID.OnlineInfo);\n    }\n\n    isOffline = false;\n};\n\nself.goOffline = function()\n{\n    if (self.noLocalWrites && !self.isDemoMode() && !DEBUG)\n    {\n        self.messageQueue.clearMessage(MessageID.OnlineInfo);\n        self.messageQueue.pushMessage(MessageID.OfflineWarn);\n    }\n\n    isOffline = true;\n};\n\nself.isOffline = function()\n{\n    return isOffline;\n};\n\nself.preventLocalWrites = function()\n{\n    if (ShouldLog(LogLevels.Warning)) log('---- WARNING: Local Writes Disabled ----');\n\n    if (isOffline && !self.isDemoMode())\n    {\n        self.messageQueue.clearMessage(MessageID.OnlineInfo);\n        self.messageQueue.pushMessage(MessageID.OfflineWarn);\n    }\n\n    self.noLocalWrites = true;\n};\n\nself.shouldWriteLocal = function()\n{\n    return !self.noLocalWrites;\n};\n\nself.enableDemoMode = function()\n{\n    self.demoMode = true;\n\n    if (!platform.mobile && !platform.script && !DEBUG)\n    {\n        self.messageQueue.pushMessage({\n            text: 'You are in demo mode, your information is not being saved. Click here to leave.',\n            type: MessageType.Info,\n            action: MessageAction.Login,\n        });\n    }\n\n    self.preventLocalWrites();\n};\n\nself.isDemoMode = function()\n{\n    return self.demoMode;\n};\n\nwindow.DisplayMode = {\n    Default:        0x00, // 0\n    NoTopBar:       0x01, // 1\n    NoPaneHeaders:  0x02, // 2\n    ForceTwoPane:   0x04, // 4\n    NoScrollbars:   0x08, // 8\n    NoBackground:   0x10, // 16\n    NoPaneTop:      0x20, // 32\n    NoInteraction:  0x40, // 64\n    NoPanePadding:  0x80, // 128\n    NoPaneStyle:    0x100, // 256\n    NoRightClick:   0x200, // 512\n    ShowBanner:     0x400, // 1024\n    FullMin:        0x7ff  // 2047\n};\n\nself.activeDisplayMode = DisplayMode.Default;\n\nself.isDisplayModeActive = function(mode)\n{\n    return ((self.activeDisplayMode & mode) === mode);\n};\n\nself.enableMinMode = function (mode)\n{\n    try\n    {\n        mode = parseInt(mode);\n\n        if (platform.browser === 'Trident' || platform.android === true)\n        {\n            mode |= DisplayMode.NoScrollbars;\n            mode |= DisplayMode.NoInteraction;\n        }\n\n        if (!platform.touch)\n        {\n            // TODO: Make all these add a class to body and handle the\n            // modifications in css\n            if (mode & DisplayMode.NoTopBar)\n            {\n                var desktopMenu = document.getElementById('desktopMenu');\n                if (desktopMenu)\n                {\n                    self.addClass(desktopMenu, 'none');\n                }\n\n                var container = document.getElementById('container');\n\n                if (container)\n                {\n                    container.style.top = '0px';\n                }\n\n                var panes = document.getElementsByClassName('pane');\n                for (var i = 0; i < panes.length; ++i)\n                {\n                    if (panes[i])\n                    {\n                        panes[i].style.marginTop = '0px';\n                        panes[i].style.height = '100%';\n                    }\n                }\n            }\n\n            if (mode & DisplayMode.NoPaneHeaders)\n            {\n                self.addClass(document.body, 'noPaneHeaders');\n            }\n\n            if (mode & DisplayMode.NoPaneTop)\n            {\n                self.addClass(document.body, 'noPaneTopBox');\n            }\n\n            if (mode & DisplayMode.NoPaneStyle)\n            {\n                self.addClass(document.body, 'noPaneStyle');\n            }\n        }\n\n        if (mode & DisplayMode.NoPaneTop)\n        {\n            self.addClass(document.body, 'noPanePadding');\n        }\n\n        if (mode & DisplayMode.NoScrollbars)\n        {\n            self.addClass(document.body, 'noScrollbars');\n        }\n\n        if (mode & DisplayMode.NoBackground)\n        {\n            var html = document.getElementsByTagName('html')[0];\n            self.Assert(html, 'Must have a valid HTML element');\n\n            if (html)\n            {\n                self.addClass(html, 'noBackground');\n            }\n        }\n\n        if (mode & DisplayMode.NoInteraction)\n        {\n            var grabber = document.getElementById('preventInteraction');\n\n            if (grabber)\n            {\n                self.removeClass(grabber, 'none');\n\n                grabber.addEventListener('mousewheel', function (e)\n                {\n                    //e.preventDefault();\n                    e.stopImmediatePropagation();\n                    return false;\n                }, true);\n\n                grabber.addEventListener('mousedown', function (e)\n                {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    return false;\n                }, true);\n\n                grabber.addEventListener('keydown', function (e)\n                {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    return false;\n                }, true);\n            }\n        }\n\n        if (mode & DisplayMode.ShowBanner && !(mode & DisplayMode.NoInteraction))\n        {\n            self.removeClass(document.getElementById('cornerBannerMessage'), 'none');\n        }\n        else\n        {\n            self.removeDOM('cornerBannerMessage');\n        }\n\n        self.activeDisplayMode = parseInt(mode);\n    }\n    catch (err)\n    {\n        self.reportError(err);\n    }\n};\n\n//\n// Analytics Helpers\n//\nself.sendEvent = function (category, action, value)\n{\n    self.Assert(!self.isString(value), 'Values must be numeric');\n\n    if (window.ga && !self.isDemoMode())\n    {\n        ga('send', 'event', category, action, self.getAnonUserIdentifier(), value);\n    }\n};\n\nself.sendTimeEvent = function (category, variable, value)\n{\n    self.Assert(!self.isString(value), 'Values must be numeric');\n\n    if (window.ga && !self.isDemoMode())\n    {\n        ga('send', 'timing', category, variable, value, self.getAnonUserIdentifier());\n    }\n};\n\nvar currentTimeEvent = undefined;\nself.startTimeEvent = function (category, variable)\n{\n    if (log && log.now)\n    {\n        self.Assert(currentTimeEvent === undefined, 'This function needs to be updated to allow nested timing events');\n\n        currentTimeEvent = {\n            startTime: log.now(),\n            category: category,\n            variable: variable\n        };\n    }\n};\n\nself.endTimeEvent = function ()\n{\n    if (log && log.now)\n    {\n        self.Assert(currentTimeEvent !== undefined, 'Must have started a timing event');\n\n        var elapsedTime = log.now() - currentTimeEvent.startTime;\n\n        self.sendTimeEvent(currentTimeEvent.category, currentTimeEvent.variable, elapsedTime);\n\n        currentTimeEvent = undefined;\n    }\n};\n\nvar aggregateEvents = { };\nself.registerEvent = function (name, category, action)\n{\n    self.Assert(!aggregateEvents.hasOwnProperty(name), 'Should only register an event once');\n    self.Assert(name !== undefined, 'Must specify a name for the event');\n    self.Assert(category !== undefined, 'Must specify a category for the event');\n    self.Assert(action !== undefined, 'Must specify an action for the event');\n\n    var registerEvent = {\n        category: category,\n        action: action,\n        label: self.getAnonUserIdentifier(),\n        count: 0\n    };\n\n    aggregateEvents[name] = registerEvent;\n};\n\nself.aggregateEvent = function (name, count)\n{\n    self.Assert(aggregateEvents.hasOwnProperty(name), 'Must register an event before using it');\n\n    if (count === undefined)\n    {\n        count = 1;\n    }\n\n    if (aggregateEvents[name])\n    {\n        aggregateEvents[name].count += count;\n    }\n};\n\nvar isPageDataCleared = false;\nself.pageDataCleared = function()\n{\n    isPageDataCleared = true;\n};\n\n//\n// On page onload, send all aggregate events\n//\nself.onunload = function ()\n{\n    log('Unloading the page');\n\n    for (var evName in aggregateEvents)\n    {\n        var ev = aggregateEvents[evName];\n\n        self.sendEvent(ev.category, ev.action, ev.count);\n        ev.count = 0;\n    }\n\n    if (self.vmMain && self.vmMain.failedGapiLoad)\n    {\n        self.sendEvent('ScriptLoad', 'GapiFailed');\n    }\n    else if (!gapiCalled)\n    {\n        self.sendEvent('ScriptLoad', 'GapiNotLoaded');\n    }\n\n    if (self.vmMain)\n    {\n        self.vmMain.updatePaneScrollState();\n    }\n\n    if (!isPageDataCleared)\n    {\n        var gdata = require('gdata');\n\n        if (gdata)\n        {\n            self.settings.set(Settings.lastServerVersion, gdata.getServerVersion());\n        }\n    }\n\n    if (self.isLoadingRemote)\n    {\n        return 'We are still syncing your changes, are you sure you want to exit?';\n    }\n};\n\nif (!platform.demo && !platform.packagedApp)\n{\n    window.onbeforeunload = self.onunload;\n}\n\n//\n// Local Storage Helpers\n//\n\nvar lastSetLoginState = LoginState.LOGGED_OUT;\nself.getLoginState = function()\n{\n    var state = lastSetLoginState;\n\n    if (self.shouldWriteLocal())\n    {\n        try\n        {\n            var savedState = util.storage.getItem('loginState');\n\n            if (savedState !== null && savedState !== undefined)\n            {\n                state = parseInt(savedState);\n            }\n        }\n        catch (err)\n        {\n            self.reportError(err);\n        }\n    }\n\n    return state;\n};\n\nself.setLoginState = function(value)\n{\n    self.Assert(value !== null && value !== undefined && !isNaN(value), 'Should always be a valid LoginState enum value');\n\n    lastSetLoginState = value;\n\n    if (self.shouldWriteLocal())\n    {\n        try\n        {\n            if (isNaN(value) || value === null || value === undefined)\n            {\n                value = LoginState.LOGGED_OUT;\n            }\n\n            util.storage.setItem('loginState', value);\n        }\n        catch (err)\n        {\n            self.reportError(err);\n        }\n    }\n};\n\nwindow.Settings = {\n    //lastCalendarSync: 'lastCalendarSync',       // used to sync the gcal list with google\n    //lastEventSync: 'lastEventSync',             // used to get updates for gcal items\n    //lastEventFullSync: 'lastEventFullySync',    // used to get items for new days within our range\n    theme: 'theme',                             // current UI theme\n    //calendarsImport: 'calendarsImport',         // list of calendar IDs to import from gcal\n    //calendarExport: 'calendarExport',           // the ID of the gcal to export our events to\n    //syncGoogle: 'syncGoogle',                   // whether to sync with google\n    syncContacts: 'syncContacts',               // whether to sync contacts\n    lastContactSync: 'lastContactSync',         // used to get updates for contacts\n    disableNotifications: 'disableNotifications', // whether to disable notifications\n    docSharing: 'docSharing',                   // whether to request full drive permissions for document sharing\n    authScopes: 'authScopes',                   // authorized OAuth2 scopes for the current user\n    localIntegrity: 'localIntegrity',           // track whether local data is the result of a full remote sync\n    paneState: 'paneState',                     // track the current state of the panes\n    localDataVersion: 'localDataVersion',       // local version of data\n    shownTutorial: 'shownTutorial',             // track whether the tutorial was shown on this device\n    gdocId: 'gdocId',                           // track the currently open document id\n    gdocTitle: 'gdocTitle',                     // track the currently open document title\n    activeUser: 'activeUser',                   // track the currently active google user\n    noSounds: 'noSounds',                       // whether to play sounds\n    noLocalWrites: 'noLocalWrites',             // whether to write to the local db or not\n    lastMessageSync: 'lastMessageSync',         // used to get remote message updates\n    lastServerVersion: 'lastServerVersion',     // track the last version syncd from the server\n    helpPaneState: 'helpPaneState',              // track the state of the help pane\n    shownInstallInfo: 'shownInstall'\n};\n\n// TODO: Switch to a 'persistSettings' list instead as it will be smaller.\n// This is a list of settings that are not persisted through the remote doc, they are per-device.\nvar ignoreSettings =\n[\n    Settings.localIntegrity,\n    Settings.paneState,\n    Settings.authScopes,\n    Settings.localDataVersion,\n    Settings.shownTutorial,\n    Settings.lastContactSync,\n    Settings.disableNotifications,\n    Settings.gdocId,\n    Settings.gdocTitle,\n    Settings.activeUser,\n    Settings.noSounds,\n    Settings.lastMessageSync,\n    Settings.lastServerVersion,\n    Settings.noLocalWrites,\n    Settings.lastMessageSync\n];\n\nself.settings = {\n    settings: { },\n    prefix: 'V~',\n\n    init: function()\n    {\n        // Verify that we can write to localStorage\n\n        try\n        {\n            util.storage.setItem('poke', 0);\n        }\n        catch (err)\n        {\n            self.preventLocalWrites();\n        }\n\n        this.ensureLocalCopy();\n    },\n    initEvents: function (fn)\n    {\n        self.Assert(fn, 'Must supply a callback function');\n\n        if (self.shouldWriteLocal())\n        {\n            window.addEventListener('storage', function (e)\n            {\n                if (DEBUG) log('SETTINGS: Storage event received - ', e);\n\n                if (!e) { e = window.event; }\n\n                fn(e);\n\n                if (e.key === 'localSettings')\n                {\n                    try\n                    {\n                        this.settings = e.newValue ? JSON.parse(e.newValue) : { };\n                    }\n                    catch (err)\n                    {\n                        self.reportError(err);\n\n                        this.settings = { };\n                    }\n                }\n            }.bind(this), false);\n        }\n    },\n    ensureLocalCopy: function (forceSync)\n    {\n        self.Assert(forceSync === undefined, 'Invalid caller param forceSync');\n\n        if (self.shouldWriteLocal() && (forceSync || self.isEmpty(this.settings)))\n        {\n            try\n            {\n                var storValue = util.storage.getItem('localSettings');\n\n                this.settings = storValue ? JSON.parse(storValue) : { };\n            }\n            catch (err)\n            {\n                self.reportError(err);\n\n                this.settings = { };\n            }\n\n            if (DEBUG) log('SETTINGS: PageLoaded - ', this.settings);\n        }\n    },\n    flushLocalCopy: function ()\n    {\n        if (self.shouldWriteLocal())\n        {\n            try\n            {\n                util.storage.setItem('localSettings', JSON.stringify(this.settings));\n            }\n            catch (err)\n            {\n                self.reportError(err);\n            }\n        }\n    },\n    set: function (property, value, remoteVersion)\n    {\n        self.Assert(property !== undefined && property !== null, 'Must specify a valid property name');\n        self.Assert(!property.startsWith(this.prefix), 'Use setVersion to set version properties');\n\n        this.ensureLocalCopy();\n\n        if (remoteVersion === null) { remoteVersion = 0; }\n\n        var oldValue = this.settings[property];\n        var localVersion = this.getVersion(property);\n\n        var writeProperty = false;\n        if (oldValue !== value || (typeof value == 'object'))\n        {\n            if (remoteVersion === undefined)\n            {\n                writeProperty = true;\n\n                // If not setting from a remote, verify that we have not yet incremented the local\n                // version number. The version should only be incremented once per remote sync.\n                if (localVersion >= 0 && ignoreSettings.indexOf(property) < 0)\n                {\n                    var oldVersion = this.getVersion(property);\n\n                    this.settings[this.prefix + property] = -(oldVersion + 1);\n\n                    if (DEBUG) log('SETTINGS: Update version for ' + property + ' (' + oldVersion + ' -> ' + this.getVersion(property) + ')');\n                }\n            }\n            else\n            {\n                self.Assert(remoteVersion >= 0, 'Remote version must be positive');\n\n                // If we are setting a property from remote, verify that it should actually be set in\n                // case it has been modified locally.\n                writeProperty = this.isPropertyNewer(property, remoteVersion);\n\n                if (writeProperty)\n                {\n                    this.settings[this.prefix + property] = remoteVersion;\n                }\n            }\n\n            if (writeProperty)\n            {\n                this.settings[property] = value;\n\n                if (ignoreSettings.indexOf(property) < 0)\n                {\n                    // The version must always be sent before the property value otherwise the remote client will think\n                    // their version is newer.\n                    self.fireCustomEvent('settingsChange', { property: this.prefix + property, value: this.settings[this.prefix + property], isRemote: (remoteVersion !== undefined) });\n                    self.fireCustomEvent('settingsChange', { property: property, value: value, isRemote: (remoteVersion !== undefined) });\n                }\n            }\n\n            this.flushLocalCopy();\n        }\n\n        if (DEBUG) log('SETTINGS: Set called for ' + property + ' [' + oldValue + ' -> ' + value + '] rVer(' + remoteVersion + ') lVer(' + localVersion + ') WRITTEN: ' + writeProperty);\n\n        return writeProperty;\n    },\n    get: function (property, forceSync)\n    {\n        self.Assert(property !== undefined && property !== null, 'Must specify a valid property name');\n\n        this.ensureLocalCopy(forceSync);\n\n        return this.settings[property];\n    },\n    getVersion: function (property, forceSync)\n    {\n        self.Assert(property !== undefined && property !== null, 'Must specify a valid property name');\n\n        this.ensureLocalCopy(forceSync);\n\n        return this.settings[this.prefix + property] || 0;\n    },\n    setVersion: function (property, value, forceSync)\n    {\n        self.Assert(property !== undefined && property !== null, 'Must specify a valid property name');\n\n        self.Assert(property.startsWith(this.prefix), 'Setting versions requires a version property name');\n        self.Assert(value >= 0, 'Versions should always be positive');\n\n        this.ensureLocalCopy(forceSync);\n\n        this.settings[property] = value;\n    },\n    reset: function (property)\n    {\n        if (property)\n        {\n            if (DEBUG) log('SETTINGS: Resetting ' + property + ' stored setting.');\n\n            this.ensureLocalCopy();\n\n            delete this.settings[property];\n\n            this.flushLocalCopy();\n        }\n        else\n        {\n            if (DEBUG) log('SETTINGS: Resetting ALL stored settings');\n\n            this.settings = { };\n\n            if (self.shouldWriteLocal())\n            {\n                try\n                {\n                    util.storage.setItem('localSettings', '{}');\n                }\n                catch (err)\n                {\n                    self.reportError(err);\n                }\n            }\n        }\n    },\n    resetAll: function (skip)\n    {\n        var newSettings = { };\n\n        if (skip)\n        {\n            for (var i = 0; i < skip.length; ++i)\n            {\n                newSettings[skip[i]] = this.settings[skip[i]];\n            }\n        }\n\n        this.settings = newSettings;\n\n        if (skip)\n        {\n            this.flushLocalCopy();\n        }\n        else\n        {\n            if (self.shouldWriteLocal())\n            {\n                try\n                {\n                    util.storage.setItem('localSettings', '{}');\n                }\n                catch (err)\n                {\n                    self.reportError(err);\n                }\n            }\n        }\n    },\n    isPropertyNewer: function (property, version)\n    {\n        self.Assert(version !== undefined && version !== null && version >= 0, 'Remote versions should always be positive');\n\n        var selfVersion = this.getVersion(property);\n        self.Assert(selfVersion !== undefined && selfVersion !== null, 'Self version should always be valid');\n\n        return Math.abs(selfVersion) < Math.abs(version);\n    },\n    getRawSettings: function ()\n    {\n        var rawSettings;\n\n        if (self.shouldWriteLocal())\n        {\n            try\n            {\n                rawSettings = util.storage.getItem('localSettings');\n            }\n            catch (err)\n            {\n                self.reportError(err);\n            }\n        }\n        else\n        {\n            try\n            {\n                return JSON.stringify(this.settings);\n            }\n            catch (err)\n            {\n                self.reportError(err);\n\n                return '{m: \"Invalid Settings\"}';\n            }\n        }\n\n        return rawSettings;\n    }\n};\n\nif (REPORT_ACTIONS)\n{\n    window.ResolveAction =\n    {\n        Error:              0x001, // Error\n        SetRemoteText:      0x002, // Text was set on the remote item\n        SetLocalText:       0x004, // Text was set on the local item\n        DupeItem:           0x008, // Text conflicted, create new local item\n        AddLocalItem:       0x010, // Item created remotely, added locally\n        RemoveRemoteItem:   0x020, // Item deleted locally, removed remotely\n        AddBackDeletedItem: 0x040, // Item deleted locally, added back by remote\n        LocalMoveCandidate: 0x080, // Item found to be moved loclaly, deal with it later\n        MoveLocalItem:      0x100, // Item was moved locally and remotely, move locally\n        DeleteLocalItem:    0x200, // Item deleted remotely, delete locally\n        MoveRemoteItem:     0x400, // Item was moved locally, move remotely\n    };\n\n    window.RATAG =\n    {\n        A: 0x00,\n        B: 0x01,\n        C: 0x02,\n        D: 0x03,\n        E: 0x04,\n        F: 0x05,\n        G: 0x06,\n        H: 0x07,\n        I: 0x08,\n        J: 0x09,\n        K: 0x0A,\n        L: 0x0B,\n        M: 0x0C,\n        O: 0x0D,\n        P: 0x0E,\n        Q: 0x0F,\n        R: 0x10,\n        S: 0x11,\n    };\n\n    var noSync = util.hasURLParam('nosync') || util.hasURLParam('demo');\n\n    if (!noSync) { console.log('%cGenerating Sync Report - use #noSync=true to disable and __syncReport.printList() to view.', \"color: green\"); }\n\n    var syncReport = [ ];\n    self.reportAction = function(tag, type, info)\n    {\n        if (!noSync)\n        {\n            syncReport.push({ tag: tag, type: type, info: info, tagString: self.enumToString(window.RATAG, tag), typeString: self.enumToString(window.ResolveAction, type) });\n        }\n    };\n\n    self.reportActionCrash = function(sErr)\n    {\n        debugger;\n\n        self.reportAction(RATAG.S, ResolveAction.Error, { msg: sErr.message, stack: sErr.stack });\n    };\n\n    window.DataSnapshot =\n    {\n        Before: 0x0,\n        After:  0x1,\n    };\n\n    var snapshots = [ ];\n    self.reportData = function(data, loc)\n    {\n        snapshots[loc] = JSON.stringify(data);\n    };\n\n    window.__syncReport =\n    {\n        print: function()\n        {\n            return syncReport;\n        },\n        printList: function()\n        {\n            if (noSync) { return \"Sync Report Disabled\"; }\n            if (syncReport.length === 0) { return \"No Actions Perfomed in Sync\"; }\n\n            for (var i = 0; i < syncReport.length; ++i)\n            {\n                var tt = syncReport[i];\n\n                log('Action: ', { type: tt.typeString, tag: tt.tagString, info: tt.info });\n            }\n\n            return 'Actions Complete';\n        },\n        filterType: function(type)\n        {\n            return syncReport.filter(function (item)\n            {\n                return item.type === type;\n            });\n        },\n        filterTag: function(tag)\n        {\n            return syncReport.filter(function (item)\n            {\n                return item.tag === tag;\n            });\n        },\n        getData: function()\n        {\n            var syncData =\n            {\n                snapshotBefore: snapshots[DataSnapshot.Before],\n                actions: JSON.stringify(syncReport),\n                snapshotAfter: snapshots[DataSnapshot.After]\n            };\n\n            return syncData;\n        },\n        getSaveData: function()\n        {\n            var syncData = this.getData();\n\n            return JSON.stringify(syncData);\n        },\n        save: function()\n        {\n            var blob = new Blob([this.getSaveData()], {type: \"text/plain;charset=utf-8\"});\n\n            saveAs(blob, 'SyncReport.json');\n        },\n        view: function()\n        {\n            self.XHR({\n                type: 'POST',\n                url: window.location.protocol + '//' + window.location.host + '/debug/sendSyncReport',\n                data: this.getSaveData(),\n                cb: function (xhr)\n                {\n                    log('SyncReport Response: ', xhr);\n\n                    if (xhr.status === 200)\n                    {\n                        try\n                        {\n                            var reportInfo = JSON.parse(xhr.responseText);\n\n                            window.location = window.location.protocol + '//' + window.location.host + '/syncReport?' + reportInfo.reportID;\n                        }\n                        catch (err)\n                        {\n                            log('Error parsing SyncReport Response: ' + err.message);\n                        }\n                    }\n                    else\n                    {\n                        log('Remote Sync Report Error: ', xhr.status, xhr.responseText);\n                    }\n                }\n            })\n        }\n    };\n}\n\nif (DEBUG)\n{\n    window.__printSettings = function () { return (JSON.parse(util.storage.getItem('localSettings')) || { }); };\n}\n\nself.applyBindings = function(model, eleID)\n{\n    var elem = document.getElementById(eleID);\n\n    self.Assert(model, 'A valid model must be defined when apply bindings');\n    self.Assert(elem, 'A valid element must be defined when apply bindings');\n\n    if (elem && model)\n    {\n        try\n        {\n            ko.applyBindings(model, elem);\n        }\n        catch (err)\n        {\n            err.message += ' | Binding on: ' + self.elementToString(elem);\n            self.reportError(err);\n\n            throw err;\n        }\n    }\n    else\n    {\n        var errStr = 'Invalid model or element passed to applyBindings | ';\n\n        if (elem)\n        {\n            errStr += 'NoModel - Elem: ' + self.elementToString(elem);\n        }\n        else if (model)\n        {\n            errStr += 'NoElem - Elem: #' + eleID;\n        }\n        else\n        {\n            errStr += 'NoModelNoElem - Elem: #' + eleID;\n        }\n\n        self.reportError(new Error(errStr));\n    }\n};\n\nko.observable.fn.toString = function() {\n    return \"observable: \" + ko.toJSON(this(), null, 2);\n};\n\nko.computed.fn.toString = function() {\n    return \"computed: \" + ko.toJSON(this(), null, 2);\n};\n\nko.bindingHandlers.load =\n{\n    init: function(element, valueAccessor, allBindingsAccessor, viewModel, context)\n    {\n        self.Assert(viewModel.onLoad, 'If no load function is specified, remove the binding from the template');\n\n        var pIndex = context.$parents.length - 2;\n        var paneRoot;\n        if (pIndex >= 0)\n        {\n            paneRoot = context.$parents[pIndex];\n        }\n\n        viewModel.onLoad(element, paneRoot);\n    }\n};\n\n// ko.bindingHandlers.hide = {\n//     update: function(element, valueAccessor, allBindingsAccessor, viewModel)\n//     {\n//         var value = ko.utils.unwrapObservable(valueAccessor());\n//         var isCurrentlyHidden = !(element.style.visibility === \"hidden\");\n\n//         if (value && !isCurrentlyVisible)\n//         {\n//             element.style.visibility = \"auto\";\n//         }\n//         else if ((!value) && isCurrentlyVisible)\n//         {\n//             element.style.visibility = \"hidden\";\n//         }\n//     }\n// };\n\nko.bindingHandlers.check =\n{\n    init: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        var obs = valueAccessor();\n        if (obs())\n        {\n            self.addClass(element, 'checked');\n        }\n\n        self.setupClick(element, viewModel,\n        {\n            onClick: function(e)\n            {\n                obs(!obs());\n\n                if (obs())\n                {\n                    self.addClass(element, 'checked');\n                }\n                else\n                {\n                    self.removeClass(element, 'checked');\n                }\n\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        });\n    },\n    update: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        var obs = valueAccessor();\n\n        if (obs())\n        {\n            self.addClass(element, 'checked');\n        }\n        else\n        {\n            self.removeClass(element, 'checked');\n        }\n    }\n};\n\nko.bindingHandlers.tap =\n{\n    init: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        self.setupClick(element, viewModel, valueAccessor());\n    }\n};\n\nko.bindingHandlers.stopBinding =\n{\n    init: function()\n    {\n        return { controlsDescendantBindings: true };\n    }\n};\n\nko.bindingHandlers.possHTML =\n{\n    init: function()\n    {\n        return { controlsDescendantBindings: true };\n    },\n    update: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        //log('Update HTML: ', viewModel);\n\n        if (viewModel.isStyled)\n        {\n            element.innerHTML = ko.utils.unwrapObservable(valueAccessor());\n        }\n        else\n        {\n            element.textContent = ko.utils.unwrapObservable(valueAccessor());\n        }\n    }\n};\n\nko.bindingHandlers.tooltip =\n{\n    init: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        if (!platform.mobile)\n        {\n            self.setupMouseOver(element, ko.utils.unwrapObservable(valueAccessor()), /*isUpdate*/false);\n        }\n    },\n    update: function(element, valueAccessor, allBindingsAccessor, viewModel)\n    {\n        if (!platform.mobile)\n        {\n            self.setupMouseOver(element, ko.utils.unwrapObservable(valueAccessor()), /*isUpdate*/true);\n        }\n    }\n};\n\nself.setupMouseOver = function(element, value, isUpdate)\n{\n    self.Assert(!platform.mobile);\n\n    if (self.tooltip)\n    {\n        if (!isUpdate)\n        {\n            self.tooltip.register(element, value);\n        }\n        else\n        {\n            self.tooltip.update(element, value);\n        }\n    }\n    else\n    {\n        self.reportError(new Error('Tooltips registered before VMTooltip created'));\n    }\n};\n\n// String.prototype.visualSize = function()\n// {\n//     var ruler = document.getElementById('ruler');\n//     ruler.textContent = this;\n\n//     return { width: ruler.offsetWidth, height: ruler.offsetHeight };\n// };\n\n// String.prototype.insertTag = function(sIndex, sTag, eIndex, eTag) {\n//     return (this.substr(0, sIndex) + sTag + this.substr(sIndex, eIndex - sIndex) + eTag + this.substr(eIndex));\n// };\n\nif (typeof String.prototype.startsWith !== 'function')\n{\n    String.prototype.startsWith = function (str)\n    {\n        return this.lastIndexOf(str, 0) === 0;\n    };\n}\n\nif (typeof String.prototype.endsWith !== 'function')\n{\n    String.prototype.endsWith = function (str)\n    {\n        return this.indexOf(str, this.length - str.length) !== -1;\n    };\n}\n\nko.bindingHandlers.css2 = ko.bindingHandlers.css;\n// ko.bindingHandlers.css3 = ko.bindingHandlers.css;\n// ko.bindingHandlers.css4 = ko.bindingHandlers.css;\n\nself.findFirstDiff = function(str1, str2, ignoreCase)\n{\n    if (!str1)\n    {\n        return str2.length;\n    }\n    else if (!str2)\n    {\n        return str1.length;\n    }\n\n    var minLen = Math.min(str1.length, str2.length);\n\n    for (var i = 0; i < minLen; ++i)\n    {\n        if (ignoreCase)\n        {\n            if (str1.charAt(i).toLowerCase() !== str2.charAt(i).toLowerCase())\n            {\n                return i;\n            }\n        }\n        else\n        {\n            if (str1.charAt(i) !== str2.charAt(i))\n            {\n                return i;\n            }\n        }\n    }\n\n    return Math.max(str1.length, str2.length);\n};\n\nself.findMatchingLength = function(str1, str2, ignoreCase)\n{\n    if (!str1 || !str2)\n    {\n        return 0;\n    }\n\n    var minLen = Math.min(str1.length, str2.length);\n\n    for (var i = 0; i < minLen; ++i)\n    {\n        if (ignoreCase)\n        {\n            if (str1.charAt(i).toLowerCase() !== str2.charAt(i).toLowerCase())\n            {\n                return i;\n            }\n        }\n        else\n        {\n            if (str1.charAt(i) !== str2.charAt(i))\n            {\n                return i;\n            }\n        }\n    }\n\n    return minLen;\n};\n\n// self.lerp = function(a, b, p)\n// {\n//     return a + (b - a) * p;\n// };\n\nself.TEMP_PREFIX = '~T^';\n\nvar idx = 0;\nself.generateTempId = function ()\n{\n    return self.TEMP_PREFIX + Date.now() + (++idx);\n};\n\nself.isLocalItem = function(item)\n{\n    self.Assert(item.id, 'All items should have an ID even if it is a temp one');\n\n    return (item.id[0] === self.TEMP_PREFIX[0] && item.id[1] === self.TEMP_PREFIX[1] && item.id[2] === self.TEMP_PREFIX[2]);\n};\n\nself.getClientInfo = function(cb)\n{\n    self.XHR({\n        type: 'GET',\n        url: 'http://api.hostip.info/get_json.php',\n        cb: function(xhr)\n        {\n            if (xhr.status === 200)\n            {\n                var clientInfo = JSON.parse(xhr.responseText);\n\n                cb(clientInfo);\n            }\n            else\n            {\n                cb({ ip: 'Unknown' });\n            }\n        }\n    });\n};\n\nself.requestNotification = function(platform)\n{\n    var reqForm = document.forms['requestNotification'];\n\n    var reqResult = document.getElementById('notificationResult');\n\n    var email = reqForm['email'].value;\n\n    if (email === undefined || email === null || email.length < 5)\n    {\n        reqResult.innerText = 'Please enter a valid email address.';\n    }\n    else\n    {\n        self.XHR({\n            type: 'POST',\n            url: window.location.protocol + '//api.moo.do/requestNotification',\n            data:\n            {\n                email: email,\n                platform: platform\n            },\n            cb: function (xhr)\n            {\n                if (xhr.status === 200)\n                {\n                    // Success\n                    reqForm['email'].value = \"\";\n\n                    reqResult.innerText = 'Thanks for your interest!';\n                }\n                else\n                {\n                    // Failure\n                    reqResult.innerText = 'There was an error processing your request, please try again in a few minutes.';\n                }\n            }\n        });\n    }\n\n    return false;\n};\n\n// var cachedUserIP = undefined;\n// self.cacheUserIP = function()\n// {\n//     self.getClientInfo(function (info)\n//     {\n//         cachedUserIP = info.ip;\n//     });\n// };\n\nvar cachedID = undefined;\nself.getUserIdentifier = function()\n{\n    if (!cachedID)\n    {\n        var goog = require('goog');\n\n        var user = goog.authenticatedUserEmail() || self.settings.get('activeUser');\n\n        if (!user)\n        {\n            return 'Unknown';\n        }\n\n        cachedID = user;\n    }\n\n    return cachedID;\n};\n\nfunction murmurhash3_32_gc(key, seed)\n{\n    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\n    remainder = key.length & 3; // key.length % 4\n    bytes = key.length - remainder;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n          ((key.charCodeAt(i) & 0xff)) |\n          ((key.charCodeAt(++i) & 0xff) << 8) |\n          ((key.charCodeAt(++i) & 0xff) << 16) |\n          ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\n        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n        h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n}\n\nvar anonID = undefined;\nself.getAnonUserIdentifier = function()\n{\n    if (!anonID)\n    {\n        var userID = self.getUserIdentifier();\n\n        anonID = userID[0] + userID[1] + userID[2] + murmurhash3_32_gc(userID, 17124123);\n    }\n\n    return anonID;\n};\n\nif (DEBUG)\n{\n    window.__getHashForUser = function(user)\n    {\n        return user[0] + user[1] + user[2] + murmurhash3_32_gc(user, 17124123);\n    };\n}\n\nself.introHash = function(str)\n{\n    return murmurhash3_32_gc(str, 347236113);\n};\n\nfunction sanitizePaneState(stateObj)\n{\n    try\n    {\n        var stateOut = JSON.parse(JSON.stringify(stateObj));\n\n        for (var i = 0; i < stateOut.length; ++i)\n        {\n            if (stateOut[i].search !== '')\n            {\n                stateOut[i].search = 'HasSearch';\n            }\n        }\n\n        return JSON.stringify(stateOut);\n    }\n    catch (err)\n    {\n        return 'Failed to sanitize pane state';\n    }\n}\n\nfunction sanitizeLocalSettings(settingsIn)\n{\n    try\n    {\n        var settingsOut = JSON.parse(settingsIn);\n\n        delete settingsOut.paneState;\n        delete settingsOut.gdocTitle;\n\n        return JSON.stringify(settingsOut);\n    }\n    catch (err)\n    {\n        return 'Failed to parse settings';\n    }\n}\n\nself.getRunningState = function(obj)\n{\n    try\n    {\n        var paneState = self.settings.get(Settings.paneState);\n    }\n    catch (err)\n    {\n        log('Failed to get paneState');\n    }\n\n    obj['isDebug'] = DEBUG;\n    obj['isDemo'] = self.isDemoMode();\n    obj['localWrites'] = self.shouldWriteLocal();\n    obj['url'] = window.location.href;\n    obj['paneState'] = sanitizePaneState(paneState);\n    obj['localSettings'] = sanitizeLocalSettings(self.settings.getRawSettings());\n    obj['loginState'] = self.getLoginState();\n    obj['checkpoints'] = window.__checkpoints;\n    obj['gapiLoadError'] = gapiLoadError;\n\n    obj['windowWidth'] = window.innerWidth;\n    obj['windowHeight'] = window.innerHeight;\n\n    obj['selection'] = self.parseExtra(window.getSelection());\n    obj['eventStream'] = self.getEventStream();\n    obj['trackerStream'] = self.getTrackerStream();\n};\n\nself.getAppInfo = function(obj)\n{\n    var gapiStatus = 'Loaded';\n    if (self.vmMain && self.vmMain.failedGapiLoad)\n    {\n        gapiStatus = 'ErrorLoading';\n    }\n    else if (!gapiCalled)\n    {\n        gapiStatus = 'NotLoaded';\n    }\n\n    obj['gapiStatus'] = gapiStatus;\n    obj['sessionID'] = window.__SESSION_ID;\n    obj['appCacheUpdated'] = wasAppCacheUpdated;\n\n    platform.getPlatformInfo(obj);\n    self.getRunningState(obj);\n\n    require('gdata').getState(obj);\n};\n\nself.reportSignup = function(email)\n{\n    self.Assert(email, 'Must specify a valid email address to signup with');\n\n    self.XHR({\n        type: 'POST',\n        url: window.location.protocol + '//api.moo.do/reportSignup',\n        data:\n        {\n            email: email\n        },\n        cb: function(xhr)\n        {\n            if (xhr.status !== 200)\n            {\n                if (ShouldLog(LogLevels.Error)) log('Failed to report signup', xhr.responseText, xhr);\n\n                debugger;\n            }\n            else\n            {\n                if (DEBUG) log('Reported Signup: ', xhr.responseText);\n            }\n        }\n    });\n};\n\nvar hasCriticalError = false;\nself.criticalErrorReported = function()\n{\n    return hasCriticalError;\n};\n\nself.handleCriticalError = function()\n{\n    hasCriticalError = true;\n\n    if (!self.isDemoMode())\n    {\n        var errorNode = document.createElement('div');\n\n        errorNode.id = 'criticalError';\n        errorNode.textContent = 'There was a critical error while loading the app, ' + platform.actionVerb() + ' to reload.';\n\n        if (platform.isTouchDevice)\n        {\n            errorNode.addEventListener(platform.touchStartEvent, function (e)\n            {\n                self.reload();\n            }, true);\n        }\n        else\n        {\n            errorNode.addEventListener(platform.upEvent, function (e)\n            {\n                self.reload();\n            }, true);\n        }\n\n        self.prependChild(document.body, errorNode);\n\n        self.removeDOM('outerWrapper');\n        self.removeDOM('setupWrapper');\n        self.removeDOM('templates');\n    }\n    else\n    {\n        self.reload();\n    }\n};\n\nfunction safeStringify(obj)\n{\n    try\n    {\n        return JSON.stringify(obj);\n    }\n    catch (err)\n    {\n        log('Error stringify object: ' + err.message);\n    }\n}\n\nself.reportEvent = function(e)\n{\n    if (!self.isDemoMode())\n    {\n        var eventString = self.parseExtra(e);\n\n        self.eventStream.push(eventString);\n    }\n};\n\nself.getEventStream = function()\n{\n    return safeStringify(self.eventStream.ordered());\n};\n\nwindow.__getEventStream = self.getEventStream;\n\nself.getTrackerStream = function()\n{\n    try\n    {\n        var tracker = require('tracker');\n\n        return tracker.stringifyGroups();\n    }\n    catch (err)\n    {\n        log('Error getting tracker stream: ', err.message);\n    }\n};\n\nself.parseExtra = function(extra)\n{\n    var extraString;\n\n    if (extra)\n    {\n        try\n        {\n            var info;\n            if (extra instanceof KeyboardEvent)\n            {\n                info =\n                {\n                    type: extra.type,\n                    currentTarget: self.elementToString(extra.currentTarget),\n                    target: self.elementToString(extra.target || extra.srcElement),\n                    keyCode: extra.keyCode,\n                    normCode: extra.normCode,\n                    ctrlKey: extra.ctrlKey,\n                    shiftKey: extra.shiftKey,\n                    metaKey: extra.metaKey,\n                    altKey: extra.altKey,\n                    tstamp: Date.now()\n                };\n            }\n            else if (extra instanceof window.MouseEvent)\n            {\n                info =\n                {\n                    type: extra.type,\n                    currentTarget: self.elementToString(extra.currentTarget),\n                    relatedTarget: self.elementToString(extra.relatedTarget),\n                    target: self.elementToString(extra.target || extra.srcElement),\n                    clientX: extra.clientX,\n                    clientY: extra.clientY,\n                    ctrlKey: extra.ctrlKey,\n                    shiftKey: extra.shiftKey,\n                    metaKey: extra.metaKey,\n                    altKey: extra.altKey,\n                    which: extra.which,\n                    button: extra.button,\n                    tstamp: Date.now()\n                };\n            }\n            else if (window.TouchEvent && extra instanceof window.TouchEvent)\n            {\n                info =\n                {\n                    type: extra.type,\n                    currentTarget: self.elementToString(extra.currentTarget),\n                    relatedTarget: self.elementToString(extra.relatedTarget),\n                    target: self.elementToString(extra.target || extra.srcElement),\n                    tstamp: Date.now()\n                };\n\n                var touch = extra.touches[0];\n\n                if(touch)\n                {\n                    info.clientX = touch.clientX;\n                    info.clientY = touch.clientY;\n                }\n            }\n            else if (window.PointerEvent && extra instanceof window.PointerEvent)\n            {\n                info =\n                {\n                    type: extra.type,\n                    currentTarget: self.elementToString(extra.currentTarget),\n                    relatedTarget: self.elementToString(extra.relatedTarget),\n                    target: self.elementToString(extra.target || extra.srcElement),\n                    clientX: extra.clientX,\n                    clientY: extra.clientY,\n                    tstamp: Date.now()\n                };\n            }\n            else if (extra instanceof window.Event)\n            {\n                info =\n                {\n                    type: extra.type,\n                    currentTarget: self.elementToString(extra.currentTarget),\n                    relatedTarget: self.elementToString(extra.relatedTarget),\n                    target: self.elementToString(extra.target || extra.srcElement),\n                    tstamp: Date.now()\n                };\n            }\n            else if (extra instanceof Selection)\n            {\n                if (extra.rangeCount === 0)\n                {\n                    info = { rangeCount: 0 };\n                }\n                else\n                {\n                    var range = extra.getRangeAt(0);\n\n                    var startElement = range.startContainer;\n                    var startWasTextNode = false;\n                    var startElementLength = 0;\n\n                    var endElement = range.endContainer;\n                    var endWasTextNode = false;\n                    var endElementLength = 0;\n\n                    if (startElement.nodeType === Node.TEXT_NODE)\n                    {\n                        startElementLength = startElement.length;\n                        startElement = startElement.parentNode;\n                        startWasTextNode = true;\n                    }\n\n                    if (self.hasClass(startElement, 'text'))\n                    {\n                        startElementLength = getElementLength(startElement);\n                    }\n\n                    if (endElement.nodeType === Node.TEXT_NODE)\n                    {\n                        endElementLength = endElement.length;\n                        endElement = endElement.parentNode;\n                        endWasTextNode = true;\n                    }\n\n                    if (self.hasClass(endElement, 'text'))\n                    {\n                        startElementLength = getElementLength(endElement);\n                    }\n\n                    info =\n                    {\n                        rangeCount: extra.rangeCount,\n                        startContainer: self.elementToString(startElement),\n                        startWasTextNode: startWasTextNode,\n                        startOffset: range.startOffset,\n                        startElementLength: startElementLength,\n                        endContainer: self.elementToString(endElement),\n                        endWasTextNode: endWasTextNode,\n                        endOffset: range.endOffset,\n                        endElementLength: endElementLength\n                    };\n                }\n            }\n            else\n            {\n                info = extra;\n            }\n\n            extraString = safeStringify(info);\n        }\n        catch (err)\n        {\n            log('Error parsing extra ' + err.message);\n        }\n    }\n\n    return extraString;\n};\n\nwindow.__jsVersion = '1403041791456';\n\n// Report javascript errors back to web site\nself.handleJSError = function(msg, stack, extra, noMsg)\n{\n    if (!noMsg)\n    {\n        console.error('JS Error: ' + msg, '  Stack: ', stack, '  Extra: ', extra);\n    }\n\n    // Do not send errors to server in DEBUG mode or if there is no information to share.\n    if (DEBUG || (!msg && !stack))\n    {\n        debugger;\n    }\n    else\n    {\n        try\n        {\n            var logs = DEBUG ? '' : logs = __LOG_BUFFER.ordered().join('\\r\\n');\n\n            var user = self.getUserIdentifier();\n\n            var extraString = self.parseExtra(extra);\n\n            function reportError()\n            {\n                var appInfo = { };\n                self.getAppInfo(appInfo);\n\n                self.XHR({\n                    type: 'POST',\n                    url: window.location.protocol + '//api.moo.do/debug/reportError',\n                    data:\n                    {\n                        msg: msg,\n                        url: window.location.href,\n                        stack: stack,\n                        logs: logs,\n                        info: JSON.stringify(appInfo),\n                        user: user,\n                        extra: extraString,\n                        jsVersion: window.__jsVersion,\n                        htmlVersion: document.body.getAttribute('ver')\n                    },\n                    cb: function(xhr)\n                    {\n                        if (xhr.status !== 200)\n                        {\n                            log('Failed to report remote error', xhr.responseText, xhr);\n\n                            debugger;\n                        }\n                        else\n                        {\n                            log('Reported Remote Error: ', xhr.responseText);\n                        }\n                    }\n                });\n            }\n\n            if (user !== 'Unknown')\n            {\n                reportError();\n            }\n            else\n            {\n                self.getClientInfo(function (info)\n                {\n                    if (info)\n                    {\n                        user = info.ip;\n                    }\n\n                    reportError();\n                });\n            }\n        }\n        catch (err)\n        {\n            log('Badness happened reporting errors to server: ', err);\n            debugger;\n        }\n    }\n}\n\n// Ensure that all errors are logged even if we dont get actionable information on them.\nwindow.onerror = function (errorMsg, url, lineNumber, colNumber, errorObj)\n{\n    if (errorObj)\n    {\n        log('Reported Global OnError: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber + ' Column: ' + colNumber);\n\n        self.reportError(errorObj);\n    }\n    else\n    {\n        log('Unreported Global OnError: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber + ' Column: ' + colNumber);\n\n        self.reportError(errorMsg);\n    }\n};\n\nself.reportError = function(err, extra)\n{\n    if (err && !extra && !err.message && !err.stack)\n    {\n        extra = err;\n        err = undefined;\n    }\n\n    if (!err)\n    {\n        err = { message: 'Undefined error passed to reporter', stack: self.getCurrentStack('') };\n    }\n\n    self.handleJSError(err.message, err.stack, extra);\n};\n\nwindow.__SendInfo = function(text)\n{\n    self.handleJSError('Remote Client Info', undefined, text, /*noMsg*/true);\n\n    return 'Thank you for providing your client info!';\n};\n\nfunction generateRemoteDebugKey()\n{\n    var user = self.settings.get('activeUser');\n\n    if (!user)\n    {\n        return 'Unknown';\n    }\n\n    return 'MooDoRDebug' + (new Date()).getTime() + '_' + user;\n}\n\nwindow.__CreateDebugSession = function(key)\n{\n    if (window.remote)\n    {\n        return 'Debug session already started';\n    }\n\n    var debugKey = key || generateRemoteDebugKey();\n\n    window.rcon = window.console;\n\n    self.handleJSError('Remote Debug Session', undefined, debugKey, /*noMsg*/true);\n\n    self.addScript('http://jsconsole.com/remote.js?' + debugKey, 'rDebugScript');\n\n    {\n        var profileRunning = false;\n        var profileIndex = 0;\n        var profileName = '';\n\n        window.rdbg =\n        {\n            startProfile: function (forceName)\n            {\n                try\n                {\n                    if (!profileRunning)\n                    {\n                        profileName = forceName ? forceName : ('RDBGProfile_' + profileIndex);\n                        window.rcon.profile(profileName);\n\n                        profileRunning = true;\n\n                        return 'Profiler Started: ' + profileName;\n                    }\n                    else\n                    {\n                        return 'Profiler already running';\n                    }\n                }\n                catch (err)\n                {\n                    return 'Error starting profile: ' + err.message;\n                }\n            },\n            stopProfile: function ()\n            {\n                try\n                {\n                    if (profileRunning)\n                    {\n                        window.rcon.profileEnd(profileName);\n                        profileRunning = false;\n\n                        var retString = 'Profile Completed: ' + profileName;\n                        profileName = '';\n                        profileIndex++;\n\n                        return retString;\n                    }\n                    else\n                    {\n                        return 'Profiler not running, use startProfile()';\n                    }\n                }\n                catch (err)\n                {\n                    return 'Error stopping profile: ' + err.message;\n                }\n            }\n        };\n    }\n\n    return 'Your remote debug session has started: ' + debugKey;\n};\n\nif (util.hasURLParam('rdebug', 'true'))\n{\n    setTimeout(function ()\n    {\n        var useKey = util.getURLParam('rsession') || generateRemoteDebugKey();\n\n        window.__CreateDebugSession(useKey);\n\n        log('%c---- REMOTE DEBUGGING ENABLED: ' + useKey + ' ----', 'color: green');\n    }, 2000);\n}\n\nif (!DEBUG && !platform.demo)\n{\nconsole.log('%cIf you have been asked to send us your client information or have been seeing issues, please use __SendInfo(\"MESSAGE\") to give us your information.', 'color: green')\n}\n\nwindow.Checkpoint =\n{\n    MainRun:           0x01,\n    RequireLoaded:     0x02,\n    PageLoad:          0x04,\n    LocalDocLoad:      0x08,\n    InitData:          0x10,\n    DBLoaded:          0x20,\n    OnInitializedData: 0x40,\n    InitializeMain:    0x80,\n    MaskRequired:      0xFF,\n};\n\nself.checkpoint = function(chk)\n{\n    window.__checkpoints |= chk;\n};\n\nif (DEBUG)\n{\n    window.__chkp = function() { return window.__checkpoints.toString(16); }\n}\n\nself.hasSentLowMemoryWarning = ko.observable(false);\nself.handleLowMemory = function(e)\n{\n    if (!self.hasSentLowMemoryWarning())\n    {\n        self.hasSentLowMemoryWarning(true);\n\n        log('Low Memory Event: ', e);\n        self.handleJSError('DeviceLowMemory: ' + e, /*stack*/undefined);\n    }\n};\n\nvar fnRegex = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n\nvar supportSimpleStack = false;\nself.getCurrentStack = function(message)\n{\n    if (supportSimpleStack || platform.noErrorStacks)\n    {\n        try\n        {\n            var msg = JSON.stringify(message);\n        }\n        catch (err)\n        {\n            log('Error stringifying stack message', err, message);\n        }\n    }\n\n    if (supportSimpleStack)\n    {\n        var err = new Error(msg || message);\n\n        if (err.stack)\n        {\n            return err.stack;\n        }\n    }\n\n    supportSimpleStack = false;\n\n    //if (DEBUG || platform.noErrorStacks)\n    {\n        try\n        {\n            var callstack = [ 'GenError: ' + (msg || message) ];\n            var currentFunction = arguments.callee.caller;\n\n            var DEPTH_LIMIT = 75;\n\n            var depth = 0;\n            while (currentFunction && (depth++ < DEPTH_LIMIT))\n            {\n                var fn = currentFunction.toString();\n\n                var fnMatch = fnRegex.exec(fn);\n                var fnName;\n                if (fnMatch && fnMatch.length === 3 && fnMatch[1] !== '' && fnMatch[1] !== undefined)\n                {\n                    fnName = 'at ' + fnMatch[1] + '(' + fnMatch[2].replace(/[\\r\\n]/g, '') + ')';\n                }\n                else\n                {\n                    if (fnMatch && fnMatch.length === 3)\n                    {\n                        fnName = 'at <anonymous> (' + fnMatch[2].replace(/[\\r\\n]/g, '') + ')';\n                    }\n                    else\n                    {\n                        fnName = 'at <anonymous> (<unknown>)';\n                    }\n                }\n\n                callstack.push(fnName);\n\n                currentFunction = currentFunction.caller;\n            }\n\n            return callstack.join('\\n');\n        }\n        catch (err)\n        {\n            log('Error generating stack trace', err);\n        }\n    }\n\n    return '';\n};\n\nvar remoteUpdateWait = 1000 * 60 * 20; // 20 minutes (in ms)\nvar lastUpdateTime = 0;\nself.checkForRemoteChanges = function()\n{\n    var currentTime = Date.now();\n\n    if (lastUpdateTime - currentTime >= remoteUpdateWait)\n    {\n        try\n        {\n            // Check for updated site version from AppCache\n            self.AppCache.checkForUpdate();\n\n            self.messageQueue.updateRemoteMessages();\n        }\n        catch (err)\n        {\n            self.reportError(err);\n        }\n        finally\n        {\n            lastUpdateTime = currentTime;\n        }\n    }\n};\n\nself.createRingBuffer = function(len)\n{\n    var p = 0;\n    var b = [ ];\n    var limit = len;\n\n    return {\n        get: function (i) { return b[i]; },\n        push: function (e) { b[p] = e; p = (limit + p + 1) % limit; },\n        count: function () { return p; },\n        reset: function () { p = 0; b = [ ]; },\n        buffer: function () { return b; },\n        limit: function(lim) { limit = lim; },\n        ordered: function () { return b.slice(p).concat(b.slice(0, p)); },\n        entries: function ()\n        {\n            var arr = this.ordered();\n\n            for (var i = 0; i < arr.length; ++i)\n            {\n                console.log('---- Entry [' + i + '] ----');\n                console.log(arr[i]);\n            }\n        }\n    };\n}\n\nself.wrapFn = function(func)\n{\n    function wrapper()\n    {\n        if (DEBUG)\n        {\n            return func.apply(this, arguments);\n        }\n        else\n        {\n            try\n            {\n                return func.apply(this, arguments);\n            }\n            catch (err)\n            {\n                var argString;\n\n                try\n                {\n                    argString = JSON.stringify(arguments)\n                }\n                catch (err2)\n                {\n                    log('Unable to stringify args: ', arguments);\n                }\n                finally\n                {\n                    self.reportError(err, argString);\n                }\n            }\n        }\n    }\n\n    return wrapper;\n};\n\n(function wrapAsyncCallbacks()\n{\n    var _helper = function _helperFn(fnName)\n    {\n        var originalFn = window[fnName];\n\n        window[fnName] = function wrapAsyncFn()\n        {\n            var args = Array.prototype.slice.call(arguments);\n            var originalCallback = args[0];\n\n            if (typeof (originalCallback) === 'function')\n            {\n                args[0] = self.wrapFn(originalCallback);\n            }\n\n            if (originalFn.apply)\n            {\n                return originalFn.apply(this, args);\n            }\n            else\n            {\n                return originalFn(args[0], args[1]);\n            }\n        };\n    };\n\n    _helper('setTimeout');\n    _helper('setInterval');\n}());\n\nvar logBufferLength = platform.mobile ? 20 : 40;\nwindow.__LOG_BUFFER = self.createRingBuffer(logBufferLength);\n\nvar oldLog = window.log;\nif (DEBUG && platform.isChrome && !platform.mobile)\n{\n    var logErrorReported = false;\n    window.log = function ()\n    {\n        __LOG_BUFFER.push(Array.prototype.join.call(arguments, ' '));\n\n        try\n        {\n            console.groupCollapsed.apply(console, arguments);\n            var stack = new Error().stack.split('\\n');\n            for(var i = 2; i < stack.length; i ++)\n            {\n                // Trim and remove 'at ';\n                console.log('%c' + stack[i].trim().substring(3), 'padding-left: 10px; color: #777');\n            }\n            console.groupEnd();\n        }\n        catch (err)\n        {\n            logErrorReported = true;\n\n            if (!logErrorReported)\n            {\n                self.reportError(err);\n            }\n\n            console.log.apply(console, arguments);\n        }\n    };\n}\nelse\n{\n    window.log = function ()\n    {\n        __LOG_BUFFER.push(Array.prototype.join.call(arguments, ' '));\n        console.log.apply(console, arguments);\n    };\n}\n\nfor (var i in oldLog)\n{\n    window.log[i] = oldLog[i];\n}\n\nself.isFunction = function(obj)\n{\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n};\n\nself.isArray = function(obj)\n{\n    return Object.prototype.toString.call( obj ) === '[object Array]';\n};\n\nself.isString = function(obj)\n{\n    return (typeof obj === 'string');\n};\n\nself.isObject = function(obj)\n{\n    return (typeof obj === \"object\") && (obj !== null);\n};\n\n// function isDOMNode(o)\n// {\n//     return (typeof Node === \"object\" ? o instanceof Node : o && typeof o === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName===\"string\");\n// }\n\n// function isDOMElement(o)\n// {\n//     return (typeof HTMLElement === \"object\" ? o instanceof HTMLElement : o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName===\"string\");\n// }\n\nself.enumToString = function(en,value)\n{\n    for (var k in en)\n        if (en[k] == value)\n            return k;\n    return null;\n};\n\nself.elementToString = function(ele, includeLength)\n{\n    if (ele)\n    {\n        var nodeString = ele.nodeName;\n\n        if (ele.id)\n        {\n            nodeString += '#' + ele.id;\n        }\n\n        if (ele.className)\n        {\n            nodeString += '.' + ele.className;\n        }\n\n        if(includeLength && ele.innerText)\n        {\n            nodeString += ':' + ele.innerText.length;\n        }\n\n        return '[' + nodeString + ']';\n    }\n    else\n    {\n        return '[UNDEFINED]';\n    }\n};\n\n// self.numProperties = function(obj)\n// {\n//     return Object.keys(obj).length;\n// };\n\nself.highlightElement = function (ele, horizOffset, vertOffset)\n{\n    self.Assert(ele, 'Must have a valid element to highlight');\n\n    if (ele)\n    {\n        var horizP = horizOffset || 0.5;\n        var vertP = vertOffset || 1.0;\n\n        var box = ele.getBoundingClientRect();\n\n        var topOffset = box.top + (box.height * vertP);\n        var leftOffset = box.left + (box.width * horizP);\n\n        self.showArrowAt(topOffset, leftOffset);\n    }\n};\n\n// self.highlightElementAtOffset = function(ele, top, left)\n// {\n//     var box = ele.getBoundingClientRect();\n\n//     var topOffset = box.top + top;\n//     var leftOffset = box.left + left;\n\n//     self.showArrowAt(topOffset, leftOffset);\n// };\n\n// self.setHighlightRotation = function(deg)\n// {\n//     var arrow = document.getElementById('iarrow');\n//     self.Assert(arrow, 'Must have a valid highlight arrow');\n\n//     var txString = 'rotate(' + deg + 'deg)';\n//     arrow.style[platform.transform] = txString;\n// };\n\n// self.resetHighlightRotation = function()\n// {\n//     self.setHighlightRotation(-20);\n// };\n\nself.showArrowAt = function(top, left)\n{\n    var arrow = document.getElementById('iarrow');\n    self.Assert(arrow, 'Must have a valid highlight arrow');\n\n    arrow.style.display = 'block';\n\n    var extraOffset = (platform.mobile ? -35 : 0);\n\n    arrow.style.top = (top + extraOffset) + 'px';\n    arrow.style.left = left + 'px';\n};\n\nself.hideHighlightElement = function ()\n{\n    var arrow = document.getElementById('iarrow');\n    self.Assert(arrow, 'Must have a valid highlight arrow');\n\n    arrow.style.display = 'none';\n};\n\n// self.shouldShowKeyboardMenu = function ()\n// {\n//     if (self.phoneMenu.isSearchOut())\n//     {\n//         return false;\n//     }\n\n//     return true;\n// };\n\nif (DEBUG)\n{\n    var eventID = 1;\n\n    if (DEBUG) window.__eventBuffer = self.createRingBuffer(100);\n\n    function tagEvent(e, info, handlers)\n    {\n        if (!e.id)\n        {\n            e.id = eventID++;\n\n            if (DEBUG) window.__eventBuffer.push(e);\n        }\n\n        if (DEBUG)\n        {\n            e.activeHandler = { owner: info, fn: handlers };\n\n            if (e.handlers)\n            {\n                e.handlers.push(e.activeHandler);\n            }\n            else\n            {\n                e.handlers = [ e.activeHandler ];\n            }\n        }\n    }\n\n    window.__tagEvent = tagEvent;\n}\n\nif (DEBUG && DEBUG)\n{\n    function replaceFunction(obj, name)\n    {\n        var rep = obj.prototype[name];\n\n        obj.prototype[name] = function ()\n        {\n            if (this.activeHandler)\n            {\n                log(this.type + '.' + name + ' ' + self.elementToString(this.target) + self.elementToString(this.activeHandler.owner));\n            }\n            else\n            {\n                log(this.type + '.' + name + ' ' + self.elementToString(this.target) + '[NOTTAGGED]');\n            }\n\n            var stack = self.getCurrentStack();\n            var call = { fn: name, handler: (this.activeHandler ? this.activeHandler.owner : 'NOTTAGGED'), stack: stack };\n\n            if (this.calls)\n            {\n                this.calls.push(call);\n            }\n            else\n            {\n                this.calls = [ call ];\n            }\n\n            rep.call(this);\n        };\n    }\n\n    if (window.MouseEvent)\n    {\n        replaceFunction(MouseEvent, 'stopImmediatePropagation');\n        replaceFunction(MouseEvent, 'stopPropagation');\n        replaceFunction(MouseEvent, 'preventDefault');\n    }\n\n    if (window.TouchEvent)\n    {\n        replaceFunction(TouchEvent, 'stopImmediatePropagation');\n        replaceFunction(TouchEvent, 'stopPropagation');\n        replaceFunction(TouchEvent, 'preventDefault');\n    }\n\n    if (window.PointerEvent)\n    {\n        replaceFunction(PointerEvent, 'stopImmediatePropagation');\n        replaceFunction(PointerEvent, 'stopPropagation');\n        replaceFunction(PointerEvent, 'preventDefault');\n    }\n}\n\nfunction fnCatch(cb)\n{\n    self.Assert(cb, 'Must specify a callback');\n\n    return function dbgCatch()\n    {\n        if (DEBUG)\n        {\n            if (cb)\n            {\n                return cb.apply(undefined, arguments);\n            }\n        }\n        else\n        {\n            try\n            {\n                if (cb)\n                {\n                    return cb.apply(undefined, arguments);\n                }\n            }\n            catch (err)\n            {\n                self.reportError(err, arguments);\n                throw err;\n            }\n        }\n    };\n}\n\nvar dblClickTime = 500;\nself.setupClick = function(obj, item, params)\n{\n    self.Assert(obj, 'Expecting an object to bind the click hanlders to.');\n\n    if (!obj)\n    {\n        log('Skipping setupClick because no valid DOM object was provided to bind to');\n\n        return;\n    }\n\n    if (DEBUG) log('SetupClick: ' + self.elementToString(obj));\n\n    if (!item)\n    {\n        item = obj;\n    }\n\n    var useCapture = false;\n    if (self.isFunction(params))\n    {\n        params = { onClick: params };\n    }\n    else\n    {\n        if (params)\n        {\n            if (params.useCapture)\n            {\n                useCapture = params.useCapture;\n            }\n        }\n    }\n\n    //\n    // Backend Event Handlers\n    //\n\n    function move(e)\n    {\n        //if (DEBUG) log('Move: ', e.id);\n\n        var xThisFrame = e.eventX - this.lastX;\n        var yThisFrame = e.eventY - this.lastY;\n\n        if (xThisFrame !== 0 || yThisFrame !== 0)\n        {\n            var firstMove = !this.moved;\n\n            this.lastX = e.eventX;\n            this.lastY = e.eventY;\n\n            e.distanceX = this.distanceX = this.distanceX + Math.abs(xThisFrame);\n            e.distanceY = this.distanceY = this.distanceY + Math.abs(yThisFrame);\n\n            if (this.moved || e.distanceX > self.ClickThreshold || e.distanceY > self.ClickThreshold)\n            {\n                this.moved = true;\n                e.moved = this.moved;\n            }\n\n            if (params.onMove || params.onFirstMove)\n            {\n                e.diffX = e.eventX - this.startX;\n                e.diffY = e.eventY - this.startY;\n\n                e.xThisFrame = xThisFrame;\n                e.yThisFrame = yThisFrame;\n\n                e.xFromTopLeft = this.xFromTopLeft;\n                e.yFromTopLeft = this.yFromTopLeft;\n\n                e.startX = this.startX;\n                e.startY = this.startY;\n\n                e.startClientX = this.startClientX;\n                e.startClientY = this.startClientY;\n\n                e.startSrc = this.startSrc;\n\n                if (firstMove && params.onFirstMove)\n                {\n                    params.onFirstMove.call(item, e);\n                }\n\n                if (params.onMove)\n                {\n                    var handled = false;\n                    handled = params.onMove.call(item, e);\n\n                    if (handled)\n                    {\n                        e.stopImmediatePropagation();\n                    }\n                }\n\n                // if (e.overrides)\n                // {\n                //     var obj = e.overrides;\n                //     for (var i in obj)\n                //     {\n                //         if (obj.hasOwnProperty(i))\n                //         {\n                //             self.Assert(this[i], 'Trying to override a property that does not exist', i);\n                //             this[i] = obj[i];\n                //         }\n                //     }\n                // }\n            }\n        }\n    }\n\n    function end(e)\n    {\n        if (DEBUG) log('End: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var now = Date.now();\n\n        var lastTouch = this.lastTouch || now;\n        var delta = Math.max(0, now - lastTouch);\n\n        if (!this.numClicks)\n        {\n            this.numClicks = 1;\n        }\n        else\n        {\n            this.numClicks++;\n        }\n\n        e.eventX = this.lastX;\n        e.eventY = this.lastY;\n\n        e.moved = this.moved;\n\n        e.timeDelta = delta;\n\n        e.diffX = (this.lastX - this.startX);\n        e.diffY = (this.lastY - this.startY);\n\n        e.startX = this.startX;\n        e.startY = this.startY;\n\n        e.xFromTopLeft = this.xFromTopLeft;\n        e.yFromTopLeft = this.yFromTopLeft;\n\n        e.startSrc = this.startSrc;\n\n        if (delta < dblClickTime && delta > 0)\n        {\n            if(params.onDblClick && !this.moved)\n            {\n                params.onDblClick.call(item, e);\n            }\n        }\n        if (isNaN(e.button) || e.button === 0)\n        {\n            this.lastTouch = now;\n\n            if (params.onClick && !this.moved)\n                params.onClick.call(item, e);\n        }\n        else if (e.button == 1)\n        {\n            if (params.onMiddleClick && !this.moved)\n                params.onMiddleClick.call(item, e);\n        }\n\n        if ((isNaN(e.button) || e.button === 0) && params.onEnd)\n        {\n            params.onEnd.call(item, e);\n        }\n\n        setTimeout(function()\n        {\n            this.lastTouch = undefined;\n            this.numClicks = undefined;\n        }.bind(this), dblClickTime);\n    }\n\n    function cancel(e)\n    {\n        if (DEBUG) log('Cancel: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        if (params.onCancel)\n        {\n            params.onCancel.call(item, e);\n        }\n    }\n\n    function start(e)\n    {\n        if (DEBUG) log('Start: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        e.timeStart = this.timeStart = Date.now();\n\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        this.startSrc = e.srcElement;\n\n        this.moved = false;\n\n        e.startX = this.startX = e.eventX;\n        e.startY = this.startY = e.eventY;\n\n        e.startClientX = this.startClientX = e.clientX;\n        e.startClientY = this.startClientY = e.clientY;\n\n        this.lastX = e.eventX;\n        this.lastY = e.eventY;\n\n        this.distanceX = 0;\n        this.distanceY = 0;\n\n        var offset = self.offset(e.srcElement);\n\n        e.xFromTopLeft = this.xFromTopLeft = e.eventX - offset.left;\n        e.yFromTopLeft = this.yFromTopLeft = e.eventY - offset.top;\n\n        if ((isNaN(e.button) || e.button === 0) && params.onStart)\n        {\n            params.onStart.call(item, e);\n        }\n\n        if (!isNaN(e.changeLastY))\n        {\n            this.lastY += e.changeLastY;\n        }\n    }\n\n    //\n    // Touch Passthrough Handlers\n    //\n\n    function touchMove(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        //if (DEBUG) log('TouchMove: ', e.id);\n\n        var touch = (platform.ie ? e : e.touches[0]);\n\n        e.eventX = touch.pageX;\n        e.eventY = touch.pageY;\n\n        e.clientX = touch.clientX;\n        e.clientY = touch.clientY;\n\n        move.call(obj, e);\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    var touchStartHandler = fnCatch(touchStart);\n    var touchMoveHandler = fnCatch(touchMove);\n    var touchEndHandler = fnCatch(touchUp);\n    var touchCancelHandler = fnCatch(touchCancel);\n\n    function touchUp(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (DEBUG) log('TouchUp: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        document.removeEventListener(platform.touchMoveEvent, touchMoveHandler, useCapture);\n        document.removeEventListener(platform.touchEndEvent, touchEndHandler, useCapture);\n        document.removeEventListener(platform.touchCancelEvent, touchCancelHandler, useCapture);\n\n        if (gesture)\n        {\n            gesture.stop();\n        }\n\n        end.call(obj, e);\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    function touchCancel(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (DEBUG) log('TouchCancel: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        document.removeEventListener(platform.touchMoveEvent, touchMoveHandler, useCapture);\n        document.removeEventListener(platform.touchEndEvent, touchEndHandler, useCapture);\n        document.removeEventListener(platform.touchCancelEvent, touchCancelHandler, useCapture);\n\n        if (gesture)\n        {\n            gesture.stop();\n        }\n\n        cancel.call(obj, e);\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    var gesture = undefined;\n\n    // if (platform.ie && platform.isTouchDevice && DEBUG)\n    // {\n    //     function gestureEv(e)\n    //     {\n    //         log('Gesture: ' + e.type + ': ', self.elementToString(e.target), self.elementToString(obj), e);\n    //     };\n\n    //     obj.addEventListener('MSGestureStart', gestureEv, useCapture);\n    //     obj.addEventListener('MSGestureEnd', gestureEv, useCapture);\n    //     obj.addEventListener('MSGestureChange', gestureEv, useCapture);\n    //     obj.addEventListener('MSGestureTap', gestureEv, useCapture);\n    //     obj.addEventListener('MSGestureHold', gestureEv, useCapture);\n    //     obj.addEventListener('MSInertiaStart', gestureEv, useCapture);\n\n    //     gesture = new MSGesture();\n    //     gesture.target = obj;\n    // }\n\n    function touchStart(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (e.handled)\n        {\n            return;\n        }\n\n        if (DEBUG) log('TouchStart: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        this.lastInputTouch = true;\n        // e.handled = true;\n\n        var touch = (platform.ie ? e : e.touches[0]);\n\n        e.eventX = touch.pageX;\n        e.eventY = touch.pageY;\n\n        e.clientX = touch.clientX;\n        e.clientY = touch.clientY;\n\n        start.call(obj, e);\n\n        if (!e.ignore)\n        {\n            document.addEventListener(platform.touchMoveEvent, touchMoveHandler, useCapture);\n            document.addEventListener(platform.touchEndEvent, touchEndHandler, useCapture);\n            document.addEventListener(platform.touchCancelEvent, touchCancelHandler, useCapture);\n\n            // Note: Don't want to stop propagation in start because taps on items\n            // need to bubble up to content to take the default action\n\n            if (gesture)\n            {\n                log('Add Gesture Pointer: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n                gesture.addPointer(e.pointerId);\n            }\n        }\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    //\n    // Mouse Passthrough Handlers\n    //\n\n    function mouseMove(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (this.lastInputTouch)\n        {\n            return;\n        }\n\n        //if (DEBUG) log('MouseMove: ', e.id);\n\n        e.eventX = e.pageX;\n        e.eventY = e.pageY;\n\n        move.call(obj, e);\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    var mouseDownHandler = fnCatch(mouseDown);\n    var mouseMoveHandler = fnCatch(mouseMove);\n    var mouseUpHandler = fnCatch(mouseUp);\n    var contextMenuHandler = fnCatch(contextMenu);\n\n    function mouseUp(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (e.handled || this.lastInputTouch)\n        {\n            return;\n        }\n\n        if (DEBUG) log('MouseUp: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        document.removeEventListener(platform.moveEvent, mouseMoveHandler, useCapture);\n        document.removeEventListener(platform.upEvent, mouseUpHandler, useCapture);\n\n        if (e.button === 0)\n        {\n            end.call(obj, e);\n        }\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    function mouseDown(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (e.handled || this.lastInputTouch)\n        {\n            return;\n        }\n\n        if (DEBUG) log('MouseDown: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        this.lastInputTouch = false;\n\n        e.eventX = e.pageX;\n        e.eventY = e.pageY;\n\n        start.call(obj, e);\n\n        if (!e.ignore)\n        {\n            if (e.button === 0)\n            {\n                document.addEventListener(platform.moveEvent, mouseMoveHandler, useCapture);\n            }\n\n            document.addEventListener(platform.upEvent, mouseUpHandler, useCapture);\n        }\n\n        if (e.returnFalse)\n        {\n            return false;\n        }\n    }\n\n    function contextMenu(e)\n    {\n        if (DEBUG) { tagEvent(e, obj, params); }\n\n        if (e.handled || this.lastInputTouch)\n        {\n            return;\n        }\n\n        if (DEBUG) log('ContextMenu: ', e.id, self.elementToString(e.target), self.elementToString(obj));\n\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        if (params.onRightClick)\n        {\n            params.onRightClick.call(item, e);\n        }\n    }\n\n    if (platform.isTouchDevice)\n    {\n        obj.addEventListener(platform.touchStartEvent, touchStartHandler, useCapture);\n    }\n    else\n    {\n        obj.addEventListener(platform.downEvent, mouseDownHandler, useCapture);\n    }\n\n    if (platform.usePointerEvents && platform.mobile)\n    {\n        obj.addEventListener('mousedown', function (e)\n        {\n            if (DEBUG) { tagEvent(e, obj, params); }\n\n            if (!android.isEnabled() || !android.isTargetBox(e))\n            {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            }\n\n            return false;\n        }, useCapture);\n    }\n\n    if (params.onRightClick && !platform.mobile)\n    {\n        obj.addEventListener('contextmenu', contextMenuHandler, useCapture);\n    }\n\n    return this;\n};\n\nvar spinnerRunning = false;\nself.StartSpinner = function()\n{\n    if (platform.mobile && !spinnerRunning)\n    {\n        spinnerRunning = true;\n\n        self.removeClass(document.getElementById('loading'), 'hidden');\n    }\n};\n\nself.StopSpinner = function()\n{\n    var spinner = document.getElementById('loading');\n\n    if (spinnerRunning && spinner)\n    {\n        self.addClass(document.getElementById('loading'), 'hidden');\n    }\n};\n\n// self.removeClick = function(element)\n// {\n//     if (platform.isTouchDevice)\n//     {\n//         element[platform.onTouchStartEvent] = undefined;\n//     }\n\n//     element.onmousedown = undefined;\n// };\n\nArray.prototype.removeAt = function(from)\n{\n    return this.splice(from, 1)[0];\n};\n\nArray.prototype.remove = function(obj)\n{\n    var index = this.indexOf(obj);\n\n    if (index >= 0)\n    {\n        this.removeAt.call(this, index);\n    }\n\n    return index;\n};\n\n// Array.prototype.insertArrayAt = function(index, arrayToInsert) {\n//     Array.prototype.splice.apply(this, [index, 0].concat(arrayToInsert));\n//     return this;\n// };\n\n// Array.prototype.arrayMap = function (mapping)\n// {\n//     var result = [ ];\n\n//     for (var i = 0, j = this.length; i < j; ++i)\n//     {\n//         var it = mapping(this[i]);\n//         if (it)\n//         {\n//             result.push(it);\n//         }\n//     }\n\n//     return result;\n// };\n\nArray.prototype.findInsertIndex = function (ele, comp)\n{\n    self.Assert(ele, 'Require a valid element to insert');\n    self.Assert(comp, 'Require a valid comparison function');\n\n    var low = 0;\n    var high = this.length - 1;\n\n    while (low <= high)\n    {\n        var i = (low + high) >> 1;\n        var c = comp(this[i], ele);\n\n        if (c < 0)\n        {\n            low = i + 1;\n        }\n        else if (c > 0)\n        {\n            high = i - 1;\n        }\n        else\n        {\n            return i;\n        }\n    }\n\n    return low;\n}\n\nArray.prototype.insertSorted = function (ele, comp)\n{\n    var idx = this.findInsertIndex(ele, comp);\n\n    this.splice.apply(this, [idx, 0, ele]);\n};\n\nko.observableArray.fn.insertSorted = function (ele, comp)\n{\n    this.peek().insertSorted(ele, comp);\n\n    this.valueHasMutated();\n};\n\nself.clamp = function(val, min, max)\n{\n    return Math.max(min, Math.min(max, val));\n};\n\n// self.pad2 = function(number) {\n//     return (number < 10 ? '0' : '') + number;\n// };\n\nself.randParam = function()\n{\n    return '?t=' + Date.now();\n};\n\n// self.getDateText = function(d) {\n//     var hour = (d.getHours() % 12);\n//     if (hour === 0)\n//         hour = 12;\n//     return (d.getMonth() + 1) + '/' + d.getDate() + ' ' + hour + ':' + pad2(d.getMinutes()) + ((d.getHours() < 11) ? ' AM' : '');\n// };\n\n// Date.prototype.sameDateAs = function(pDate){\n//     return ((this.getFullYear()==pDate.getFullYear())&&(this.getMonth()==pDate.getMonth())&&(this.getDate()==pDate.getDate()));\n// };\n\n// Date.prototype.toShortDateString = function() {\n//     return this.getMonth() + this.getDate() + this.getFullYear();\n// }\n\n// self.onTransitionEnd = function(obj, handler)\n// {\n//     function _handler(event)\n//     {\n//         obj.removeEventListener(platform.transitionEnd, _handler);\n//         handler(event);\n//     }\n\n//     obj.addEventListener(platform.transitionEnd, _handler, false);\n// };\n\nfunction readyStateCallback(e, callback)\n{\n    e.onloadDone = false; //for Opera\n    e.onload = function()\n    {\n        e.onloadDone = true;\n        if (callback)\n        {\n            callback();\n        }\n    };\n\n    e.onReadystatechange = function()\n    {\n        if (e.readyState === 'loaded' && !e.onloadDone)\n        {\n            e.onloadDone = true;\n\n            if (callback)\n            {\n                callback();\n            }\n        }\n    };\n}\n\nself.createPath = function(filename)\n{\n    return window.location.protocol + '//' + window.location.host + '/' + filename;\n};\n\nself.addScript = function(filename, id, callback)\n{\n    var e = document.createElement('script');\n    e.type = 'text/javascript';\n    e.src = filename;\n\n    if (id)\n    {\n        e.id = id;\n    }\n\n    if (callback)\n    {\n        readyStateCallback(e, callback);\n    }\n\n    if (typeof(e) !== 'undefined')\n    {\n        document.getElementsByTagName('head')[0].appendChild(e);\n    }\n};\n\nself.addStylesheet = function(filename, callback)\n{\n    var e = document.createElement('link');\n    e.type = 'text/css';\n    e.rel = 'stylesheet';\n    e.href = filename;\n\n    if (callback)\n    {\n        readyStateCallback(e, callback);\n    }\n\n    if (typeof(e) !== 'undefined')\n    {\n        document.getElementsByTagName('head')[0].appendChild(e);\n    }\n};\n\n//\n// Debug Helpers\n//\n\nfunction makeString(args)\n{\n    var str = '';\n\n    for (var i = 0; i < args.length; ++i)\n    {\n        str += (' ' + safeStringify(args[i]));\n    }\n\n    return str;\n}\n\nif (DEBUG)\n{\n\nself.Assert = function(value)\n{\n    if (!value)\n    {\n        try\n        {\n            if (arguments.length > 1)\n            {\n                console.error.apply(console, Array.prototype.slice.call(arguments, 1));\n\n                if (DEBUG && DEBUG && window.__handleAssertForTest)\n                {\n                    window.__handleAssertForTest(Array.prototype.slice.call(arguments, 1));\n                }\n            }\n            else\n            {\n                console.error('Assert Failure!');\n\n                if (DEBUG && DEBUG && window.__handleAssertForTest)\n                {\n                    window.__handleAssertForTest('Assert Failure');\n                }\n            }\n        }\n        catch (err)\n        {\n            // Ignore error\n            console.error('Problem reporting Assert!');\n        }\n\n        debugger;\n    }\n};\n\n}\n\nself.PAssert = function(tag, value)\n{\n    if (!value)\n    {\n        var assertExtra = { isAssert: true, tag: tag };\n\n        try\n        {\n            var argString = makeString(Array.prototype.slice.call(arguments, 2));\n\n            if (arguments.length > 2)\n            {\n                log('Assert Failure: ' + argString);\n            }\n            else\n            {\n                log('Assert Failure');\n            }\n\n            self.reportError(new Error('Assert Failure: ' + argString), assertExtra);\n        }\n        catch (err)\n        {\n            log('Exception in PAssert: ', err);\n\n            self.reportError(err, assertExtra);\n        }\n    }\n};\n\n//\n// DOM Helpers\n//\n\nself.getSelectionInfo = function()\n{\n    var selection = window.getSelection();\n\n    var node = selection.anchorNode;\n\n    if (node)\n    {\n        return {node: (node.nodeType === Node.TEXT_NODE ? node.parentNode : node), selection: selection};\n    }\n\n    return undefined;\n};\n\nself.getSelectionRange = function()\n{\n    var selection = window.getSelection();\n\n    if (selection.rangeCount > 0)\n    {\n        var range = selection.getRangeAt(0);\n\n        return range;\n    }\n\n    return undefined;\n};\n\n// self.backupSelection = function()\n// {\n//     var selection = window.getSelection();\n//     var range = selection.getRangeAt(0);\n\n//     this.selectionBackup =\n//     {\n//         startContainer: range.startContainer,\n//         endContainer: range.endContainer,\n//         startOffset: range.startOffset,\n//         endOffset: range.endOffset\n//     };\n\n//     //log(this.selectionBackup.startContainer);\n// };\n\n// self.restoreSelection = function()\n// {\n//     var sel = window.getSelection();\n//     var range = document.createRange();\n\n//     range.setStart(this.selectionBackup.startContainer, this.selectionBackup.startOffset);\n//     range.setEnd(this.selectionBackup.endContainer, this.selectionBackup.endOffset);\n\n//     sel.removeAllRanges();\n//     sel.addRange(range);\n// };\n\nself.getItemForElement = function(el)\n{\n    if (android.isEnabled())\n    {\n        var currentVMLI = android.getCurrentVMLI();\n\n        if (currentVMLI)\n        {\n            return currentVMLI;\n        }\n    }\n\n    if (el && el !== document.body)\n    {\n        // If the node being requested is a #text node, ensure a valid element is used instead\n        if (el.nodeType === Node.TEXT_NODE)\n        {\n            el = el.parentNode;\n        }\n\n        var vm = ko.dataFor(el);\n\n        return (vm instanceof VMLI) ? vm : undefined;\n    }\n\n    return undefined;\n};\n\nself.getSelectedItem = function()\n{\n    var selection = window.getSelection();\n\n    return self.getItemForElement(selection.anchorNode);\n};\n\n// TODO: Remove this function in favor of traversing the items tree\n// Get the LI that is the next line\n// self.getNextLI = function(li, e)\n// {\n//     var ulIndex = 0;\n//     for (var i = 1; i < li.children.length; i ++)\n//     {\n//         if(li.children[i].nodeName === 'UL')\n//         {\n//             ulIndex = i;\n//             break;\n//         }\n//     }\n\n//     if (ulIndex)\n//     {\n//         if(e)\n//             e.numLevels++;\n//         // li -> ul -> first li\n//         if(li.children[ulIndex].children[0])\n//             return li.children[ulIndex].children[0].tagName == 'LI' ? li.children[ulIndex].children[0] : null;\n//         else\n//             return null;\n//     }\n//     else if (li.nextElementSibling)\n//     {\n//         return li.nextElementSibling.tagName == 'LI' ? li.nextElementSibling : null;\n//     }\n//     else\n//     {\n//         var parent = li;\n//         var next;\n\n//         do\n//         {\n//             if(e)\n//                 e.numLevels--;\n//             // li -> ul -> parent li\n//             parent = parent.parentElement.parentElement;\n//             next = parent.nextElementSibling;\n//         } while(!next);\n\n//         return next.tagName == 'LI' ? next : null;\n//     }\n// };\n\nself.clearSelection = function()\n{\n    if (DEBUG) log('Clear Selection');\n\n    window.getSelection().removeAllRanges();\n};\n\n// Get all text node children under a given <span class='text'> element.\nfunction getTextNodesIn(element)\n{\n    // TODO: Support nested styling - change to descendants instead of children?\n    var nodes = [];\n\n    function getTextNodes(node)\n    {\n        if (node)\n        {\n            if (node.nodeType === Node.TEXT_NODE)\n            {\n                nodes.push(node);\n            }\n            else\n            {\n                for (var i = 0; i < node.childNodes.length; ++i)\n                {\n                    var el = node.childNodes[i];\n                    // if(el.tagName == 'B' || el.tagName == 'I' || el.tagName == 'U')\n                    // {\n                    //     if(isNaN(el.length))\n                    //     {\n                    //         el.length = 1;\n                    //     }\n                    //     nodes.push(el);\n                    //     getTextNodes(el);\n                    //     nodes.push(el);\n                    // }\n                    // else\n                    // {\n                        getTextNodes(el);\n                    // }\n                }\n            }\n        }\n    }\n\n    getTextNodes(element);\n\n    return nodes;\n};\n\nself.selectElement = function (ele, selectEnd)\n{\n    if (ele.textContent.length > 0 && ele.textContent !== TextSpace)\n    {\n        var sel = window.getSelection();\n        var range = document.createRange();\n\n        var selStart = (selectEnd ? ele.textContent.length : 0);\n\n        range.setStart(ele.childNodes[0], selStart);\n        range.setEnd(ele.childNodes[0], ele.textContent.length);\n\n        if (DEBUG) log('Set Selection: [' + selStart + ',' + ele.textContent.length + ']', ele.childNodes[0]);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else\n    {\n        ele.focus();\n\n        if (DEBUG) log('Set Focus:', ele);\n    }\n};\n\n// Given a <span class='text'> element, select text independent of styling given a starting\n// offset and length. This is useful when used in conjunction with the functions below that\n// give offsets of selected text based on span elements.\nself.selectChildren = function(item, start, length)\n{\n    if (!item)\n    {\n        self.Assert(false, 'Valid item and text required to perform selection');\n\n        return;\n    }\n\n    var maxLength = item.getParsedText().length - item.styleLength;\n    var start = Math.min(start, maxLength);\n    var end = Math.min(start + length, maxLength);\n\n    var sel = window.getSelection();\n    var range = document.createRange();\n\n    var startElement = undefined;\n    var startOffset = -1;\n\n    var endElement = undefined;\n    var endOffset = -1;\n    var totalOffset = 0;\n\n    // The element may be undefined in cases where we are undoing an item deletion or\n    // are trying to select into an unloaded item.\n    var element = item.getSpan();\n\n    if (element)\n    {\n        var children = getTextNodesIn(element);\n\n        for (var i = 0; i < children.length; ++i)\n        {\n            var childLength = children[i].length;\n            if (startOffset === -1 && (totalOffset + childLength) >= start)\n            {\n                startElement = children[i];\n                startOffset = start - totalOffset;\n            }\n\n            if ((totalOffset + childLength >= end))\n            {\n                endElement = children[i];\n                endOffset = end - totalOffset;\n                break;\n            }\n            totalOffset += childLength;\n        }\n\n        self.Assert(startElement && startOffset >= 0);\n        self.Assert(endElement && endOffset >= 0);\n\n        self.Assert(startOffset <= startElement.length);\n        self.Assert(endOffset <= endElement.length);\n\n        startOffset = (startOffset < 0) ? 0 : startOffset;\n        endOffset = (endOffset < 0) ? 0 : endOffset;\n\n        range.setStart(startElement, startOffset);\n        range.setEnd(endElement, endOffset);\n\n        if (DEBUG) log('Set Selection: [' + startOffset + ',' + endOffset + ']', startElement, endElement);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n};\n\n// Given a <span class='text'> element, find the element that the offset maps to. This is\n// useful when the span has styled text and the element may not be the span's firstChild.\nfunction getOffsetChildElement(element, offset)\n{\n    var totalOffset = 0;\n    var children = getTextNodesIn(element);\n\n    for (var i = 0; i < children.length; ++i)\n    {\n        var childLength = children[i].length;\n        if ((totalOffset + childLength) >= offset)\n        {\n            return { element: children[i], offset: offset - totalOffset };\n        }\n\n        totalOffset += childLength;\n    }\n\n    self.Assert(false, 'Unable to find offset child element');\n\n    return undefined;\n};\n\nfunction getElementLength(element)\n{\n    var children = getTextNodesIn(element);\n\n    var total = 0;\n\n    for (var i = 0; i < children.length; ++i)\n    {\n        total += children[i].length;\n    }\n\n    return total;\n}\n\nself.getOffsetOfSubNode = function(element, subnode)\n{\n    var offset = 0;\n    var children = getTextNodesIn(element);\n    var childrenSub = getTextNodesIn(subnode);\n    for (var i = 0; i < children.length; ++i)\n    {\n        if(children[i] == childrenSub[0])\n        {\n            break;\n        }\n        // var childLength = children[i].length;\n        offset += children[i].length;\n    }\n    return offset;\n};\n\n// Given a starting element and offset and an ending element and offset, sets the current\n// text selection to range.\nself.selectMultiline = function(eStart, oStart, eEnd, oEnd)\n{\n    var retVal = false;\n\n    var sel = window.getSelection();\n    var range = document.createRange();\n\n    var start = getOffsetChildElement(eStart, oStart);\n    var end = getOffsetChildElement(eEnd, oEnd);\n\n    self.Assert(start && start.element && !isNaN(start.offset), 'Start element is invalid');\n    self.Assert(end && end.element && !isNaN(end.offset), 'End element is invalid');\n\n    if (start && start.element && end && end.element)\n    {\n        range.setStart(start.element, start.offset);\n        range.setEnd(end.element, end.offset);\n\n        if (DEBUG) log('Set Selection: [' + start.offset + ',' + end.offset + ']', start.element, end.element);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n\n        retval = true;\n    }\n\n    return retVal;\n};\n\nself.saveSelectionItem = function(range)\n{\n    if (!range)\n    {\n        var selection = self.getSelectionInfo();\n\n        if (!selection || selection.rangeCount === 0)\n        {\n            return undefined;\n        }\n\n        range = selection.selection.getRangeAt(0);\n    }\n\n    var validSelectionInfo = true;\n\n    if (range && range.startContainer && range.endContainer)\n    {\n        try\n        {\n            var startItem = self.getItemForElement(range.startContainer);\n            var endItem = self.getItemForElement(range.endContainer);\n\n            if (startItem && endItem)\n            {\n                var startOffsets = self.getSelectOffsetsInSpan(startItem, startItem.getSpan(), range);\n                var endOffsets = self.getSelectOffsetsInSpan(endItem, endItem.getSpan(), range);\n\n                var savedPane = self.getPaneForElement(startItem.getSpan());\n            }\n            else\n            {\n                validSelectionInfo = false;\n            }\n        }\n        catch (err)\n        {\n            self.reportError(err);\n\n            validSelectionInfo = false;\n        }\n    }\n    else\n    {\n        validSelectionInfo = false;\n    }\n\n    var selData = undefined;\n    if (validSelectionInfo)\n    {\n        selData = { start: startOffsets, end: endOffsets, startItem: startItem, endItem: endItem, pane: savedPane };\n    }\n\n    return selData;\n};\n\nvar savedSelections = { };\nself.saveSelection = function (name, range)\n{\n    savedSelections[name] = self.saveSelectionItem(range, name);\n};\n\nself.clearSavedSelection = function (name)\n{\n    savedSelections[name] = undefined;\n};\n\nself.restoreSavedSelection = function (name, forcePane)\n{\n    var selData = savedSelections[name];\n    var restoreItem = undefined;\n\n    if (selData && (!forcePane || forcePane === selData.pane))\n    {\n        try\n        {\n            restoreItem = self.restoreSelectionItem(selData);\n\n            if (restoreItem)\n            {\n                self.scrollIntoView(restoreItem.getSpan(), 0);\n            }\n        }\n        catch (err)\n        {\n            self.reportError(err);\n        }\n\n        self.clearSavedSelection(name);\n    }\n\n    return !!restoreItem;\n};\n\nself.restoreSelectionItem = function(selectionInfo)\n{\n    self.Assert(selectionInfo, 'Must restore to a valid selection');\n\n    var startIsHidden = self.hasClass(selectionInfo.startItem.getElement(), 'hidden');\n    var endIsHidden = self.hasClass(selectionInfo.endItem.getElement(), 'hidden');\n\n    if (startIsHidden && !endIsHidden)\n    {\n        var setSelection = self.selectMultiline(selectionInfo.endItem.getSpan(), selectionInfo.end.end, selectionInfo.endItem.getSpan(), selectionInfo.end.end);\n\n        return setSelection ? selectionInfo.endItem : undefined;\n    }\n    else if (!startIsHidden && endIsHidden)\n    {\n        var setSelection = self.selectMultiline(selectionInfo.startItem.getSpan(), selectionInfo.start.start, selectionInfo.startItem.getSpan(), selectionInfo.start.start);\n\n        return setSelection ? selectionInfo.startItem : undefined;\n    }\n    else\n    {\n        var setSelection = self.selectMultiline(selectionInfo.startItem.getSpan(), selectionInfo.start.start, selectionInfo.endItem.getSpan(), selectionInfo.end.end);\n\n        return setSelection ? selectionInfo.startItem : undefined;\n    }\n\n    return undefined;\n};\n\n// Gets both the start and end offsets relative to a <span class='text'> element. The offsets\n// are relative to the text of the item the span corresponds to.\n// TODO: Allow to accept multiple elements? (multi-line?)\nself.getSelectOffsetsInSpan = function(item, element, range, forceSelection)\n{\n    var styleLength = (item ? item.styleLength : 0);\n    var returnValue = { start: 0, startText: styleLength, end: 0, endText: styleLength, total: 0, totalText: styleLength };\n\n    if (android.isEnabled() && !forceSelection)\n    {\n        returnValue.start = android.getSelectionStart();\n        returnValue.startText = returnValue.start + styleLength;\n\n        returnValue.end = android.getSelectionEnd();\n        returnValue.endText = returnValue.end + styleLength;\n\n        returnValue.total = android.getInputText().length;\n        returnValue.totalText = returnValue.total + styleLength;\n    }\n    else\n    {\n        self.Assert(element && element.tagName == 'SPAN', 'Expected SPAN, Actual: ', element);\n\n        if (element && element.textContent !== TextSpace && !(android.isEnabled() && element.textContent === \"\"))\n        {\n            var startElement = range.startContainer;\n            var startOffset = range.startOffset;\n\n            var endElement = range.endContainer;\n            var endOffset = range.endOffset;\n\n            //console.log('Start: ' + startOffset + '  End: ' + endOffset);\n\n            self.Assert(startElement.nodeName == '#text', 'Expected #text, Actual: ', startElement.nodeName);\n\n            var totalOffset = 0;\n            var children = getTextNodesIn(element);\n\n            // TODO: Early out for loop\n            for (var i = 0; i < children.length; ++i)\n            {\n                if (children[i] == startElement)\n                {\n                    returnValue.start = totalOffset + startOffset;\n                    returnValue.startText = totalOffset + startOffset + styleLength;\n                }\n\n                if (children[i] == endElement)\n                {\n                    returnValue.end = totalOffset + endOffset;\n                    returnValue.endText = totalOffset + endOffset + styleLength;\n                }\n\n                totalOffset += children[i].length;\n            }\n\n            returnValue.total = totalOffset;\n            returnValue.totalText = totalOffset + styleLength;\n        }\n    }\n\n    return returnValue;\n};\n\nfunction hasValidClass(el)\n{\n    return self.hasClass(el, 'text') || (el.id === 'androidInput' && android.isEnabled());\n}\n\n// Find the closest <span class='text'> to el. All styling of text should be done using <p> or <a>\n// elements, and only a span with a class of 'text' should be returned.\nself.getSpanParent = function(el)\n{\n    if (android.isEnabled())\n    {\n        return android.getInputBox();\n    }\n    else if (self.hasClass(el, 'noItems'))\n    {\n        return undefined;\n    }\n\n    while (el && (el.tagName !== 'SPAN' || !hasValidClass(el)))\n    {\n        el = el.parentNode;\n    }\n\n    if (el && (hasValidClass(el)))\n    {\n        return el;\n    }\n\n    self.Assert(false, 'This shouldn\\'t happen, spans should always be found');\n\n    return undefined;\n};\n\n// Find the closest <span> to el. All styling of text should be done using <p>\n// elements, and only a span with a class of \"text\" should be returned.\nself.getLIParent = function(el)\n{\n    while (el && el.tagName !== 'LI')\n    {\n        el = el.parentNode;\n    }\n\n    if(el && !self.hasClass(el, 'item'))\n    {\n        //self.Assert(false, 'This shouldn\\'t happen, LIs should always be found');\n        return null;\n    }\n\n    return el;\n};\n\n// Given a VMLI, finds the visually previous item by searching the item tree.\nself.getPreviousItem = function(item, pane, options)\n{\n    self.Assert(item, 'Item must be specified');\n\n    if (!item)\n    {\n        return undefined;\n    }\n\n    var found = undefined;\n\n    var isTest = options && options.isTest;\n    var ignoreSearch = options && options.ignoreSearch;\n\n    var prev = item.parent();\n\n    if (!prev)\n    {\n        return undefined;\n    }\n\n    var index = prev.getChildIndex(item);\n\n    if (index > 0)\n    {\n        while (!found)\n        {\n            var newChild = false;\n\n            for (var i = index - 1; i >= 0; i--)\n            {\n                var prevChild = prev.getChild(i);\n                if (prevChild.hasChildren() && !prevChild.isCollapsed())\n                {\n                    if (ignoreSearch || !pane || !self.hasClass(prevChild.getElement(pane.id), 'hidden'))\n                    {\n                        prev = prevChild;\n                        index = prevChild.numChildren();\n                        newChild = true;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (ignoreSearch || !pane || !self.hasClass(prevChild.getElement(pane.id), 'hidden'))\n                    {\n                        found = prevChild;\n                        newChild = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!newChild)\n            {\n                found = prev;\n            }\n        }\n        self.Assert(isTest || !found || found.isCollapsed() || item === self.getNextItem(found, pane, { isTest: true, ignoreSearch: ignoreSearch }), 'Previous/Next should always match');\n    }\n    else\n    {\n        found = item.parent();\n    }\n\n    return found;\n};\n\n// Given a VMLI, finds the visually next item by searching the item tree.\nself.getNextItem = function(item, pane, options)\n{\n    self.Assert(item, 'Item must be specified');\n\n    if (!item)\n    {\n        return undefined;\n    }\n\n    var next = undefined;\n\n    var isTest = options && options.isTest;\n    var ignoreSearch = options && options.ignoreSearch;\n\n    // If there are children, grab the first child\n    if (item.hasChildren() && !item.isCollapsed())\n    {\n        var numChildren = item.numChildren();\n        for (var i = 0; i < numChildren; ++i)\n        {\n            var candidate = item.getChild(i);\n            if (ignoreSearch || !pane || !self.hasClass(candidate.getElement(pane.id), 'hidden'))\n            {\n                next = candidate;\n\n                if (options)\n                {\n                    options.numLevels++;\n                }\n\n                break;\n            }\n        }\n    }\n\n    var cItem = item;\n    while (!next)\n    {\n        var parent = cItem.parent();\n        if (!parent)\n        {\n            break;\n        }\n\n        var index = parent.getChildIndex(cItem);\n        var numChildren = parent.numChildren();\n        if (!parent.isCollapsed())\n        {\n            for (var i = index + 1; i < numChildren; ++i)\n            {\n                var candidate = parent.getChild(i);\n                self.Assert(!pane || candidate.getElement(pane.id), 'next element should be visible in pane');\n\n                if (ignoreSearch || !pane || !self.hasClass(candidate.getElement(pane.id), 'hidden'))\n                {\n                    next = candidate;\n                    break;\n                }\n            }\n        }\n\n        cItem = parent;\n\n        if (options && !next)\n        {\n            options.numLevels--;\n        }\n\n        if (pane && cItem === pane.item())\n        {\n            break;\n        }\n    }\n\n    self.Assert(isTest || !next || item === self.getPreviousItem(next, pane, { isTest: true, ignoreSearch: ignoreSearch }), 'Previous/Next should always match');\n\n    return next;\n};\n\nself.getFirstPaneItem = function(pane)\n{\n    return self.getNextItem(pane.item());\n};\n\nself.getLastPaneItem = function(pane)\n{\n    var item = pane.item().getLastChild();\n    for (; item.hasChildren(); item = item.getLastChild());\n\n    self.Assert(item, 'Must always have a valid pane item');\n\n    return item;\n};\n\nself.getItemCounts = function(start, end, pane)\n{\n    self.Assert(start, 'Start must be a valid item');\n    self.Assert(end, 'End must be a valid item');\n\n    var count = 0;\n    var fullscreenChildCount = 0;\n\n    var item = start;\n    do\n    {\n        item = self.getNextItem(item, pane);\n        self.Assert(item, 'Items must exist');\n\n        if (item.parent() === pane.item() && item.isHeader())\n        {\n            fullscreenChildCount++;\n        }\n\n        count++;\n    } while (item !== end)\n\n    return { fscount: fullscreenChildCount, icount: count };\n};\n\n// This is inclusive of the start and end item.\nself.getItemsBetween = function (start, end, pane)\n{\n    self.Assert(start, 'Start must be a valid item');\n    self.Assert(end, 'End must be a valid item');\n\n    var selected = [ start ];\n\n    var item = start;\n    while (item !== end)\n    {\n        item = self.getNextItem(item, pane);\n        self.Assert(item, 'Items must exist');\n\n        selected.push(item);\n    }\n\n    return selected;\n};\n\n// Given two items, determine which appears first in the tree\nself.getFirstItem = function (item1, item2)\n{\n    if (item1.id == item2.id || item2.parent().id == item1.id)\n    {\n        return item1;\n    }\n    else if (item1.parent().id == item2.id)\n    {\n        return item2;\n    }\n\n    var p = item1;\n\n    var prevP = undefined;\n    do\n    {\n        var q = item2;\n\n        var prevQ = undefined;\n        do\n        {\n            if (p.id == q.id)\n            {\n                if (prevP === undefined)\n                {\n                    // item2 is an ancestor of item1\n                    return item1;\n                }\n                else if (prevQ === undefined)\n                {\n                    // item1 is an ancestor of item2\n                    return item2;\n                }\n\n                // TODO: These asserts arent really valid, edge cases that aren't handled can hit them\n                self.Assert(prevQ !== undefined, \"Fix this assert by handling this edge case!\");\n\n                self.Assert(p.id == prevQ.parent().id, \"Must share a common parent\");\n                self.Assert(p.id == prevP.parent().id, \"Must share a common parent\");\n\n                self.Assert(prevP.id != prevQ.id, \"If both previous items match, they should have been the common ancestor\");\n\n                return (prevP.getIndex() < prevQ.getIndex())  ? item1 : item2;\n            }\n\n            prevQ = q;\n        } while ((q = q.parent()) !== undefined)\n\n        prevP = p;\n    } while ((p = p.parent()) !== undefined)\n\n    self.Assert(false, 'One item must appear first in the tree');\n\n    return undefined;\n}\n\nself.animateTransform = function(element, options)\n{\n    var transform = options.transform;\n\n    // If we want a delay, delay and call setTransform again without the delay set\n    if(!isNaN(options.delay))\n    {\n        var delay = options.delay;\n        options.delay = undefined;\n        setTimeout(self.animateTransform, delay, element, options);\n\n        return;\n    }\n\n    function onComplete()\n    {\n        if(options.clearTransform)\n        {\n            element.style[platform.transform.style] = '';\n            element.style[platform.transformOrigin.style] = '';\n        }\n        if(options.onComplete)\n        {\n            options.onComplete();\n        }\n    }\n\n    if (options.time)\n    {\n        var trans = self.getTransitionClass(options.time);\n        self.addClass(element, trans);\n\n        // After the animation is complete, remove the animation class\n        setTimeout(function()\n        {\n            self.removeClass(element, trans);\n            onComplete();\n        }, options.time);\n    }\n    else\n    {\n        onComplete();\n    }\n\n    if (!isNaN(options.opacity))\n    {\n        element.style.opacity = options.opacity;\n    }\n    if(!transform && !isNaN(options.left) && !isNaN(options.top))\n    {\n        transform = 'translate3d(' + left + 'px,' + top + 'px,0)';\n    }\n\n    if(options.origin)\n    {\n        element.style[platform.transformOrigin.style] = options.origin;\n    }\n\n    element.style[platform.transform.style] = transform;\n};\n\nself.easeOut = function (t, b, c)\n{\n    return -c *(t)*(t-2) + b;\n};\n\nself.scrollTo = function(n, duration, element, horiz, cb)\n{\n    element = element || self.focusedPane.rootElement;\n\n    var scrollVar = (horiz ? 'scrollLeft' : 'scrollTop');\n\n    if (duration > 0)\n    {\n        self.isScrollingIntoView = true;\n\n        var scrollValue = element[scrollVar];\n        var startTime;\n        var difference = n - scrollValue;\n\n        if (DEBUG)\n        {\n            console.log('Animated Scrolling [' + scrollValue + '] -> [' + n + ']');\n        }\n\n        var lastValue = scrollValue;\n        function scrollLoop(timestamp)\n        {\n            if (!startTime)\n            {\n                startTime = timestamp - 20;\n            }\n\n            var t = Math.min((timestamp - startTime) / duration, 1);\n\n            var scrollOffset = self.easeOut(t, scrollValue, difference);\n            element[scrollVar] = scrollOffset\n\n            if (t == 1)\n            {\n                self.isScrollingIntoView = false;\n\n                if (platform.ios)\n                {\n                    // Fix that weird rendering bug that doesn't move\n                    // the cursor to where it's supposed to be\n                    self.setSelectionToWhatItAlreadyIs();\n\n                    if (cb)\n                    {\n                        cb();\n                    }\n                }\n\n                return;\n            }\n\n            requestAnimationFrame(scrollLoop);\n        }\n\n        requestAnimationFrame(scrollLoop);\n    }\n    else\n    {\n        if (DEBUG)\n        {\n            log('Jump Scrolling [' + element[scrollVar] + '] -> [' + n + ']');\n        }\n\n        if (element)\n        {\n            element[scrollVar] = n;\n        }\n    }\n};\n\nself.computeScrollSpeed = function (min, max, val)\n{\n    return ((max - min) - (max - val)) / (max - min);\n};\n\nvar lastState = { speed: 0, pane: undefined };\nvar runScroll = false;\n\nfunction performScroll()\n{\n    var minSpeed = 2;\n    var maxSpeedAdd = 12;\n\n    var scroller = lastState.pane.getScroller();\n\n    var diff = (minSpeed + (maxSpeedAdd * lastState.speed));\n\n    scroller.scrollTop += diff;\n\n    if (runScroll)\n    {\n        requestAnimationFrame(performScroll);\n    }\n}\n\nself.repeatScroll = function (speed, pane)\n{\n    lastState.speed = speed;\n    lastState.pane = pane;\n\n    if (!runScroll)\n    {\n        runScroll = true;\n\n        requestAnimationFrame(performScroll);\n    }\n};\n\nself.cancelRepeatScroll = function ()\n{\n    runScroll = false;\n};\n\nvar VMPane;\nself.getPaneForElement = function (element)\n{\n    if (!VMPane)\n    {\n        VMPane = require('VMPane');\n    }\n\n    if (element)\n    {\n        var localContext;\n        if (android && android.isEnabled() && element.id == 'androidInput')\n        {\n            localContext = ko.contextFor(android.getCurrentVMLI().getSpan());\n        }\n        else\n        {\n            localContext = ko.contextFor(element);\n        }\n\n        // In some cases (zooming in) we detach nodes from the DOM. In this case, VMLIs may be referring to stale\n        // DOM elements and try to get the KO context for them.\n        //self.Assert(localContext, 'Need a valid KO context to find pane');\n\n        var paneCandidate = (localContext ? localContext.$parents[localContext.$parents.length - 2] : undefined);\n\n        if (!paneCandidate && (localContext && localContext.$parents.length === 1))\n        {\n            paneCandidate = localContext.$data;\n        }\n\n        if (paneCandidate instanceof VMPane)\n        {\n            return paneCandidate;\n        }\n    }\n\n    return undefined;\n};\n\nself.elementInPane = function (element)\n{\n    if (element)\n    {\n        var localContext = ko.contextFor(element);\n\n        if (localContext)\n        {\n            var paneCandidate = localContext.$parents[localContext.$parents.length - 2];\n            if (paneCandidate)\n            {\n                return self.hasClass(paneCandidate.element, 'pane');\n            }\n        }\n    }\n\n    return false;\n};\n\nself.scrollToTop = function(element, duration, options)\n{\n    if (element)\n    {\n        var callback = options && options.callback;\n        var scrollView = self.findParent(element, 'scroller');\n\n        if (scrollView)\n        {\n            var top = element.getBoundingClientRect().top;\n\n            var scrollTop = scrollView.scrollTop;\n            var amtMoved = top - self.topBoxHeight + ((platform.orientation == Orientation.Landscape) ? self.topBarHeight : 0);\n\n            var n = scrollTop + amtMoved;\n\n            self.scrollTo(n, duration, scrollView);\n\n            return amtMoved || true;\n        }\n    }\n\n    return false;\n};\n\nself.scrollIntoView = function(element, duration, options)\n{\n    var callback = options && options.callback;\n    var noToolbar = options && options.noToolbar;\n    if (isNaN(duration))\n    {\n        duration = 200; // Default time\n    }\n\n    var performedScroll = false;\n\n    if (element)\n    {\n        var scrollView = self.findParent(element, 'scroller');\n\n        if (scrollView)\n        {\n            var scrollBounds = scrollView.getBoundingClientRect();\n            var scrollBottom = scrollBounds.bottom;\n\n            var bounds = element.getBoundingClientRect();\n\n            var extraMoveAmt = 10;\n            var scrollTop = scrollView.scrollTop;\n            var n;\n\n            // TODO: This doesn't take into account horizontal scrollbars that may appear from having multiple panes\n            if(platform.mobile)\n            {\n                if(!noToolbar)\n                {\n                    scrollBottom -= self.keyboardToolbarHeight;\n                }\n                // Don't do this on ios7 unless keyboard is not open\n                if(!platform.ios || platform.ios71 || !self.isKeyboardOpen)\n                {\n                    if(platform.kbsize)\n                    {\n                        scrollBottom -= platform.kbsize;\n                    }\n                    else\n                    {\n                        // Don't know the actual keyboard height so we'll have to guess.\n\n                        // TODO: Put a number for Android in here?\n                        // if(platform.ios)\n                        scrollBottom -= 248; // iOS keyboard size + keyboard toolbar height\n                    }\n                }\n            }\n\n            if(bounds.top < scrollBounds.top)\n            {\n                var item = ko.dataFor(element);\n                if(!platform.mobile && item == self.getFirstPaneItem(self.focusedPane))\n                    n = 0;\n                else\n                    n = scrollTop + bounds.top - scrollBounds.top - extraMoveAmt;\n            }\n            else if(bounds.bottom > scrollBottom)\n            {\n                n = scrollTop + bounds.bottom - scrollBottom + extraMoveAmt;\n            }\n\n            if(n !== undefined)\n            {\n                self.scrollTo(n, duration, scrollView);\n                if(callback)\n                {\n                    if(duration > 0)\n                    {\n                        setTimeout(callback, duration);\n                    }\n                    else\n                    {\n                        callback();\n                    }\n                }\n                performedScroll = true;\n            }\n        }\n    }\n\n    return performedScroll;\n};\n\nself.isKeyboardInputElement = function(ele)\n{\n    if(ele.type === 'checkbox')\n        return false;\n    if(ele.nodeName == 'INPUT' || ele.type == 'textarea')\n        return true;\n    return false;\n};\n\nself.openKeyboardOn = function(e, element, showKeyboard, focusFn, blurFn)\n{\n    self.Assert(platform.mobile, 'Should only be opening keyboard on mobile devices');\n\n    var scrollView = self.findParent(element, 'scroller');\n    var scrollStart = scrollView ? scrollView.scrollTop : 0;\n    var performedScroll = false;\n\n    if(showKeyboard)\n        self.keyboardToolbar.preShow();\n\n    if (!self.isKeyboardOpen)\n    {\n        // Scroll item into view first\n        if (platform.app || platform.android || platform.mobileie)\n        {\n            var callback = function()\n            {\n                if(showKeyboard)\n                    self.keyboardToolbar.show();\n                else\n                    self.isKeyboardOpen = true;\n                if(focusFn)\n                    focusFn();\n\n                self.enforceScroll();\n            };\n\n            self.addClass(scrollView, 'padded');\n\n            // Wait a frame to allow padding to take effect before scrolling\n            performedScroll = self.scrollIntoView(element, platform.keyboardOpenTime, {callback: callback, noToolbar: !showKeyboard});\n        }\n        else\n        {\n            performedScroll = self.scrollIntoView(element, platform.keyboardOpenTime);\n        }\n    }\n    else\n    {\n        log('keyboard open');\n        // if(focusFn)\n        //     focusFn();\n    }\n\n    if(!performedScroll || !platform.app || platform.android)\n    {\n        // focusFn needs to be called first so it will blur the previous element before\n        // showing the keybaord\n        if(focusFn)\n            focusFn();\n        if(showKeyboard)\n            self.keyboardToolbar.show();\n    }\n\n\n    // TODO: Defining this here is not the sexiest thing\n    self.onCloseKeyboard = function ()\n    {\n        self.addClass(scrollView, 'padded');\n\n        self.scrollTo(scrollStart, platform.keyboardOpenTime, scrollView, false, function()\n        {\n            self.removeClass(scrollView, 'padded');\n        });\n        // if(showKeyboard)\n        // {\n        self.isKeyboardOpen = false;\n        // }\n        if(blurFn)\n            blurFn();\n\n        // editable.onblur = undefined;\n        // self.fireCustomEvent('blur');\n        window.removeEventListener('closeKeyboard', self.onCloseKeyboard);\n        self.onCloseKeyboard = undefined;\n    }\n    window.addEventListener('closeKeyboard', self.onCloseKeyboard);\n\n    // if(platform.ios && !platform.app)\n    // {\n    //     var editable = self.findParent(element, 'editable');\n    //     self.Assert(editable, 'Editable parent should exist');\n    //     editable.onblur = function()\n    //     {\n    //         self.fireCustomEvent('closeKeyboard');\n    //         if (editable) { editable.onblur = undefined; }\n    //     };\n    // }\n\n\n    // Prevent native tap handler since setting selection will bring up\n    // the keyboard\n    if (platform.ios)\n    {\n        self.preventClick();\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    e.returnFalse = true;\n\n    self.enforceScroll();\n}\n\nself.blurActiveElement = function(ignoreSelectionChange)\n{\n    self.ignoreSelectionChange = !!ignoreSelectionChange;\n    self.fireCustomEvent('closeKeyboard');\n\n    document.activeElement.blur();\n\n    setTimeout(function(){\n        self.ignoreSelectionChange = false;\n    }, 100);\n}\n\nself.preventScrollPropagation = function (ele)\n{\n    // return true;\n\n    // log(self.vmMain.isKeyboardOpen());\n    // if(!self.vmMain.isKeyboardOpen())\n    // {\n    //     return true;\n    // }\n    if (ele.scrollHeight === ele.clientHeight)\n    {\n        return false;\n    }\n    else\n    {\n        if (ele.scrollTop === 0)\n        {\n            ele.scrollTop = 1;\n        }\n        else\n        {\n            if (ele.scrollTop + ele.offsetHeight >= ele.scrollHeight)\n            {\n                ele.scrollTop = ele.scrollHeight - ele.offsetHeight - 1;\n            }\n        }\n    }\n\n    return true;\n};\n\nself.setSelectionToWhatItAlreadyIs = function()\n{\n    var sel = window.getSelection();\n    if (sel.rangeCount > 0)\n    {\n        var range = sel.getRangeAt(0);\n\n        if (DEBUG) log('Set Selection to Same', range);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n};\n\nself.setSelection = function(element, start, end)\n{\n    self.Assert(element, 'Must supply a valid element to set selection on');\n    self.Assert(start >= 0 && end >= 0, 'Must specify positive start and end offsets');\n    if (start < 0 || end < 0) { return false; }\n    if (!element) { return false; }\n\n    var retVal = true;\n    var select;\n\n    try\n    {\n        var children = getTextNodesIn(element);\n        var range = document.createRange();\n        select = children.length > 0 ? children[0] : element;\n\n        range.setStart(select, start);\n        range.setEnd(select, end);\n\n        var sel = window.getSelection();\n\n        if (DEBUG) log('Set Selection: [' + start + ',' + end + ']', select);\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    catch (err)\n    {\n        self.reportError(err, {\n            element: self.elementToString(element, true),\n            select: self.elementToString(select, true),\n            start: start,\n            end: end,\n            children: (children.length > 0 ? self.elementToString(element, true) : undefined)\n        });\n\n        retVal = false;\n    }\n\n    return retVal;\n};\n\n// Takes the current DOM Range selection and restricts it to a valid set of selections that\n// only contain text under <span class='text'> elements.\nself.restrictSelectionToText = function()\n{\n    if (android && android.isEnabled())\n    {\n        return;\n    }\n\n    var selection,\n        range,\n        rangeStartContainer,\n        rangeEndContainer,\n        rangeStart,\n        rangeEnd;\n\n    var updateSelection = function()\n    {\n        selection = self.getSelectionInfo();\n        if (!selection || selection.rangeCount === 0)\n        {\n            return true;\n        }\n\n        range = selection.selection.getRangeAt(0);\n        rangeStartContainer = range.startContainer;\n        rangeEndContainer = range.endContainer;\n        rangeStart = range.startOffset;\n        rangeEnd = range.endOffset;\n    };\n\n    updateSelection();\n\n    if (!selection)\n    {\n        return;\n    }\n\n    self.Assert(rangeStartContainer.nodeName == '#text' || rangeStartContainer.nodeName == 'SPAN', 'Expected #text or SPAN, Actual: ' + rangeStartContainer.nodeName);\n    self.Assert(rangeEndContainer.nodeName == '#text' || rangeEndContainer.tagName == 'LI' || rangeEndContainer.tagName == 'UL' ||\n                rangeEndContainer.tagName == 'SPAN', 'Expected LI, UL, #text, SPAN, Actual: ' + rangeEndContainer.tagName);\n\n    if(rangeStartContainer.nodeName === 'SPAN')\n    {\n        self.selectMultiline(rangeStartContainer, rangeStart, rangeEndContainer, rangeEnd);\n        updateSelection();\n    }\n\n    // This is the case where the selection is at the end of the li and past the #comment block so\n    // the rangeStartContainer's parent is the li and not the text span.\n    if(rangeStartContainer.nodeName === '#text' &&\n       rangeStartContainer.previousSibling &&\n       rangeStartContainer.previousSibling.nodeName === '#comment')\n    {\n        self.Assert(false, 'This case shouldnt be getting hit');\n\n        self.selectChildren(self.getSpanParent(rangeStartContainer), 0, rangeEnd);\n        updateSelection();\n    }\n\n    if (rangeStartContainer !== rangeEndContainer && rangeEnd === 0 && rangeEndContainer.nodeName == 'P')\n    {\n        rangeEndContainer = rangeEndContainer.parentNode.parentNode;\n        // log(rangeEndContainer);\n        var prevLI = rangeEndContainer.previousElementSibling;\n        self.Assert(!prevLI || prevLI.tagName == 'LI');\n\n        if (!prevLI)\n        {\n            prevLI = rangeEndContainer.parentNode.parentNode;\n        }\n        // Preview sibling has children. The line before is its last child.\n        else if (prevLI.children.length > 1)\n        {\n            var children = prevLI.children[1].children;\n            prevLI = children[children.length - 1];\n        }\n\n        var textLength = ko.dataFor(prevLI).getParsedText().length;\n        // log(rangeStartContainer, prevLI);\n        self.selectMultiline(rangeStartContainer, rangeStart, prevLI, textLength);\n    }\n\n    // If the selection goes past it into the next LI, the line we want is the line before.\n    // This happens when you triple click in the margin to the right of the text\n    // or select multiple items ending past the margin.\n    else if (rangeEndContainer.tagName === 'LI')\n    {\n        var prevLI = rangeEndContainer.previousElementSibling;\n        self.Assert(!prevLI || prevLI.tagName === 'LI');\n\n        if (!prevLI)\n        {\n            prevLI = rangeEndContainer.parentNode.parentNode;\n            console.log(prevLI);\n        }\n        // Preview sibling has children. The line before is its last child.\n        else if (prevLI.children.length > 1)\n        {\n            var children = prevLI.children[1].children;\n            prevLI = children[children.length - 1];\n        }\n\n        var prevSpan = prevLI.firstChild;\n        self.Assert(prevSpan.tagName === 'SPAN', 'Expected SPAN, Actual: ' + prevSpan.tagName);\n\n        self.selectChildren(ko.dataFor(prevSpan), 0, prevSpan.textContent.length);\n    }\n    else if (rangeEndContainer.nodeName === 'UL')\n    {\n        // This happens when pressing ctrl+A when there is only a title for a fullscreen child\n        var prevSpan = rangeEndContainer.parentElement.firstElementChild;\n        self.Assert(prevSpan.tagName === 'SPAN', 'Expected SPAN, Actual: ' + prevSpan.tagName);\n\n        self.selectChildren(ko.dataFor(prevSpan), 0, prevSpan.textContent.length);\n    }\n};\n\nself.trimString = function (str)\n{\n    var str = str.replace(/^\\s\\s*/, ''),\n        ws = /\\s/,\n        i = str.length;\n    while (ws.test(str.charAt(--i)));\n    return str.slice(0, i + 1);\n};\n\nself.enforceScroll = function(force, top)\n{\n    if (force || (((platform.ios || platform.android) && (!platform.app || platform.ios71)) && !platform.bodyscroll))\n    {\n        setTimeout(function() {window.scrollTo(0, top || 0);},0);\n        requestAnimationFrame(function() {window.scrollTo(0, top || 0);});\n        window.scrollTo(0, top || 0);\n        document.body.scrollTop = 0;\n    }\n};\n\nself.preventDefault = function(e)\n{\n    e.preventDefault();\n};\n\nself.preventClick = function()\n{\n    self.addClass(self.element('outerWrapper'), 'noClick');\n\n    window.ontouchstart = self.preventDefault;\n\n    requestAnimationFrame(function()\n    {\n        window.ontouchstart = undefined;\n        self.removeClass(self.element('outerWrapper'), 'noClick');\n    });\n};\n\nfunction searchVMLIArray(options, array)\n{\n    for (var i = 0; i < array.length; ++i)\n    {\n        if(options.comparator)\n        {\n            if (options.comparator(array[i]))\n            {\n                options.action(array[i]);\n            }\n        }\n        else if(options.each)\n        {\n            options.each(array[i]);\n        }\n\n        options.item = array[i];\n        // Recurse through children\n        self.searchVMLIs(options);\n    }\n}\n\nself.searchVMLIs = function(options)\n{\n    var startItem = options.item;\n    if(!startItem)\n    {\n        startItem = self.vmMain.root();\n    }\n\n    if(options.headers)\n    {\n        searchVMLIArray(options, startItem.headers());\n    }\n    else\n    {\n        searchVMLIArray(options, startItem.items());\n    }\n\n    if (options.includeArchived && startItem.hasArchivedChildren())\n    {\n        searchVMLIArray(options, startItem.archivedItems(/*underlying*/true));\n    }\n};\n\nself.getLastVisibleItem = function(root)\n{\n    var list = root.items();\n    for(var i = list.length - 1; i >= 0; i --)\n    {\n        if(!self.vmSearchPhone.hiddenItems[list[i].id])\n        {\n            var lastItem = self.getLastVisibleItem(list[i]);\n            if(lastItem)\n                return lastItem;\n            else\n                return list[i];\n        }\n    }\n    return undefined;\n}\n\nself.invertObject = function(obj)\n{\n    var target = {};\n    for (var i in obj)\n    {\n        if (obj.hasOwnProperty(i))\n        {\n            target[obj[i]] = i;\n        }\n    }\n    return target;\n};\n\n// self.valueExistsOnObject = function(obj, value)\n// {\n//     for (var i in obj)\n//     {\n//         if (obj.hasOwnProperty(i))\n//         {\n//             if(obj[i] === value)\n//             {\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n\nself.fieldMapOut = self.invertObject(self.fieldMapIn);\n// self.flagMapOut = self.invertObject(self.flagMapIn);\n\nif (DEBUG)\n{\n    window.fieldTranslation = self.fieldMapOut;\n}\n\nfunction getMapping(obj, map)\n{\n    self.Assert(typeof obj !== 'string', 'Should only pass objects to the obj mapping function', obj);\n\n    var target = { };\n    for (var i in obj)\n    {\n        self.Assert(obj.hasOwnProperty(i), 'This should always be the case, the prototype shouldn\\'t be extended');\n\n        if (obj[i] !== undefined && obj[i] !== null)\n        {\n            var mappedField = map[i];\n\n            if (mappedField)\n            {\n                target[mappedField] = obj[i];\n            }\n            else\n            {\n                self.Assert(false, 'Incoming field should be added to the field map', i);\n                target[i] = obj[i];\n            }\n        }\n    }\n\n    return target;\n}\n\nself.translateFieldIn = function(field)\n{\n    self.Assert(self.fieldMapIn[field], 'Incoming field should be added to the field map', field);\n    self.Assert(typeof field === 'string', 'Should only pass strings to the field mapping function', field);\n\n    return self.fieldMapIn[field] || field;\n};\n\nself.translateFieldOut = function(field)\n{\n    self.Assert(self.fieldMapOut[field], 'Incoming field should be added to the field map', field);\n    self.Assert(typeof field === 'string', 'Should only pass strings to the field mapping function', field);\n\n    return self.fieldMapOut[field] || field;\n};\n\nself.translateObjIn = function(obj)\n{\n    return getMapping(obj, self.fieldMapIn);\n}\n\nself.translateObjOut = function(obj)\n{\n    return getMapping(obj, self.fieldMapOut);\n};\n\nvar eventListeners = { };\nself.addCustomEventListener = function(name, fn, priority)\n{\n    if (priority !== undefined)\n    {\n        var evs = eventListeners[name];\n\n        var entry = { fn: fn, pri: priority };\n        if (!evs)\n        {\n            eventListeners[name] = [ entry ];\n\n            window.addEventListener(name, function (e)\n            {\n                for (var i = 0; i < eventListeners[name].length; ++i)\n                {\n                    var ev = eventListeners[name][i];\n\n                    var ret = ev.fn(e);\n\n                    if (ret === false)\n                    {\n                        break;\n                    }\n                }\n            });\n        }\n        else\n        {\n            eventListeners[name].insertSorted(entry, function (left, right)\n            {\n                return left < right ? 1 : -1;\n            });\n        }\n    }\n    else\n    {\n        window.addEventListener(name, fn);\n    }\n};\n\nself.removeCustomEventListener = function(name, fn, isPriority)\n{\n    if (isPriority)\n    {\n        var evs = eventListeners[name];\n\n        var found = false;\n        for (var i = 0; i < evs.length; ++i)\n        {\n            if (evs[i].fn === fn)\n            {\n                found = true;\n\n                evs.removeAt(i);\n\n                break;\n            }\n        }\n\n        self.Assert(found, 'Event listener should always be found when removing');\n    }\n    else\n    {\n        window.removeEventListener(name, fn);\n    }\n};\n\nself.fireCustomEvent = function(name, data, target)\n{\n    if (document.createEvent)\n    {\n        var eventObj = document.createEvent('Event');\n\n        if (data)\n        {\n            eventObj.data = data;\n        }\n\n        eventObj.initEvent(name, true, true);\n\n        if (DEBUG) log('Dispatch Custom Event: ', name);\n\n        return (target || window).dispatchEvent(eventObj);\n    }\n    else\n    {\n        self.Assert(false, 'Unable to fire custom event');\n    }\n};\n\nfunction fireKeyEventInternal(ele, etype, key)\n{\n    self.Assert(key !== undefined, 'Must pass in valid key data to type');\n\n    if (!ele)\n    {\n        var selection = self.getSelectionInfo();\n\n        if (selection)\n        {\n            ele = selection.node;\n        }\n    }\n\n    if (document.createEvent && ele)\n    {\n        var eventObj = document.createEvent('Event');\n\n        eventObj.normCode = key.normCode;\n        eventObj.shiftKey = !!key.shiftKey;\n        eventObj.synthetic = true;\n\n        eventObj.initEvent(etype, true, true);\n\n        ele.dispatchEvent(eventObj);\n    }\n    else\n    {\n        self.Assert(false, 'Unable to fire key event');\n    }\n};\n\nself.fireKeyEvent = function(ele, keyData)\n{\n    fireKeyEventInternal(ele, 'keydown', keyData);\n    fireKeyEventInternal(ele, 'keypress', keyData);\n    fireKeyEventInternal(ele, 'keyup', keyData);\n};\n\nfunction fireClickEventInternal(ele, etype, button)\n{\n    self.Assert(button !== undefined, 'Must pass in a valid button to click with');\n\n    if (!ele)\n    {\n        var selection = self.getSelectionInfo();\n\n        if (selection)\n        {\n            ele = selection.node;\n        }\n    }\n\n    if (document.createEvent)\n    {\n        var evObj = document.createEvent('Event');\n\n        evObj.button = button;\n        evObj.synthetic = true;\n\n        evObj.initEvent(etype, /*canBubble*/true, /*cancelable*/true);\n\n        ele.dispatchEvent(evObj);\n    }\n    else\n    {\n        self.Assert(false, 'Unable to fire click event');\n    }\n};\n\nself.fireClickEvent = function(ele, button)\n{\n    fireClickEventInternal(ele, 'mousedown', button);\n    fireClickEventInternal(ele, 'mouseup', button);\n    fireClickEventInternal(ele, 'mouseclick', button);\n};\n\nself.clone = function(obj)\n{\n    var target = {};\n    for (var i in obj)\n    {\n        if (obj.hasOwnProperty(i))\n        {\n            target[i] = obj[i];\n        }\n    }\n    return target;\n};\n\nself.alias = function()\n{\n    var args = Array.prototype.slice.call(arguments);\n    var obj = args[0];\n    for(var i = 1; i < args.length; i ++)\n    {\n        var fn = args[i];\n        obj[fn] = obj['_'+fn];\n    }\n};\n\nself.extend = function (target, source)\n{\n    self.Assert(target && source, 'Invalid call to extend');\n\n    if (source)\n    {\n        for (var prop in source)\n        {\n            if (source.hasOwnProperty(prop))\n            {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\n\nself.loadXML = function(xml)\n{\n    try\n    {\n        if (typeof window.DOMParser != \"undefined\")\n        {\n            return ( new window.DOMParser() ).parseFromString(xml, \"text/xml\");\n        }\n        else if (typeof window.ActiveXObject != \"undefined\" && new window.ActiveXObject(\"Microsoft.XMLDOM\"))\n        {\n            var xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n\n            xmlDoc.async = \"false\";\n            xmlDoc.loadXML(xml);\n\n            return xmlDoc;\n        }\n        else\n        {\n            self.Assert(false, \"No XML parser found\");\n\n            return undefined;\n        }\n    }\n    catch (err)\n    {\n        self.reportError(err);\n        return undefined;\n    }\n}\n\nself.adjustOriginToBeInsideBounds = function(bounds, rect, xMin, yMin, xPad, yPad)\n{\n    var out = { x: rect.left, y: rect.top };\n\n    xMin = xMin || 0;\n    yMin = yMin || 0;\n\n    xPad = xPad || 0;\n    yPad = yPad || 0;\n\n    if (rect.bottom + yPad > bounds.bottom)\n    {\n        out.y = Math.max(yMin, rect.top - ((rect.bottom + yPad) - bounds.bottom));\n    }\n\n    if (rect.top - yPad < bounds.top)\n    {\n\n        out.y = Math.max(yMin, rect.top);\n    }\n\n    if (rect.right + xPad > bounds.right)\n    {\n        out.x = Math.max(xMin, rect.left - ((rect.right + xPad) - bounds.right));\n    }\n\n    return out;\n};\n\nself.setOrigin = function(rect, xOrigin, yOrigin)\n{\n    var xDiff = rect.left - xOrigin;\n    var yDiff = rect.top - yOrigin;\n\n    rect.left -= xDiff;\n    rect.right -= xDiff;\n\n    rect.top -= yDiff;\n    rect.bottom -= yDiff;\n};\n\n//\n// jQuery Fill\n//\n\n// When copying styles from src to dst, ensure that they are accessed in a RRWW pattern\n// instead of RWRW.\nself.copyStyles = function (src, dst, styles)\n{\n    self.Assert(src, 'Must have a valid source element');\n    self.Assert(dst, 'Must have a valid dest element');\n    self.Assert(styles, 'Must have a valid list of styles to copy');\n\n    var computedStyle = window.getComputedStyle(src);\n\n    if (computedStyle)\n    {\n        var values = [ ];\n\n        for (var i = 0; i < styles.length; ++i)\n        {\n            values[i] = computedStyle[styles[i]];\n        }\n\n        for (var i = 0; i < values.length; ++i)\n        {\n            //log('Copy Style: ' + styles[i] + ' -> ' + values[i]);\n            dst.style[styles[i]] = values[i];\n        }\n    }\n};\n\nself.hasClass = function (elem, cls)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    return (elem && elem.classList) ? elem.classList.contains(cls) : undefined;\n};\n\nself.removeClass = function (elem, cls)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (elem && elem.classList)\n    {\n        elem.classList.remove(cls);\n    }\n};\n\nself.addClass = function (elem, cls)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (elem && elem.classList)\n    {\n        elem.classList.add(cls);\n    }\n};\n\nself.toggleClass = function(elem, cls)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (elem && elem.classList)\n    {\n        elem.classList.toggle(cls)\n    }\n}\n\nself.css = function (elem, styles)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (elem)\n    {\n        for (var style in styles)\n        {\n            if (styles.hasOwnProperty(style))\n            {\n                var value = styles[style];\n\n                if (typeof value === \"number\")\n                {\n                    value += \"px\";\n                }\n\n                elem.style[style] = value;\n            }\n        }\n    }\n};\n\nself.findChild = function (elem, cls)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (elem)\n    {\n        for (var i = 0; i < elem.childElementCount; ++i)\n        {\n            if (self.hasClass(elem.children[i], cls))\n            {\n                return elem.children[i];\n            }\n        }\n    }\n\n    return undefined;\n};\n\nself.findParent = function (elem, cls, num)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    if (!num)\n    {\n        num = 10000;\n    }\n\n    if (elem)\n    {\n        var parent = elem;\n        self.Assert(parent, 'Must have a valid parent element');\n\n        for (var i = 0; i < num && parent; ++i, parent = parent.parentNode)\n        {\n            if (self.hasClass(parent, cls))\n            {\n                return parent;\n            }\n        }\n    }\n\n    return undefined;\n};\n\nself.isAncestor = function (elem, candidate)\n{\n    self.Assert(elem, 'Must have a valid element');\n    self.Assert(candidate, 'Must have a valid candidate');\n\n    while (elem && elem !== candidate)\n    {\n        elem = elem.parentNode;\n    }\n\n    return !!elem;\n};\n\nself.firstChildTag = function (elem, tag)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n    self.Assert(tag, 'Must pass in a valid tag to check');\n\n    if (elem)\n    {\n        var upper = tag.toUpperCase();\n\n        for (var i = 0; i < elem.childElementCount; ++i)\n        {\n            if (elem.children[i].tagName === upper)\n            {\n                //self.Assert(elem.children[i] == $(elem).children(tag).first()[0], 'Must match!');\n\n                return elem.children[i];\n            }\n        }\n    }\n\n    return undefined;\n}\n\nself.insertAfter = function (reference, newNode)\n{\n    self.Assert(reference, 'Must pass in a valid element');\n    self.Assert(newNode, 'Must pass in a valid element');\n\n    reference.parentNode.insertBefore(newNode, reference.nextSibling);\n}\n\nself.prependChild = function (parent, newNode)\n{\n    self.Assert(parent, 'Must pass in a valid element');\n    self.Assert(newNode, 'Must pass in a valid element');\n\n    parent.insertBefore(newNode, parent.firstChild);\n};\n\nself.offset = function (elem)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    var box = elem.getBoundingClientRect();\n\n    var doc = elem.ownerDocument;\n    var docElem = elem.ownerDocument.documentElement;\n    var win = doc.defaultView;\n\n    var customAns = {\n        top: box.top + win.pageYOffset - docElem.clientTop,\n        left: box.left + win.pageXOffset - docElem.clientLeft\n    };\n\n    //self.Assert(customAns.top === $(elem).offset().top && customAns.left === $(elem).offset().left, 'Must match!');\n\n    return customAns;\n};\n\nself.height = function (elem)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    var customHeight = elem.offsetHeight;\n\n    var cStyle = window.getComputedStyle(elem);\n\n    if (cStyle)\n    {\n        if (elem.style.boxSizing !== \"border-box\")\n        {\n            customHeight -= (parseFloat(cStyle.paddingTop) + parseFloat(cStyle.paddingBottom));\n        }\n\n        customHeight -= (parseFloat(cStyle.borderTopWidth) + parseFloat(cStyle.borderBottomWidth));\n    }\n    else\n    {\n        if (ShouldLog(LogLevels.Error)) log('GetComputedStyle failed in globals::height');\n    }\n\n    //self.Assert(customHeight === $(elem).height(), 'Must Match!');\n\n    return customHeight;\n};\n\nself.width = function (elem)\n{\n    self.Assert(elem, 'Must pass in a valid element');\n\n    var customWidth = elem.offsetWidth;\n\n    var cStyle = window.getComputedStyle(elem);\n\n    if (cStyle)\n    {\n        if (cStyle.boxSizing !== \"border-box\")\n        {\n            customWidth -= (parseFloat(cStyle.paddingLeft) + parseFloat(cStyle.paddingRight));\n        }\n\n        customWidth -= (parseFloat(cStyle.borderLeftWidth) + parseFloat(cStyle.borderRightWidth));\n    }\n    else\n    {\n        if (ShouldLog(LogLevels.Error)) log('GetComputedStyle failed in globals::width');\n    }\n\n    //self.Assert(customWidth === $(elem).width(), 'Must Match!');\n\n    return customWidth;\n};\n\nvar onLoadCallbacks = undefined;\nfunction loadDone(cb)\n{\n    document.removeEventListener('DOMContentLoaded', loadDone, false);\n    window.removeEventListener('load', loadDone, false);\n\n    for (var i = 0; i < onLoadCallbacks.length; ++i)\n    {\n        onLoadCallbacks[i]();\n    }\n\n    onLoadCallbacks = undefined;\n}\n\nself.runOnLoad = function(cb)\n{\n    if (document.readyState === 'complete' || document.readyState === 'interactive')\n    {\n        setTimeout(cb);\n    }\n    else\n    {\n        if (!onLoadCallbacks)\n        {\n            onLoadCallbacks = [ ];\n\n            document.addEventListener('DOMContentLoaded', loadDone, false);\n            window.addEventListener('load', loadDone, false);\n        }\n\n        onLoadCallbacks[onLoadCallbacks.length] = cb;\n    }\n}\n\nfunction generateQueryString(data)\n{\n    var queryString = '';\n\n    if (typeof data == 'object')\n    {\n        var queryArr = [ ]\n        for (key in data)\n        {\n            queryArr[queryArr.length] = encodeURIComponent(key) + '=' + encodeURIComponent(data[key]);\n        }\n\n        queryString = queryArr.join('&').replace(/%20/g, '+');\n    }\n    else\n    {\n        self.Assert(typeof data == 'string', 'Only Objects or Strings are currently supported');\n\n        queryString = data;\n    }\n\n    return queryString;\n};\n\nself.XHR = function (params)\n{\n    var url = params.url;\n    var type = params.type;\n    var cb = params.cb;\n    var data = params.data;\n    var headers = params.headers;\n\n    var username = params.username;\n    var password = params.password;\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function ()\n    {\n        if (xhr.readyState !== 4)\n        {\n            return;\n        }\n\n        cb(xhr);\n    };\n\n    if (username && password)\n    {\n        xhr.open(type.toUpperCase(), url, /*async*/true, username, password);\n    }\n    else\n    {\n        xhr.open(type.toUpperCase(), url, /*async*/true);\n    }\n\n\n    if (headers)\n    {\n        for (var key in headers)\n        {\n            xhr.setRequestHeader(key, headers[key]);\n        }\n    }\n\n    if (data)\n    {\n        xhr.setRequestHeader('Accept', '*/*');\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n\n        var queryString = generateQueryString(data);\n        xhr.send(queryString);\n    }\n    else\n    {\n        //xhr.setRequestHeader('Access-Control-Allow-Origin', '*');\n\n        xhr.send();\n    }\n};\n\nself.element = function (id, reload)\n{\n    self.Assert(id, 'Tried to get an element without an id');\n    if(!self.elements[id] || reload)\n    {\n        self.elements[id] = document.getElementById(id);\n    }\n\n    self.Assert(self.elements[id], 'Tried to get an element that doesn\\'t exist', id);\n\n    return self.elements[id];\n};\n\nself.waitingList = {};\n\nself._waitForElement = function(id, cb)\n{\n    var el = document.getElementById(id);\n    if(el)\n    {\n        cb(el);\n        delete self.waitingList[id];\n        return el;\n    }\n    else\n    {\n        setTimeout(self._waitForElement, 100, id, cb);\n    }\n}\n\nself.waitForElement = function(id, cb)\n{\n    var el = self._waitForElement(id, cb);\n    if(!el)\n    {\n        self.waitingList[id] = cb;\n    }\n}\n\nself.getElementByClassName = function(className, parent)\n{\n    if(!parent)\n    {\n        return document.getElementsByClassName(className)[0];\n    }\n    else\n    {\n        var len = parent.children.length;\n        for(var i = 0; i < len; i ++)\n        {\n            if(parent.children[i].className.indexOf(className) >= 0)\n                return parent.children[i];\n        }\n    }\n}\n\nself.getElementsByClassName = function(className, parent)\n{\n    if(!parent)\n    {\n        return document.getElementsByClassName(className);\n    }\n    else\n    {\n        var arr = [];\n        var len = parent.children.length;\n        for(var i = 0; i < len; i ++)\n        {\n            if(parent.children[i].className.indexOf(className) >= 0)\n                arr.push(parent.children[i]);\n        }\n        return arr;\n    }\n}\n\nself.isDateSoft = function(dateText)\n{\n    if (dateText)\n    {\n        switch(dateText.toUpperCase())\n        {\n            case 'NEXT':\n            case 'SOON':\n            case 'LATER':\n            case 'NOW':\n                return true;\n        }\n    }\n\n    return false;\n}\n\nself.handlerPreventStop = function(e)\n{\n    e.preventDefault();\n    e.stopImmediatePropagation();\n};\n\nself.fFalse = function()\n{\n    return false;\n};\n\nself.emptyFn = function() { };\n\nif (DEBUG)\n{\n    self.verifyFields();\n}\n\nif (util.hasURLParam('nolocal', 'true'))\n{\n    self.noLocalWrites = true;\n}\n\nself.settings.init();\n\nself.eventStream = self.createRingBuffer(100);\n\nreturn self;\n});\n","asserts":[{"tag":742,"offset":6144},{"tag":743,"offset":7437},{"tag":744,"offset":7523},{"tag":745,"offset":7593},{"tag":746,"offset":8016},{"tag":747,"offset":8988},{"tag":748,"offset":11017},{"tag":749,"offset":15334},{"tag":750,"offset":16932},{"tag":751,"offset":17200},{"tag":752,"offset":17533},{"tag":753,"offset":17865},{"tag":754,"offset":18246},{"tag":755,"offset":18340},{"tag":756,"offset":18414},{"tag":757,"offset":18496},{"tag":758,"offset":18818},{"tag":759,"offset":20743},{"tag":760,"offset":24458},{"tag":761,"offset":25288},{"tag":762,"offset":26248},{"tag":763,"offset":26352},{"tag":764,"offset":27505},{"tag":765,"offset":28990},{"tag":766,"offset":29237},{"tag":767,"offset":29510},{"tag":768,"offset":29615},{"tag":769,"offset":29723},{"tag":770,"offset":31361},{"tag":771,"offset":31540},{"tag":772,"offset":37381},{"tag":773,"offset":37458},{"tag":774,"offset":38582},{"tag":775,"offset":41827},{"tag":776,"offset":44546},{"tag":777,"offset":51208},{"tag":778,"offset":73947},{"tag":779,"offset":74688},{"tag":780,"offset":75043},{"tag":781,"offset":75376},{"tag":782,"offset":77845},{"tag":783,"offset":78480},{"tag":784,"offset":81159},{"tag":785,"offset":93166},{"tag":786,"offset":93225},{"tag":787,"offset":103658},{"tag":788,"offset":104945},{"tag":789,"offset":105000},{"tag":790,"offset":105052},{"tag":791,"offset":105109},{"tag":792,"offset":106136},{"tag":793,"offset":107248},{"tag":794,"offset":107341},{"tag":795,"offset":110051},{"tag":796,"offset":112065},{"tag":797,"offset":112564},{"tag":798,"offset":114209},{"tag":799,"offset":114633},{"tag":800,"offset":114891},{"tag":801,"offset":116324},{"tag":802,"offset":116713},{"tag":803,"offset":117931},{"tag":804,"offset":118457},{"tag":805,"offset":118872},{"tag":806,"offset":119005},{"tag":807,"offset":119059},{"tag":808,"offset":119248},{"tag":809,"offset":119622},{"tag":810,"offset":119676},{"tag":811,"offset":119860},{"tag":812,"offset":120878},{"tag":813,"offset":120976},{"tag":814,"offset":121062},{"tag":815,"offset":121149},{"tag":816,"offset":121496},{"tag":817,"offset":126184},{"tag":818,"offset":130661},{"tag":819,"offset":133079},{"tag":820,"offset":134833},{"tag":821,"offset":134910},{"tag":822,"offset":136818},{"tag":823,"offset":136985},{"tag":824,"offset":137768},{"tag":825,"offset":138230},{"tag":826,"offset":139190},{"tag":827,"offset":139676},{"tag":828,"offset":140087},{"tag":829,"offset":143265},{"tag":830,"offset":143424},{"tag":831,"offset":143785},{"tag":832,"offset":143994},{"tag":833,"offset":144093},{"tag":834,"offset":144294},{"tag":835,"offset":144394},{"tag":836,"offset":146066},{"tag":837,"offset":146629},{"tag":838,"offset":146743},{"tag":839,"offset":147303},{"tag":840,"offset":147620},{"tag":841,"offset":148142},{"tag":842,"offset":148872},{"tag":843,"offset":149682},{"tag":844,"offset":150883},{"tag":845,"offset":150941},{"tag":846,"offset":150997},{"tag":847,"offset":151528},{"tag":848,"offset":151710},{"tag":849,"offset":151889},{"tag":850,"offset":152067},{"tag":851,"offset":152242},{"tag":852,"offset":152702},{"tag":853,"offset":153057},{"tag":854,"offset":153212},{"tag":855,"offset":153553},{"tag":856,"offset":153605},{"tag":857,"offset":153816},{"tag":858,"offset":153871},{"tag":859,"offset":154138},{"tag":860,"offset":154373},{"tag":861,"offset":154433},{"tag":862,"offset":154615},{"tag":863,"offset":154672},{"tag":864,"offset":154820},{"tag":865,"offset":155195},{"tag":866,"offset":155370},{"tag":867,"offset":155929},{"tag":868,"offset":156057},{"tag":869,"offset":156607},{"tag":870,"offset":157843},{"tag":871,"offset":159175},{"tag":872,"offset":159344}]},"ko":{"path":"F:/p/bce/Duchess/public/js/lib/knockout-2.3.0.custom.js","data":"// Knockout JavaScript library v2.3.0\n// (c) Steven Sanderson - http://knockoutjs.com/\n// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n\n(function() {(function(q){var w=this||(0,eval)(\"this\"),t=w.document,G=w.navigator,s=w.jQuery,A=w.JSON;(function(q){\"function\"===typeof require&&\"object\"===typeof exports&&\"object\"===typeof module?q(module.exports||exports):\"function\"===typeof define&&define.amd?define([\"exports\"],q):q(w.ko={})})(function(B){function F(b,c,d,f){a.d[b]={init:function(b){a.a.f.set(b,H,{});return{controlsDescendantBindings:!0}},update:function(b,e,k,h,m){k=a.a.f.get(b,H);e=a.a.c(e());h=!d!==!e;var l=!k.gb;if(l||c||h!==k.wb)l&&(k.gb=\na.a.Pa(a.e.childNodes(b),!0)),h?(l||a.e.S(b,a.a.Pa(k.gb)),a.Ka(f?f(m,e):m,b)):a.e.ca(b),k.wb=h}};a.g.V[b]=!1;a.e.N[b]=!0}function I(b,c,d){d&&c!==a.i.n(b)&&a.i.X(b,c);c!==a.i.n(b)&&a.o.P(a.a.Ha,null,[b,\"change\"])}var a=\"undefined\"!==typeof B?B:{};a.b=function(b,c){for(var d=b.split(\".\"),f=a,g=0;g<d.length-1;g++)f=f[d[g]];f[d[d.length-1]]=c};a.q=function(a,c,d){a[c]=d};a.version=\"2.3.0\";a.b(\"version\",a.version);a.a=function(){function b(a,b){for(var e in a)a.hasOwnProperty(e)&&b(e,a[e])}function c(b,\ne){if(\"input\"!==a.a.u(b)||!b.type||\"click\"!=e.toLowerCase())return!1;var c=b.type;return\"checkbox\"==c||\"radio\"==c}var d={},f={};d[G&&/Firefox\\/2/i.test(G.userAgent)?\"KeyboardEvent\":\"UIEvents\"]=[\"keyup\",\"keydown\",\"keypress\"];d.MouseEvents=\"click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave\".split(\" \");b(d,function(a,b){if(b.length)for(var e=0,c=b.length;e<c;e++)f[b[e]]=a});var g={propertychange:!0},e=t&&function(){for(var a=3,b=t.createElement(\"div\"),e=b.getElementsByTagName(\"i\");b.innerHTML=\n\"\\x3c!--[if gt IE \"+ ++a+\"]><i></i><![endif]--\\x3e\",e[0];);return 4<a?a:q}(),k={__proto__:[]}instanceof Array;return{Ua:[\"authenticity_token\",/^__RequestVerificationToken(_.*)?$/],r:function(a,b){for(var e=0,c=a.length;e<c;e++)b(a[e])},k:function(a,b){if(\"function\"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var e=0,c=a.length;e<c;e++)if(a[e]===b)return e;return-1},Ma:function(a,b,e){for(var c=0,d=a.length;c<d;c++)if(b.call(e,a[c]))return a[c];return null},la:function(b,\ne){var c=a.a.k(b,e);0<=c&&b.splice(c,1)},Na:function(b){b=b||[];for(var e=[],c=0,d=b.length;c<d;c++)0>a.a.k(e,b[c])&&e.push(b[c]);return e},$:function(a,b){a=a||[];for(var e=[],c=0,d=a.length;c<d;c++)e.push(b(a[c]));return e},Z:function(a,b){a=a||[];for(var e=[],c=0,d=a.length;c<d;c++)b(a[c])&&e.push(a[c]);return e},U:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var e=0,c=b.length;e<c;e++)a.push(b[e]);return a},ka:function(b,e,c){var d=b.indexOf?b.indexOf(e):a.a.k(b,e);0>d?c&&b.push(e):\nc||b.splice(d,1)},extend:function(a,b){if(b)for(var e in b)b.hasOwnProperty(e)&&(a[e]=b[e]);return a},w:b,pa:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Ob:function(b){b=a.a.Q(b);for(var e=t.createElement(\"div\"),c=0,d=b.length;c<d;c++)e.appendChild(a.J(b[c]));return e},Pa:function(b,e){for(var c=0,d=b.length,g=[];c<d;c++){var f=b[c].cloneNode(!0);g.push(e?a.J(f):f)}return g},S:function(b,e){a.a.pa(b);if(e)for(var c=0,d=e.length;c<d;c++)b.appendChild(e[c])},fb:function(b,e){var c=b.nodeType?\n[b]:b;if(0<c.length){for(var d=c[0],g=d.parentNode,f=0,k=e.length;f<k;f++)g.insertBefore(e[f],d);f=0;for(k=c.length;f<k;f++)a.removeNode(c[f])}},ib:function(a,b){7>e?a.setAttribute(\"selected\",b):a.selected=b},H:function(a){return null===a||a===q?\"\":a.trim?a.trim():a.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")},Yb:function(b,e){for(var c=[],d=(b||\"\").split(e),g=0,f=d.length;g<f;g++){var k=a.a.H(d[g]);\"\"!==k&&c.push(k)}return c},Vb:function(a,b){a=a||\"\";return b.length>a.length?!1:a.substring(0,\nb.length)===b},zb:function(a,b){if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;null!=a;){if(a==b)return!0;a=a.parentNode}return!1},ba:function(b){return a.a.zb(b,b.ownerDocument)},qb:function(b){return!!a.a.Ma(b,a.a.ba)},u:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},p:function(b,d,f){var k=e&&g[d];if(k||\"undefined\"==typeof s)if(k||\"function\"!=typeof b.addEventListener)if(\"undefined\"!=typeof b.attachEvent){var p=function(a){f.call(b,a)},r=\"on\"+d;b.attachEvent(r,\np);a.a.F.ja(b,function(){b.detachEvent(r,p)})}else throw Error(\"Browser doesn't support addEventListener or attachEvent\");else b.addEventListener(d,f,!1);else{if(c(b,d)){var x=f;f=function(a,b){var e=this.checked;b&&(this.checked=!0!==b.tb);x.call(this,a);this.checked=e}}s(b).bind(d,f)}},Ha:function(a,b){if(!a||!a.nodeType)throw Error(\"element must be a DOM node when calling triggerEvent\");if(\"undefined\"!=typeof s){var e=[];c(a,b)&&e.push({tb:a.checked});s(a).trigger(b,e)}else if(\"function\"==typeof t.createEvent)if(\"function\"==\ntypeof a.dispatchEvent)e=t.createEvent(f[b]||\"HTMLEvents\"),e.initEvent(b,!0,!0,w,0,0,0,0,0,!1,!1,!1,!1,0,a),a.dispatchEvent(e);else throw Error(\"The supplied element doesn't support dispatchEvent\");else if(\"undefined\"!=typeof a.fireEvent)c(a,b)&&(a.checked=!0!==a.checked),a.fireEvent(\"on\"+b);else throw Error(\"Browser doesn't support triggering events\");},c:function(b){return a.W(b)?b():b},za:function(b){return a.W(b)?b.t():b},ha:function(b,e,c){if(e){var d=/\\S+/g,g=b.className.match(d)||[];a.a.r(e.match(d),\nfunction(b){a.a.ka(g,b,c)});b.className=g.join(\" \")}},jb:function(b,e){var c=a.a.c(e);if(null===c||c===q)c=\"\";var d=a.e.firstChild(b);!d||3!=d.nodeType||a.e.nextSibling(d)?a.e.S(b,[t.createTextNode(c)]):d.data=c;a.a.Cb(b)},hb:function(a,b){a.name=b;if(7>=e)try{a.mergeAttributes(t.createElement(\"<input name='\"+a.name+\"'/>\"),!1)}catch(c){}},Cb:function(a){9<=e&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Ab:function(a){if(e){var b=a.style.width;a.style.width=0;a.style.width=\nb}},Sb:function(b,e){b=a.a.c(b);e=a.a.c(e);for(var c=[],d=b;d<=e;d++)c.push(d);return c},Q:function(a){for(var b=[],e=0,c=a.length;e<c;e++)b.push(a[e]);return b},Wb:6===e,Xb:7===e,da:e,Va:function(b,e){for(var c=a.a.Q(b.getElementsByTagName(\"input\")).concat(a.a.Q(b.getElementsByTagName(\"textarea\"))),d=\"string\"==typeof e?function(a){return a.name===e}:function(a){return e.test(a.name)},g=[],f=c.length-1;0<=f;f--)d(c[f])&&g.push(c[f]);return g},Pb:function(b){return\"string\"==typeof b&&(b=a.a.H(b))?\nA&&A.parse?A.parse(b):(new Function(\"return \"+b))():null},Da:function(b,e,c){if(!A||!A.stringify)throw Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");return A.stringify(a.a.c(b),e,c)},Qb:function(e,c,d){d=d||{};var g=d.params||{},f=d.includeFields||this.Ua,k=e;if(\"object\"==typeof e&&\"form\"===a.a.u(e))for(var k=e.action,x=f.length-1;0<=x;x--)for(var E=\na.a.Va(e,f[x]),q=E.length-1;0<=q;q--)g[E[q].name]=E[q].value;c=a.a.c(c);var u=t.createElement(\"form\");u.style.display=\"none\";u.action=k;u.method=\"post\";for(var y in c)e=t.createElement(\"input\"),e.name=y,e.value=a.a.Da(a.a.c(c[y])),u.appendChild(e);b(g,function(a,b){var e=t.createElement(\"input\");e.name=a;e.value=b;u.appendChild(e)});t.body.appendChild(u);d.submitter?d.submitter(u):u.submit();setTimeout(function(){u.parentNode.removeChild(u)},0)},I:function(a,b){return k?(a.__proto__=b,!0):!1}}}();\na.b(\"utils\",a.a);a.b(\"utils.arrayForEach\",a.a.r);a.b(\"utils.arrayFirst\",a.a.Ma);a.b(\"utils.arrayFilter\",a.a.Z);a.b(\"utils.arrayGetDistinctValues\",a.a.Na);a.b(\"utils.arrayIndexOf\",a.a.k);a.b(\"utils.arrayMap\",a.a.$);a.b(\"utils.arrayPushAll\",a.a.U);a.b(\"utils.arrayRemoveItem\",a.a.la);a.b(\"utils.extend\",a.a.extend);a.b(\"utils.fieldsIncludedWithJsonPost\",a.a.Ua);a.b(\"utils.getFormFields\",a.a.Va);a.b(\"utils.peekObservable\",a.a.za);a.b(\"utils.postJson\",a.a.Qb);a.b(\"utils.parseJson\",a.a.Pb);a.b(\"utils.registerEventHandler\",\na.a.p);a.b(\"utils.stringifyJson\",a.a.Da);a.b(\"utils.range\",a.a.Sb);a.b(\"utils.toggleDomNodeCssClass\",a.a.ha);a.b(\"utils.triggerEvent\",a.a.Ha);a.b(\"utils.unwrapObservable\",a.a.c);a.b(\"utils.objectForEach\",a.a.w);a.b(\"utils.addOrRemoveItem\",a.a.ka);a.b(\"unwrap\",a.a.c);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this,d=Array.prototype.slice.call(arguments);a=d.shift();return function(){return c.apply(a,d.concat(Array.prototype.slice.call(arguments)))}});a.a.f=new function(){var b=\n0,c=\"__ko__\"+(new Date).getTime(),d={};return{get:function(b,c){var e=a.a.f.qa(b,!1);return e===q?q:e[c]},set:function(b,c,e){if(e!==q||a.a.f.qa(b,!1)!==q)a.a.f.qa(b,!0)[c]=e},qa:function(a,g){var e=a[c];if(!e||\"null\"===e||!d[e]){if(!g)return q;e=a[c]=\"ko\"+b++;d[e]={}}return d[e]},clear:function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}}};a.b(\"utils.domData\",a.a.f);a.b(\"utils.domData.clear\",a.a.f.clear);a.a.F=new function(){function b(b,c){var g=a.a.f.get(b,d);g===q&&c&&(g=[],a.a.f.set(b,\nd,g));return g}function c(e){var d=b(e,!1);if(d)for(var d=d.slice(0),f=0;f<d.length;f++)d[f](e);a.a.f.clear(e);\"function\"==typeof s&&\"function\"==typeof s.cleanData&&s.cleanData([e]);if(g[e.nodeType])for(d=e.firstChild;e=d;)d=e.nextSibling,8===e.nodeType&&c(e)}var d=\"__ko_domNodeDisposal__\"+(new Date).getTime(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{ja:function(a,c){if(\"function\"!=typeof c)throw Error(\"Callback must be a function\");b(a,!0).push(c)},eb:function(e,c){var g=b(e,!1);g&&(a.a.la(g,c),0==\ng.length&&a.a.f.set(e,d,q))},J:function(b){if(f[b.nodeType]&&(c(b),g[b.nodeType])){var d=[];a.a.U(d,b.getElementsByTagName(\"*\"));for(var h=0,m=d.length;h<m;h++)c(d[h])}return b},removeNode:function(b){a.J(b);b.parentNode&&b.parentNode.removeChild(b)}}};a.J=a.a.F.J;a.removeNode=a.a.F.removeNode;a.b(\"cleanNode\",a.J);a.b(\"removeNode\",a.removeNode);a.b(\"utils.domNodeDisposal\",a.a.F);a.b(\"utils.domNodeDisposal.addDisposeCallback\",a.a.F.ja);a.b(\"utils.domNodeDisposal.removeDisposeCallback\",a.a.F.eb);(function(){a.a.ya=\nfunction(b){var c;if(\"undefined\"!=typeof s)if(s.parseHTML)c=s.parseHTML(b)||[];else{if((c=s.clean([b]))&&c[0]){for(b=c[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&b.parentNode.removeChild(b)}}else{var d=a.a.H(b).toLowerCase();c=t.createElement(\"div\");d=d.match(/^<(thead|tbody|tfoot)/)&&[1,\"<table>\",\"</table>\"]||!d.indexOf(\"<tr\")&&[2,\"<table><tbody>\",\"</tbody></table>\"]||(!d.indexOf(\"<td\")||!d.indexOf(\"<th\"))&&[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"]||[0,\"\",\"\"];\nb=\"ignored<div>\"+d[1]+b+d[2]+\"</div>\";for(\"function\"==typeof w.innerShiv?c.appendChild(w.innerShiv(b)):c.innerHTML=b;d[0]--;)c=c.lastChild;c=a.a.Q(c.lastChild.childNodes)}return c};a.a.ga=function(b,c){a.a.pa(b);c=a.a.c(c);if(null!==c&&c!==q)if(\"string\"!=typeof c&&(c=c.toString()),\"undefined\"!=typeof s)s(b).html(c);else for(var d=a.a.ya(c),f=0;f<d.length;f++)b.appendChild(d[f])}})();a.b(\"utils.parseHtmlFragment\",a.a.ya);a.b(\"utils.setHtml\",a.a.ga);a.s=function(){function b(c,f){if(c)if(8==c.nodeType){var g=\na.s.ab(c.nodeValue);null!=g&&f.push({yb:c,Mb:g})}else if(1==c.nodeType)for(var g=0,e=c.childNodes,k=e.length;g<k;g++)b(e[g],f)}var c={};return{wa:function(a){if(\"function\"!=typeof a)throw Error(\"You can only pass a function to ko.memoization.memoize()\");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return\"\\x3c!--[ko_memo:\"+b+\"]--\\x3e\"},nb:function(a,b){var g=c[a];if(g===q)throw Error(\"Couldn't find any memo with ID \"+\na+\". Perhaps it's already been unmemoized.\");try{return g.apply(null,b||[]),!0}finally{delete c[a]}},ob:function(c,f){var g=[];b(c,g);for(var e=0,k=g.length;e<k;e++){var h=g[e].yb,m=[h];f&&a.a.U(m,f);a.s.nb(g[e].Mb,m);h.nodeValue=\"\";h.parentNode&&h.parentNode.removeChild(h)}},ab:function(a){return(a=a.match(/^\\[ko_memo\\:(.*?)\\]$/))?a[1]:null}}}();a.b(\"memoization\",a.s);a.b(\"memoization.memoize\",a.s.wa);a.b(\"memoization.unmemoize\",a.s.nb);a.b(\"memoization.parseMemoText\",a.s.ab);a.b(\"memoization.unmemoizeDomNodeAndDescendants\",\na.s.ob);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.h({read:b,write:function(a){clearTimeout(d);d=setTimeout(function(){b(a)},c)}})},notify:function(b,c){b.equalityComparer=\"always\"==c?function(){return!1}:a.l.fn.equalityComparer;return b}};a.b(\"extenders\",a.Ta);a.lb=function(b,c,d){this.target=b;this.ma=c;this.xb=d;a.q(this,\"dispose\",this.D)};a.lb.prototype.D=function(){this.Jb=!0;this.xb()};a.A=function(){this.B={};a.a.I(this,a.A.fn)||a.a.extend(this,a.A.fn);a.q(this,\n\"subscribe\",this.Ea);a.q(this,\"extend\",this.extend);a.q(this,\"getSubscriptionsCount\",this.Eb)};a.A.fn={Ea:function(b,c,d){d=d||\"change\";var f=new a.lb(this,c?b.bind(c):b,function(){a.a.la(this.B[d],f)}.bind(this));this.B[d]||(this.B[d]=[]);this.B[d].push(f);return f},notifySubscribers:function(b,c){c=c||\"change\";if(this.Fb(c))try{a.o.Oa();for(var d=this.B[c].slice(0),f=0,g;g=d[f];++f)g&&!0!==g.Jb&&g.ma(b)}finally{a.o.end()}},Fb:function(a){return this.B[a]&&this.B[a].length},Eb:function(){var b=0;\na.a.w(this.B,function(a,d){b+=d.length});return b},extend:function(b){var c=this;b&&a.a.w(b,function(b,f){var g=a.Ta[b];\"function\"==typeof g&&(c=g(c,f))});return c}};a.a.I(a.A.fn,Function.prototype);a.Xa=function(a){return null!=a&&\"function\"==typeof a.Ea&&\"function\"==typeof a.notifySubscribers};a.b(\"subscribable\",a.A);a.b(\"isSubscribable\",a.Xa);a.o=function(){var b=[];return{Oa:function(a){b.push(a&&{ma:a,Sa:[]})},end:function(){b.pop()},cb:function(c){if(!a.Xa(c))throw Error(\"Only subscribable things can act as dependencies\");\nif(0<b.length){var d=b[b.length-1];!d||0<=a.a.k(d.Sa,c)||(d.Sa.push(c),d.ma(c))}},P:function(a,d,f){try{return b.push(null),a.apply(d,f||[])}finally{b.pop()}}}}();var K={undefined:!0,\"boolean\":!0,number:!0,string:!0};a.l=function(b){function c(){if(0<arguments.length)return c.equalityComparer&&c.equalityComparer(d,arguments[0])||(c.M(),d=arguments[0],c.L()),this;a.o.cb(c);return d}var d=b;a.A.call(c);c.t=function(){return d};c.L=function(){c.notifySubscribers(d)};c.M=function(){c.notifySubscribers(d,\n\"beforeChange\")};a.a.I(c,a.l.fn)||a.a.extend(c,a.l.fn);a.q(c,\"peek\",c.t);a.q(c,\"valueHasMutated\",c.L);a.q(c,\"valueWillMutate\",c.M);return c};a.l.fn={equalityComparer:function(a,c){return null===a||typeof a in K?a===c:!1}};var z=a.l.Rb=\"__ko_proto__\";a.l.fn[z]=a.l;a.a.I(a.l.fn,a.A.fn);a.ra=function(b,c){return null===b||b===q||b[z]===q?!1:b[z]===c?!0:a.ra(b[z],c)};a.W=function(b){return a.ra(b,a.l)};a.Ya=function(b){return\"function\"==typeof b&&b[z]===a.l||\"function\"==typeof b&&b[z]===a.h&&b.Gb?!0:\n!1};a.b(\"observable\",a.l);a.b(\"isObservable\",a.W);a.b(\"isWriteableObservable\",a.Ya);a.K=function(b){b=b||[];if(\"object\"!=typeof b||!(\"length\"in b))throw Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");b=a.l(b);a.a.I(b,a.K.fn)||a.a.extend(b,a.K.fn);return b};a.K.fn={remove:function(a){for(var c=this.t(),d=[],f=\"function\"==typeof a?a:function(e){return e===a},g=0;g<c.length;g++){var e=c[g];f(e)&&(0===d.length&&this.M(),d.push(e),c.splice(g,\n1),g--)}d.length&&this.L();return d},removeAll:function(b){if(b===q){var c=this.t(),d=c.slice(0);this.M();c.splice(0,c.length);this.L();return d}return b?this.remove(function(c){return 0<=a.a.k(b,c)}):[]},destroy:function(a){var c=this.t(),d=\"function\"==typeof a?a:function(c){return c===a};this.M();for(var f=c.length-1;0<=f;f--)d(c[f])&&(c[f]._destroy=!0);this.L()},destroyAll:function(b){return b===q?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.k(b,c)}):[]},indexOf:function(b){var c=\nthis();return a.a.k(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.M(),this.t()[d]=c,this.L())}};a.a.r(\"pop push reverse shift sort splice unshift\".split(\" \"),function(b){a.K.fn[b]=function(){var a=this.t();this.M();a=a[b].apply(a,arguments);this.L();return a}});a.a.r([\"slice\"],function(b){a.K.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.a.I(a.K.fn,a.l.fn);a.b(\"observableArray\",a.K);a.h=function(b,c,d){function f(){a.a.r(u,function(a){a.D()});u=[]}function g(){var a=\nk.throttleEvaluation;a&&0<=a?(clearTimeout(y),y=setTimeout(e,a)):e()}function e(){if(!n)if(l&&E())C();else{n=!0;try{var b=a.a.$(u,function(a){return a.target});a.o.Oa(function(e){var c;0<=(c=a.a.k(b,e))?b[c]=q:u.push(e.Ea(g))});for(var e=c?p.call(c):p(),d=b.length-1;0<=d;d--)b[d]&&u.splice(d,1)[0].D();l=!0;k.notifySubscribers(m,\"beforeChange\");m=e;k.notifySubscribers(m)}finally{a.o.end(),n=!1}u.length||C()}}function k(){if(0<arguments.length){if(\"function\"===typeof r)r.apply(c,arguments);else throw Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\nreturn this}l||e();a.o.cb(k);return m}function h(){return!l||0<u.length}var m,l=!1,n=!1,p=b;p&&\"object\"==typeof p?(d=p,p=d.read):(d=d||{},p||(p=d.read));if(\"function\"!=typeof p)throw Error(\"Pass a function that returns the value of the ko.computed\");var r=d.write,x=d.disposeWhenNodeIsRemoved||d.aa||null,E=d.disposeWhen||d.Ra||function(){return!1},C=f,u=[],y=null;c||(c=d.owner);k.t=function(){l||e();return m};k.Db=function(){return u.length};k.Gb=\"function\"===typeof d.write;k.D=function(){C()};k.ua=\nh;a.A.call(k);a.a.I(k,a.h.fn)||a.a.extend(k,a.h.fn);a.q(k,\"peek\",k.t);a.q(k,\"dispose\",k.D);a.q(k,\"isActive\",k.ua);a.q(k,\"getDependenciesCount\",k.Db);!0!==d.deferEvaluation&&e();if(x&&h()){C=function(){a.a.F.eb(x,C);f()};a.a.F.ja(x,C);var s=E,E=function(){return!a.a.ba(x)||s()}}return k};a.Ib=function(b){return a.ra(b,a.h)};B=a.l.Rb;a.h[B]=a.l;a.h.fn={};a.h.fn[B]=a.h;a.a.I(a.h.fn,a.A.fn);a.b(\"dependentObservable\",a.h);a.b(\"computed\",a.h);a.b(\"isComputed\",a.Ib);(function(){function b(a,g,e){e=e||new d;\na=g(a);if(\"object\"!=typeof a||null===a||a===q||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};e.save(a,k);c(a,function(c){var d=g(a[c]);switch(typeof d){case \"boolean\":case \"number\":case \"string\":case \"function\":k[c]=d;break;case \"object\":case \"undefined\":var l=e.get(d);k[c]=l!==q?l:b(d,g,e)}});return k}function c(a,b){if(a instanceof Array){for(var e=0;e<a.length;e++)b(e);\"function\"==typeof a.toJSON&&b(\"toJSON\")}else for(e in a)b(e)}\nfunction d(){this.keys=[];this.Ia=[]}a.mb=function(c){if(0==arguments.length)throw Error(\"When calling ko.toJS, pass the object you want to convert.\");return b(c,function(b){for(var e=0;a.W(b)&&10>e;e++)b=b();return b})};a.toJSON=function(b,c,e){b=a.mb(b);return a.a.Da(b,c,e)};d.prototype={save:function(b,c){var e=a.a.k(this.keys,b);0<=e?this.Ia[e]=c:(this.keys.push(b),this.Ia.push(c))},get:function(b){b=a.a.k(this.keys,b);return 0<=b?this.Ia[b]:q}}})();a.b(\"toJS\",a.mb);a.b(\"toJSON\",a.toJSON);(function(){a.i=\n{n:function(b){switch(a.a.u(b)){case \"option\":return!0===b.__ko__hasDomDataOptionValue__?a.a.f.get(b,a.d.options.xa):7>=a.a.da?b.getAttributeNode(\"value\")&&b.getAttributeNode(\"value\").specified?b.value:b.text:b.value;case \"select\":return 0<=b.selectedIndex?a.i.n(b.options[b.selectedIndex]):q;default:return b.value}},X:function(b,c){switch(a.a.u(b)){case \"option\":switch(typeof c){case \"string\":a.a.f.set(b,a.d.options.xa,q);\"__ko__hasDomDataOptionValue__\"in b&&delete b.__ko__hasDomDataOptionValue__;\nb.value=c;break;default:a.a.f.set(b,a.d.options.xa,c),b.__ko__hasDomDataOptionValue__=!0,b.value=\"number\"===typeof c?c:\"\"}break;case \"select\":\"\"===c&&(c=q);if(null===c||c===q)b.selectedIndex=-1;for(var d=b.options.length-1;0<=d;d--)if(a.i.n(b.options[d])==c){b.selectedIndex=d;break}1<b.size||-1!==b.selectedIndex||(b.selectedIndex=0);break;default:if(null===c||c===q)c=\"\";b.value=c}}}})();a.b(\"selectExtensions\",a.i);a.b(\"selectExtensions.readValue\",a.i.n);a.b(\"selectExtensions.writeValue\",a.i.X);a.g=\nfunction(){function b(a,b){for(var d=null;a!=d;)d=a,a=a.replace(c,function(a,c){return b[c]});return a}var c=/\\@ko_token_(\\d+)\\@/g,d=[\"true\",\"false\",\"null\",\"undefined\"],f=/^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i;return{V:[],ea:function(c){var e=a.a.H(c);if(3>e.length)return[];\"{\"===e.charAt(0)&&(e=e.substring(1,e.length-1));c=[];for(var d=null,f,m=0;m<e.length;m++){var l=e.charAt(m);if(null===d)switch(l){case '\"':case \"'\":case \"/\":d=m,f=l}else if(l==f&&\"\\\\\"!==e.charAt(m-1)){l=e.substring(d,\nm+1);c.push(l);var n=\"@ko_token_\"+(c.length-1)+\"@\",e=e.substring(0,d)+n+e.substring(m+1),m=m-(l.length-n.length),d=null}}f=d=null;for(var p=0,r=null,m=0;m<e.length;m++){l=e.charAt(m);if(null===d)switch(l){case \"{\":d=m;r=l;f=\"}\";break;case \"(\":d=m;r=l;f=\")\";break;case \"[\":d=m,r=l,f=\"]\"}l===r?p++:l===f&&(p--,0===p&&(l=e.substring(d,m+1),c.push(l),n=\"@ko_token_\"+(c.length-1)+\"@\",e=e.substring(0,d)+n+e.substring(m+1),m-=l.length-n.length,d=null))}f=[];e=e.split(\",\");d=0;for(m=e.length;d<m;d++)p=e[d],\nr=p.indexOf(\":\"),0<r&&r<p.length-1?(l=p.substring(r+1),f.push({key:b(p.substring(0,r),c),value:b(l,c)})):f.push({unknown:b(p,c)});return f},fa:function(b){var e=\"string\"===typeof b?a.g.ea(b):b,c=[];b=[];for(var h,m=0;h=e[m];m++)if(0<c.length&&c.push(\",\"),h.key){var l;a:{l=h.key;var n=a.a.H(l);switch(n.length&&n.charAt(0)){case \"'\":case '\"':break a;default:l=\"'\"+n+\"'\"}}h=h.value;c.push(l);c.push(\":\");c.push(h);h=a.a.H(h);0<=a.a.k(d,a.a.H(h).toLowerCase())?h=!1:(n=h.match(f),h=null===n?!1:n[1]?\"Object(\"+\nn[1]+\")\"+n[2]:h);h&&(0<b.length&&b.push(\", \"),b.push(l+\" : function(__ko_value) { \"+h+\" = __ko_value; }\"))}else h.unknown&&c.push(h.unknown);e=c.join(\"\");0<b.length&&(e=e+\", '_ko_property_writers' : { \"+b.join(\"\")+\" } \");return e},Lb:function(b,c){for(var d=0;d<b.length;d++)if(a.a.H(b[d].key)==c)return!0;return!1},ia:function(b,c,d,f,m){if(b&&a.W(b))!a.Ya(b)||m&&b.t()===f||b(f);else if((b=c()._ko_property_writers)&&b[d])b[d](f)}}}();a.b(\"expressionRewriting\",a.g);a.b(\"expressionRewriting.bindingRewriteValidators\",\na.g.V);a.b(\"expressionRewriting.parseObjectLiteral\",a.g.ea);a.b(\"expressionRewriting.preProcessBindings\",a.g.fa);a.b(\"jsonExpressionRewriting\",a.g);a.b(\"jsonExpressionRewriting.insertPropertyAccessorsIntoJson\",a.g.fa);(function(){function b(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(e)}function c(a){return 8==a.nodeType&&(g?a.text:a.nodeValue).match(k)}function d(a,e){for(var d=a,g=1,f=[];d=d.nextSibling;){if(c(d)&&(g--,0===g))return f;f.push(d);b(d)&&g++}if(!e)throw Error(\"Cannot find closing comment tag to match: \"+\na.nodeValue);return null}function f(a,b){var c=d(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var g=t&&\"\\x3c!--test--\\x3e\"===t.createComment(\"test\").text,e=g?/^\\x3c!--\\s*ko(?:\\s+(.+\\s*\\:[\\s\\S]*))?\\s*--\\x3e$/:/^\\s*ko(?:\\s+(.+\\s*\\:[\\s\\S]*))?\\s*$/,k=g?/^\\x3c!--\\s*\\/ko\\s*--\\x3e$/:/^\\s*\\/ko\\s*$/,h={ul:!0,ol:!0};a.e={N:{},childNodes:function(a){return b(a)?d(a):a.childNodes},ca:function(c){if(b(c)){c=a.e.childNodes(c);for(var e=0,d=c.length;e<d;e++)a.removeNode(c[e])}else a.a.pa(c)},\nS:function(c,e){if(b(c)){a.e.ca(c);for(var d=c.nextSibling,g=0,f=e.length;g<f;g++)d.parentNode.insertBefore(e[g],d)}else a.a.S(c,e)},bb:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},Wa:function(c,e,d){d?b(c)?c.parentNode.insertBefore(e,d.nextSibling):d.nextSibling?c.insertBefore(e,d.nextSibling):c.appendChild(e):a.e.bb(c,e)},firstChild:function(a){return b(a)?!a.nextSibling||c(a.nextSibling)?null:a.nextSibling:a.firstChild},\nnextSibling:function(a){b(a)&&(a=f(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},pb:function(a){return(a=b(a))?a[1]:null},$a:function(e){if(h[a.a.u(e)]){var d=e.firstChild;if(d){do if(1===d.nodeType){var g;g=d.firstChild;var k=null;if(g){do if(k)k.push(g);else if(b(g)){var r=f(g,!0);r?g=r:k=[g]}else c(g)&&(k=[g]);while(g=g.nextSibling)}if(g=k)for(k=d.nextSibling,r=0;r<g.length;r++)k?e.insertBefore(g[r],k):e.appendChild(g[r])}while(d=d.nextSibling)}}}}})();a.b(\"virtualElements\",a.e);\na.b(\"virtualElements.allowedBindings\",a.e.N);a.b(\"virtualElements.emptyNode\",a.e.ca);a.b(\"virtualElements.insertAfter\",a.e.Wa);a.b(\"virtualElements.prepend\",a.e.bb);a.b(\"virtualElements.setDomNodeChildren\",a.e.S);(function(){a.O=function(){this.sb={}};a.a.extend(a.O.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute(\"data-bind\");case 8:return null!=a.e.pb(b);default:return!1}},getBindings:function(a,c){var d=this.getBindingsString(a,c);return d?this.parseBindingsString(d,\nc,a):null},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute(\"data-bind\");case 8:return a.e.pb(b);default:return null}},parseBindingsString:function(b,c,d){try{var f=this.sb,g;if(!(g=f[b])){var e,k=\"with($context){with($data||{}){return{\"+a.g.fa(b)+\"}}}\";e=new Function(\"$context\",\"$element\",k);g=f[b]=e}return g(c,d)}catch(h){throw h.message=\"Unable to parse bindings.\\nBindings value: \"+b+\"\\nMessage: \"+h.message,h;}}});a.O.instance=new a.O})();a.b(\"bindingProvider\",a.O);\n(function(){function b(b,e,d){for(var f=a.e.firstChild(e);e=f;)f=a.e.nextSibling(e),c(b,e,d)}function c(c,e,f){var h=!0,m=1===e.nodeType;m&&a.e.$a(e);if(m&&f||a.O.instance.nodeHasBindings(e))h=d(e,null,c,f).Ub;h&&b(c,e,!m)}function d(b,c,d,h){function m(a){return function(){return p[a]}}function l(){return p}var n=0,p,r,x=a.a.f.get(b,f);if(!c){if(x)throw Error(\"You cannot apply bindings multiple times to the same element.\"+b.id+\" \"+b.className);a.a.f.set(b,f,!0)}a.h(function(){var f=d&&d instanceof\na.C?d:new a.C(a.a.c(d)),C=f.$data;!x&&h&&a.kb(b,f);if(p=(\"function\"==typeof c?c(f,b):c)||a.O.instance.getBindings(b,f))0===n&&(n=1,a.a.w(p,function(c){var e=a.d[c];if(e&&8===b.nodeType&&!a.e.N[c])throw Error(\"The binding '\"+c+\"' cannot be used with virtual elements\");if(e&&\"function\"==typeof e.init&&(e=(0,e.init)(b,m(c),l,C,f))&&e.controlsDescendantBindings){if(r!==q)throw Error(\"Multiple bindings (\"+r+\" and \"+c+\") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\nr=c}}),n=2),2===n&&a.a.w(p,function(c){var e=a.d[c];e&&\"function\"==typeof e.update&&(0,e.update)(b,m(c),l,C,f)})},null,{aa:b});return{Ub:r===q}}a.d={};a.C=function(b,c,d){c?(a.a.extend(this,c),this.$parentContext=c,this.$parent=c.$data,this.$parents=(c.$parents||[]).slice(0),this.$parents.unshift(this.$parent)):(this.$parents=[],this.$root=b,this.ko=a);this.$data=b;d&&(this[d]=b)};a.C.prototype.createChildContext=function(b,c){return new a.C(b,this,c)};a.C.prototype.extend=function(b){var c=a.a.extend(new a.C,\nthis);return a.a.extend(c,b)};var f=\"__ko_boundElement\";a.kb=function(b,c){if(2==arguments.length)a.a.f.set(b,\"__ko_bindingContext__\",c);else return a.a.f.get(b,\"__ko_bindingContext__\")};a.La=function(b,c,f){1===b.nodeType&&a.e.$a(b);return d(b,c,f,!0)};a.Ka=function(a,c){1!==c.nodeType&&8!==c.nodeType||b(a,c,!0)};a.Ja=function(a,b){if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");b=b||w.document.body;\nc(a,b,!0)};a.oa=function(b){switch(b.nodeType){case 1:case 8:var c=a.kb(b);if(c)return c;if(b.parentNode)return a.oa(b.parentNode)}return q};a.vb=function(b){return(b=a.oa(b))?b.$data:q};a.b(\"bindingHandlers\",a.d);a.b(\"applyBindings\",a.Ja);a.b(\"applyBindingsToDescendants\",a.Ka);a.b(\"applyBindingsToNode\",a.La);a.b(\"contextFor\",a.oa);a.b(\"dataFor\",a.vb)})();var J={\"class\":\"className\",\"for\":\"htmlFor\"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.w(d,function(c,d){d=a.a.c(d);var e=!1===d||\nnull===d||d===q;e&&b.removeAttribute(c);8>=a.a.da&&c in J?(c=J[c],e?b.removeAttribute(c):b[c]=d):e||b.setAttribute(c,d.toString());\"name\"===c&&a.a.hb(b,e?\"\":d.toString())})}};a.d.checked={init:function(b,c,d){a.a.p(b,\"click\",function(){var f;if(\"checkbox\"==b.type)f=b.checked;else if(\"radio\"==b.type&&b.checked)f=b.value;else return;var g=c(),e=a.a.c(g);\"checkbox\"==b.type&&e instanceof Array?a.a.ka(g,b.value,b.checked):a.g.ia(g,d,\"checked\",f,!0)});\"radio\"!=b.type||b.name||a.d.uniqueName.init(b,function(){return!0})},\nupdate:function(b,c){var d=a.a.c(c());\"checkbox\"==b.type?b.checked=d instanceof Array?0<=a.a.k(d,b.value):d:\"radio\"==b.type&&(b.checked=b.value==d)}};a.d.css={update:function(b,c){var d=a.a.c(c());\"object\"==typeof d?a.a.w(d,function(c,d){d=a.a.c(d);a.a.ha(b,c,d)}):(d=String(d||\"\"),a.a.ha(b,b.__ko__cssValue,!1),b.__ko__cssValue=d,a.a.ha(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());d&&b.disabled?b.removeAttribute(\"disabled\"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,\nc){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,f){var g=c()||{};a.a.w(g,function(e){\"string\"==typeof e&&a.a.p(b,e,function(b){var g,m=c()[e];if(m){var l=d();try{var n=a.a.Q(arguments);n.unshift(f);g=m.apply(f,n)}finally{!0!==g&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===l[e+\"Bubble\"]&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={Za:function(b){return function(){var c=b(),d=a.a.za(c);if(!d||\"number\"==typeof d.length)return{foreach:c,\ntemplateEngine:a.G.ta};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.G.ta}}},init:function(b,c){return a.d.template.init(b,a.d.foreach.Za(c))},update:function(b,c,d,f,g){return a.d.template.update(b,a.d.foreach.Za(c),d,f,g)}};a.g.V.foreach=!1;a.e.N.foreach=!0;a.d.hasfocus={init:function(b,c,d){function f(e){b.__ko_hasfocusUpdating=!0;\nvar f=b.ownerDocument;if(\"activeElement\"in f){var g;try{g=f.activeElement}catch(l){g=f.body}e=g===b}f=c();a.g.ia(f,d,\"hasfocus\",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var g=f.bind(null,!0),e=f.bind(null,!1);a.a.p(b,\"focus\",g);a.a.p(b,\"focusin\",g);a.a.p(b,\"blur\",e);a.a.p(b,\"focusout\",e)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===d||(d?b.focus():b.blur(),a.o.P(a.a.Ha,null,[b,d?\"focusin\":\"focusout\"]))}};a.d.hasFocus=a.d.hasfocus;\na.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.ga(b,c())}};var H=\"__ko_withIfBindingData\";F(\"if\");F(\"ifnot\",!1,!0);F(\"with\",!0,!1,function(a,c){return a.createChildContext(c)});a.d.options={init:function(b){if(\"select\"!==a.a.u(b))throw Error(\"options binding applies only to SELECT elements\");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function f(a,b,c){var d=typeof b;return\"function\"==d?b(a):\"string\"==d?a[b]:\nc}function g(b,c){if(p){var d=0<=a.a.k(p,a.i.n(c[0]));a.a.ib(c[0],d)}}var e=0==b.length,k=!e&&b.multiple?b.scrollTop:null;c=a.a.c(c());var h=d(),m=h.optionsIncludeDestroyed,l={},n,p;b.multiple?p=a.a.$(b.selectedOptions||a.a.Z(b.childNodes,function(b){return b.tagName&&\"option\"===a.a.u(b)&&b.selected}),function(b){return a.i.n(b)}):0<=b.selectedIndex&&(p=[a.i.n(b.options[b.selectedIndex])]);if(c){\"undefined\"==typeof c.length&&(c=[c]);var r=a.a.Z(c,function(b){return m||b===q||null===b||!a.a.c(b._destroy)});\n\"optionsCaption\"in h&&(n=a.a.c(h.optionsCaption),null!==n&&n!==q&&r.unshift(l))}else c=[];d=g;h.optionsAfterRender&&(d=function(b,c){g(0,c);a.o.P(h.optionsAfterRender,null,[c[0],b!==l?b:q])});a.a.Ba(b,r,function(b,c,d){d.length&&(p=d[0].selected&&[a.i.n(d[0])]);c=t.createElement(\"option\");b===l?(a.a.ga(c,n),a.i.X(c,q)):(d=f(b,h.optionsValue,b),a.i.X(c,a.a.c(d)),b=f(b,h.optionsText,d),a.a.jb(c,b));return[c]},null,d);p=null;e&&\"value\"in h&&I(b,a.a.za(h.value),!0);a.a.Ab(b);k&&20<Math.abs(k-b.scrollTop)&&\n(b.scrollTop=k)}};a.d.options.xa=\"__ko.optionValueDomData__\";a.d.selectedOptions={init:function(b,c,d){a.a.p(b,\"change\",function(){var f=c(),g=[];a.a.r(b.getElementsByTagName(\"option\"),function(b){b.selected&&g.push(a.i.n(b))});a.g.ia(f,d,\"selectedOptions\",g)})},update:function(b,c){if(\"select\"!=a.a.u(b))throw Error(\"values binding applies only to SELECT elements\");var d=a.a.c(c());d&&\"number\"==typeof d.length&&a.a.r(b.getElementsByTagName(\"option\"),function(b){var c=0<=a.a.k(d,a.i.n(b));a.a.ib(b,\nc)})}};a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.w(d,function(c,d){d=a.a.c(d);b.style[c]!==d&&(b.style[c]=d||\"\")})}};a.d.submit={init:function(b,c,d,f){if(\"function\"!=typeof c())throw Error(\"The value for a submit binding must be a function\");a.a.p(b,\"submit\",function(a){var d,k=c();try{d=k.call(f,b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={update:function(b,c){a.a.jb(b,c())}};a.e.N.text=!0;a.d.uniqueName={init:function(b,c){if(c()){var d=\n\"ko_unique_\"+ ++a.d.uniqueName.ub;a.a.hb(b,d)}}};a.d.uniqueName.ub=0;a.d.value={init:function(b,c,d){function f(){k=!1;var e=c(),f=a.i.n(b);a.g.ia(e,d,\"value\",f)}var g=[\"change\"],e=d().valueUpdate,k=!1;e&&(\"string\"==typeof e&&(e=[e]),a.a.U(g,e),g=a.a.Na(g));!a.a.da||\"input\"!=b.tagName.toLowerCase()||\"text\"!=b.type||\"off\"==b.autocomplete||b.form&&\"off\"==b.form.autocomplete||-1!=a.a.k(g,\"propertychange\")||(a.a.p(b,\"propertychange\",function(){k=!0}),a.a.p(b,\"blur\",function(){k&&f()}));a.a.r(g,function(c){var d=\nf;a.a.Vb(c,\"after\")&&(d=function(){setTimeout(f,0)},c=c.substring(5));a.a.p(b,c,d)})},update:function(b,c){var d=\"select\"===a.a.u(b),f=a.a.c(c()),g=a.i.n(b);f!==g&&(g=function(){a.i.X(b,f)},g(),d&&setTimeout(g,0));d&&0<b.length&&I(b,f,!1)}};a.d.visible={update:function(b,c){var d=a.a.c(c()),f=\"none\"!=b.style.display;d&&!f?b.style.display=\"\":!d&&f&&(b.style.display=\"none\")}};(function(b){a.d[b]={init:function(c,d,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},f,g)}}})(\"click\");\na.v=function(){};a.v.prototype.renderTemplateSource=function(){throw Error(\"Override renderTemplateSource\");};a.v.prototype.createJavaScriptEvaluatorBlock=function(){throw Error(\"Override createJavaScriptEvaluatorBlock\");};a.v.prototype.makeTemplateSource=function(b,c){if(\"string\"==typeof b){c=c||t;var d=c.getElementById(b);if(!d)throw Error(\"Cannot find template with ID \"+b);return new a.m.j(d)}if(1==b.nodeType||8==b.nodeType)return new a.m.T(b);throw Error(\"Unknown template type: \"+b);};a.v.prototype.renderTemplate=\nfunction(a,c,d,f){a=this.makeTemplateSource(a,f);return this.renderTemplateSource(a,c,d)};a.v.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data(\"isRewritten\")};a.v.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data(\"isRewritten\",!0)};a.b(\"templateEngine\",a.v);a.Fa=function(){function b(b,c,d,k){b=a.g.ea(b);for(var h=a.g.V,m=0;m<b.length;m++){var l=b[m].key;if(h.hasOwnProperty(l)){var n=\nh[l];if(\"function\"===typeof n){if(l=n(b[m].value))throw Error(l);}else if(!n)throw Error(\"This template engine does not support the '\"+l+\"' binding within its templates\");}}d=\"ko.__tr_ambtns(function($context,$element){return(function(){return{ \"+a.g.fa(b)+\" } })()},'\"+d.toLowerCase()+\"')\";return k.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\\"[^\\\"]*\\\"|\\'[^\\']*\\'))?)*\\s+)data-bind\\s*=\\s*([\"'])([\\s\\S]*?)\\3/gi,d=/\\x3c!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*--\\x3e/g;\nreturn{Bb:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Fa.Nb(b,c)},d)},Nb:function(a,g){return a.replace(c,function(a,c,d,f,l){return b(l,c,d,g)}).replace(d,function(a,c){return b(c,\"\\x3c!-- ko --\\x3e\",\"#comment\",g)})},rb:function(b,c){return a.s.wa(function(d,k){var h=d.nextSibling;h&&h.nodeName.toLowerCase()===c&&a.La(h,b,k)})}}}();a.b(\"__tr_ambtns\",a.Fa.rb);(function(){a.m={};a.m.j=function(a){this.j=a};a.m.j.prototype.text=function(){var b=a.a.u(this.j),\nb=\"script\"===b?\"text\":\"textarea\"===b?\"value\":\"innerHTML\";if(0==arguments.length)return this.j[b];var c=arguments[0];\"innerHTML\"===b?a.a.ga(this.j,c):this.j[b]=c};a.m.j.prototype.data=function(b){if(1===arguments.length)return a.a.f.get(this.j,\"templateSourceData_\"+b);a.a.f.set(this.j,\"templateSourceData_\"+b,arguments[1])};a.m.T=function(a){this.j=a};a.m.T.prototype=new a.m.j;a.m.T.prototype.text=function(){if(0==arguments.length){var b=a.a.f.get(this.j,\"__ko_anon_template__\")||{};b.Ga===q&&b.na&&\n(b.Ga=b.na.innerHTML);return b.Ga}a.a.f.set(this.j,\"__ko_anon_template__\",{Ga:arguments[0]})};a.m.j.prototype.nodes=function(){if(0==arguments.length)return(a.a.f.get(this.j,\"__ko_anon_template__\")||{}).na;a.a.f.set(this.j,\"__ko_anon_template__\",{na:arguments[0]})};a.b(\"templateSources\",a.m);a.b(\"templateSources.domElement\",a.m.j);a.b(\"templateSources.anonymousTemplate\",a.m.T)})();(function(){function b(b,c,d){var f;for(c=a.e.nextSibling(c);b&&(f=b)!==c;)b=a.e.nextSibling(f),1!==f.nodeType&&8!==f.nodeType||\nd(f)}function c(c,d){if(c.length){var f=c[0],g=c[c.length-1];b(f,g,function(b){a.Ja(d,b)});b(f,g,function(b){a.s.ob(b,[d])})}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function f(b,f,h,m,l){l=l||{};var n=b&&d(b),n=n&&n.ownerDocument,p=l.templateEngine||g;a.Fa.Bb(h,p,n);h=p.renderTemplate(h,m,l,n);if(\"number\"!=typeof h.length||0<h.length&&\"number\"!=typeof h[0].nodeType)throw Error(\"Template engine must return an array of DOM nodes\");n=!1;switch(f){case \"replaceChildren\":a.e.S(b,h);n=!0;\nbreak;case \"replaceNode\":a.a.fb(b,h);n=!0;break;case \"ignoreTargetNode\":break;default:throw Error(\"Unknown renderMode: \"+f);}n&&(c(h,m),l.afterRender&&a.o.P(l.afterRender,null,[h,m.$data]));return h}var g;a.Ca=function(b){if(b!=q&&!(b instanceof a.v))throw Error(\"templateEngine must inherit from ko.templateEngine\");g=b};a.Aa=function(b,c,h,m,l){h=h||{};if((h.templateEngine||g)==q)throw Error(\"Set a template engine before calling renderTemplate\");l=l||\"replaceChildren\";if(m){var n=d(m);return a.h(function(){var g=\nc&&c instanceof a.C?c:new a.C(a.a.c(c)),r=\"function\"==typeof b?b(g.$data,g):b,g=f(m,l,r,g,h);\"replaceNode\"==l&&(m=g,n=d(m))},null,{Ra:function(){return!n||!a.a.ba(n)},aa:n&&\"replaceNode\"==l?n.parentNode:n})}return a.s.wa(function(d){a.Aa(b,c,h,d,\"replaceNode\")})};a.Tb=function(b,d,g,m,l){function n(a,b){c(b,r);g.afterRender&&g.afterRender(b,a)}function p(c,d){r=l.createChildContext(a.a.c(c),g.as);r.$index=d;var k=\"function\"==typeof b?b(c,r):b;return f(null,\"ignoreTargetNode\",k,r,g)}var r;return a.h(function(){var b=\na.a.c(d)||[];\"undefined\"==typeof b.length&&(b=[b]);b=a.a.Z(b,function(b){return g.includeDestroyed||b===q||null===b||!a.a.c(b._destroy)});a.o.P(a.a.Ba,null,[m,b,p,g,n])},null,{aa:m})};a.d.template={init:function(b,c){var d=a.a.c(c());\"string\"==typeof d||d.name||1!=b.nodeType&&8!=b.nodeType||(d=1==b.nodeType?b.childNodes:a.e.childNodes(b),d=a.a.Ob(d),(new a.m.T(b)).nodes(d));return{controlsDescendantBindings:!0}},update:function(b,c,d,f,g){c=a.a.c(c());d={};f=!0;var n,p=null;\"string\"!=typeof c&&(d=\nc,c=a.a.c(d.name),\"if\"in d&&(f=a.a.c(d[\"if\"])),f&&\"ifnot\"in d&&(f=!a.a.c(d.ifnot)),n=a.a.c(d.data));\"foreach\"in d?p=a.Tb(c||b,f&&d.foreach||[],d,b,g):f?(g=\"data\"in d?g.createChildContext(n,d.as):g,p=a.Aa(c||b,g,d,b)):a.e.ca(b);g=p;(n=a.a.f.get(b,\"__ko__templateComputedDomDataKey__\"))&&\"function\"==typeof n.D&&n.D();a.a.f.set(b,\"__ko__templateComputedDomDataKey__\",g&&g.ua()?g:q)}};a.g.V.template=function(b){b=a.g.ea(b);return 1==b.length&&b[0].unknown||a.g.Lb(b,\"name\")?null:\"This template engine does not support anonymous templates nested within its templates\"};\na.e.N.template=!0})();a.b(\"setTemplateEngine\",a.Ca);a.b(\"renderTemplate\",a.Aa);a.a.Qa=function(){function a(b,d,f,g,e){var k=Math.min,h=Math.max,m=[],l,n=b.length,p,r=d.length,q=r-n||1,s=n+r+1,t,u,y;for(l=0;l<=n;l++)for(u=t,m.push(t=[]),y=k(r,l+q),p=h(0,l-1);p<=y;p++)t[p]=p?l?b[l-1]===d[p-1]?u[p-1]:k(u[p]||s,t[p-1]||s)+1:p+1:l+1;k=[];h=[];q=[];l=n;for(p=r;l||p;)r=m[l][p]-1,p&&r===m[l][p-1]?h.push(k[k.length]={status:f,value:d[--p],index:p}):l&&r===m[l-1][p]?q.push(k[k.length]={status:g,value:b[--l],\nindex:l}):(k.push({status:\"retained\",value:d[--p]}),--l);if(h.length&&q.length){b=10*n;var w;for(d=f=0;(e||d<b)&&(w=h[f]);f++){for(g=0;m=q[g];g++)if(w.value===m.value){w.moved=m.index;m.moved=w.index;q.splice(g,1);d=g=0;break}d+=g}}return k.reverse()}return function(c,d,f){c=c||[];d=d||[];return c.length<=d.length?a(c,d,\"added\",\"deleted\",f):a(d,c,\"deleted\",\"added\",f)}}();a.b(\"utils.compareArrays\",a.a.Qa);(function(){function b(b){for(;b.length&&!a.a.ba(b[0]);)b.splice(0,1);if(1<b.length){for(var c=\nb[0],g=b[b.length-1],e=[c];c!==g;){c=c.nextSibling;if(!c)return;e.push(c)}Array.prototype.splice.apply(b,[0,b.length].concat(e))}return b}function c(c,f,g,e,k){var h=[];c=a.h(function(){var c=f(g,k,b(h))||[];0<h.length&&(a.a.fb(h,c),e&&a.o.P(e,null,[g,c,k]));h.splice(0,h.length);a.a.U(h,c)},null,{aa:c,Ra:function(){return!a.a.qb(h)}});return{R:h,h:c.ua()?c:q}}a.a.Ba=function(d,f,g,e,k){function h(a,c){v=n[c];w!==c&&(A[a]=v);v.sa(w++);b(v.R);s.push(v);y.push(v)}function m(b,c){if(b)for(var d=0,e=c.length;d<\ne;d++)c[d]&&a.a.r(c[d].R,function(a){b(a,d,c[d].Y)})}f=f||[];e=e||{};var l=a.a.f.get(d,\"setDomNodeChildrenFromArrayMapping_lastMappingResult\")===q,n=a.a.f.get(d,\"setDomNodeChildrenFromArrayMapping_lastMappingResult\")||[],p=a.a.$(n,function(a){return a.Y}),r=a.a.Qa(p,f,e.dontLimitMoves),s=[],t=0,w=0,u=[],y=[];f=[];for(var A=[],p=[],v,D=0,z,B;z=r[D];D++)switch(B=z.moved,z.status){case \"deleted\":B===q&&(v=n[t],v.h&&v.h.D(),u.push.apply(u,b(v.R)),e.beforeRemove&&(f[D]=v,y.push(v)));t++;break;case \"retained\":h(D,\nt++);break;case \"added\":B!==q?h(D,B):(v={Y:z.value,sa:a.l(w++)},s.push(v),y.push(v),l||(p[D]=v))}m(e.beforeMove,A);a.a.r(u,e.beforeRemove?a.J:a.removeNode);for(var D=0,l=a.e.firstChild(d),F;v=y[D];D++){v.R||a.a.extend(v,c(d,g,v.Y,k,v.sa));for(t=0;r=v.R[t];l=r.nextSibling,F=r,t++)r!==l&&a.e.Wa(d,r,F);!v.Hb&&k&&(k(v.Y,v.R,v.sa),v.Hb=!0)}m(e.beforeRemove,f);m(e.afterMove,A);m(e.afterAdd,p);a.a.f.set(d,\"setDomNodeChildrenFromArrayMapping_lastMappingResult\",s)}})();a.b(\"utils.setDomNodeChildrenFromArrayMapping\",\na.a.Ba);a.G=function(){this.allowTemplateRewriting=!1};a.G.prototype=new a.v;a.G.prototype.renderTemplateSource=function(b){var c=(9>a.a.da?0:b.nodes)?b.nodes():null;if(c)return a.a.Q(c.cloneNode(!0).childNodes);b=b.text();return a.a.ya(b)};a.G.ta=new a.G;a.Ca(a.G.ta);a.b(\"nativeTemplateEngine\",a.G);(function(){a.va=function(){var a=this.Kb=function(){if(\"undefined\"==typeof s||!s.tmpl)return 0;try{if(0<=s.tmpl.tag.tmpl.open.toString().indexOf(\"__\"))return 2}catch(a){}return 1}();this.renderTemplateSource=\nfunction(b,f,g){g=g||{};if(2>a)throw Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");var e=b.data(\"precompiled\");e||(e=b.text()||\"\",e=s.template(null,\"{{ko_with $item.koBindingContext}}\"+e+\"{{/ko_with}}\"),b.data(\"precompiled\",e));b=[f.$data];f=s.extend({koBindingContext:f},g.templateOptions);f=s.tmpl(e,b,f);f.appendTo(t.createElement(\"div\"));s.fragments={};return f};this.createJavaScriptEvaluatorBlock=function(a){return\"{{ko_code ((function() { return \"+\na+\" })()) }}\"};this.addTemplate=function(a,b){t.write(\"<script type='text/html' id='\"+a+\"'>\"+b+\"\\x3c/script>\")};0<a&&(s.tmpl.tag.ko_code={open:\"__.push($1 || '');\"},s.tmpl.tag.ko_with={open:\"with($1) {\",close:\"} \"})};a.va.prototype=new a.v;var b=new a.va;0<b.Kb&&a.Ca(b);a.b(\"jqueryTmplTemplateEngine\",a.va)})()})})();\n})();\n","asserts":[]},"platform":{"path":"F:/p/bce/Duchess/public/js/platform.js","data":"define(['ko', 'util'],\r\nfunction(ko, util) {\r\n\r\nwindow.Orientation =\r\n{\r\n    Portrait: 0,\r\n    Landscape: 1\r\n};\r\n\r\nfunction platform()\r\n{\r\n    this.versionRequired = 4;\r\n    this.requireCustomRedirect = false;\r\n    this.b = document.documentElement || document.body;\r\n    this.orientation = Orientation.Portrait;\r\n    this.windowWidth = ko.observable(0);\r\n    this.windowHeight = ko.observable(0);\r\n    this.kbsize = undefined;\r\n    this.kbsizePortrait = undefined;\r\n    this.kbsizeLandscape = undefined;\r\n    this.hasBeenPortrait = false;\r\n    this.iframeApp = undefined;\r\n    this.appState = undefined;\r\n\r\n    this.isDevURL = (window.location.hostname === 'dev.moo.do');\r\n\r\n    this.init();\r\n\r\n    var useLocationHost = DEBUG || this.isDevURL || (this.app && this.debugApp) || (!this.app && this.standalone);\r\n\r\n    this.customRedirectString = window.location.protocol + '//' + (useLocationHost ? window.location.host : 'www.moo.do');\r\n\r\n    if (this.app)\r\n    {\r\n        this.customRedirectState =\r\n        {\r\n            app: true,\r\n            appv: this.versionRequired\r\n        };\r\n    }\r\n\r\n    if (this.app || this.android)\r\n    {\r\n        this.keyboardOpenTime = 200;\r\n    }\r\n    else if (this.winphone)\r\n    {\r\n        this.keyboardOpenTime = 200;\r\n    }\r\n    else if (this.mobileie)\r\n    {\r\n        this.keyboardOpenTime = 600;\r\n    }\r\n    else\r\n    {\r\n        this.keyboardOpenTime = 0;\r\n    }\r\n}\r\n\r\nplatform.prototype =\r\n{\r\n    getPlatformInfo: function(obj)\r\n    {\r\n        obj['os'] = this.OSName;\r\n        obj['browser'] = this.browser;\r\n        obj['appVersionRequired'] = this.versionRequired;\r\n        obj['app'] = this.app;\r\n        obj['standalone'] = this.standalone;\r\n        obj['packagedApp'] = this.packagedApp;\r\n        obj['requireCustomRedirect'] = this.requireCustomRedirect;\r\n        obj['isMobile'] = this.mobile;\r\n        obj['isPhone'] = this.phone;\r\n        obj['isTouch'] = this.touch;\r\n        obj['isTouchDevice'] = this.isTouchDevice;\r\n        obj['usePointerEvents'] = this.usePointerEvents;\r\n        obj['kbsize'] = this.kbsize;\r\n        obj['appState'] = this.appState;\r\n        obj['bodyClass'] = this.b.className;\r\n        obj['rawUA'] = navigator.userAgent;\r\n    },\r\n    init: function()\r\n    {\r\n        this.initAppState();\r\n\r\n        var userAgent = navigator.userAgent;\r\n\r\n        var bodyClass = '';\r\n\r\n        // OS Detection\r\n        var OSName = 'Unknown OS';\r\n\r\n        if (this.app)\r\n        {\r\n            bodyClass += \" app\";\r\n        }\r\n\r\n        if (userAgent.indexOf('Win') !== -1)\r\n        {\r\n            this.OSName = 'Windows';\r\n            this.windows = true;\r\n\r\n            if (userAgent.indexOf('Windows Phone') !== -1)\r\n            {\r\n                this.phone = true;\r\n                this.touch = true;\r\n                this.mobile = true;\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('iPad') !== -1)\r\n        {\r\n            this.OSName = 'iPad';\r\n            this.ios = true;\r\n            this.ipad = true;\r\n            this.phone = true;\r\n            this.touch = true;\r\n            this.mobile = true;\r\n        }\r\n        else if (userAgent.indexOf('iPhone') !== -1)\r\n        {\r\n            this.OSName = 'iPhone';\r\n            this.ios = true;\r\n            this.iphone = true;\r\n            this.phone = true;\r\n            this.mobile = true;\r\n            this.touch = true;\r\n        }\r\n        else if (userAgent.indexOf('iPod') !== -1)\r\n        {\r\n            this.OSName = 'iPod';\r\n            this.ios = true;\r\n            this.ipod = true;\r\n            this.phone = true;\r\n            this.mobile = true;\r\n            this.touch = true;\r\n        }\r\n        else if (userAgent.indexOf('Mac') !== -1)\r\n        {\r\n            this.OSName = 'MacOS';\r\n            this.mac = true;\r\n        }\r\n        else if (userAgent.indexOf('X11') !== -1)\r\n        {\r\n            this.OSName = 'UNIX';\r\n            this.unix = true;\r\n        }\r\n        else if (userAgent.indexOf('Android') !== -1)\r\n        {\r\n            this.OSName = 'Android';\r\n            this.android = true;\r\n            this.touch = true;\r\n            this.mobile = true;\r\n            this.phone = true;\r\n\r\n            bodyClass += \" android\";\r\n        }\r\n        else if (userAgent.indexOf('Linux') !== -1)\r\n        {\r\n            this.OSName = 'Linux';\r\n            this.linux = true;\r\n        }\r\n\r\n        if (this.ios)\r\n        {\r\n            this.ios7 = userAgent.indexOf('OS 7') !== -1;\r\n            this.ios70 = userAgent.indexOf('OS 7_0') !== -1;\r\n            this.ios71 = userAgent.indexOf('OS 7_1') !== -1;\r\n\r\n            if (this.ios7)\r\n            {\r\n                bodyClass += \" ios7\";\r\n            }\r\n        }\r\n\r\n        this.majorVersion = 1000;\r\n        this.minorVersion = 1000;\r\n\r\n        if (userAgent.indexOf('MSIE') !== -1 || userAgent.indexOf('Trident') !== -1)\r\n        {\r\n            this.browser = 'Trident';\r\n            this.ie = true;\r\n\r\n            this.winphone = !!userAgent.match(/IEMobile/i);\r\n\r\n            var re;\r\n            if (this.winphone || navigator.appName === 'Microsoft Internet Explorer')\r\n            {\r\n                re = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\r\n            }\r\n            else\r\n            {\r\n                re = new RegExp(\"Trident/.*rv:([0-9]{1,}[\\.0-9]{0,})\");\r\n            }\r\n\r\n            if (re.exec(userAgent) != null)\r\n            {\r\n                this.majorVersion = parseFloat(RegExp.$1);\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('Chrome') !== -1 || userAgent.indexOf('CriOS') !== -1)\r\n        {\r\n            this.browser = 'Chrome';\r\n            this.isChrome = true;\r\n\r\n            var re = new RegExp('Chrome/([0-9]{1,})\\.');\r\n\r\n            if (re.exec(userAgent) != null)\r\n            {\r\n                this.majorVersion = parseFloat(RegExp.$1);\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('Android') !== -1)\r\n        {\r\n            this.browser = 'Native Android';\r\n\r\n            var re = new RegExp('Linux; Android ([0-9]{1,})\\.([0-9]{1,})\\.');\r\n\r\n            if (re.exec(userAgent) != null)\r\n            {\r\n                this.majorVersion = parseFloat(RegExp.$1);\r\n                this.minorVersion = parseFloat(RegExp.$2);\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('Firefox') !== -1)\r\n        {\r\n            this.browser = 'Firefox';\r\n\r\n            var re = new RegExp('Firefox/([0-9]{1,})\\.');\r\n\r\n            if (re.exec(userAgent) != null)\r\n            {\r\n                this.majorVersion = parseFloat(RegExp.$1);\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('Safari') !== -1 || this.OSName === 'iPad' || this.OSName === 'iPhone' || this.OSName === 'iPod')\r\n        {\r\n            this.browser = 'Safari';\r\n\r\n            var re;\r\n\r\n            if (this.mobile)\r\n            {\r\n                re = new RegExp('OS ([0-9]{1,})\\_([0-9]{1,})');\r\n            }\r\n            else\r\n            {\r\n                re = new RegExp('Version/([0-9]{1,})\\.([0-9]{1,})\\.');\r\n            }\r\n\r\n            if (re.exec(userAgent) != null)\r\n            {\r\n                this.majorVersion = parseFloat(RegExp.$1);\r\n                this.minorVersion = parseFloat(RegExp.$2);\r\n            }\r\n        }\r\n        else if (userAgent.indexOf('Opera') !== -1)\r\n        {\r\n            this.browser = 'Opera';\r\n        }\r\n\r\n        this.isTouchDevice = !!(('ontouchstart' in window) || window.navigator.msMaxTouchPoints);\r\n\r\n        this.usePointerEvents = !!window.navigator.msPointerEnabled;\r\n\r\n        log('Touch Device: ' + this.isTouchDevice + ' Pointer Events: ' + this.usePointerEvents);\r\n\r\n        log('Browser: ' + this.browser + '  Major Version: ' + this.majorVersion + '  Minor Version: ' + this.minorVersion);\r\n\r\n        if (this.isTouchDevice)\r\n        {\r\n            if (this.usePointerEvents)\r\n            {\r\n                // Use pointer events\r\n                this.touchStartEvent = 'MSPointerDown';\r\n                this.touchMoveEvent = 'MSPointerMove';\r\n                this.touchEndEvent = 'MSPointerUp';\r\n                this.touchCancelEvent = 'MSPointerCancel';\r\n            }\r\n            else\r\n            {\r\n                // Use touch events\r\n                this.touchStartEvent = 'touchstart';\r\n                this.touchMoveEvent = 'touchmove';\r\n                this.touchEndEvent = 'touchend';\r\n                this.touchCancelEvent = 'touchcancel';\r\n            }\r\n        }\r\n\r\n        if (this.usePointerEvents)\r\n        {\r\n            this.downEvent = 'MSPointerDown';\r\n            this.moveEvent = 'MSPointerMove';\r\n            this.upEvent = 'MSPointerUp';\r\n        }\r\n        else\r\n        {\r\n            this.downEvent = 'mousedown';\r\n            this.moveEvent = 'mousemove';\r\n            this.upEvent = 'mouseup';\r\n        }\r\n\r\n        try\r\n        {\r\n            var forceFullUI = !!util.storage.getItem('forceFullUI');\r\n        }\r\n        catch (err)\r\n        {\r\n            // Do Nothing\r\n        }\r\n\r\n        // TODO: Being a touch device does not automatically mean phone/mobile\r\n        if (util.hasURLParam('touch', 'false') || forceFullUI)\r\n        {\r\n            this.touch = false;\r\n            this.phone = false;\r\n            this.mobile = false;\r\n            this.ios = false;\r\n            this.android = false;\r\n        }\r\n        else if (this.isTouchDevice || util.hasURLParam('touch', 'true'))\r\n        {\r\n            this.touch = true;\r\n            this.phone = true;\r\n            this.mobile = true;\r\n        }\r\n\r\n        if (this.windows)\r\n        {\r\n            bodyClass += \" windows\";\r\n\r\n            if (this.ie)\r\n            {\r\n                bodyClass += \" ie\";\r\n\r\n                if (!this.demo)\r\n                {\r\n                    this.mobro = this.isMobro();\r\n                }\r\n            }\r\n            else if (this.browser === 'Firefox')\r\n            {\r\n                bodyClass += \" firefox\";\r\n            }\r\n        }\r\n\r\n        if (this.phone)\r\n        {\r\n            bodyClass += \" phone\";\r\n            // if(!this.ios7 || this.app || this.browser != 'Safari')\r\n            // {\r\n                bodyClass += ' nonbodyscroll';\r\n                this.bodyscroll = false;\r\n            // }\r\n            // else\r\n            // {\r\n            //     bodyClass += ' bodyscroll';\r\n            //     this.bodyscroll = true;\r\n            // }\r\n        }\r\n\r\n        if(this.ipad)\r\n        {\r\n            bodyClass += ' ipad';\r\n        }\r\n\r\n        this.mobileie = this.ie && this.mobile;\r\n\r\n        if (this.mobile && !this.app)\r\n        {\r\n            this.calcKeyboardSize();\r\n        }\r\n\r\n        this.cmdChar = this.windows ? 'ctrl' : '';\r\n\r\n        this.noErrorStacks = platform.OSName === 'iPad' || platform.OSName === 'iPhone' || platform.OSName === 'iPod';\r\n\r\n        this.packagedApp = (window.location.protocol === 'chrome-extension:');\r\n        this.standalone = !!window.navigator.standalone || this.packagedApp || (window.navigator.userAgent.indexOf('FluidApp') >= 0);\r\n\r\n        if (this.standalone || this.app || this.mobro)\r\n        {\r\n            this.requireCustomRedirect = true;\r\n        }\r\n\r\n        if (bodyClass && bodyClass.length > 0)\r\n        {\r\n            this.b.className += bodyClass;\r\n        }\r\n\r\n        this.transition = this.addPrefix('transition');\r\n        this.animation = this.addPrefix('animation');\r\n        this.transform = this.addPrefix('transform');\r\n        this.transformOrigin = this.addPrefix('transformOrigin'); // This will not have a valid 'prop' value\r\n        //this.transitionEnd = this.addPrefix('transitionEnd');\r\n\r\n        window.requestAnimationFrame = window.requestAnimationFrame ||\r\n                                   window.webkitRequestAnimationFrame ||\r\n                                   window.mozRequestAnimationFrame ||\r\n                                   window.msRequestAnimationFrame ||\r\n                                   window.oRequestAnimationFrame ||\r\n                                   function(callback){ window.setTimeout(callback, 1000/60); };\r\n\r\n        if (this.ie)\r\n        {\r\n            document.documentElement.addEventListener(\"MSHoldVisual\", function(e) { e.preventDefault(); }, false);\r\n            document.documentElement.addEventListener(\"contextmenu\", function(e) { e.preventDefault(); }, false);\r\n        }\r\n\r\n        document.documentElement.addEventListener('keydown', this.normalizeKeys, true);\r\n        document.documentElement.addEventListener('keypress', this.normalizeKeys, true);\r\n        document.documentElement.addEventListener('keyup', this.normalizeKeys, true);\r\n    },\r\n    isMobro: function()\r\n    {\r\n        var supported = null;\r\n\r\n        try\r\n        {\r\n            new ActiveXObject(\"\");\r\n        }\r\n        catch (e)\r\n        {\r\n            // FF has ReferenceError here\r\n            errorName = e.name;\r\n        }\r\n\r\n        try\r\n        {\r\n            supported = !!new ActiveXObject(\"htmlfile\");\r\n        }\r\n        catch (e)\r\n        {\r\n            supported = false;\r\n        }\r\n\r\n        if (errorName != 'ReferenceError' && supported==false)\r\n        {\r\n            supported = false;\r\n        }\r\n        else\r\n        {\r\n            supported =true;\r\n        }\r\n\r\n        return !supported;\r\n    },\r\n    calcKeyboardSize: function()\r\n    {\r\n        if(this.ios)\r\n        {\r\n            if(this.iphone || this.ipod)\r\n            {\r\n                this.kbsizePortrait = 216;\r\n                this.kbsizeLandscape = 162;\r\n\r\n                if(this.ios71)\r\n                {\r\n                    this.kbsizePortrait += 44;\r\n                    this.kbsizeLandscape += 44;\r\n                }\r\n            }\r\n            else if(this.ipad)\r\n            {\r\n                this.kbsizePortrait = 264;\r\n                this.kbsizeLandscape = 352;\r\n\r\n                this.kbsizePortrait += 44;\r\n                this.kbsizeLandscape += 44;\r\n            }\r\n        }\r\n        else if (this.android || this.winphone)\r\n        {\r\n            this.kbsizePortrait = 0;\r\n            this.kbsizeLandscape = 0;\r\n        }\r\n        else if (this.mobileie)\r\n        {\r\n            this.kbsizePortrait = 369;\r\n            this.kbsizeLandscape = 492;\r\n        }\r\n\r\n    },\r\n    normalizeKeys: function(ev)\r\n    {\r\n        if (ev.normCode === undefined)\r\n        {\r\n            if (ev.keyCode === null || ev.keyCode === 0)\r\n            {\r\n                ev.normCode = ev.charCode != null ? ev.charCode : ev.which;\r\n            }\r\n            else\r\n            {\r\n                ev.normCode = ev.keyCode;\r\n            }\r\n        }\r\n    },\r\n    initAppState: function()\r\n    {\r\n        var appState = location.hash.substring(1);\r\n        if (appState)\r\n        {\r\n            var regex = /([^&=]+)=([^&]*)/g,\r\n                        m;\r\n            while (m = regex.exec(appState))\r\n            {\r\n                if (decodeURIComponent(m[1]) === 'state')\r\n                {\r\n                    var uri = decodeURIComponent(m[2]);\r\n                    if (uri)\r\n                    {\r\n                        try\r\n                        {\r\n                            appState = JSON.parse(uri);\r\n                        }\r\n                        catch (err)\r\n                        {\r\n                            log('Error parsing AppState: ', uri);\r\n\r\n                            debugger;\r\n\r\n                            appState = undefined;\r\n                        }\r\n\r\n                        if (appState)\r\n                        {\r\n                            this.app = (appState.app === true);\r\n                            this.appv = appState.appv;\r\n                            this.debugApp = appState.debug;\r\n                            this.live = appState.live;\r\n                            this.offline = appState.offline;\r\n                            this.syncContacts = appState.syncContacts;\r\n                            this.test = appState.test;\r\n                            this.appState = appState;\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.live = this.live || util.hasURLParam('live', 'true');\r\n        this.test = DEBUG && (this.test || util.hasURLParam('test'));\r\n        this.offline = this.offline || this.test || util.hasURLParam('offline', 'true') || (DEBUG && DEBUG);\r\n        this.demo = util.hasURLParam('demo', 'true') || (DEBUG && DEBUG);\r\n        this.script = util.hasURLParam('script');\r\n    },\r\n    addPrefix: function(p)\r\n    {\r\n        var prefix = '';\r\n        var v = [ 'ms', 'webkit', 'moz', 'o' ];\r\n        var s = this.b.style;\r\n        if (typeof s[p] == 'string')\r\n        {\r\n            prefix = '';\r\n        }\r\n        else\r\n        {\r\n            for ( var i = 0; i < v.length; i++) {\r\n                if (typeof s['-' + v[i] + '-' + p] == 'string') {\r\n                    prefix = v[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        var styleString = (prefix.length > 0) ? p.charAt(0).toUpperCase() + p.slice(1) : p;\r\n\r\n        if (prefix)\r\n        {\r\n            return { prop: '-' + prefix + '-' + p, style: prefix + styleString };\r\n        }\r\n        else\r\n        {\r\n            return { prop: p, style: styleString };\r\n        }\r\n    },\r\n    blockClient: function ()\r\n    {\r\n        // switch (this.OSName)\r\n        // {\r\n        //     //case 'iPad':\r\n        //     // case 'iPhone':\r\n        //         //platformName = 'the ' + this.OSName;\r\n        //         //break;\r\n        //     // case 'Android':\r\n        //     //     if (!DEBUG)\r\n        //     //     {\r\n        //     //         platformName = this.OSName;\r\n        //     //     }\r\n        //     //     break;\r\n        // }\r\n\r\n        // Features:\r\n        //  calc\r\n        //    Firefox: 16\r\n        //    Chrome: 26\r\n        //    IE: 9\r\n        //    Safari: 6.1\r\n        //    iOS: 6.0\r\n        //    Android: 4.4\r\n        //  webworkers (optional)\r\n        //    Firefox: 4\r\n        //    Chrome: 4\r\n        //    IE: 10\r\n        //    Safari: 4.0\r\n        //    iOS: 5.0\r\n        //    Android: 4.4\r\n        //  AppCache\r\n        //    Firefox: 4\r\n        //    Chrome: 4\r\n        //    IE: 10\r\n        //    Safari: 4.0\r\n        //    iOS: 3.2\r\n        //    Android: 2.1\r\n        //  localStorage\r\n        //    Firefox: 4\r\n        //    Chrome: 4\r\n        //    IE: 8\r\n        //    Safari: 4.0\r\n        //    iOS: 3.2\r\n        //    Android: 2.1\r\n        //  indexedDB\r\n        //    Firefox: 16\r\n        //    Chrome: 24\r\n        //    IE: 10\r\n        //    Safari: 8.0\r\n        //    iOS: 8.0\r\n        //    Android: 4.4\r\n        //  webSQL\r\n        //    Firefox: N/A\r\n        //    Chrome: 4\r\n        //    IE: N/A\r\n        //    Safari: 3.1\r\n        //    iOS: 3.2\r\n        //    Android: 2.1\r\n        //  transform\r\n        //    Firefox: 4\r\n        //    Chrome: 4\r\n        //    IE: 9\r\n        //    Safari: 3.1\r\n        //    iOS: 3.2\r\n        //    Android: 2.1\r\n\r\n        switch (this.browser)\r\n        {\r\n            case 'Firefox':\r\n                if (this.majorVersion < 16)\r\n                {\r\n                    return { platform: 'Firefox', browser: this.browser, update: true };\r\n                }\r\n                break;\r\n            case 'Chrome':\r\n                if (this.majorVersion < 26)\r\n                {\r\n                    return { platform: 'Chrome', browser: this.browser, update: true };\r\n                }\r\n                break;\r\n            case 'Native Android':\r\n                if (this.majorVersion === 2 && this.minorVersion < 1 || this.majorVersion < 2)\r\n                {\r\n                    return { platform: 'Native Android', browser: 'NativeAndroid', update: true };\r\n                }\r\n                break;\r\n            case 'Opera':\r\n                return { platform: this.browser, browser: this.browser, update: false };\r\n            case 'Trident':\r\n                // Disable IE below 10 and mobile IE unless demo\r\n                if (!DEBUG && !this.isDevURL)\r\n                {\r\n                    if (this.majorVersion < 10 || (this.phone && !this.demo))\r\n                    {\r\n                        return { platform: 'Internet Explorer', browser: this.browser, update: (this.majorVersion < 10) };\r\n                    }\r\n                }\r\n\r\n                break;\r\n            case 'Safari':\r\n                if (this.mobile && this.majorVersion < 6)\r\n                {\r\n                    return { platform: 'Safari', browser: this.browser, update: true };\r\n                }\r\n                else if(!this.mobile && ((this.majorVersion == 6 && this.minorVersion < 1) || this.majorVersion < 6))\r\n                {\r\n                    return { platform: 'Safari', browser: this.browser, update: true };\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (this.app)\r\n        {\r\n            if (this.appv < this.versionRequired)\r\n            {\r\n                // JS  expects a version great than app is sending\r\n                log('App Version out of date.');\r\n\r\n                return { version: this.versionRequired };\r\n            }\r\n            else if (this.appv > this.versionRequired)\r\n            {\r\n                // App is sending a greater version than JS expects\r\n                log('App is newer than the javascript, forcing an app cache update');\r\n\r\n                return { cacheUpdate: true, error: false };\r\n            }\r\n        }\r\n\r\n        if (!DEBUG && '1403041791456' !== document.body.getAttribute('ver'))\r\n        {\r\n            // If the page has a version mismatch, do not infinitely loop page refresh.\r\n            var cErr = util.hasURLParam('cacheError');\r\n            require(['globals'], function (g)\r\n            {\r\n                g.reportError(new Error('VersionMismatch, CacheError: ' + cErr));\r\n            });\r\n            if (!cErr)\r\n            {\r\n                this.sendToApp('resetCache');\r\n                return { cacheUpdate: true, error: true };\r\n            }\r\n        }\r\n    },\r\n    actionVerb: function ()\r\n    {\r\n        return this.touch ? 'tap' : 'click';\r\n    },\r\n    actionVerbCaps: function ()\r\n    {\r\n        return this.touch ? 'Tap' : 'Click';\r\n    },\r\n    updateOrientation: function ()\r\n    {\r\n        var orientation = (Math.abs(window.orientation) == 90) ? Orientation.Landscape: Orientation.Portrait;\r\n        if(this.orientation == Orientation.Portrait)\r\n        {\r\n            this.hasBeenPortrait = true;\r\n        }\r\n\r\n        this.orientation = orientation;\r\n\r\n        if(!this.app)\r\n        {\r\n            this.kbsize = this.orientation == Orientation.Portrait ? this.kbsizePortrait : this.kbsizeLandscape;\r\n        }\r\n\r\n        return this.orientation;\r\n    },\r\n    sendToApp: function(method, data)\r\n    {\r\n        // alert('Send To App: ' + data);\r\n\r\n        if (this.app)\r\n        {\r\n            if (this.ios)\r\n            {\r\n                if(!this.iframeApp)\r\n                {\r\n                    this.iframeApp = document.createElement(\"IFRAME\");\r\n                    this.iframeApp.setAttribute(\"height\", \"1px\");\r\n                    this.iframeApp.setAttribute(\"width\", \"1px\");\r\n                    document.documentElement.appendChild(this.iframeApp);\r\n                }\r\n\r\n                var href = 'duchess://' + method;\r\n                if(data !== undefined)\r\n                {\r\n                    href += '//' + data;\r\n                }\r\n\r\n                this.iframeApp.setAttribute(\"src\", href);\r\n            }\r\n            else if (this.android && AppInterface !== undefined)\r\n            {\r\n                AppInterface.addNotification(data);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nreturn new platform();\r\n});","asserts":[]},"util":{"path":"F:/p/bce/Duchess/public/js/util.js","data":"define([],\r\nfunction() {\r\n\r\nvar self = { };\r\n\r\nwindow.URLPart =\r\n{\r\n    Search: 1,\r\n    Hash:   2\r\n};\r\n\r\nvar URLParamMap =\r\n{\r\n    'demo':          URLPart.Hash,   // Demo\r\n    'login':         URLPart.Hash,   // LandingPage\r\n    'access_token':  URLPart.Hash,   // OAuth\r\n    'error':         URLPart.Hash,   // OAuth\r\n    'expires_in':    URLPart.Hash,   // OAuth\r\n    'scope':         URLPart.Hash,   // OAuth\r\n    'token_type':    URLPart.Hash,   // OAuth\r\n    'data':          URLPart.Hash,   // Demo\r\n    'script':        URLPart.Hash,   // Demo\r\n    'dmode':         URLPart.Hash,   // Demo\r\n    'jasmine':       URLPart.Hash,   // Debug\r\n    'touch':         URLPart.Hash,   // Debug\r\n    'file':          URLPart.Hash,   // GDrive\r\n    'panes':         URLPart.Hash,   // Demo\r\n    'offline':       URLPart.Hash,   // Debug\r\n    'live':          URLPart.Hash,   // Debug\r\n    'test':          URLPart.Hash,   // Debug\r\n    'nolocal':       URLPart.Hash,   // Debug\r\n    'nosync':        URLPart.Hash,   // Debug\r\n    'rdebug':        URLPart.Hash,   // DebugAssist\r\n    'rsession':      URLPart.Hash,   // DebugAssist\r\n    'cacheError':    URLPart.Hash,   // PageUpdate\r\n    'state':         URLPart.Search, // GDrive\r\n};\r\n\r\nfunction setURLPart(part, str)\r\n{\r\n    if (part === URLPart.Search)\r\n    {\r\n        window.location.search = str;\r\n    }\r\n    else if (part === URLPart.Hash)\r\n    {\r\n        window.location.hash = str;\r\n    }\r\n}\r\n\r\nfunction getStringForPart(part)\r\n{\r\n    if (part === URLPart.Search)\r\n    {\r\n        return window.location.search;\r\n    }\r\n    else if (part === URLPart.Hash)\r\n    {\r\n        return window.location.hash;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction getURLPartForParam(param)\r\n{\r\n    return URLParamMap[param];\r\n}\r\n\r\nself.hasURLParam = function(key, value)\r\n{\r\n    var str = key + '=';\r\n    if (value)\r\n    {\r\n        str += value;\r\n    }\r\n\r\n    var part = getURLPartForParam(key);\r\n    if (!part) { log('Invalid URL Part'); debugger; }\r\n\r\n    var rawString = getStringForPart(part);\r\n\r\n    return (rawString.indexOf(str) >= 0);\r\n}\r\n\r\nself.getURLParam = function(key, forcePart)\r\n{\r\n    var part = forcePart ? forcePart : getURLPartForParam(key);\r\n\r\n    if (part === URLPart.Search)\r\n    {\r\n        key = key.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\");\r\n        var regexS = \"[\\\\?&]\" + key + \"=([^&#]*)\";\r\n        var regex = new RegExp(regexS);\r\n        var results = regex.exec(window.location.href);\r\n\r\n        if (results === null)\r\n        {\r\n            return undefined;\r\n        }\r\n        else\r\n        {\r\n            return decodeURIComponent(results[1].replace(/\\+/g, \" \"));\r\n        }\r\n    }\r\n    else if (part === URLPart.Hash)\r\n    {\r\n        var queryString = window.location.hash.substring(1);\r\n        var regex = /([^&=]+)=([^&]*)/g;\r\n        var m;\r\n\r\n        while (m = regex.exec(queryString))\r\n        {\r\n            if (decodeURIComponent(m[1]) === key)\r\n            {\r\n                return decodeURIComponent(m[2]);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n    else\r\n    {\r\n        log('Invalid URL part');\r\n        debugger;\r\n    }\r\n};\r\n\r\nself.insertURLParam = function(key, value, noReload)\r\n{\r\n    key = encodeURIComponent(key);\r\n    value = encodeURIComponent(value);\r\n\r\n    var part = getURLPartForParam(key);\r\n    var rawString = getStringForPart(part);\r\n\r\n    var params = rawString.substr(1).split('&');\r\n\r\n    for (var i = params.length - 1; i >= 0; i --)\r\n    {\r\n        var param = params[i].split('=');\r\n\r\n        if (param[0] == key)\r\n        {\r\n            param[1] = value;\r\n\r\n            params[i] = param.join('=');\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (i < 0)\r\n    {\r\n        params[params.length] = [key,value].join('=');\r\n    }\r\n\r\n    setURLPart(part, params.join('&'));\r\n\r\n    if (part === URLPart.Hash && !noReload)\r\n    {\r\n        window.location.reload();\r\n    }\r\n};\r\n\r\nself.removeURLParam = function(key, noReload)\r\n{\r\n    key = encodeURIComponent(key);\r\n\r\n    var part = getURLPartForParam(key);\r\n    var rawString = getStringForPart(part);\r\n\r\n    var params = rawString.substr(1).split('&');\r\n\r\n    for(var i = params.length - 1; i >= 0; i --)\r\n    {\r\n        var param = params[i].split('=');\r\n\r\n        if (param[0] == key)\r\n        {\r\n            params.splice(i, 1);\r\n            break;\r\n        }\r\n    }\r\n\r\n    setURLPart(part, params.join('&'));\r\n\r\n    if (part === URLPart.Hash && !noReload)\r\n    {\r\n        window.location.reload();\r\n    }\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    window.getURLParam = self.getURLParam;\r\n    window.insertURLParam = self.insertURLParam;\r\n    window.removeURLParam = self.removeURLParam;\r\n}\r\n\r\n\r\n//\r\n// Storage\r\n//\r\n\r\nvar pck = (window.location.protocol === 'chrome-extension:');\r\n\r\nself.__storage = !pck ? window.localStorage : chrome.storage.local;\r\n\r\nfunction dummyStorageGetFn() { };\r\n\r\nself.storage =\r\n{\r\n    getItem: (self.__storage.getItem || function (key, cb)\r\n    {\r\n        return this.get(key, cb || dummyStorageGetFn);\r\n    }).bind(self.__storage),\r\n\r\n    setItem: (self.__storage.setItem || function (key, value)\r\n    {\r\n        var obj = { }; obj[key] = value;\r\n\r\n        self.__storage.set(obj);\r\n    }).bind(self.__storage),\r\n\r\n    removeItem: (self.__storage.removeItem || function (key, cb)\r\n    {\r\n        this.remove(key, cb);\r\n    }).bind(self.__storage),\r\n};\r\n\r\n\r\nreturn self;\r\n\r\n});\r\n","asserts":[]},"date":{"path":"F:/p/bce/Duchess/public/js/lib/date.js","data":"/**\n * @version: 1.0 Alpha-1\n * @author: Coolite Inc. http://www.coolite.com/\n * @date: 2008-05-13\n * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.\n * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. \n * @website: http://www.datejs.com/\n */\nfunction dateWrapper()\n{\n\nthis.dateLibLoaded = true;\n\nDate.CultureInfo = {\n    name: \"en-US\",\n    englishName: \"English (United States)\",\n    nativeName: \"English (United States)\",\n    dayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    abbreviatedDayNames: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    shortestDayNames: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n    firstLetterDayNames: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n    monthNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    abbreviatedMonthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    amDesignator: \"am\",\n    pmDesignator: \"pm\",\n    firstDayOfWeek: 0,\n    twoDigitYearMax: 2029,\n    dateElementOrder: \"mdy\",\n    formatPatterns: {\n        shortDate: \"M/d/yyyy\",\n        longDate: \"dddd, MMMM dd, yyyy\",\n        shortTime: \"h:mm tt\",\n        longTime: \"h:mm:ss tt\",\n        fullDateTime: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n        sortableDateTime: \"yyyy-MM-ddTHH:mm:ss\",\n        universalSortableDateTime: \"yyyy-MM-dd HH:mm:ssZ\",\n        rfc1123: \"ddd, dd MMM yyyy HH:mm:ss GMT\",\n        monthDay: \"MMMM dd\",\n        yearMonth: \"MMMM, yyyy\"\n    },\n    regexPatterns: {\n        jan: /^jan(uary)?/i,\n        feb: /^feb(ruary)?/i,\n        mar: /^mar(ch)?/i,\n        apr: /^apr(il)?/i,\n        may: /^may/i,\n        jun: /^jun(e)?/i,\n        jul: /^jul(y)?/i,\n        aug: /^aug(ust)?/i,\n        sep: /^sep(t(ember)?)?/i,\n        oct: /^oct(ober)?/i,\n        nov: /^nov(ember)?/i,\n        dec: /^dec(ember)?/i,\n        sun: /^sun(day)?/i,\n        mon: /^mon(day)?/i,\n        tue: /^tue(s(day)?)?/i,\n        wed: /^wed(nesday)?/i,\n        thu: /^thu(rsday)?/i,\n        fri: /^fri(day)?/i,\n        sat: /^sat(urday)?/i,\n        future: /^next/i,\n        past: /^last|past|prev(ious)?/i,\n        yesterday: /^yesterday/i,\n        today: /^today/i,\n        tomorrow: /^tom(orrow)?/i,\n        soon: /^soon/i,\n        later: /^later/i,\n        now: /^now/i,\n        shortMeridian: /^(a|p)/i,\n        longMeridian: /^(a\\.?m?\\.?|p\\.?m?\\.?)/i,\n        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\\s*(\\+|\\-)\\s*\\d\\d\\d\\d?)|gmt|utc)/i,\n        ordinalSuffix: /^\\s*(st|nd|rd|th)/i,\n        timeContext: /^\\s*(\\:|a(?!u|p)|p)/i\n    },\n    timezones: [{\n        name: \"UTC\",\n        offset: \"-000\"\n    }, {\n        name: \"GMT\",\n        offset: \"-000\"\n    }, {\n        name: \"EST\",\n        offset: \"-0500\"\n    }, {\n        name: \"EDT\",\n        offset: \"-0400\"\n    }, {\n        name: \"CST\",\n        offset: \"-0600\"\n    }, {\n        name: \"CDT\",\n        offset: \"-0500\"\n    }, {\n        name: \"MST\",\n        offset: \"-0700\"\n    }, {\n        name: \"MDT\",\n        offset: \"-0600\"\n    }, {\n        name: \"PST\",\n        offset: \"-0800\"\n    }, {\n        name: \"PDT\",\n        offset: \"-0700\"\n    }]\n    }; (function() {\n    var $D = Date,\n    $P = $D.prototype,\n    $C = $D.CultureInfo,\n    p = function(s, l) {\n        if (!l) {\n            l = 2;\n        }\n        return (\"000\" + s).slice(l * -1);\n    };\n    $P.clearTime = function() {\n        this.setHours(0);\n        this.setMinutes(0);\n        this.setSeconds(0);\n        this.setMilliseconds(0);\n        return this;\n    };\n    $P.setTimeToNow = function() {\n        var n = new Date();\n        this.setHours(n.getHours());\n        this.setMinutes(n.getMinutes());\n        this.setSeconds(n.getSeconds());\n        this.setMilliseconds(n.getMilliseconds());\n        return this;\n    };\n    $D.today = function() {\n        return new Date().clearTime();\n    };\n    $D.compare = function(date1, date2) {\n        if (isNaN(date1) || isNaN(date2)) {\n            throw new Error(date1 + \" - \" + date2);\n        } else if (date1 instanceof Date && date2 instanceof Date) {\n            return (date1 < date2) ? -1: (date1 > date2) ? 1: 0;\n        } else {\n            throw new TypeError(date1 + \" - \" + date2);\n        }\n    };\n    $D.equals = function(date1, date2) {\n        return (date1.compareTo(date2) === 0);\n    };\n    $D.getDayNumberFromName = function(name) {\n        var n = $C.dayNames,\n        m = $C.abbreviatedDayNames,\n        o = $C.shortestDayNames,\n        s = name.toLowerCase();\n        for (var i = 0; i < n.length; i++) {\n            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s) {\n                return i;\n            }\n        }\n        return - 1;\n    };\n    $D.getMonthNumberFromName = function(name) {\n        var n = $C.monthNames,\n        m = $C.abbreviatedMonthNames,\n        s = name.toLowerCase();\n        for (var i = 0; i < n.length; i++) {\n            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {\n                return i;\n            }\n        }\n        return - 1;\n    };\n    $D.isLeapYear = function(year) {\n        return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    };\n    $D.getDaysInMonth = function(year, month) {\n        return [31, ($D.isLeapYear(year) ? 29: 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n    };\n    $D.getTimezoneAbbreviation = function(offset) {\n        var z = $C.timezones,\n        p;\n        for (var i = 0; i < z.length; i++) {\n            if (z[i].offset === offset) {\n                return z[i].name;\n            }\n        }\n        return null;\n    };\n    $D.getTimezoneOffset = function(name) {\n        var z = $C.timezones,\n        p;\n        for (var i = 0; i < z.length; i++) {\n            if (z[i].name === name.toUpperCase()) {\n                return z[i].offset;\n            }\n        }\n        return null;\n    };\n    $P.clone = function() {\n        var tempDate = new Date(this.getTime());\n        tempDate._explicitTime = this._explicitTime;\n\n        return tempDate;\n    };\n    $P.compareTo = function(date) {\n        return Date.compare(this, date);\n    };\n    $P.equals = function(date) {\n        return Date.equals(this, date || new Date());\n    };\n    $P.between = function(start, end) {\n        return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();\n    };\n    $P.isAfter = function(date) {\n        return this.compareTo(date || new Date()) === 1;\n    };\n    $P.isBefore = function(date) {\n        return (this.compareTo(date || new Date()) === -1);\n    };\n    $P.isToday = function() {\n        return this.isSameDay(new Date());\n    };\n    $P.isSameDay = function(date) {\n        return this.clone().clearTime().equals(date.clone().clearTime());\n    };\n    $P.addMilliseconds = function(value) {\n        this.setMilliseconds(this.getMilliseconds() + value);\n        return this;\n    };\n    $P.addSeconds = function(value) {\n        return this.addMilliseconds(value * 1000);\n    };\n    $P.addMinutes = function(value) {\n        return this.addMilliseconds(value * 60000);\n    };\n    $P.addHours = function(value) {\n        return this.addMilliseconds(value * 3600000);\n    };\n    $P.addDays = function(value) {\n        this.setDate(this.getDate() + value);\n        return this;\n    };\n    $P.addWeeks = function(value) {\n        return this.addDays(value * 7);\n    };\n    $P.addMonths = function(value) {\n        var n = this.getDate();\n        this.setDate(1);\n        this.setMonth(this.getMonth() + value);\n        this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth())));\n        return this;\n    };\n    $P.addYears = function(value) {\n        return this.addMonths(value * 12);\n    };\n    $P.add = function(config) {\n        if (typeof config == \"number\") {\n            this._orient = config;\n            return this;\n        }\n        var x = config;\n        if (x.millisecond) {\n            this.addMilliseconds(x.millisecond);\n        }\n        if (x.second) {\n            this.addSeconds(x.second);\n        }\n        if (x.minute) {\n            this.addMinutes(x.minute);\n        }\n        if (x.hour) {\n            this.addHours(x.hour);\n        }\n        if (x.week) {\n            this.addWeeks(x.week);\n        }\n        if (x.month) {\n            this.addMonths(x.month);\n        }\n        if (x.years) {\n            this.addYears(x.years);\n        }\n        if (x.days) {\n            this.addDays(x.days);\n        }\n        if (x.setExplicitTime) {\n            this._explicitTime = true;\n        }\n\n        return this;\n    };\n    var $y,\n    $m,\n    $d;\n    $P.getWeek = function() {\n        var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        n,\n        s,\n        w;\n        $y = (!$y) ? this.getFullYear() : $y;\n        $m = (!$m) ? this.getMonth() + 1: $m;\n        $d = (!$d) ? this.getDate() : $d;\n        if ($m <= 2) {\n            a = $y - 1;\n            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);\n            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);\n            s = b - c;\n            e = 0;\n            f = $d - 1 + (31 * ($m - 1));\n        } else {\n            a = $y;\n            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);\n            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);\n            s = b - c;\n            e = s + 1;\n            f = $d + ((153 * ($m - 3) + 2) / 5) + 58 + s;\n        }\n        g = (a + b) % 7;\n        d = (f + g - e) % 7;\n        n = (f + 3 - d) | 0;\n        if (n < 0) {\n            w = 53 - ((g - s) / 5 | 0);\n        } else if (n > 364 + s) {\n            w = 1;\n        } else {\n            w = (n / 7 | 0) + 1;\n        }\n        $y = $m = $d = null;\n        return w;\n    };\n    $P.getISOWeek = function() {\n        $y = this.getUTCFullYear();\n        $m = this.getUTCMonth() + 1;\n        $d = this.getUTCDate();\n        return p(this.getWeek());\n    };\n    $P.setWeek = function(n) {\n        return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek());\n    };\n    $D._validate = function(n, min, max, name) {\n        if (typeof n == \"undefined\") {\n            return false;\n        } else if (typeof n != \"number\") {\n            throw new TypeError(n + \" is not a Number.\");\n        } else if (n < min || n > max) {\n            throw new RangeError(n + \" is not a valid value for \" + name + \".\");\n        }\n        return true;\n    };\n    $D.validateMillisecond = function(value) {\n        return $D._validate(value, 0, 999, \"millisecond\");\n    };\n    $D.validateSecond = function(value) {\n        return $D._validate(value, 0, 59, \"second\");\n    };\n    $D.validateMinute = function(value) {\n        return $D._validate(value, 0, 59, \"minute\");\n    };\n    $D.validateHour = function(value) {\n        return $D._validate(value, 0, 23, \"hour\");\n    };\n    $D.validateDay = function(value, year, month) {\n        return $D._validate(value, 1, $D.getDaysInMonth(year, month), \"day\");\n    };\n    $D.validateMonth = function(value) {\n        return $D._validate(value, 0, 11, \"month\");\n    };\n    $D.validateYear = function(value) {\n        return $D._validate(value, 0, 9999, \"year\");\n    };\n    $P.set = function(config) {\n        if ($D.validateMillisecond(config.millisecond)) {\n            this.addMilliseconds(config.millisecond - this.getMilliseconds());\n        }\n        if ($D.validateSecond(config.second)) {\n            this.addSeconds(config.second - this.getSeconds());\n        }\n        if ($D.validateMinute(config.minute)) {\n            this.addMinutes(config.minute - this.getMinutes());\n        }\n        if ($D.validateHour(config.hour)) {\n            this.addHours(config.hour - this.getHours());\n        }\n        if ($D.validateMonth(config.month)) {\n            this.addMonths(config.month - this.getMonth());\n        }\n        if ($D.validateYear(config.year)) {\n            this.addYears(config.year - this.getFullYear());\n        }\n        if ($D.validateDay(config.day, this.getFullYear(), this.getMonth())) {\n            this.addDays(config.day - this.getDate());\n        }\n        if (config.timezone) {\n            this.setTimezone(config.timezone);\n        }\n        if (config.timezoneOffset) {\n            this.setTimezoneOffset(config.timezoneOffset);\n        }\n        if (config.week && $D._validate(config.week, 0, 53, \"week\")) {\n            this.setWeek(config.week);\n        }\n        if (config.setExplicitTime) {\n            this._explicitTime = true;\n        }\n        return this;\n    };\n    $P.moveToFirstDayOfMonth = function() {\n        return this.set({\n            day: 1\n        });\n    };\n    $P.moveToLastDayOfMonth = function() {\n        return this.set({\n            day: $D.getDaysInMonth(this.getFullYear(), this.getMonth())\n            });\n    };\n    $P.moveToNthOccurrence = function(dayOfWeek, occurrence) {\n        var shift = 0;\n        if (occurrence > 0) {\n            shift = occurrence - 1;\n        } else if (occurrence === -1) {\n            this.moveToLastDayOfMonth();\n            if (this.getDay() !== dayOfWeek) {\n                this.moveToDayOfWeek(dayOfWeek, -1);\n            }\n            return this;\n        }\n        return this.moveToFirstDayOfMonth().addDays( - 1).moveToDayOfWeek(dayOfWeek, +1).addWeeks(shift);\n    };\n    $P.moveToDayOfWeek = function(dayOfWeek, orient) {\n        var diff = (dayOfWeek - this.getDay() + 7 * (orient || +1)) % 7;\n        return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff);\n    };\n    $P.moveToMonth = function(month, orient) {\n        var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;\n        return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff);\n    };\n    $P.getOrdinalNumber = function() {\n        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;\n    };\n    $P.getTimezone = function() {\n        return $D.getTimezoneAbbreviation(this.getUTCOffset());\n    };\n    $P.setTimezoneOffset = function(offset) {\n        var here = this.getTimezoneOffset(),\n        there = Number(offset) * -6 / 10;\n        return this.addMinutes(there - here);\n    };\n    $P.setTimezone = function(offset) {\n        return this.setTimezoneOffset($D.getTimezoneOffset(offset));\n    };\n    $P.hasDaylightSavingTime = function() {\n        return (Date.today().set({\n            month: 0,\n            day: 1\n        }).getTimezoneOffset() !== Date.today().set({\n            month: 6,\n            day: 1\n        }).getTimezoneOffset());\n    };\n    $P.isDaylightSavingTime = function() {\n        return (this.hasDaylightSavingTime() && new Date().getTimezoneOffset() === Date.today().set({\n            month: 6,\n            day: 1\n        }).getTimezoneOffset());\n    };\n    $P.getUTCOffset = function() {\n        var n = this.getTimezoneOffset() * -10 / 6,\n        r;\n        if (n < 0) {\n            r = (n - 10000).toString();\n            return r.charAt(0) + r.substr(2);\n        } else {\n            r = (n + 10000).toString();\n            return \"+\" + r.substr(1);\n        }\n    };\n    $P.getElapsed = function(date) {\n        return (date || new Date()) - this;\n    };\n    if (!$P.toISOString) {\n        $P.toISOString = function() {\n            function f(n) {\n                return n < 10 ? '0' + n: n;\n            }\n            return '\"' + this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z\"';\n        };\n    }\n    $P._toString = $P.toString;\n    $P.toString = function(format) {\n        var x = this;\n        if (format && format.length == 1) {\n            var c = $C.formatPatterns;\n            x.t = x.toString;\n            switch (format) {\n            case \"d\":\n                return x.t(c.shortDate);\n            case \"D\":\n                return x.t(c.longDate);\n            case \"F\":\n                return x.t(c.fullDateTime);\n            case \"m\":\n                return x.t(c.monthDay);\n            case \"r\":\n                return x.t(c.rfc1123);\n            case \"s\":\n                return x.t(c.sortableDateTime);\n            case \"t\":\n                return x.t(c.shortTime);\n            case \"T\":\n                return x.t(c.longTime);\n            case \"u\":\n                return x.t(c.universalSortableDateTime);\n            case \"y\":\n                return x.t(c.yearMonth);\n            }\n        }\n        var ord = function(n) {\n            switch (n * 1) {\n            case 1:\n            case 21:\n            case 31:\n                return \"st\";\n            case 2:\n            case 22:\n                return \"nd\";\n            case 3:\n            case 23:\n                return \"rd\";\n            default:\n                return \"th\";\n            }\n        };\n        return format ? format.replace(/(\\\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g, function(m) {\n            if (m.charAt(0) === \"\\\\\") {\n                return m.replace(\"\\\\\", \"\");\n            }\n            x.h = x.getHours;\n            switch (m) {\n            case \"hh\":\n                return p(x.h() < 13 ? (x.h() === 0 ? 12: x.h()) : (x.h() - 12));\n            case \"h\":\n                return x.h() < 13 ? (x.h() === 0 ? 12: x.h()) : (x.h() - 12);\n            case \"HH\":\n                return p(x.h());\n            case \"H\":\n                return x.h();\n            case \"mm\":\n                return p(x.getMinutes());\n            case \"m\":\n                return x.getMinutes();\n            case \"ss\":\n                return p(x.getSeconds());\n            case \"s\":\n                return x.getSeconds();\n            case \"yyyy\":\n                return p(x.getFullYear(), 4);\n            case \"yy\":\n                return p(x.getFullYear());\n            case \"dddd\":\n                return $C.dayNames[x.getDay()];\n            case \"ddd\":\n                return $C.abbreviatedDayNames[x.getDay()];\n            case \"dd\":\n                return p(x.getDate());\n            case \"d\":\n                return x.getDate();\n            case \"MMMM\":\n                return $C.monthNames[x.getMonth()];\n            case \"MMM\":\n                return $C.abbreviatedMonthNames[x.getMonth()];\n            case \"MM\":\n                return p((x.getMonth() + 1));\n            case \"M\":\n                return x.getMonth() + 1;\n            case \"t\":\n                return x.h() < 12 ? $C.amDesignator.substring(0, 1) : $C.pmDesignator.substring(0, 1);\n            case \"tt\":\n                return x.h() < 12 ? $C.amDesignator: $C.pmDesignator;\n            case \"S\":\n                return ord(x.getDate());\n            default:\n                return m;\n            }\n        }):\n        this._toString();\n    };\n} ()); (function() {\n    var $D = Date,\n    $P = $D.prototype,\n    $C = $D.CultureInfo,\n    $N = Number.prototype;\n    $P._orient = +1;\n    $P._nth = null;\n    $P._is = false;\n    $P._same = false;\n    $P._explicitTime = false;\n    $P._isSecond = false;\n    $N._dateElement = \"day\";\n    $P.next = function() {\n        this._orient = +1;\n        return this;\n    };\n    $D.next = function() {\n        return $D.today().next();\n    };\n    $P.last = $P.prev = $P.previous = function() {\n        this._orient = -1;\n        return this;\n    };\n    $D.last = $D.prev = $D.previous = function() {\n        return $D.today().last();\n    };\n    $P.is = function() {\n        this._is = true;\n        return this;\n    };\n    $P.same = function() {\n        this._same = true;\n        this._isSecond = false;\n        return this;\n    };\n    $P.today = function() {\n        return this.same().day();\n    };\n    $P.weekday = function() {\n        if (this._is) {\n            this._is = false;\n            return (!this.is().sat() && !this.is().sun());\n        }\n        return false;\n    };\n    $P.at = function(time) {\n        return (typeof time === \"string\") ? $D.parse(this.toString(\"d\") + \" \" + time) : this.set(time);\n    };\n    $N.fromNow = $N.after = function(date) {\n        var c = {};\n        c[this._dateElement] = this;\n        return ((!date) ? new Date() : date.clone()).add(c);\n    };\n    $N.ago = $N.before = function(date) {\n        var c = {};\n        c[this._dateElement] = this * -1;\n        return ((!date) ? new Date() : date.clone()).add(c);\n    };\n\n    var dx = (\"sunday monday tuesday wednesday thursday friday saturday\").split(/\\s/),\n    mx = (\"january february march april may june july august september october november december\").split(/\\s/),\n\n    px = [],\n\n    pxf = [],\n\n    nth = (\"final first second third fourth fifth\").split(/\\s/),\n\n    de;\n\n    $P.toObject = function() {\n        var o = {};\n        for (var i = 0; i < px.length; i++) {\n            o[px[i].toLowerCase()] = this[\"get\" + pxf[i]]();\n        }\n        return o;\n    };\n    $D.fromObject = function(config) {\n        config.week = null;\n        return Date.today().set(config);\n    };\n    var df = function(n) {\n        return function() {\n            if (this._is) {\n                this._is = false;\n                return this.getDay() == n;\n            }\n            if (this._nth !== null) {\n                if (this._isSecond) {\n                    this.addSeconds(this._orient * -1);\n                }\n                this._isSecond = false;\n                var ntemp = this._nth;\n                this._nth = null;\n                var temp = this.clone().moveToLastDayOfMonth();\n                this.moveToNthOccurrence(n, ntemp);\n                if (this > temp) {\n                    throw new RangeError($D.getDayName(n) + \" does not occur \" + ntemp + \" times in the month of \" + $D.getMonthName(temp.getMonth()) + \" \" + temp.getFullYear() + \".\");\n                }\n                return this;\n            }\n            return this.moveToDayOfWeek(n, this._orient);\n        };\n    };\n    var sdf = function(n) {\n        return function() {\n            var t = $D.today(),\n            shift = n - t.getDay();\n            if ((n === 0 && $C.firstDayOfWeek === 1 && t.getDay() !== 0) || shift < 0) {\n                shift = shift + 7;\n            }\n            return t.addDays(shift);\n        };\n    };\n    for (var i = 0; i < dx.length; i++) {\n        $D[dx[i].toUpperCase()] = $D[dx[i].toUpperCase().substring(0, 3)] = i;\n        $D[dx[i]] = $D[dx[i].substring(0, 3)] = sdf(i);\n        $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i);\n    }\n    var mf = function(n) {\n        return function() {\n            if (this._is) {\n                this._is = false;\n                return this.getMonth() === n;\n            }\n            return this.moveToMonth(n, this._orient);\n        };\n    };\n    var smf = function(n) {\n        return function() {\n            return $D.today().set({\n                month: n,\n                day: 1\n            });\n        };\n    };\n    for (var j = 0; j < mx.length; j++) {\n        $D[mx[j].toUpperCase()] = $D[mx[j].toUpperCase().substring(0, 3)] = j;\n        $D[mx[j]] = $D[mx[j].substring(0, 3)] = smf(j);\n        $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j);\n    }\n    var ef = function(j) {\n        return function() {\n            if (this._isSecond) {\n                this._isSecond = false;\n                return this;\n            }\n            if (this._same) {\n                this._same = this._is = false;\n                var o1 = this.toObject(),\n                o2 = (arguments[0] || new Date()).toObject(),\n                v = \"\",\n                k = j.toLowerCase();\n                for (var m = (px.length - 1); m > -1; m--) {\n                    v = px[m].toLowerCase();\n                    if (o1[v] != o2[v]) {\n                        return false;\n                    }\n                    if (k == v) {\n                        break;\n                    }\n                }\n                return true;\n            }\n            if (j.substring(j.length - 1) != \"s\") {\n                j += \"s\";\n            }\n            return this[\"add\" + j](this._orient);\n        };\n    };\n    var nf = function(n) {\n        return function() {\n            this._dateElement = n;\n            return this;\n        };\n    };\n    for (var k = 0; k < px.length; k++) {\n        de = px[k].toLowerCase();\n        $P[de] = $P[de + \"s\"] = ef(px[k]);\n        $N[de] = $N[de + \"s\"] = nf(de);\n    }\n    $P._ss = ef(\"Second\");\n    var nthfn = function(n) {\n        return function(dayOfWeek) {\n            if (this._same) {\n                return this._ss(arguments[0]);\n            }\n            if (dayOfWeek || dayOfWeek === 0) {\n                return this.moveToNthOccurrence(dayOfWeek, n);\n            }\n            this._nth = n;\n            if (n === 2 && (dayOfWeek === undefined || dayOfWeek === null)) {\n                this._isSecond = true;\n                return this.addSeconds(this._orient);\n            }\n            return this;\n        };\n    };\n    for (var l = 0; l < nth.length; l++) {\n        $P[nth[l]] = (l === 0) ? nthfn( - 1) : nthfn(l);\n    }\n} ()); (function() {\n    Date.Parsing = {\n        Exception: function(s) {\n            this.message = \"Parse error at '\" + s.substring(0, 10) + \" ...'\";\n        }\n    };\n    var $P = Date.Parsing;\n    var _ = $P.Operators = {\n        rtoken: function(r) {\n            return function(s) {\n                var mx = s.match(r);\n                if (mx) {\n                    return ([mx[0], s.substring(mx[0].length)]);\n                } else {\n                    throw new $P.Exception(s);\n                }\n            };\n        },\n        token: function(s) {\n            return function(s) {\n                return _.rtoken(new RegExp(\"^\\s*\" + s + \"\\s*\"))(s);\n            };\n        },\n        stoken: function(s) {\n            return _.rtoken(new RegExp(\"^\" + s));\n        },\n        until: function(p) {\n            return function(s) {\n                var qx = [],\n                rx = null;\n                while (s.length) {\n                    try {\n                        rx = p.call(this, s);\n                    } catch(e) {\n                        qx.push(rx[0]);\n                        s = rx[1];\n                        continue;\n                    }\n                    break;\n                }\n                return [qx, s];\n            };\n        },\n        many: function(p) {\n            return function(s) {\n                var rx = [],\n                r = null;\n                while (s.length) {\n                    try {\n                        r = p.call(this, s);\n                    } catch(e) {\n                        return [rx, s];\n                    }\n                    rx.push(r[0]);\n                    s = r[1];\n                }\n                return [rx, s];\n            };\n        },\n        optional: function(p) {\n            return function(s) {\n                var r = null;\n                try {\n                    r = p.call(this, s);\n                } catch(e) {\n                    return [null, s];\n                }\n                return [r[0], r[1]];\n            };\n        },\n        not: function(p) {\n            return function(s) {\n                try {\n                    p.call(this, s);\n                } catch(e) {\n                    return [null, s];\n                }\n                throw new $P.Exception(s);\n            };\n        },\n        ignore: function(p) {\n            return p ? function(s) {\n                var r = null;\n                r = p.call(this, s);\n                return [null, r[1]];\n            }: null;\n        },\n        product: function() {\n            var px = arguments[0],\n            qx = Array.prototype.slice.call(arguments, 1),\n            rx = [];\n            for (var i = 0; i < px.length; i++) {\n                rx.push(_.each(px[i], qx));\n            }\n            return rx;\n        },\n        cache: function(rule) {\n            var cache = {},\n            r = null;\n            return function(s) {\n                try {\n                    r = cache[s] = (cache[s] || rule.call(this, s));\n                } catch(e) {\n                    r = cache[s] = e;\n                }\n                if (r instanceof $P.Exception) {\n                    throw r;\n                } else {\n                    return r;\n                }\n            };\n        },\n        any: function() {\n            var px = arguments;\n            return function(s) {\n                var r = null;\n                for (var i = 0; i < px.length; i++) {\n                    if (px[i] == null) {\n                        continue;\n                    }\n                    try {\n                        r = (px[i].call(this, s));\n                    } catch(e) {\n                        r = null;\n                    }\n                    if (r) {\n                        return r;\n                    }\n                }\n                throw new $P.Exception(s);\n            };\n        },\n        each: function() {\n            var px = arguments;\n            return function(s) {\n                var rx = [],\n                r = null;\n                for (var i = 0; i < px.length; i++) {\n                    if (px[i] == null) {\n                        continue;\n                    }\n                    try {\n                        r = (px[i].call(this, s));\n                    } catch(e) {\n                        throw new $P.Exception(s);\n                    }\n                    rx.push(r[0]);\n                    s = r[1];\n                }\n                return [rx, s];\n            };\n        },\n        all: function() {\n            var px = arguments,\n            _ = _;\n            return _.each(_.optional(px));\n        },\n        sequence: function(px, d, c) {\n            d = d || _.rtoken(/^\\s*/);\n            c = c || null;\n            if (px.length == 1) {\n                return px[0];\n            }\n            return function(s) {\n                var r = null,\n                q = null;\n                var rx = [];\n                for (var i = 0; i < px.length; i++) {\n                    try {\n                        r = px[i].call(this, s);\n                    } catch(e) {\n                        break;\n                    }\n                    rx.push(r[0]);\n                    try {\n                        q = d.call(this, r[1]);\n                    } catch(ex) {\n                        q = null;\n                        break;\n                    }\n                    s = q[1];\n                }\n                if (!r) {\n                    throw new $P.Exception(s);\n                }\n                if (q) {\n                    throw new $P.Exception(q[1]);\n                }\n                if (c) {\n                    try {\n                        r = c.call(this, r[1]);\n                    } catch(ey) {\n                        throw new $P.Exception(r[1]);\n                    }\n                }\n                return [rx, (r ? r[1] : s)];\n            };\n        },\n        between: function(d1, p, d2) {\n            d2 = d2 || d1;\n            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));\n            return function(s) {\n                var rx = _fn.call(this, s);\n                return [[rx[0][0], r[0][2]], rx[1]];\n            };\n        },\n        list: function(p, d, c) {\n            d = d || _.rtoken(/^\\s*/);\n            c = c || null;\n            return (p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice( - 1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));\n        },\n        set: function(px, d, c) {\n            d = d || _.rtoken(/^\\s*/);\n            c = c || null;\n            return function(s) {\n                var r = null,\n                p = null,\n                q = null,\n                rx = null,\n                best = [[], s],\n                last = false;\n                for (var i = 0; i < px.length; i++) {\n                    q = null;\n                    p = null;\n                    r = null;\n                    last = (px.length == 1);\n                    try {\n                        r = px[i].call(this, s);\n                    } catch(e) {\n                        continue;\n                    }\n                    rx = [[r[0]], r[1]];\n                    if (r[1].length > 0 && !last) {\n                        try {\n                            q = d.call(this, r[1]);\n                        } catch(ex) {\n                            last = true;\n                        }\n                    } else {\n                        last = true;\n                    }\n                    if (!last && q[1].length === 0) {\n                        last = true;\n                    }\n                    if (!last) {\n                        var qx = [];\n                        for (var j = 0; j < px.length; j++) {\n                            if (i != j) {\n                                qx.push(px[j]);\n                            }\n                        }\n                        p = _.set(qx, d).call(this, q[1]);\n                        if (p[0].length > 0) {\n                            rx[0] = rx[0].concat(p[0]);\n                            rx[1] = p[1];\n                        }\n                    }\n                    if (rx[1].length < best[1].length) {\n                        best = rx;\n                    }\n                    if (best[1].length === 0) {\n                        break;\n                    }\n                }\n                if (best[0].length === 0) {\n                    return best;\n                }\n                if (c) {\n                    try {\n                        q = c.call(this, best[1]);\n                    } catch(ey) {\n                        throw new $P.Exception(best[1]);\n                    }\n                    best[1] = q[1];\n                }\n                return best;\n            };\n        },\n        forward: function(gr, fname) {\n            return function(s) {\n                return gr[fname].call(this, s);\n            };\n        },\n        replace: function(rule, repl) {\n            return function(s) {\n                var r = rule.call(this, s);\n                return [repl, r[1]];\n            };\n        },\n        process: function(rule, fn) {\n            return function(s) {\n                var r = rule.call(this, s);\n                return [fn.call(this, r[0]), r[1]];\n            };\n        },\n        min: function(min, rule) {\n            return function(s) {\n                var rx = rule.call(this, s);\n                if (rx[0].length < min) {\n                    throw new $P.Exception(s);\n                }\n                return rx;\n            };\n        }\n    };\n    var _generator = function(op) {\n        return function() {\n            var args = null,\n            rx = [];\n            if (arguments.length > 1) {\n                args = Array.prototype.slice.call(arguments);\n            } else if (arguments[0]\n                instanceof Array) {\n                args = arguments[0];\n            }\n            if (args) {\n                for (var i = 0, px = args.shift(); i < px.length; i++) {\n                    args.unshift(px[i]);\n                    rx.push(op.apply(null, args));\n                    args.shift();\n                    return rx;\n                }\n            } else {\n                return op.apply(null, arguments);\n            }\n        };\n    };\n    var gx = \"optional not ignore cache\".split(/\\s/);\n    for (var i = 0; i < gx.length; i++) {\n        _[gx[i]] = _generator(_[gx[i]]);\n    }\n    var _vector = function(op) {\n        return function() {\n            if (arguments[0]\n                instanceof Array) {\n                return op.apply(null, arguments[0]);\n            } else {\n                return op.apply(null, arguments);\n            }\n        };\n    };\n    var vx = \"each any all\".split(/\\s/);\n    for (var j = 0; j < vx.length; j++) {\n        _[vx[j]] = _vector(_[vx[j]]);\n    }\n} ()); (function() {\n    var $D = Date,\n    $P = $D.prototype,\n    $C = $D.CultureInfo;\n    var flattenAndCompact = function(ax) {\n        var rx = [];\n        for (var i = 0; i < ax.length; i++) {\n            if (ax[i]\n                instanceof Array) {\n                rx = rx.concat(flattenAndCompact(ax[i]));\n            } else {\n                if (ax[i]) {\n                    rx.push(ax[i]);\n                }\n            }\n        }\n        return rx;\n    };\n    $D.Grammar = {};\n    $D.Translator = {\n        hour: function(s) {\n            return function() {\n                this.hour = Number(s);\n                this.setExplicitTime = true;\n            };\n        },\n        minute: function(s) {\n            return function() {\n                this.minute = Number(s);\n                this.setExplicitTime = true;\n            };\n        },\n        second: function(s) {\n            return function() {\n                this.second = Number(s);\n                this.setExplicitTime = true;\n            };\n        },\n        meridian: function(s) {\n            return function() {\n                this.meridian = s.slice(0, 1).toLowerCase();\n            };\n        },\n        timezone: function(s) {\n            return function() {\n                var n = s.replace(/[^\\d\\+\\-]/g, \"\");\n                if (n.length) {\n                    this.timezoneOffset = Number(n);\n                } else {\n                    this.timezone = s.toLowerCase();\n                }\n            };\n        },\n        day: function(x) {\n            var s = x[0];\n            return function() {\n                this.day = Number(s.match(/\\d+/)[0]);\n            };\n        },\n        month: function(s) {\n            return function() {\n                this.month = (s.length == 3) ? \"jan feb mar apr may jun jul aug sep oct nov dec\".indexOf(s) / 4: Number(s) - 1;\n            };\n        },\n        year: function(s) {\n            return function() {\n                var n = Number(s);\n                this.year = ((s.length > 2) ? n: (n + (((n + 2000) < $C.twoDigitYearMax) ? 2000: 1900)));\n            };\n        },\n        rday: function(s) {\n            return function() {\n                var day = (new Date()).getDate();\n                switch (s) {\n                case \"yesterday\":\n                    this.days = -1;\n                    break;\n                case \"later\":\n                    this.days = 5;\n                    break;\n                case \"soon\":\n                    this.days = 2;\n                    break;\n                case \"tomorrow\":\n                    this.days = 1;\n                    break;\n                case \"today\":\n                    this.days = 0;\n                    break;\n                case \"now\":\n                    this.days = 0;\n                    this.now = true;\n                    break;\n                }\n            };\n        },\n        finishExact: function(x) {\n            x = (x instanceof Array) ? x: [x];\n            for (var i = 0; i < x.length; i++) {\n                if (x[i]) {\n                    x[i].call(this);\n                }\n            }\n            var now = new Date();\n            if ((this.hour || this.minute) && (!this.month && !this.year && !this.day)) {\n                this.day = now.getDate();\n            }\n            if (!this.year) {\n                this.year = now.getFullYear();\n\n                if (this.month < now.getMonth())\n                {\n                    this.year++;\n                }\n            }\n            if (!this.month && this.month !== 0) {\n                this.month = now.getMonth();\n            }\n            if (!this.day) {\n                this.day = 1;\n            }\n            if (!this.hour) {\n                this.hour = 0;\n            }\n            if (!this.minute) {\n                this.minute = 0;\n            }\n            if (!this.second) {\n                this.second = 0;\n            }\n            if (this.meridian && this.hour) {\n                if (this.meridian == \"p\" && this.hour < 12) {\n                    this.hour = this.hour + 12;\n                } else if (this.meridian == \"a\" && this.hour == 12) {\n                    this.hour = 0;\n                }\n            }\n            if (this.day > $D.getDaysInMonth(this.year, this.month)) {\n                throw new RangeError(this.day + \" is not a valid value for days.\");\n            }\n            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);\n            r._explicitTime = this.setExplicitTime;\n\n            if (this.timezone) {\n                r.set({\n                    timezone: this.timezone\n                });\n            } else if (this.timezoneOffset) {\n                r.set({\n                    timezoneOffset: this.timezoneOffset\n                });\n            }\n            return r;\n        },\n        finish: function(x) {\n            x = (x instanceof Array) ? flattenAndCompact(x) : [x];\n            if (x.length === 0) {\n                return null;\n            }\n            for (var i = 0; i < x.length; i++) {\n                if (typeof x[i] == \"function\") {\n                    x[i].call(this);\n                }\n            }\n            var today = $D.today();\n            if (this.now && !this.unit && !this.operator) {\n                return new Date();\n            } else if (this.now) {\n                today = new Date();\n            }\n            var givenYear = !!this.year;\n            var expression = !!(this.days && this.days !== null || this.orient || this.operator);\n            var gap,\n            mod,\n            orient;\n            orient = ((this.orient == \"past\" || this.operator == \"subtract\") ? -1: 1);\n            if (!this.now && \"hour minute second\".indexOf(this.unit) != -1) {\n                today.setTimeToNow();\n            }\n            if (this.month || this.month === 0) {\n                if (\"year day hour minute second\".indexOf(this.unit) != -1) {\n                    this.value = this.month + 1;\n                    this.month = null;\n                    expression = true;\n                }\n            }\n            if (!expression && this.weekday && !this.day && !this.days) {\n                var temp = Date[this.weekday]();\n                this.day = temp.getDate();\n                if (!this.month) {\n                    this.month = temp.getMonth();\n                }\n                this.year = temp.getFullYear();\n            }\n            if (expression && this.weekday && this.unit != \"month\") {\n                this.unit = \"day\";\n                gap = ($D.getDayNumberFromName(this.weekday) - today.getDay());\n                mod = 7;\n                this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);\n            }\n            if (this.month && this.unit == \"day\" && this.operator) {\n                this.value = (this.month + 1);\n                this.month = null;\n            }\n            if (this.value != null && this.month != null && this.year != null) {\n                this.day = this.value * 1;\n            }\n            if (this.month && !this.day && this.value) {\n                today.set({\n                    day: this.value * 1\n                });\n                if (!expression) {\n                    this.day = this.value * 1;\n                }\n            }\n            if (!this.month && this.value && this.unit == \"month\" && !this.now) {\n                this.month = this.value;\n                expression = true;\n            }\n            if (expression && (this.month || this.month === 0) && this.unit != \"year\") {\n                this.unit = \"month\";\n                gap = (this.month - today.getMonth());\n                mod = 12;\n                this.months = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);\n                this.month = null;\n            }\n            if (!this.unit) {\n                this.unit = \"day\";\n            }\n            if (!this.value && this.operator && this.operator !== null && this[this.unit + \"s\"] && this[this.unit + \"s\"] !== null) {\n                this[this.unit + \"s\"] = this[this.unit + \"s\"] + ((this.operator == \"add\") ? 1: -1) + (this.value || 0) * orient;\n            } else if (this[this.unit + \"s\"] == null || this.operator != null) {\n                if (!this.value) {\n                    this.value = 1;\n                }\n                this[this.unit + \"s\"] = this.value * orient;\n            }\n            if (this.meridian && this.hour) {\n                if (this.meridian == \"p\" && this.hour < 12) {\n                    this.hour = this.hour + 12;\n                } else if (this.meridian == \"a\" && this.hour == 12) {\n                    this.hour = 0;\n                }\n            }\n            if (this.weekday && !this.day && !this.days) {\n                var temp = Date[this.weekday]();\n                this.day = temp.getDate();\n                if (temp.getMonth() !== today.getMonth()) {\n                    this.month = temp.getMonth();\n                }\n            }\n            if ((this.month || this.month === 0) && !this.day) {\n                this.day = 1;\n            }\n            if (!this.orient && !this.operator && this.unit == \"week\" && this.value && !this.day && !this.month) {\n                return Date.today().setWeek(this.value);\n            }\n            if (expression && this.timezone && this.day && this.days) {\n                this.day = this.days;\n            }\n            if (!givenYear && this.month < today.getMonth())\n            {\n                this.year = today.getFullYear() + 1;\n            }\n            return (expression) ? today.add(this) : today.set(this);\n        }\n    };\n    var _ = $D.Parsing.Operators,\n    g = $D.Grammar,\n    t = $D.Translator,\n    _fn;\n    g.datePartDelimiter = _.rtoken(/^([\\s\\-\\.\\,\\/\\x27]+)/);\n    g.timePartDelimiter = _.stoken(\":\");\n    g.whiteSpace = _.rtoken(/^\\s*/);\n    g.generalDelimiter = _.rtoken(/^(([\\s\\,]|at|@|on)+)/);\n    var _C = {};\n    g.ctoken = function(keys) {\n        var fn = _C[keys];\n        if (!fn) {\n            var c = $C.regexPatterns;\n            var kx = keys.split(/\\s+/),\n            px = [];\n            for (var i = 0; i < kx.length; i++) {\n                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));\n            }\n            fn = _C[keys] = _.any.apply(null, px);\n        }\n        return fn;\n    };\n\n    g.ctoken2 = function(key) {\n        return _.rtoken($C.regexPatterns[key]);\n    };\n\n    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));\n    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));\n    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));\n    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));\n\n    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));\n    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));\n\n    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));\n    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));\n\n    g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter));\n\n    g.t = _.cache(_.process(g.ctoken2(\"shortMeridian\"), t.meridian));\n    g.tt = _.cache(_.process(g.ctoken2(\"longMeridian\"), t.meridian));\n\n    g.z = _.cache(_.process(_.rtoken(/^((\\+|\\-)\\s*\\d\\d\\d\\d)|((\\+|\\-)\\d\\d\\:?\\d\\d)/), t.timezone));\n    g.zz = _.cache(_.process(_.rtoken(/^((\\+|\\-)\\s*\\d\\d\\d\\d)|((\\+|\\-)\\d\\d\\:?\\d\\d)/), t.timezone));\n    g.zzz = _.cache(_.process(g.ctoken2(\"timezone\"), t.timezone));\n\n    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));\n    g.time = _.each(_.optional(_.ignore(_.stoken(\"T\"))), g.hms, g.timeSuffix);\n\n    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\\d|3[0-1]|\\d)/), _.optional(g.ctoken2(\"ordinalSuffix\"))), t.day));\n    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\\d|3[0-1])/), _.optional(g.ctoken2(\"ordinalSuffix\"))), t.day));\n    g.rday = _.cache(_.process(g.ctoken(\"yesterday tomorrow soon later today now\"), t.rday));\n\n    g.ddd = g.dddd = _.cache(_.process(g.ctoken(\"sun mon tue wed thu fri sat\"), function(s) {\n        return function() {\n            this.weekday = s;\n        };\n    }));\n\n    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\\d|\\d)/), t.month));\n    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\\d)/), t.month));\n    g.MMM = g.MMMM = _.cache(_.process(g.ctoken(\"jan feb mar apr may jun jul aug sep oct nov dec\"), t.month));\n\n    g.y = _.cache(_.process(_.rtoken(/^(\\d\\d?)/), t.year));\n    g.yy = _.cache(_.process(_.rtoken(/^(\\d\\d)/), t.year));\n    g.yyy = _.cache(_.process(_.rtoken(/^(\\d\\d?\\d?\\d?)/), t.year));\n    g.yyyy = _.cache(_.process(_.rtoken(/^(\\d\\d\\d\\d)/), t.year));\n\n    _fn = function() {\n        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2(\"timeContext\")));\n    };\n\n    g.day = _fn(g.d, g.dd, g.rday);\n    g.month = _fn(g.M, g.MMM);\n    g.year = _fn(g.yyyy, g.yy);\n\n    g.orientation = _.process(g.ctoken(\"past future\"), function(s) {\n        return function() {\n            this.orient = s;\n        };\n    });\n\n    g.value = _.process(_.rtoken(/^\\d\\d?(st|nd|rd|th)?/), function(s) {\n        return function() {\n            this.value = s.replace(/\\D/g, \"\");\n        };\n    });\n\n    g.expression = _.set([g.rday, g.value, g.orientation, g.ddd, g.MMM]);\n    _fn = function() {\n        return _.set(arguments, g.datePartDelimiter);\n    };\n\n    g.mdy = _fn(g.ddd, g.month, g.day, g.year);\n    g.ymd = _fn(g.ddd, g.year, g.month, g.day);\n    g.dmy = _fn(g.ddd, g.day, g.month, g.year);\n\n    g.date = function(s) {\n        return ((g[$C.dateElementOrder] || g.mdy).call(this, s));\n    };\n\n    g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function(fmt) {\n        if (g[fmt]) {\n            return g[fmt];\n        } else {\n            throw $D.Parsing.Exception(fmt);\n        }\n    }), _.process(_.rtoken(/^[^dMyhHmstz]+/), function(s) {\n        return _.ignore(_.stoken(s));\n    }))), function(rules) {\n        return _.process(_.each.apply(null, rules), t.finishExact);\n    });\n    var _F = {};\n    var _get = function(f) {\n        return _F[f] = (_F[f] || g.format(f)[0]);\n    };\n    g.formats = function(fx) {\n        if (fx instanceof Array) {\n            var rx = [];\n            for (var i = 0; i < fx.length; i++) {\n                rx.push(_get(fx[i]));\n            }\n            return _.any.apply(null, rx);\n        } else {\n            return _get(fx);\n        }\n    };\n\n    var dateParseFormats = \n    [\n        \"M/d H\",\n        \"M-d H\",\n        \"MMddyyyy\",\n        \"ddMMyyyy\",\n        \"Mddyyyy\",\n        \"ddMyyyy\",\n        \"Mdyyyy\",\n        \"dMyyyy\",\n        \"yyyy\",\n        \"Mdyy\",\n        \"dMyy\"\n    ];\n\n    g._formats = g.formats(dateParseFormats);\n    g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish);\n    g.start = function(s) {\n        try {\n            var r = g._formats.call({}, s);\n            if (r[1].length === 0) {\n                return r;\n            }\n        } catch(e) {}\n        return g._start.call({}, s);\n    };\n    $D._parse = $D.parse;\n    $D.parse = function(s) {\n        var r = null;\n        if (!s) {\n            return null;\n        }\n        if (s instanceof Date) {\n            return s;\n        }\n        try {\n            r = $D.Grammar.start.call({}, s.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, \"$1\"));\n        } catch(e) {\n            return null;\n        }\n        return ((r[1].length === 0) ? r[0] : null);\n    };\n    $D.getParseFunction = function(fx) {\n        var fn = $D.Grammar.formats(fx);\n        return function(s) {\n            var r = null;\n            try {\n                r = fn.call({}, s);\n            } catch(e) {\n                return null;\n            }\n            return ((r[1].length === 0) ? r[0] : null);\n        };\n    };\n    $D.parseExact = function(s, fx) {\n        return $D.getParseFunction(fx)(s);\n    };\n} ());\n\n}\n\nif (this.document)\n{\n    window.dateWrapper = dateWrapper;\n}\n\nif (!this.dateLibLoaded)\n{\n    dateWrapper();\n}\n","asserts":[]},"goog":{"path":"F:/p/bce/Duchess/public/js/goog.js","data":"define(['ko', 'data', 'globals', 'util', 'gdata', 'platform'],\nfunction (ko, d, g, util, gdata, platform) {\nvar self = {\n    CLIENT_ID: \"597847337936.apps.googleusercontent.com\",\n    exportID: undefined,\n    calendars: ko.observable({ }),\n    eventSubscribers: [ ],\n    authenticatedUserEmail: ko.observable(undefined),\n    //authenticatedUser: ko.observable(),\n    //docTitle: ko.observable(g.settings.get('gdocTitle') || 'Default Document'),\n    gapiLoaded: false\n};\n\ng.goog = self;\n\n//var EXPORT_SUMMARY = \"Duchess\";\nvar NUM_DAYS = 14;\nvar MAX_RESULTS_EVENTS = 50;\nvar MAX_RESULTS_CALENDARS = 15;\nvar MAX_DESCRIPTION = 8000;\n\nvar DEFAULT_REFRESH_WAIT = 10000; // 10 seconds\nvar MAX_REFRESH_WAIT = 10000 * 2 * 2 * 2 * 2; // 4 Retries\n\nself.APP_ID = '597847337936';\n\nself.REALTIME_MIMETYPE = 'application/vnd.google-apps.drive-sdk';\n\nwindow.GScope =\n{\n    Calendar: 'https://www.googleapis.com/auth/calendar',\n    CalendarRO: 'https://www.googleapis.com/auth/calendar.readonly',\n    Contacts: 'https://www.google.com/m8/feeds',\n    Drive: 'https://www.googleapis.com/auth/drive.file',\n    UserInfoEmail: 'https://www.googleapis.com/auth/userinfo.email',\n    DriveFull: 'https://www.googleapis.com/auth/drive',\n    TasksRO: 'https://www.googleapis.com/auth/tasks.readonly',\n    UserInfoProfile: 'https://www.googleapis.com/auth/userinfo.profile',\n    DriveInstall: 'https://www.googleapis.com/auth/drive.install',\n    DriveAppData: 'https://www.googleapis.com/auth/drive.appdata'\n};\n\nvar noSaveScopes = [ GScope.TasksRO ];\n\n// WARNING: Do not change this value, we expect at least one drive file to have this title for legacy clients.\nself.LEGACY_DefaultDriveDocTitle = 'DuchessBeta';\n\n// This value can be changed, we have no hard requirement that it is static.\nself.DefaultDocTitle = 'Moo.do Personal Document';\n\n// WARNING: These cannot change as we rely on these to load a default doc for a user on new clients.\nself.DefaultProperty = 'MooDoDefault';\nself.DefaultPropertyValue = 'TRUE';\n\n// Note: If we need to add additional scopes here, the init function needs to be updated to force include\n//       any scopes in the default required scopes. Currently these get overwritten by the clients saved\n//       scopes.\nself.requiredScopes = [ GScope.Drive, GScope.UserInfoEmail, GScope.DriveInstall ];\n\nself.requestScopes = [ ];\n\n// Note: If adding additional scopes here, only add to the end of the list as we store indices on the client.\nself.scopes = [ GScope.Calendar, GScope.CalendarRO, GScope.Contacts, GScope.Drive, GScope.UserInfoEmail, GScope.DriveFull, GScope.UserInfoProfile, GScope.DriveInstall, GScope.DriveAppData ];\n\n// Once authorized, scopes should be added to this array to ensure that they get refreshed\n// when the current OAuth2 token expires.\nvar authorizedScopes = [ ];\n\nif (DEBUG)\n{\n\nwindow.__GetScopes = function()\n{\n    return authorizedScopes;\n};\n\n}\n\nvar docFields = 'items(id,title)';\nvar eventFields = \"created,description,extendedProperties,end,etag,htmlLink,id,kind,location,locked,start,status,summary,updated,creator\";\nvar eventListFields = \"items(\" + eventFields + \"),kind,updated,accessRole\";\nvar calendarListFields = \"etag,items(description,etag,id,kind,location,selected,summary,summaryOverride,timeZone),kind,nextPageToken\";\n\nself.isLoaded = false;\n\nself.init = function()\n{\n    // Grab the saved scope indices\n    var savedScopesString = g.settings.get(Settings.authScopes);\n\n    // If there are saved scopes, combine with the default set of required scopes\n    if (savedScopesString)\n    {\n        var savedScopes;\n        try\n        {\n            savedScopes = JSON.parse(savedScopesString);\n        }\n        catch (err)\n        {\n            g.reportError(err);\n        }\n\n        if (savedScopes)\n        {\n            for (var i = 0; i < savedScopes.length; ++i)\n            {\n                g.Assert(savedScopes[i] >= 0, 'Each saved scope should be a valid array index');\n\n                if (savedScopes[i] >= 0)\n                {\n                    self.requestScopes.push(self.scopes[savedScopes[i]]);\n                }\n            }\n\n            // No reason to save the same scope multiple times\n            self.requestScopes = ko.utils.arrayGetDistinctValues(self.requestScopes);\n\n            if (DEBUG) log('Saved Scopes: ', savedScopes);\n        }\n    }\n    else\n    {\n        self.requestScopes = self.requiredScopes;\n    }\n\n    authorizedScopes = self.requestScopes;\n\n    // If custom redirect was for syncing contacts, setup contact sync\n    if (platform.syncContacts)\n    {\n        if (util.getURLParam('access_token') && !util.hasURLParam('error'))\n        {\n            if (authorizedScopes.indexOf(GScope.Contacts) < 0)\n            {\n                authorizedScopes.push(GScope.Contacts);\n\n                saveAuthorizedScopes();\n            }\n\n            g.settings.set(Settings.syncContacts, true);\n        }\n    }\n\n    // Setup Analytics UserID feature\n    var authGASub = self.authenticatedUserEmail.subscribe(function (newValue)\n    {\n        if (newValue !== undefined)\n        {\n            if (window.ga)\n            {\n                ga('set', '&uid', g.getAnonUserIdentifier());\n            }\n\n            authGASub.dispose();\n            authGASub = undefined;\n        }\n    });\n};\n\nself.ensureRequiredScopesAreRequested = function()\n{\n    var needsAdditionalScopes = false;\n\n    // If we're missing any of the required OAuth scopes, prompt the user to authenticate them.\n    for (var i = 0; i < self.requiredScopes.length; ++i)\n    {\n        if (authorizedScopes.indexOf(self.requiredScopes[i]) < 0)\n        {\n            needsAdditionalScopes = true;\n\n            break;\n        }\n    }\n\n    if (needsAdditionalScopes)\n    {\n        self.runAuthenticate(self.requiredScopes, /*runImmediate*/true, /*retry*/false, function (token)\n        {\n            if (!token || token.error)\n            {\n                g.messageQueue.pushMessage({\n                    text: 'We need additional permissions to give you the best experience, ' + platform.actionVerb() + ' here to authenticate.',\n                    type: MessageType.Warning,\n                    action: function ()\n                    {\n                        self.runAuthenticate(self.requiredScopes, /*runImmediate*/false, /*retry*/false, function (token2)\n                        {\n                            if (!token2 || token2.error)\n                            {\n                                g.messageQueue.pushMessage({\n                                    text: 'There was an error authenticating, ' + platform.actionVerb() + ' here to try again.',\n                                    type: MessageType.Error,\n                                    action: self.ensureRequiredScopesAreRequested\n                                });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n};\n\nvar watchdogWait = 1000 * 60 * 16; // 16 minutes (in ms)\nvar watchdogInterval = undefined;\nself.startWatchdog = function()\n{\n    if (!watchdogInterval)\n    {\n        watchdogInterval = setInterval(self.watchdogFn, watchdogWait);\n    }\n};\n\nself.stopWatchdog = function()\n{\n    clearInterval(watchdogInterval);\n    watchdogInterval = undefined;\n};\n\nvar lastWatchdogTime = 0;\nself.watchdogFn = function()\n{\n    var currentTime = Date.now();\n\n    // When devices come back from sleep, they may fire multiple interval events at once. Limit\n    // number of events that get fired when coming back into the foreground.\n    if (lastWatchdogTime - currentTime >= watchdogWait)\n    {\n        try\n        {\n            var token = gapi.auth.getToken();\n\n            if (token)\n            {\n                var expireTime = parseInt(token.expires_at) * 1000;\n\n                if (currentTime > expireTime)\n                {\n                    if (ShouldLog(LogLevels.Error)) log('Active token is no longer valid: ' + currentTime + ' vs. ' + expireTime);\n\n                    refreshAuthorization();\n\n                    g.reportError(new Error('Watchdog found expired token on client'));\n                }\n                else\n                {\n                    gdata.poke();\n                }\n            }\n            else\n            {\n                if (ShouldLog(LogLevels.Error)) log('No active token on client!');\n\n                refreshAuthorization();\n\n                g.reportError(new Error('Watchdog found client with no token set'));\n            }\n        }\n        catch (err)\n        {\n            g.reportError(err);\n        }\n        finally\n        {\n            lastWatchdogTime = currentTime;\n        }\n\n        g.checkForRemoteChanges();\n    }\n};\n\nself.hasPermission = function(scope)\n{\n    return (authorizedScopes.indexOf(scope) > -1);\n};\n\n//\n// GAPI Functionality\n//\nvar refreshAuthorizationTimer = undefined;\nvar authorizedUntil = undefined;\nvar refreshingAuth = true;\nself.onFocusHandler = function()\n{\n    if (authorizedUntil && Date.now() > authorizedUntil)\n    {\n        refreshAuthorization();\n    }\n};\n\nself.onBlurHandler = function()\n{\n    if (refreshAuthorizationTimer)\n    {\n        clearTimeout(refreshAuthorizationTimer);\n    }\n}\n\nfunction getAccessTokenInternal()\n{\n    var token = undefined;\n\n    try\n    {\n        var gapiToken = gapi.auth.getToken();\n\n        if (gapiToken)\n        {\n            token = gapiToken.access_token;\n        }\n    }\n    catch (err)\n    {\n        self.recoverFromError(err);\n    }\n\n    return token;\n}\n\nself.getAccessToken = function()\n{\n    var token = getAccessTokenInternal();\n\n    if (!token)\n    {\n        self.recoverFromError();\n    }\n\n    return token;\n};\n\n// self.subscribeToEvents = function (insertCallback, updateCallback)\n// {\n//     self.eventSubscribers.push({ onInsert: insertCallback, onUpdate: updateCallback });\n// };\n\n// self.notifySubscribers = function (type, id, data)\n// {\n//     g.Assert(type !== UpdateType.None);\n\n//     for (var i = 0; i < self.eventSubscribers.length; ++i)\n//     {\n//         if (type === UpdateType.Update)\n//         {\n//             self.eventSubscribers[i].onUpdate(id, data);\n//         }\n//         else if (type === UpdateType.Insert)\n//         {\n//             self.eventSubscribers[i].onInsert(id, data);\n//         }\n//     }\n// };\n\n// self.syncCalendarEvents = function (skipExport)\n// {\n//     var lastEventSync = g.settings.get(Settings.lastEventSync);\n//     var cals = g.settings.get(Settings.calendarsImport);\n\n//     g.settings.set(Settings.lastEventSync, Date.now());\n\n//     var exportCal = g.settings.get(Settings.calendarExport);\n\n//     var minDate = Date.today();\n//     var maxDate = Date.today();\n//     minDate.setDate(minDate.getDate() - 1);\n//     maxDate.setDate(maxDate.getDate() + NUM_DAYS);\n\n//     for (var i = 0; i < cals.length; ++i)\n//     {\n//         var cal = self.calendars()[cals[i]];\n\n//         if (!(skipExport && cal.id == exportCal))\n//         {\n//             var params =\n//             {\n//                 'calendarId': cal.id,\n//                 'maxResults': MAX_RESULTS_EVENTS,\n//                 'singleEvents': true,\n//                 'fields': eventListFields,\n//                 'timeMin': minDate.toISOString(),\n//                 'timeMax': maxDate.toISOString()\n//             };\n\n//             self.updateCalendarEvents(cal, params, self.notifySubscribers);\n//         }\n//     }\n// };\n\n// self.updateCalendarEvents = function (cal, params, callbackEach, callbackDone)\n// {\n//     if (params.calendarId)\n//     {\n//         var request = gapi.client.calendar.events.list(params);\n\n//         request.execute(function (response)\n//         {\n//             g.Assert(response.kind == \"calendar#events\", response);\n\n//             if (response.items)\n//             {\n//                 for (var i = 0; i < response.items.length; ++i)\n//                 {\n//                     var item = response.items[i];\n\n//                     item.calendarId = params.calendarId;\n\n//                     var res = d.storeEvent(item);\n\n//                     if (res.type != UpdateType.None)\n//                     {\n//                         if (callbackEach)\n//                         {\n//                             callbackEach(res.type, res.id, item);\n//                         }\n//                     }\n//                 }\n//             }\n\n//             if (callbackDone)\n//             {\n//                 callbackDone();\n//             }\n//         });\n//     }\n// };\n\n// self.updateCalendarList = function (callback)\n// {\n//     if (!self.isLoaded || !gapi || !gapi.client || !gapi.client.calendar)\n//         return;\n\n//     var request = gapi.client.calendar.calendarList.list(\n//     {\n//         'maxResults': MAX_RESULTS_CALENDARS,\n//         'fields': calendarListFields\n//     });\n\n//     request.execute(function (response)\n//     {\n//         g.Assert(response.kind == \"calendar#calendarList\", response);\n\n//         g.settings.set(Settings.lastCalendarSync, Date.now());\n\n//         var foundExportCalendar = false;\n\n//         if (response.items)\n//         {\n//             for (var i = 0; i < response.items.length; ++i)\n//             {\n//                 var cal = response.items[i];\n\n//                 if (cal.summary == EXPORT_SUMMARY)\n//                 {\n//                     foundExportCalendar = true;\n//                     self.exportID = cal.id;\n//                 }\n\n//                 if (!self.calendars()[cal.id])\n//                 {\n//                     self.calendars()[cal.id] = cal;\n//                 }\n//             }\n//         }\n\n//         if (!foundExportCalendar)\n//         {\n//             self.createExportCalendar(callback);\n//         }\n//         else if(callback)\n//         {\n//             callback(self.calendars());\n//         }\n//     });\n// };\n\n// self.updateDefaultReminder = function(calendarId)\n// {\n//     var updateRequest = gapi.client.calendar.calendarList.update(\n//         {\n//             'calendarId': calendarId,\n//             'resource':\n//             {\n//                 'defaultReminders': [{\n//                     \"method\": \"popup\",\n//                     \"minutes\": 30\n//                 }]\n//             }\n//         });\n//         updateRequest.execute(function(response2) {\n//             // TODO: Check for errors?\n//         });\n// };\n\n// self.createExportCalendar = function (callback)\n// {\n//     var request = gapi.client.calendar.calendars.insert(\n//     {\n//         \"resource\" :\n//         {\n//             'summary': EXPORT_SUMMARY,\n//             'description': 'Temporary Home for Duchess'\n//         }\n//     });\n\n//     request.execute(function (response)\n//     {\n//         g.Assert(response.kind == \"calendar#calendar\", response);\n\n//         self.updateDefaultReminder(response.id);\n\n//         self.exportID = response.id;\n//         self.calendars()[response.id] = response;\n\n//         callback(self.calendars());\n//     });\n// };\n\n// function exportItem(response, calendarId, isUpdate)\n// {\n//     //log('Event Exported: ', response);\n\n//     if (!response.error)\n//     {\n//         response.result.calendarId = calendarId;\n//         var res = d.storeEvent(response.result);\n\n//         if (isUpdate)\n//         {\n//             g.Assert(res.type === UpdateType.Update);\n//         }\n//         else\n//         {\n//             g.Assert(res.type === UpdateType.Insert);\n\n//             d.updateItemWithExtern(response.id, res.id);\n//         }\n//     }\n//     else\n//     {\n//         // TODO: Handle error where server ETag is different than the client\n//         g.Assert(!response.error, \"Error while exporting: \", response);\n//     }\n// }\n\n// function deleteItem(response)\n// {\n//     log('Event Deleted: ', response);\n\n//     if (!response.error)\n//     {\n//         d.deleteEvent(response.id);\n//     }\n//     else\n//     {\n//         g.Assert(!response.error, \"Error while exporting a delete: \", response);\n//     }\n// }\n\n// function itemChildrenToString(item, numLevels)\n// {\n//     var text = '';\n//     if(isNaN(numLevels))\n//         numLevels = -1; // Don't include the text of the parent\n//     if(numLevels >= 0)\n//     {\n//         for(var u = 0; u < numLevels; u ++)\n//         {\n//             text += '    ';\n//         }\n//         text += item.text + '\\n';\n//     }\n//     for(var i = 0; i < item.items().length; i ++)\n//     {\n//         text += itemChildrenToString(item.items()[i], numLevels + 1);\n//     }\n//     return text;\n// }\n\n// function doExport()\n// {\n//     var exportCal = g.settings.get(Settings.calendarExport);\n//     var exportData = d.getExportableItems(exportCal);\n\n//     var items = exportData.items;\n\n//     if (items.length > 0)\n//     {\n//         var rpcBatch = gapi.client.newRpcBatch();\n\n//         for (var i = 0; i < items.length; ++i)\n//         {\n//             var item = items[i];\n//             var extern = exportData.externs[item.extern];\n\n//             var isDuchessOwned = false;\n//             if (extern && extern.extendedProperties && extern.extendedProperties.private)\n//             {\n//                 isDuchessOwned = extern.extendedProperties.private.DuchessOwned;\n//             }\n\n//             if (!isDuchessOwned || (!item.isDeleted && item.date))\n//             {\n//                 var realItem = d.models[item.id];\n//                 var description = \"\";\n\n//                 if (realItem)\n//                 {\n//                     description = itemChildrenToString(realItem);\n//                     if(description.length > MAX_DESCRIPTION) // Maximum gcal description length is 8192\n//                     {\n//                         description = description.substr(0, MAX_DESCRIPTION);\n//                     }\n//                 }\n\n//                 var requestResource = {\n//                     'summary': item.text,\n//                     'extendedProperties':\n//                     {\n//                         'private': {\n//                             'DuchessID': item.id\n//                         }\n//                     },\n//                     'description': description\n//                 };\n\n//                 if (!item.extern)\n//                 {\n//                     g.Assert(!extern);\n\n//                     requestResource['extendedProperties']['private']['DuchessOwned'] = true;\n\n//                     if (item.allDayDate)\n//                     {\n//                         var date = new Date(item.date).toString(\"yyyy-MM-dd\");\n\n//                         requestResource['start'] = { 'date': date, 'dateTime': null };\n//                         requestResource['end'] = { 'date': date, 'dateTime': null };\n//                         requestResource['reminders'] = {'useDefault': 'false'};\n//                     }\n//                     else\n//                     {\n//                         var startTime = new Date(item.date);\n//                         var endTime = new Date(item.date);\n//                         endTime.setMinutes(startTime.getMinutes() + 30);\n\n//                         requestResource['start'] = { 'dateTime': startTime.toISOString(), 'date': null };\n//                         requestResource['end'] = { 'dateTime': endTime.toISOString(), 'date': null };\n//                     }\n\n//                     var request = gapi.client.calendar.events.insert(\n//                     {\n//                         'calendarId': exportCal,\n//                         'fields': eventFields,\n//                         'resource' : requestResource\n//                     });\n\n//                     var cb = function (response) { exportItem(response, exportCal, /*isUpdate*/false); };\n\n//                     rpcBatch.add(request, {\n//                         'id': item.id,\n//                         'callback': cb\n//                     });\n//                 }\n//                 else\n//                 {\n//                     g.Assert(extern);\n\n//                     if (item.date)\n//                     {\n//                         if (item.allDayDate)\n//                         {\n//                             var date = new Date(item.date).toString(\"yyyy-MM-dd\");\n\n//                             requestResource['start'] = { 'date': date, 'dateTime': null };\n//                             requestResource['end'] = { 'date': date, 'dateTime': null };\n//                         }\n//                         else\n//                         {\n//                             var externStart = extern.start;\n//                             var externEnd = extern.end;\n\n//                             var eventLength = 30 * 60 * 1000; // Default to a half hour event\n//                             if (externStart.dateTime && externEnd.dateTime)\n//                             {\n//                                 var startTime = new Date(externStart.dateTime);\n//                                 var endTime = new Date(externEnd.dateTime);\n//                                 eventLength = endTime - startTime;\n//                             }\n\n//                             var startTime = new Date(item.date);\n//                             var endTime = new Date(item.date);\n//                             endTime.addMilliseconds(eventLength);\n\n//                             requestResource['start'] = { 'dateTime': startTime.toISOString(), 'date': null };\n//                             requestResource['end'] = { 'dateTime': endTime.toISOString(), 'date': null };\n//                         }\n//                     }\n//                     else\n//                     {\n//                         requestResource['start'] = extern.start;\n//                         requestResource['end'] = extern.end;\n//                     }\n\n//                     var request = gapi.client.calendar.events.patch(\n//                     {\n//                         'calendarId': exportCal,\n//                         'eventId': extern.id,\n//                         'resource' : requestResource\n//                     });\n\n//                     var cb = function (response) { exportItem(response, exportCal, /*isUpdate*/true); };\n\n//                     rpcBatch.add(request, {\n//                         'id': item.id,\n//                         'callback': cb\n//                     });\n//                 }\n//             }\n//             else\n//             {\n//                 var extern = exportData.externs[item.extern];\n//                 g.Assert(extern);\n\n//                 var externDeleteId = undefined;\n//                 if (extern.extendedProperties && extern.extendedProperties.private)\n//                 {\n//                     if (extern.extendedProperties.private.DuchessOwned)\n//                     {\n//                         externDeleteId = extern.id;\n//                     }\n//                 }\n\n//                 if (externDeleteId)\n//                 {\n//                     var request = gapi.client.calendar.events.delete(\n//                     {\n//                         'calendarId': exportCal,\n//                         'eventId': externDeleteId\n//                     });\n\n//                     var cb = function (response) { deleteItem(response); };\n\n//                     rpcBatch.add(request, {\n//                         'id': item.id,\n//                         'callback': cb\n//                     });\n//                 }\n//             }\n//         }\n\n//         rpcBatch.execute(function () { });\n//     }\n// }\n\n// self.exportCalendarEvents = function (data)\n// {\n//     var exportCal = g.settings.get(Settings.calendarExport);\n\n//     if (exportCal)\n//     {\n//         //log('Exporting to: ', exportCal);\n\n//         var minDate = Date.today();\n//         var maxDate = Date.today();\n//         minDate.setDate(minDate.getDate() - 1);\n//         maxDate.setDate(maxDate.getDate() + NUM_DAYS);\n\n//         var params =\n//         {\n//             'calendarId': exportCal,\n//             'maxResults': MAX_RESULTS_EVENTS,\n//             'singleEvents': true,\n//             'fields': eventListFields,\n//             'timeMin': minDate.toISOString(),\n//             'timeMax': maxDate.toISOString()\n//         };\n\n//         var doneCallback = undefined;\n//         if (g.settings.get(Settings.calendarsImport).indexOf(exportCal) > -1)\n//         {\n//             doneCallback = self.notifySubscribers;\n//         }\n\n//         self.updateCalendarEvents(exportCal, params, doneCallback, doExport);\n//     }\n// };\n\nself.getContactInfo = function (name, callback)\n{\n    var accessToken = self.getAccessToken();\n\n    if (!accessToken)\n    {\n        callback(undefined);\n\n        return;\n    }\n\n    var lastSync = undefined;\n    var url = 'https://www.google.com/m8/feeds/contacts/default/full?v=3.0&alt=json';\n\n    if (name)\n    {\n        url += '&q=\\\"' + name + '\\\"';\n    }\n    else\n    {\n        lastSync = g.settings.get(Settings.lastContactSync);\n    }\n\n    // If local contacts have been loaded and we have no contacts loaded, force a full reload.\n    var forceLoad = d.areLocalContactsLoaded() && (d.numContacts() === 0);\n    if (lastSync && !forceLoad)\n    {\n        var syncDate = new Date(lastSync);\n        url += '&updated-min=' + syncDate.toString(\"yyyy-MM-ddTHH:mm:ss\");\n    }\n\n    url += '&max-results=10000';\n    url += '&access_token=' + accessToken;\n\n    function handleResponse(xhr)\n    {\n        if (xhr.status !== 200)\n        {\n            callback();\n        }\n        else\n        {\n            var obj = JSON.parse(xhr.responseText);\n\n            try\n            {\n                g.settings.set(Settings.lastContactSync, new Date(obj.feed.updated.$t));\n            }\n            catch (err)\n            {\n                g.reportError(err);\n            }\n\n            // if (parseInt(obj['feed']['openSearch$itemsPerPage']['$t']) < parseInt(obj['feed']['openSearch$totalResults']['$t']))\n            // {\n\n            // }\n\n            callback(obj);\n        }\n    }\n\n    g.XHR({\n        type: 'GET',\n        url: url,\n        cb: handleResponse\n    });\n};\n\nself.loadedContacts = false;\nself.loadContacts = function(callback)\n{\n    if (self.loadedContacts)\n    {\n        return;\n    }\n\n    self.loadedContacts = true;\n\n    // Ensure that all local contacts have been loaded before loading the remote contacts\n    d.loadLocalContacts();\n\n    var loadedContacts = d.numContacts();\n\n    self.getContactInfo(/*name*/undefined, function (data)\n    {\n        if (!data)\n        {\n            callback(-1);\n\n            return;\n        }\n\n        log('Loading Remote Contacts!', parseInt(data['feed']['openSearch$totalResults']['$t']));\n\n        var contactCount = 0;\n        var contactsAdded = false;\n\n        if (data && data.feed && data.feed.entry && data.feed.entry.length)\n        {\n            // Ensure that any updated contacts are forwarded to the parseWorker\n            g.vmMain.notifyContactsUpdated();\n\n            contactCount = data.feed.entry.length;\n\n            var entries = data.feed.entry;\n\n            for(var i = 0; i < entries.length; i ++)\n            {\n                var entry = entries[i];\n\n                var contact =\n                {\n                    id: (/\\/([^\\s\\/]+$)/ig.exec(entry['id']['$t']))[1],\n                    text: ''\n                };\n\n                if (entry['gd$name'] && entry['gd$name']['gd$fullName'])\n                {\n                    var text = entry['gd$name']['gd$fullName']['$t'];\n                    contact.text = text;\n\n                    // Remove leading ' from names that screw up sorting\n                    if(contact.text[0] == \"'\")\n                    {\n                        contact.text = contact.text.substr(1);\n                    }\n                }\n\n                if (entry['gd$email'])\n                {\n                    var emails = entry['gd$email'];\n                    contact.emails = emails;\n\n                    for (var u = 0; u < emails.length; u ++)\n                    {\n                        delete contact.emails[u].rel;\n\n                        // If contact has no text use email as text\n                        if (!contact.text && contact.emails[u].primary)\n                        {\n                            contact.text = contact.emails[u].address;\n                        }\n                    }\n                    // If contact has no text or primary email use first email as text\n                    if(!contact.text && emails.length > 0)\n                    {\n                        contact.text = contact.emails[0].address;\n                    }\n                }\n\n                if (entry['gd$phoneNumber'])\n                {\n                    var phoneNumbers = entry['gd$phoneNumber'];\n                    contact.phoneNumbers = [ ];\n                    for (var u = 0; u < phoneNumbers.length; u ++)\n                    {\n                        var phoneNumber =\n                        {\n                            number: phoneNumbers[u]['$t']\n                        };\n\n                        if (phoneNumbers[u].rel)\n                        {\n                            phoneNumber.type = phoneNumbers[u].rel.replace('http://schemas.google.com/g/2005#', '');\n                        }\n                        else\n                        {\n                            phoneNumber.type = phoneNumbers[u].label;\n                        }\n\n                        contact.phoneNumbers.push(phoneNumber);\n                    }\n                }\n\n                if(!contact.text)\n                {\n                    // This contact has no text or email address so skip it\n                    if (DEBUG) log('Contact entry with no name or email address', entry);\n                    continue;\n                }\n\n                if (entry['link'])\n                {\n                    var links = entry['link'];\n                    for (var u = 0; u < links.length; u ++)\n                    {\n                        if (links[u].type.startsWith('image') && links[u]['gd$etag'] !== undefined)\n                        {\n                            var url = links[u].href;// + '&alt=json';\n                            contact.avatar = url;\n                        }\n                    }\n                }\n\n                if (loadedContacts === 0)\n                {\n                    d.addContact(contact, false);\n                    contactsAdded = true;\n                }\n                else\n                {\n                    contactsAdded = d.updateContact(contact, false) || contactsAdded;\n                }\n            }\n        }\n\n        if(contactCount > 0)\n        {\n            d.saveContacts();\n        }\n\n        if(contactsAdded)\n        {\n            d.sortContacts();\n        }\n\n\n        if (callback)\n        {\n            callback(contactCount);\n        }\n    });\n};\n\nfunction showErrorMessage()\n{\n    g.messageQueue.pushMessage({\n        text: 'There was an internal error in Google Drive, refresh to try again in a couple minutes.',\n        type: MessageType.Error,\n        action: MessageAction.Reload\n    });\n\n    g.vmMain.setGDriveStatus(DriveStatus.Offline);\n}\n\n//\n// Drive / Realtime\n//\n\n// We only want to create a single realtime doc for the user (for now). Ensure that we\n// check if the user already has a doc created by us and use that instead of creating a\n// new doc.\nfunction openDefaultRealtimeFile(callback)\n{\n    g.vmMain.setGDriveStatus(DriveStatus.Connecting);\n\n    gapi.client.load('drive', 'v2', function ()\n    {\n        if(!gapi.client.drive)\n        {\n            showErrorMessage();\n            return;\n        }\n\n        var queryString = \"(title='\"+self.LEGACY_DefaultDriveDocTitle+\"' or properties has {key='\"+self.DefaultProperty+\"' and value='\"+self.DefaultPropertyValue+\"' and visibility='PRIVATE'}) and 'me' in owners and trashed=false\"\n\n        gapi.client.drive.files.list(\n        {\n            // 'maxResults': 1, // TODO: Why does maxResults of 1 not work?\n            'fields': docFields,\n            'q': queryString\n        }).execute(function (results)\n        {\n            if (!results || !results.items)\n            {\n                if (results && (results.code !== 200 && results.error))\n                {\n                    showErrorMessage();\n                }\n                else\n                {\n                    createDefaultRealtimeFile(callback);\n                }\n            }\n            else\n            {\n                callback(results.items[0], /*newDoc*/false);\n            }\n        });\n    });\n}\n\nfunction deleteRealtimeFile(fileId, callback)\n{\n    gapi.client.drive.files.delete({\n        'fileId': fileId\n    }).execute(callback);\n}\n\n// self.reset = function(id, callback)\n// {\n//     g.Assert(callback, 'Callback must be defined');\n\n//     gapi.client.load('drive', 'v2', function ()\n//     {\n//         if (id)\n//         {\n//             deleteRealtimeFile(id, function ()\n//             {\n//                 callback();\n//             });\n//         }\n//         else\n//         {\n//             gapi.client.drive.files.list(\n//             {\n//                 'fields': docFields,\n//                 'q': 'title=' + \"'\" + self.LEGACY_DefaultDriveDocTitle + \"'\"\n//             }).execute(function (results)\n//             {\n//                 if (results.items)\n//                 {\n//                     var num = results.items.length;\n//                     var deleted = 0;\n//                     function deleteCallback()\n//                     {\n//                         deleted ++;\n//                         if (num == deleted)\n//                         {\n//                             callback();\n//                         }\n//                     }\n\n//                     for (var i = 0; i < num; i ++)\n//                     {\n//                         deleteRealtimeFile(results.items[i].id, deleteCallback);\n//                     }\n//                 }\n//                 else\n//                 {\n//                     g.Assert(false, 'Nothing to delete');\n//                 }\n//             });\n//         }\n//     });\n\n//     self.clearDocInfo();\n// };\n\nself.setDocInfo = function(id, title)\n{\n    g.settings.set(Settings.gdocId, id);\n    g.settings.set(Settings.gdocTitle, title);\n\n    //self.docTitle(title);\n};\n\nself.getDocId = function ()\n{\n    return g.settings.get(Settings.gdocId);\n};\n\nif (DEBUG)\n{\n    window.__GetDocId = self.getDocId.bind(self);\n}\n\n// self.isDefaultDoc = function ()\n// {\n//     var loadedTitle = g.settings.get(Settings.gdocTitle);\n\n//     return !loadedTitle || (loadedTitle === self.LEGACY_DefaultDriveDocTitle);\n// };\n\nself.clearDocInfo = function()\n{\n    g.settings.reset(Settings.gdocId);\n    g.settings.reset(Settings.gdocTitle);\n\n    //self.docTitle('Default Document');\n};\n\n// If a doc has not been created for us yet, this will create one. For now, leave the doc\n// visible through your google drive management page.\nfunction createDefaultRealtimeFile(callback)\n{\n    gapi.client.load('drive', 'v2', function ()\n    {\n        gapi.client.drive.files.insert({\n            'resource':\n            {\n                'mimeType': self.REALTIME_MIMETYPE,\n                'title': self.DefaultDocTitle,\n                'writersCanShare': false,\n                'properties':\n                [\n                    {\n                        'key': self.DefaultProperty,\n                        'value': self.DefaultPropertyValue,\n                        'visibility': 'PRIVATE'\n                    }\n                ]\n            }\n        }).execute(function (docInfo)\n        {\n            if (docInfo.code !== 200 && docInfo.error)\n            {\n                showErrorMessage();\n            }\n            else\n            {\n                var loadFileID = util.getURLParam('file');\n\n                // In the case where a user has had a file shared with them and this is their first file,\n                // after we have created their default file, open the requested shared file.\n                if (loadFileID)\n                {\n                    try\n                    {\n                        g.Assert(gapi.drive, 'gapi.drive should exist');\n\n                        util.removeURLParam('file');\n\n                        gapi.drive.realtime.load(loadFileID, onDocLoaded, onDocInitialized, onDocLoadError);\n                    }\n                    catch (err)\n                    {\n                        g.reportError(err);\n                    }\n                }\n                else\n                {\n                    callback(docInfo, /*newDoc*/true);\n                }\n            }\n        });\n    });\n}\n\nfunction onFirstDocInitialized(doc)\n{\n    log('First Run Drive Document');\n\n    onDocInitialized(doc);\n\n    if (self.authenticatedUserEmail())\n    {\n        g.sendEvent('Subscribe', 'NewUser');\n\n        g.reportSignup(self.authenticatedUserEmail());\n    }\n    else\n    {\n        var userSub = self.authenticatedUserEmail.subscribe(function (newValue)\n        {\n            userSub.dispose();\n            userSub = undefined;\n\n            g.sendEvent('Subscribe', 'NewUser');\n\n            g.reportSignup(self.authenticatedUserEmail());\n        });\n    }\n}\n\nfunction onDocInitialized(doc)\n{\n    log('Drive Document Initialized');\n\n    gdata.onInitialized(doc);\n\n    if (self.authenticatedUserEmail())\n    {\n        g.sendEvent('Documents', 'CreateNew');\n    }\n    else\n    {\n        var userSub = self.authenticatedUserEmail.subscribe(function (newValue)\n        {\n            userSub.dispose();\n            userSub = undefined;\n\n            g.sendEvent('Documents', 'CreateNew');\n        });\n    }\n}\n\nfunction onDocLoaded(doc)\n{\n    if (DEBUG) log('Drive document load started: ', log.now());\n\n    g.vmMain.setGDriveStatus(DriveStatus.Saved);\n    var success = gdata.onLoad(doc);\n\n    if(success)\n    {\n        if (DEBUG) log('Drive document load done: ', log.now());\n\n        gdata.onRemoteSettingsLoad();\n\n        self.startWatchdog();\n    }\n}\n\nfunction onDocLoadError(e)\n{\n    if (ShouldLog(LogLevels.Error)) log('Doc Load Error - ', JSON.stringify(e));\n\n    switch (e.type)\n    {\n        case gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED:\n            g.Assert(!e.isFatal, 'Token refresh required causes a non-fatal error');\n\n            self.recoverFromError();\n\n            break;\n        case gapi.drive.realtime.ErrorType.INVALID_COMPOUND_OPERATION:\n            g.Assert(e.isFatal, 'Invalid compound operation causes a fatal error');\n\n            if (ShouldLog(LogLevels.Error)) log('RealtimeAPI Error: [' + e.type + '] Fatal: ' + e.isFatal);\n\n            break;\n        case gapi.drive.realtime.ErrorType.CONCURRENT_CREATION:\n        case gapi.drive.realtime.ErrorType.CLIENT_ERROR:\n            if (ShouldLog(LogLevels.Error)) log('RealtimeAPI Error: [' + e.type + '] Fatal: ' + e.isFatal);\n\n            self.clearDocInfo();\n            findAndLoadDoc();\n\n            break;\n        case gapi.drive.realtime.ErrorType.FORBIDDEN:\n        case gapi.drive.realtime.ErrorType.NOT_FOUND:\n            if (ShouldLog(LogLevels.Error)) log('Unable to access or find the requested document');\n\n            g.reportError(new Error('DocError Forbidden/NotFound: ' + JSON.stringify(e)));\n\n            d.clearData(function ()\n            {\n                g.reload();\n            });\n\n            break;\n        case gapi.drive.realtime.ErrorType.SERVER_ERROR:\n            g.Assert(e.isFatal, 'Server errors are always fatal');\n\n            log('SERVER_ERROR');\n\n            g.vmMain.setGDriveStatus(DriveStatus.Offline);\n\n            break;\n        default:\n            if (ShouldLog(LogLevels.Error)) log('Unkown Doc Error - ', JSON.stringify(e));\n\n            break;\n    }\n\n    if (e.isFatal)\n    {\n        gdata.close(e);\n    }\n}\n\nvar lastRecoverTime = 0;\nvar lastRefreshWait = DEFAULT_REFRESH_WAIT;\nself.recoverFromError = function(err)\n{\n    if (err)\n    {\n        if (ShouldLog(LogLevels.Error)) log('GDrive Error: ', err);\n\n        g.reportError(err);\n    }\n\n    g.vmMain.setGDriveStatus(DriveStatus.Connecting);\n\n    refreshAuthorization(function (token)\n    {\n        if (!token || token.error)\n        {\n            g.messageQueue.pushMessage(MessageID.ConnectionError);\n\n            g.vmMain.setGDriveStatus(DriveStatus.Offline);\n\n            var errorMessage = 'Unable to refresh authentication token - ';\n\n            var sendReport = true;\n            if (!token)\n            {\n                errorMessage += 'No Token';\n            }\n            else\n            {\n                errorMessage += token.error;\n\n                if (token.error === 'immediate_failed')\n                {\n                    sendReport = false;\n                }\n            }\n\n            if (sendReport)\n            {\n                g.reportError(new Error(errorMessage));\n            }\n\n            // Since we failed to reauthenticate, setup a retry for some amount of time in the\n            // future. There is a maximum number of retries and stop retrying when we successfully\n            // reauth.\n            if (lastRefreshWait < MAX_REFRESH_WAIT)\n            {\n                setTimeout(self.recoverFromError, lastRefreshWait);\n                lastRefreshWait *= 2;\n            }\n        }\n    });\n};\n\nfunction loadDoc(newDoc)\n{\n    var docId = self.getDocId();\n\n    if (!docId)\n    {\n        // If no doc ID has been cached yet, go ahead and look for one and cache its ID locally\n        findAndLoadDoc();\n    }\n    else\n    {\n        // If a doc ID has already been cached, assume it is valid and try to load it\n        if (DEBUG) log('Drive document requested: ', log.now());\n\n        try\n        {\n            var initFn = newDoc ? onFirstDocInitialized : onDocInitialized;\n            gapi.drive.realtime.load(docId, onDocLoaded, initFn, onDocLoadError);\n        }\n        catch (err)\n        {\n            self.recoverFromError(err);\n        }\n    }\n}\n\nfunction findAndLoadDoc()\n{\n    openDefaultRealtimeFile(function (docInfo, newDoc)\n    {\n        if (docInfo && docInfo.id)\n        {\n            self.setDocInfo(docInfo.id, docInfo.title);\n\n            loadDoc(newDoc);\n        }\n        else\n        {\n            g.reportError(new Error('We should always find a valid document with a defined id'));\n        }\n\n        if (newDoc)\n        {\n            g.fireCustomEvent('firstRun');\n        }\n    });\n}\n\nself.getActiveUser = function(cb)\n{\n    if (self.getAccessToken())\n    {\n        // If the authenticated user is already set, simply return it. The active user should not changed\n        // over the course of the app running.\n        if (!self.authenticatedUserEmail())\n        {\n            var url = 'https://www.googleapis.com/oauth2/v2/userinfo?alt=json&access_token=' + self.getAccessToken();\n\n            g.XHR({\n                type: 'GET',\n                url: url,\n                cb: function (xhr)\n                {\n                    if (xhr.status === 200)\n                    {\n                        var obj = JSON.parse(xhr.responseText);\n\n                        self.authenticatedUserEmail(obj.email);\n                        //self.authenticatedUser(obj);\n                    }\n\n                    if (cb) { cb(self.authenticatedUserEmail()); }\n                }\n            });\n        }\n        else\n        {\n            if (cb) { cb(self.authenticatedUserEmail()); }\n        }\n    }\n    else\n    {\n        if (cb) { cb(self.authenticatedUserEmail()); }\n    }\n};\n\n// Callin point on page load to intiialize the google realtime api and open our realtime doc.\nvar loadedClientDefaultFile = false;\nself.loadClientDefaultFile = function()\n{\n    var mainLoaded = !!g.vmMain;\n    var driveLoaded = !!window.gapi && !!window.gapi.drive && !!window.gapi.drive.realtime;\n\n    if (!loadedClientDefaultFile && mainLoaded && driveLoaded)\n    {\n        var token = getAccessTokenInternal();\n\n        if (token && (g.getLoginState() == LoginState.LOGGED_IN))\n        {\n            loadedClientDefaultFile = true;\n\n            if (DEBUG) log('Loading Default Client File: ', log.now());\n            g.vmMain.setGDriveStatus(DriveStatus.Connecting);\n\n            // Grab the currently logged in user for the authenticated account.\n            self.getActiveUser(function (newUser)\n            {\n                // Verify that the local data corresponds to the currently active user.\n                var prevUser = g.settings.get(Settings.activeUser);\n\n                // If the newUser is undefined, we failed a remote request, this shouldnt be enough\n                // to decide a different user is now logged in, so do not reset data.\n                if (prevUser && newUser && newUser !== prevUser)\n                {\n                    // If the active user is different, reset the local data and reload the page.\n                    d.clearData(function ()\n                    {\n                        g.reload();\n                    });\n                }\n                else if (!prevUser && newUser)\n                {\n                    // If the active user was not set, save it away for later.\n                    g.settings.set(Settings.activeUser, newUser);\n                }\n            });\n\n            loadDoc();\n\n            self.loadCalendarAndContacts();\n\n            // Load user info\n            // gapi.client.load('oauth2', 'v2', function()\n            // {\n            //     var request = gapi.client.oauth2.userinfo.get();\n\n            //     request.execute(function (obj)\n            //     {\n            //         if (obj && obj.email)\n            //         {\n            //             log('Authenticated User: ', obj.email);\n\n            //             self.authenticatedUserEmail(obj.email);\n            //         }\n            //     });\n            // });\n        }\n    }\n};\n\n//\n// Authentication / Authorization\n//\n\nfunction saveAuthorizedScopes()\n{\n    if (DEBUG) log('Saving Scopes: ');\n\n    var scopeArr = [ ];\n\n    for (var i = 0; i < authorizedScopes.length; ++i)\n    {\n        var scopeIndex = self.scopes.indexOf(authorizedScopes[i]);\n\n        //g.Assert(scopeIndex >= 0, 'Scopes should always be found');\n\n        var forceNoSave = noSaveScopes.indexOf(authorizedScopes[i]) >= 0;\n\n        if (DEBUG && forceNoSave)\n        {\n            log('Skipping scope save: ', authorizedScopes[i]);\n        }\n\n        if (scopeIndex >= 0 && !forceNoSave)\n        {\n            scopeArr.push(scopeIndex);\n        }\n\n        if (DEBUG) log(' :', authorizedScopes[i]);\n    }\n\n    var saveString = JSON.stringify(scopeArr);\n\n    g.settings.set(Settings.authScopes, saveString);\n}\n\nfunction handleContactsLoaded(numContacts)\n{\n    if (numContacts > 0)\n    {\n        g.vmMain.runParseWorkerNewContacts();\n    }\n}\n\nself.authAndLoadContacts = function(cb)\n{\n    if (g.settings.get(Settings.syncContacts))\n    {\n        if (authorizedScopes.indexOf(GScope.Contacts) < 0)\n        {\n            self.runAuthenticate([GScope.Contacts], /*runImmediate*/true, /*retry*/true, function (token)\n            {\n                if (!token || token.error)\n                {\n                    authorizedScopes.push(GScope.Contacts);\n                    saveAuthorizedScopes();\n\n                    g.messageQueue.pushMessage({\n                        text: 'Contact sync is enabled but permissions have been lost, ' + platform.verb() + ' here to find it again.',\n                        type: MessageType.Error,\n                        action: self.authAndLoadContacts\n                    });\n\n                    if (cb) { cb(false); }\n                }\n                else\n                {\n                    self.loadContacts(function (numContacts)\n                    {\n                        handleContactsLoaded(numContacts);\n\n                        if (cb && numContacts > 0) { cb(true); }\n                    });\n                }\n            });\n        }\n        else\n        {\n            self.loadContacts(function (numContacts)\n            {\n                handleContactsLoaded(numContacts);\n\n                if (cb && numContacts > 0) { cb(true); }\n            });\n        }\n    }\n};\n\nself.authDocSharing = function()\n{\n    // if (g.settings.get(Settings.docSharing))\n    // {\n    //     if (authorizedScopes.indexOf(GScope.DriveFull) < 0)\n    //     {\n    //         self.runAuthenticate([ GScope.DriveFull ], /*runImmediate*/true, /*retry*/true, function (token)\n    //         {\n    //             if (!token || token.error)\n    //             {\n    //                 authorizedScopes.push(GScope.DriveFull);\n    //                 saveAuthorizedScopes();\n\n    //                 g.messageQueue.pushMessage({\n    //                     text: 'Document sharing is enabled but permissions have been lost, ' + platform.verb() + ' here to find it again.',\n    //                     type: MessageType.Error,\n    //                     action: self.authDocSharing\n    //                 });\n    //             }\n    //         });\n    //     }\n    // }\n};\n\nself.loadCalendarAndContacts = function()\n{\n    if(!window.gapi)\n        return;\n\n    //if (g.settings.get(Settings.syncGoogle))\n    {\n        // gapi.client.load('calendar', 'v3', function ()\n        // {\n        //     self.updateCalendarList();\n        // });\n\n        self.authAndLoadContacts();\n    }\n};\n\nif (DEBUG)\n{\n    window.__AUTH_REQUESTS = g.createRingBuffer(10);\n}\n\nself.checkTokenInHash = function()\n{\n    var setToken = false;\n\n    if (util.hasURLParam('access_token'))\n    {\n        try\n        {\n            var scopeString = util.getURLParam('scope');\n\n            var token =\n            {\n                access_token: util.getURLParam('access_token'),\n                expires_in: util.getURLParam('expires_in'),\n                scope: scopeString.split('+')\n            };\n\n            gapi.auth.setToken(token);\n\n            setToken = true;\n\n            util.removeURLParam('access_token', true);\n            util.removeURLParam('expires_in', true);\n            util.removeURLParam('scope', true);\n            util.removeURLParam('token_type', true);\n        }\n        catch (err)\n        {\n            g.reportError(err);\n        }\n    }\n\n    return setToken;\n};\n\nself.runAuthenticate = function (requestScopes, runImmediate, retry, callback)\n{\n    if (!window.gapi || !window.gapi.auth)\n    {\n        if (callback)\n        {\n            callback();\n        }\n\n        return false;\n    }\n\n    if (!self.gapiLoaded)\n    {\n        //g.events.emit('gapi_loaded');\n        g.fireCustomEvent('gapiLoaded');\n\n        self.gapiLoaded = true;\n    }\n\n    var currentToken = undefined;\n\n    try\n    {\n        currentToken = gapi.auth.getToken();\n    }\n    catch (err)\n    {\n        g.reportError(err);\n    }\n\n    if (DEBUG) log('Request Scopes: ', requestScopes);\n    if (DEBUG) log('Current OAuth2 Token: ', currentToken);\n\n    var requiredScopesToRequest;\n    if (!currentToken)\n    {\n        requiredScopesToRequest = requestScopes;\n    }\n    else\n    {\n        requiredScopesToRequest = currentToken.scope;\n\n        if (!g.isArray(requiredScopesToRequest))\n        {\n            g.reportError(new Error('Scopes are not an array: ' + requiredScopesToRequest));\n\n            if (g.isString(requiredScopesToRequest))\n            {\n                try\n                {\n                    requiredScopesToRequest = currentToken.scope.split(' ');\n                }\n                catch (err)\n                {\n                    g.reportError(err);\n                }\n            }\n        }\n\n        var numScopesAdded = 0;\n        for (var i = 0; i < requestScopes.length; ++i)\n        {\n            if (currentToken.scope.indexOf(requestScopes[i]) < 0)\n            {\n                requiredScopesToRequest.push(requestScopes[i]);\n                numScopesAdded++;\n            }\n        }\n\n        // If there are no new scopes being requested, skip sending an authorization request\n        if (numScopesAdded === 0)\n        {\n            requiredScopesToRequest = [ ];\n        }\n    }\n\n    if (DEBUG) log('Require Scopes To Request: ', requiredScopesToRequest);\n\n    if (requiredScopesToRequest.length > 0)\n    {\n        // Some scopes are a superset of others, prune scopes that duplicate permissions.\n        if (requiredScopesToRequest.indexOf(GScope.DriveFull) >= 0)\n        {\n            requiredScopesToRequest.remove(GScope.Drive);\n        }\n\n        var userId = self.authenticatedUserEmail() || g.settings.get('activeUser');\n\n        var config = {\n            'client_id': self.CLIENT_ID,\n            'scope': requiredScopesToRequest,\n            'immediate': runImmediate,\n            'user_id': userId,\n            'authuser': runImmediate ? 0 : -1\n        };\n\n        if (platform.requireCustomRedirect && !runImmediate)\n        {\n            config['redirect_uri'] = platform.customRedirectString;\n\n            if (platform.customRedirectState)\n            {\n                if (requiredScopesToRequest.indexOf(GScope.Contacts) >= 0)\n                {\n                    platform.customRedirectState.syncContacts = true;\n                }\n\n                config['state'] = JSON.stringify(platform.customRedirectState);\n            }\n        }\n\n        if (DEBUG) log('AuthScopes: ', config.scope);\n\n        refreshingAuth = true;\n\n        if (DEBUG)\n        {\n            var tokenString = 'runAuthenticate: ' + (currentToken ? JSON.stringify(currentToken) : 'undefined');\n            window.__AUTH_REQUESTS.push(g.getCurrentStack(tokenString));\n        }\n\n        gapi.auth.authorize(config, function (token)\n        {\n            refreshingAuth = false;\n\n            if (DEBUG) log('Returned Scopes: ', token);\n\n            if (DEBUG) log('GAPI Authorized: ', log.now());\n\n            //log(Date.now(), ': GAPI Authorized', gapi.auth.getToken());\n\n            if ((!token || token.error) && runImmediate && retry)\n            {\n                self.runAuthenticate(requiredScopesToRequest, /*runImmediate*/false, /*retry*/false, callback);\n            }\n            else\n            {\n                if (token && !token.error)\n                {\n                    if (platform.app || util.hasURLParam('login', 'true'))\n                    {\n                        if (g.vmSetup)\n                        {\n                            g.vmSetup.setLoginState(LoginState.LOGGED_IN);\n                        }\n                        else\n                        {\n                            g.setLoginState(LoginState.LOGGED_IN);\n                        }\n\n                        self.loadClientDefaultFile();\n                    }\n                }\n\n                handleAuthorization(token, callback);\n            }\n        });\n    }\n    else\n    {\n        if (ShouldLog(LogLevels.Error)) log('Authorization request with no scopes: ', requiredScopesToRequest);\n\n        if (callback)\n        {\n            callback(currentToken);\n        }\n    }\n\n    return true;\n};\n\n// Handle an authorization error. This may mean that we log the user out as it was a critical failure,\n// otherwise we should display a message complaining about the failure. If this function returns true,\n// execution should continue, otherwise we have bailed out of the app completely.\n// function handleAuthError()\n// {\n//     if (g.vmSetup.loginState() == LoginState.LOGGED_IN)\n//     {\n//         g.vmSetup.setLoginState(LoginState.LOGGED_OUT);\n\n//         setTimeout(function()\n//         {\n//             g.reload();\n//         }, 0);\n//     }\n// }\n\n// Used to track the iframes injected into the page by gapi when refreshing auth tokens.\nvar authIndex = 0;\n\nfunction frameIdx(frame)\n{\n    return parseInt(frame.id.split('_')[1]);\n}\n\n// The OAuth2 token has an expiration time at which point we need to refresh it\nfunction handleAuthorization(token, callback)\n{\n    if (token && !token.error)\n    {\n        g.Assert(token.scope, 'Scopes must be valid');\n\n        if (g.isString(token.scope))\n        {\n            token.scope = token.scope.split(' ');\n        }\n\n        //g.Assert(ko.utils.arrayGetDistinctValues(authorizedScopes.concat(token.scope)).length >= self.requiredScopes.length, 'We lost some required scopes somewhere...');\n\n        var oldAuthorizedScopes = authorizedScopes;\n\n        var newAuthorizedScopes = ko.utils.arrayGetDistinctValues(token.scope);\n        authorizedScopes = newAuthorizedScopes;\n\n        if (oldAuthorizedScopes.length !== newAuthorizedScopes.length || oldAuthorizedScopes !== newAuthorizedScopes)\n        {\n            saveAuthorizedScopes();\n        }\n\n        //log('Authorized Token: ', token);\n\n        var expireMS = ((parseInt(token.expires_in) - 600) * 1000);\n        log('Token expires in', (expireMS / 1000));\n        authorizedUntil = Date.now() + expireMS;\n\n        clearTimeout(refreshAuthorizationTimer);\n\n        refreshAuthorizationTimer = setTimeout(function ()\n        {\n            refreshAuthorization();\n        }, expireMS);\n\n        lastRefreshWait = DEFAULT_REFRESH_WAIT;\n\n        gdata.poke();\n\n        setTimeout(function ()\n        {\n            var iframes = document.getElementsByTagName('iframe');\n\n            for (var i = 0; i < iframes.length; ++i)\n            {\n                if (iframes[i].src.startsWith('https://accounts.google.com/o/oauth2/auth?'))\n                {\n                    if (iframes[i].id === '')\n                    {\n                        // Found the new iframe, set its ID\n                        iframes[i].id = 'auth_' + authIndex++;\n                        //log('Marking iframe: ' + iframes[i].id);\n                    }\n                    else\n                    {\n                        var idx = frameIdx(iframes[i]);\n                        if (idx !== authIndex && idx !== authIndex - 1)\n                        {\n                            //log('Removing iframe: ' + iframes[i].id);\n                            iframes[i].parentElement.removeChild(iframes[i]);\n                        }\n                    }\n                }\n            }\n        }, 0);\n    }\n    else\n    {\n        log('Error authorizing token' + (token ? token.error : ''));\n    }\n\n    if (callback)\n    {\n        callback(token);\n    }\n}\n\nvar tokenRefreshed = false;\n\nfunction refreshAuthorization(cb)\n{\n    if (!gapi || !gapi.auth || !gapi.auth.authorize)\n    {\n        cb(undefined);\n        return false;\n    }\n\n    if (DEBUG) log(Date.now(), ': Refreshing OAuth2 Token: ', authorizedScopes);\n    if (DEBUG) log(Date.now(), ': Current Token: ', gapi.auth.getToken());\n\n    g.Assert(authorizedScopes.length >= self.requiredScopes.length, 'We lost some required scopes somewhere...');\n\n    refreshingAuth = true;\n\n    if (DEBUG)\n    {\n        var tokenString = 'refreshAuthorization: ';\n        var currentToken = gapi.auth.getToken()\n        tokenString += (currentToken ? JSON.stringify(currentToken) : 'undefined');\n\n        window.__AUTH_REQUESTS.push(g.getCurrentStack(tokenString));\n    }\n\n    var userId = self.authenticatedUserEmail() || g.settings.get('activeUser');\n\n    var config = {\n        'client_id': self.CLIENT_ID,\n        'scope': authorizedScopes,\n        'immediate': true,\n        'user_id': userId,\n    };\n\n    gapi.auth.authorize(config, function (token)\n    {\n        // Used by goOnline to determine whether a token authorization was successful\n        tokenRefreshed = true;\n\n        refreshingAuth = false;\n\n        if (DEBUG) log(Date.now(), ': Refreshed OAuth2 Token: ', token);\n        if (DEBUG) log(Date.now(), ': New Token: ', gapi.auth.getToken());\n\n        handleAuthorization(token, cb);\n    });\n\n    return true;\n}\n\nself.isDriveAPILoaded = function()\n{\n    return window.gapi && window.gapi.client && window.gapi.client.drive;\n};\n\nself.isRealtimeAPILoaded = function()\n{\n    return window.gapi && window.gapi.client && window.gapi.drive && window.gapi.drive.realtime;\n};\n\nvar RELOAD_TIMEOUT = 10000;\n\nvar numTriesLoad = 0;\nvar isLoadingScript = false;\nfunction tryToLoadGapi()\n{\n    if (!self.isRealtimeAPILoaded())\n    {\n        if (DEBUG) { log('Reloading GAPI'); }\n\n        var oldScript = document.getElementById('gapiScript');\n\n        if (oldScript)\n        {\n            oldScript.parentNode.removeChild(oldScript);\n        }\n\n        g.addScript('https://apis.google.com/js/client.js?onload=GoogleApiLoaded', 'gapiScript', function ()\n        {\n            isLoadingScript = false;\n        });\n\n        if (numTriesLoad-- > 0)\n        {\n            setTimeout(tryToLoadGapi, RELOAD_TIMEOUT);\n        }\n        else\n        {\n            isLoadingScript = false;\n        }\n    }\n    else\n    {\n        isLoadingScript = false;\n    }\n}\n\nfunction tryToRefreshToken()\n{\n    if (!tokenRefreshed)\n    {\n        refreshAuthorization();\n        setTimeout(tryToRefreshToken, RELOAD_TIMEOUT);\n    }\n    else\n    {\n        g.vmMain.setGDriveStatus(DriveStatus.Saved);\n\n        g.messageQueue.clearMessage(MessageID.ConnectionError);\n    }\n}\n\nself.goOnline = function()\n{\n    numTriesLoad = 2;\n\n    if (!self.isRealtimeAPILoaded())\n    {\n        if (!isLoadingScript)\n        {\n            isLoadingScript = true;\n\n            setTimeout(tryToLoadGapi, 2000);\n        }\n\n        return false;\n    }\n    else\n    {\n        tokenRefreshed = false;\n        setTimeout(tryToRefreshToken, 2000);\n\n        return true;\n    }\n};\n\nself.init();\n\nreturn self;\n});","asserts":[{"tag":1036,"offset":3840},{"tag":1037,"offset":9881},{"tag":1038,"offset":11645},{"tag":1039,"offset":12845},{"tag":1040,"offset":14667},{"tag":1041,"offset":15230},{"tag":1042,"offset":15329},{"tag":1043,"offset":15566},{"tag":1044,"offset":15842},{"tag":1045,"offset":18177},{"tag":1046,"offset":19869},{"tag":1047,"offset":22388},{"tag":1048,"offset":32635},{"tag":1049,"offset":33897},{"tag":1050,"offset":36018},{"tag":1051,"offset":38102},{"tag":1052,"offset":38316},{"tag":1053,"offset":39314},{"tag":1054,"offset":45969},{"tag":1055,"offset":55694},{"tag":1056,"offset":55860},{"tag":1057,"offset":58351}]},"data":{"path":"F:/p/bce/Duchess/public/js/data.js","data":"define(['globals', 'util', 'gdata', 'db', 'demo', 'platform'],\r\nfunction (g, util, gdata, db, demo, platform) {\r\n\r\nvar DB_CONTACTS = 'ctcs';\r\n\r\nvar DB_HELP_INTRO = 'helpIntro';\r\nvar DB_HELP_NORMAL = 'helpNormal';\r\n\r\nvar defaultContactNames = {\r\n    '___info___': {\r\n        'count': 0\r\n    }\r\n};\r\n//\r\n// Initialize local storage.\r\n//\r\nvar self = {\r\n    contacts: [ ],\r\n    contactsByName: {},\r\n    contactNames: defaultContactNames,\r\n    //models: { },\r\n    pendingRemoteUpdates: { },\r\n    itemsById: { },\r\n    loadedItemCount: 0,\r\n    hasLocalData: false,\r\n    freezeUpdates: false,\r\n    dbi: undefined\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    window.__getContacts = function ()\r\n    {\r\n        return self.contacts;\r\n    };\r\n\r\n    window.__getContactsByName = function ()\r\n    {\r\n        return self.contactsByName;\r\n    };\r\n}\r\n\r\nif (REPORT_ACTIONS)\r\n{\r\n\r\nself.reportData = function (loc)\r\n{\r\n    if (!util.hasURLParam('nosync'))\r\n    {\r\n        var rData = { };\r\n\r\n        for (var id in self.itemsById)\r\n        {\r\n            rData[id] = self.itemsById[id].data;\r\n        }\r\n\r\n        g.reportData(rData, loc);\r\n    }\r\n};\r\n\r\n}\r\n\r\nvar contactSaveTimer;\r\n\r\nself.getModel = function (id)\r\n{\r\n    g.Assert(id, \"Tried to get a model that doesn't exist\");\r\n\r\n    var entry = self.itemsById[id];\r\n\r\n    return entry ? entry.model : undefined;\r\n};\r\n\r\nself.setModel = function (id, model)\r\n{\r\n    g.Assert(id, 'Tried to set a model with an invalid id');\r\n\r\n    if (self.itemsById[id])\r\n    {\r\n        self.itemsById[id].model = model;\r\n    }\r\n    else\r\n    {\r\n        self.itemsById[id] = { model: model, data: undefined };\r\n    }\r\n};\r\n\r\nself.getItem = function (id)\r\n{\r\n    g.Assert(id, \"Tried to get an item that doesn't exist\");\r\n\r\n    var entry = self.itemsById[id];\r\n\r\n    return entry ? entry.data : undefined;\r\n};\r\n\r\nself.setItem = function (id, data)\r\n{\r\n    g.Assert(id, 'Tried to set an item with an invalid id');\r\n\r\n    //log('Add item: ', id, JSON.stringify(data, null, 4));\r\n\r\n    if (self.itemsById[id])\r\n    {\r\n        self.itemsById[id].data = data;\r\n    }\r\n    else\r\n    {\r\n        self.itemsById[id] = { model: undefined, data: data };\r\n    }\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    window.__getModel = self.getModel;\r\n    window.__getItem = self.getItem;\r\n}\r\n\r\nself.getRootItem = function ()\r\n{\r\n    return self.rootId ? self.getItem(self.rootId) : undefined;\r\n};\r\n\r\nself.getRootModel = function ()\r\n{\r\n    return self.rootId ? self.getModel(self.rootId) : undefined;\r\n};\r\n\r\nself.initializeIndexedDB = function (handler)\r\n{\r\n    var version = 1;\r\n\r\n    // This is inside a setTimeout call to work around a mobile safari bug where the websql\r\n    // databases are never created for duchess on the first load. The callbacks are never called\r\n    // and the databases are not created. It looks like there are some issues running websql queries\r\n    // from inside event handlers.\r\n    function initLocalDB(initSuccess)\r\n    {\r\n        if (initSuccess)\r\n        {\r\n            db.open({\r\n                server: 'duchess',\r\n                version: version,\r\n                schema: {\r\n                    items: {\r\n                        key: {keyPath: 'id'}\r\n                    },\r\n                    settings: {\r\n\r\n                    }\r\n                }\r\n            }).done(function(server) {\r\n                self.dbi = server;\r\n\r\n                handler();\r\n            }).fail(function(e) {\r\n                log('Error loading local DB client', e);\r\n\r\n                g.preventLocalWrites();\r\n\r\n                g.reportError(e);\r\n\r\n                handler();\r\n            });\r\n        }\r\n        else\r\n        {\r\n            log('Shim failed to init.');\r\n\r\n            g.preventLocalWrites();\r\n\r\n            handler();\r\n        }\r\n    }\r\n\r\n    if (window.indexedDB.onIsReady !== undefined && window.indexedDB.onIsReady !== null)\r\n    {\r\n        window.indexedDB.onIsReady(initLocalDB);\r\n    }\r\n    else\r\n    {\r\n        setTimeout(function () { initLocalDB(/*initSuccess*/true); }, 0);\r\n    }\r\n};\r\n\r\nfunction migrateFromOldData(item)\r\n{\r\n    if (item._id)\r\n    {\r\n        // Change _id to id and make them considered temp\r\n        item.id = g.TEMP_PREFIX + item._id;\r\n        delete item._id;\r\n    }\r\n\r\n    // Delete old fields\r\n    delete item.hasLocalChange;\r\n    delete item.isLocalRoot;\r\n    delete item.modifiedOffline;\r\n    delete item.isRoot;\r\n    delete item.v;\r\n    delete item.isLayout2D;\r\n\r\n    // Add new fields to mark items to be saved remotely\r\n    item.modifiedOffline = true;\r\n    item.modifiedOfflineText = true;\r\n    item.dateCreated = Date.now();\r\n\r\n    // Convert old header style\r\n    var itemText = item.getRawText();\r\n    if (itemText.length > 0 && itemText[0] == '#')\r\n    {\r\n        item.setRawText(itemText.substr(1) + ':');\r\n    }\r\n    else if (itemText.length > 1 && itemText[0] == 'x' && itemText[1] == ' ')\r\n    {\r\n        item.setRawText('^' + itemText.substr(2));\r\n    }\r\n\r\n    // Convert old items list style\r\n    if (item.items)\r\n    {\r\n        for (var i = 0; item.items && i < item.items.length; i++)\r\n        {\r\n            var child = item.items[i];\r\n            if (child.itemRef)\r\n            {\r\n                item.items[i] = 'T' + child.itemRef;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nself.migrateLocalData_One = function()\r\n{\r\n    for (var id in self.itemsById)\r\n    {\r\n        var hasChanges = false;\r\n        var changes = { };\r\n\r\n        var item = self.getItem(id);\r\n\r\n        if (item)\r\n        {\r\n            var text = item.text;\r\n\r\n            if (text.startsWith('!'))\r\n            {\r\n                changes.priority = VMLIFlag.P0\r\n                changes.text = text.substr(1);\r\n\r\n                hasChanges = true;\r\n            }\r\n            else if (text.startsWith('*'))\r\n            {\r\n                changes.isFlagged = true;\r\n                changes.text = text.substr(1);\r\n\r\n                hasChanges = true;\r\n            }\r\n            else if (text.startsWith('^'))\r\n            {\r\n                changes.isComplete = true;\r\n                changes.text = text.substr(1);\r\n\r\n                hasChanges = true;\r\n            }\r\n\r\n            if (hasChanges)\r\n            {\r\n                self.dbUpdateItem({\r\n                    id: id,\r\n                    changes: changes,\r\n                    saveFlags: SaveFlag.None\r\n                });\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nself.migrateLocalData_Two = function()\r\n{\r\n    // Skip migration if no contacts are loaded.\r\n    if (self.contacts.length === 0)\r\n    {\r\n        log('Skipping local data migration two');\r\n        return;\r\n    }\r\n\r\n    for (var id in self.itemsById)\r\n    {\r\n        var hasChanges = false;\r\n        var changes = { };\r\n\r\n        var item = self.getItem(id);\r\n\r\n        if (item && item.text.indexOf('@') >= 0)\r\n        {\r\n            var words = item.text.split(' ');\r\n\r\n            var lineIndex = 0;\r\n            for (var i = 0; i < words.length; ++i)\r\n            {\r\n                if (words[i].indexOf('@') === 0)\r\n                {\r\n                    var matchedName = undefined;\r\n                    var combined = words[i].substring(1);\r\n                    for (var u = 1; u < 4; u ++)\r\n                    {\r\n                        var compStr = (combined.indexOf(':', combined.length - 1) !== -1) ? combined.substr(0, combined.length - 1) : combined;\r\n\r\n                        if (self.contactsByName[compStr])\r\n                        {\r\n                            matchedName = compStr;\r\n                        }\r\n\r\n                        if (i + u < words.length)\r\n                        {\r\n                            combined += ' ' + words[i + u];\r\n                        }\r\n                        else\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (matchedName)\r\n                    {\r\n                        g.Assert(item.text[lineIndex] == '@', 'Explicitly matching @, should always match');\r\n\r\n                        var text = item.text.substr(0, lineIndex) + '+' + item.text.substr(lineIndex + 1);\r\n\r\n                        changes.text = text;\r\n                        hasChanges = true;\r\n\r\n                        var model = self.getModel(id);\r\n                        if (model)\r\n                        {\r\n                            model.setRawText(text);\r\n                            model.parseText(/*immediateParse*/true);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                lineIndex += words[i].length + 1; // + 1 for space\r\n            }\r\n        }\r\n\r\n        if (hasChanges)\r\n        {\r\n            self.dbUpdateItem({\r\n                id: id,\r\n                changes: changes,\r\n                saveFlags: SaveFlag.None\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nvar isLocalDataLoaded = false;\r\n\r\nself.localDataLoaded = function()\r\n{\r\n    return isLocalDataLoaded;\r\n};\r\n\r\nself.loadFromIndexedDB = function(callback)\r\n{\r\n    g.Assert(!isLocalDataLoaded, 'Should never load local data twice');\r\n\r\n    if (DEBUG) log('Loading DB: ', log.now());\r\n\r\n    self.itemsById = { };\r\n\r\n    if (g.shouldWriteLocal() && self.dbi && self.dbi.items)\r\n    {\r\n        self.dbi.items.query().all().execute().done(function(results)\r\n        {\r\n            if (DEBUG) log('Loaded DB: ', log.now());\r\n\r\n            self.loadedItemCount = results.length;\r\n\r\n            for (var i = 0; i < results.length; ++i)\r\n            {\r\n                self.setItem(results[i].id, g.translateObjOut(results[i]));\r\n            }\r\n\r\n            isLocalDataLoaded = true;\r\n\r\n            if (self.dbi.settings)\r\n            {\r\n                self.dbi.settings.get('root').done(function(result)\r\n                {\r\n                    if (!g.criticalErrorReported())\r\n                    {\r\n                        if (result)\r\n                        {\r\n                            g.Assert(self.getItem(result.root), 'If there is a root item defined there should be a corresponding local item');\r\n\r\n                            self.rootId = result.root;\r\n                        }\r\n\r\n                        log('Root Item: ', self.rootId);\r\n\r\n                        if (callback)\r\n                        {\r\n                            callback();\r\n                        }\r\n                    }\r\n                }).fail(callback);\r\n            }\r\n            else\r\n            {\r\n                log('Unable to load local settings DB');\r\n\r\n                if (callback)\r\n                {\r\n                    callback();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    else\r\n    {\r\n        log('Unable to load local items DB');\r\n\r\n        isLocalDataLoaded = true;\r\n\r\n        g.preventLocalWrites();\r\n\r\n        if (callback)\r\n        {\r\n            callback();\r\n        }\r\n    }\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    window.__UPDATES_EXPECTED = 0;\r\n    window.__UPDATES_ACTUAL = 0;\r\n    //window.__LOCAL_UPDATE_STACKS = g.createRingBuffer(50);\r\n}\r\n\r\nvar updateTransaction = undefined;\r\n\r\nself.beginTransaction = function()\r\n{\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        updateTransaction = { };\r\n    }\r\n};\r\n\r\nself.transactionUpdate = function(id, data)\r\n{\r\n    g.Assert(g.shouldWriteLocal(), 'Should never be writing during a transaction if local writes are disabled');\r\n\r\n    if (updateTransaction[id])\r\n    {\r\n        //log('Merge Objects: ', id, JSON.stringify(updateTransaction[id], null, 4), JSON.stringify(data, null, 4));\r\n        for (var attr in data) { updateTransaction[id][attr] = data[attr]; }\r\n    }\r\n    else\r\n    {\r\n        //log('Add Object: ', id, JSON.stringify(data, null, 4));\r\n        updateTransaction[id] = data;\r\n    }\r\n}\r\n\r\nfunction transactionDoneCallback()\r\n{\r\n    //log('Transaction Done: ', arguments);\r\n}\r\n\r\nfunction transactionErrorCallback()\r\n{\r\n    log('Transaction Error: ', arguments);\r\n}\r\n\r\nself.endTransaction = function()\r\n{\r\n    if (g.shouldWriteLocal() && self.dbi && self.dbi.items)\r\n    {\r\n        if (DEBUG) log('Bundled Transactions: ' + Object.keys(updateTransaction).length);\r\n\r\n        self.dbi.items.updateObject(updateTransaction).done(transactionDoneCallback).fail(transactionErrorCallback);\r\n    }\r\n    else if (updateTransaction !== undefined)\r\n    {\r\n        g.reportError(new Error('Started a transaction and stopped writes halfway through'));\r\n    }\r\n\r\n    updateTransaction = undefined;\r\n};\r\n\r\nself.dbUpdateItem = function(params)\r\n{\r\n    if (self.freezeUpdates)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!self.hasLocalData && !g.isLoadingRemote && !params.skipLocalModification)\r\n    {\r\n        self.hasLocalData = true;\r\n    }\r\n\r\n    var changes = params.changes || { };\r\n    var id = params.id ? params.id : changes.id;\r\n    var callback = params.callback;\r\n\r\n    var saveFlags = params.saveFlags;\r\n    g.Assert(saveFlags === SaveFlag.None || saveFlags === SaveFlag.Prop || saveFlags === SaveFlag.Text || saveFlags === SaveFlag.All);\r\n\r\n    var item = self.getItem(id);\r\n\r\n    // When local writes are disabled the in-memory cache still needs to be updated, but ignore any DB writes.\r\n    if (!g.shouldWriteLocal())\r\n    {\r\n        if (item)\r\n        {\r\n            for (var prop in changes)\r\n            {\r\n                if (changes.hasOwnProperty(prop))\r\n                {\r\n                    item[prop] = changes[prop];\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            self.setItem(id, changes);\r\n        }\r\n\r\n        if (callback)\r\n        {\r\n            callback();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        var translated;\r\n\r\n        g.Assert(!saveFlags || (changes.modifiedOffline === undefined && changes.modifiedOfflineText === undefined), 'Shouldn\\'t be setting a modified flag while passing them in with changes');\r\n\r\n        if (g.isFlagSet(saveFlags, SaveFlag.Prop))\r\n        {\r\n            g.Assert(changes.modifiedOffline === undefined, 'Shouldnt be passing in a value and assigning true');\r\n\r\n            if (DEBUG) log('Marking Item Modified Offline:', (item ? item.getParsedText() : changes.text));\r\n\r\n            changes.modifiedOffline = true;\r\n\r\n            var model = self.getModel(id);\r\n            if (model)\r\n            {\r\n                model.modifiedOffline = true;\r\n            }\r\n        }\r\n\r\n        if (g.isFlagSet(saveFlags, SaveFlag.Text))\r\n        {\r\n            g.Assert(changes.modifiedOfflineText === undefined, 'Shouldnt be passing in a value and assigning true');\r\n\r\n            if (DEBUG) log('Marking Text Modified Offline:', (item ? item.getParsedText() : changes.text));\r\n\r\n            changes.modifiedOfflineText = true;\r\n\r\n            var model = self.getModel(id);\r\n            if (model)\r\n            {\r\n                model.modifiedOfflineText = true;\r\n            }\r\n        }\r\n\r\n        if (item)\r\n        {\r\n            for (var prop in changes)\r\n            {\r\n                if (changes.hasOwnProperty(prop))\r\n                {\r\n                    if (DEBUG && DEBUG)\r\n                    {\r\n                        if (prop === 'version' || prop === 'versionText')\r\n                        {\r\n                            var verStr = item[prop] + ' -> ' + changes[prop];\r\n                            window.__LOCAL_VERSION_UPDATES.push(prop + ': ' + id + ': ' + g.getCurrentStack(verStr));\r\n\r\n                            if (DEBUG) log('Setting local ' + prop + ' ' + id + ': ', verStr);\r\n                        }\r\n                    }\r\n\r\n                    item[prop] = changes[prop];\r\n                }\r\n            }\r\n\r\n            translated = g.translateObjIn(item);\r\n        }\r\n        else\r\n        {\r\n            g.Assert(changes.id, 'Item being modified does not already exist as expected', changes);\r\n\r\n            if (DEBUG && DEBUG && changes.version)\r\n            {\r\n                var verStr = 'UNDEFINED -> ' + changes['version'];\r\n                window.__LOCAL_VERSION_UPDATES.push('VERSION: ' + id + ': ' + g.getCurrentStack(verStr));\r\n\r\n                if (DEBUG) log('Setting local version ' + id + ': ', verStr);\r\n            }\r\n\r\n            if (DEBUG && DEBUG && changes.versionText)\r\n            {\r\n                var verStr = 'UNDEFINED -> ' + changes['versionText'];\r\n                window.__LOCAL_VERSION_UPDATES.push('VERSIONTEXT: ' + id + ': ' + g.getCurrentStack(verStr));\r\n\r\n                if (DEBUG) log('Setting local TEXT version ' + id + ': ', verStr);\r\n            }\r\n\r\n            self.setItem(id, changes);\r\n\r\n            translated = g.translateObjIn(changes);\r\n        }\r\n\r\n        if (DEBUG) log('Local Update: ', JSON.stringify(changes, null, 4));\r\n\r\n        //if (DEBUG) log('Local Update: ', JSON.stringify(changes, null, 4), JSON.stringify(translated, null, 4));\r\n\r\n        if (DEBUG)\r\n        {\r\n            if (updateTransaction)\r\n            {\r\n                g.Assert(!callback, 'Callbacks not supported for updates inside of a transaction');\r\n\r\n                self.transactionUpdate(id, translated);\r\n            }\r\n            else\r\n            {\r\n                function trackUpdates()\r\n                {\r\n                    window.__UPDATES_ACTUAL++;\r\n\r\n                    if (callback)\r\n                    {\r\n                        var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n                        callback(args);\r\n                    }\r\n                }\r\n\r\n                window.__UPDATES_EXPECTED++;\r\n                //window.__LOCAL_UPDATE_STACKS.push(g.getCurrentStack(changes));\r\n\r\n                self.dbi.items.update(translated).done(trackUpdates).fail(trackUpdates);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (updateTransaction)\r\n            {\r\n                g.Assert(!callback, 'Callbacks not supported for updates inside of a transaction');\r\n\r\n                self.transactionUpdate(id, translated);\r\n            }\r\n            else\r\n            {\r\n                if (callback)\r\n                {\r\n                    self.dbi.items.update(translated).done(callback).fail(callback);\r\n                }\r\n                else\r\n                {\r\n                    self.dbi.items.update(translated);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nself.dbDeleteItem = function(id, callback)\r\n{\r\n    if(self.freezeUpdates)\r\n    {\r\n        return;\r\n    }\r\n\r\n    self.setItem(id, undefined);\r\n\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        if (callback)\r\n        {\r\n            self.dbi.items.remove(id).done(callback).fail(callback);\r\n        }\r\n        else\r\n        {\r\n            self.dbi.items.remove(id);\r\n        }\r\n    }\r\n};\r\n\r\nself.setRoot = function(id)\r\n{\r\n    if(self.freezeUpdates)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        self.dbi.settings.update({key: 'root', item: {'root': id}});\r\n    }\r\n\r\n    self.rootId = id;\r\n\r\n    return self.getRootItem();\r\n};\r\n\r\nvar demoId = 0;\r\nvar loadedDemoData = { };\r\nself.loadDemoData = function(testData, handler)\r\n{\r\n    if (testData === undefined)\r\n    {\r\n        testData = 10;\r\n    }\r\n\r\n    if (testData !== undefined && testData !== \"\" && loadedDemoData[testData] !== undefined)\r\n    {\r\n        log('Use Preloaded demo data: ', testData);\r\n\r\n        var newRoot = loadedDemoData[testData];\r\n\r\n        self.setRoot(newRoot.id);\r\n\r\n        if (handler)\r\n        {\r\n            handler(newRoot.id);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        function insertIntoDB(root)\r\n        {\r\n            if (!root.id)\r\n            {\r\n                root.id = 'demo' + (demoId++);\r\n            }\r\n\r\n            self.setItem(root.id, root);\r\n\r\n            var items = root.items;\r\n            if (items)\r\n            {\r\n                var itemIDs = [ ];\r\n                for (var i = 0; i < items.length; ++i)\r\n                {\r\n                    if (!items[i].id)\r\n                    {\r\n                        items[i].id = 'demo' + (demoId++);\r\n                    }\r\n\r\n                    itemIDs.push(items[i].id);\r\n\r\n                    insertIntoDB(items[i]);\r\n                }\r\n\r\n                root.items = itemIDs;\r\n            }\r\n        }\r\n\r\n        var root;\r\n        if (testData === \"\")\r\n        {\r\n            root = demo()[0];\r\n        }\r\n        else\r\n        {\r\n            var dataIndex = parseInt(testData);\r\n\r\n            var demoData = demo(dataIndex);\r\n\r\n            if (demoData)\r\n            {\r\n                root = demoData[0];\r\n            }\r\n        }\r\n\r\n        if (root)\r\n        {\r\n            insertIntoDB(root);\r\n\r\n            self.setRoot(root.id);\r\n\r\n            // Store data root at index in case data is swapped on the fly for demo\r\n            loadedDemoData[testData] = root;\r\n\r\n            isLocalDataLoaded = true;\r\n\r\n            if (handler)\r\n            {\r\n                handler(root.id);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n// Initialize data in the 'items' local store. This will\r\n// synchronize the stores with the latest data from the server as well\r\n// as pushing any updates that are stored locally to the server. If we\r\n// are in offline mode, then initialize the stores and simply passthrough\r\n// to the handler.\r\n//\r\nvar initDataCalled = false;\r\nself.initData = function (handler)\r\n{\r\n    if (initDataCalled)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    initDataCalled = true;\r\n\r\n    if (DEBUG) log('Initializing User Item Data', log.now());\r\n\r\n    try\r\n    {\r\n        if (g.isDemoMode())\r\n        {\r\n            setTimeout(function ()\r\n            {\r\n                var testData = util.getURLParam('data');\r\n\r\n                self.loadDemoData(testData, handler);\r\n            }, 0);\r\n        }\r\n        else\r\n        {\r\n            g.checkpoint(Checkpoint.InitData);\r\n\r\n            self.initializeIndexedDB(function()\r\n            {\r\n                self.loadFromIndexedDB(function()\r\n                {\r\n                    g.checkpoint(Checkpoint.DBLoaded);\r\n                    self.checkLocalIntegrity(function(localDataStatus)\r\n                    {\r\n                        self.loadLocalContacts();\r\n\r\n                        handler();\r\n\r\n                        if (!self.hasLocalData && !platform.offline && navigator.onLine)\r\n                        {\r\n                            g.vmMain.isLoadingDoc(true);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    }\r\n    catch (err)\r\n    {\r\n        g.reportError(err);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nself.initializeItem = function (item)\r\n{\r\n    var oldId = item.id;\r\n\r\n    var isNewItem = !oldId || g.isLocalItem(item) || !item.data;\r\n\r\n    if (isNewItem)\r\n    {\r\n        var newId = gdata.createNewItem(item, item.hasChildren(), item.hasArchivedChildren());\r\n\r\n        if (DEBUG) log('Initializing', item.id, item.getParsedText());\r\n\r\n        if (oldId && oldId !== newId)\r\n        {\r\n            self.modifyItemId(oldId, newId);\r\n        }\r\n\r\n        var hasNewChildren = false;\r\n\r\n        var items = item.items();\r\n        for (var i = 0; i < items.length; ++i)\r\n        {\r\n            hasNewChildren |= self.initializeItem(items[i]);\r\n        }\r\n\r\n        if (item.hasArchivedChildren())\r\n        {\r\n            var archivedItems = item.archivedItems(/*underlying*/true);\r\n            for (var i = 0; i < archivedItems.length; ++i)\r\n            {\r\n                hasNewChildren |= self.initializeItem(archivedItems[i]);\r\n            }\r\n        }\r\n\r\n        gdata.initializeNewItem(item);\r\n\r\n        // TODO: Is this the best thing to do?\r\n        if (oldId && oldId !== newId)\r\n        {\r\n            var parent = item.parent();\r\n            if (parent)\r\n            {\r\n                parent.save(null, SaveFlag.None);\r\n            }\r\n        }\r\n    }\r\n    // else\r\n    // {\r\n    //     item.initFromGDrive(item.data);\r\n    // }\r\n\r\n    return isNewItem;\r\n};\r\n\r\nfunction removeItemSubtree(id)\r\n{\r\n    var item = self.getItem(id);\r\n\r\n    if (item)\r\n    {\r\n        var children = item.items;\r\n\r\n        if (children)\r\n        {\r\n            for (var i = 0; i < children.length; ++i)\r\n            {\r\n                removeItemSubtree(children[i]);\r\n            }\r\n        }\r\n\r\n        self.dbDeleteItem(item.id);\r\n    }\r\n}\r\n\r\n//\r\n// Ensure that the local item structure is still valid despite any\r\n// deletions that may have occured.\r\n//\r\nself.checkLocalIntegrity = function (callback)\r\n{\r\n    if (DEBUG) log('Checking Local: ', log.now());\r\n\r\n    // Keep track if we have seen an error with the local data\r\n    var localDataError = false;\r\n    var localData = false;\r\n\r\n    self.ensureLocalCache(function()\r\n    {\r\n        if (DEBUG) log('Verifying Local Data', log.now());\r\n\r\n        var rootSeen = false;\r\n\r\n        var seen = { };\r\n        for (var id in self.itemsById)\r\n        {\r\n            if (self.itemsById.hasOwnProperty(id) && self.getItem(id))\r\n            {\r\n                var item = self.getItem(id);\r\n                if(item.i || item.t)\r\n                {\r\n                    log('%cInvalid local properties on item: ', 'color: red', item);\r\n                    localDataError = true;\r\n                }\r\n\r\n                if (!seen[item.id])\r\n                {\r\n                    seen[item.id] = {\r\n                        'exist': true,\r\n                        'ref': false,\r\n                        'del': !!item.isDeleted\r\n                    };\r\n                }\r\n                else\r\n                {\r\n                    if (seen[item.id].exist)\r\n                    {\r\n                        log(item.id, ': Duplicated IDs in the local database', item);\r\n                        localDataError = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        seen[item.id].exist = true;\r\n                        seen[item.id].del = !!item.isDeleted;\r\n                    }\r\n                }\r\n\r\n                if (item.id == self.rootId)\r\n                {\r\n                    if (rootSeen)\r\n                    {\r\n                        log(item.id, ': Multiple roots present locally', item);\r\n                        localDataError = true;\r\n                    }\r\n\r\n                    rootSeen = true;\r\n                    seen[item.id].isRoot = true;\r\n                }\r\n\r\n                if (item.text == undefined)\r\n                {\r\n                    log('Found item with no text', item.id);\r\n                    item.text = '';\r\n                    self.dbUpdateItem({\r\n                        id: id,\r\n                        changes: {text: ''},\r\n                        saveFlags: SaveFlag.None\r\n                    });\r\n                }\r\n\r\n                var seenArchived = undefined;\r\n                for (var j = 0; item.items && j < item.items.length; ++j)\r\n                {\r\n                    if (!item.items[j])\r\n                    {\r\n                        log(item.id, ': Invalid item in local items array');\r\n                        localDataError = true;\r\n\r\n                        continue;\r\n                    }\r\n\r\n                    var child = item.items[j];\r\n\r\n                    var childInfo = self.getItem(child);\r\n\r\n                    if (childInfo)\r\n                    {\r\n                        // Once an archived child is seen, only other archived children should be seen\r\n                        if (childInfo.isArchived)\r\n                        {\r\n                            seenArchived = child;\r\n                        }\r\n\r\n                        if (seenArchived && !childInfo.isArchived)\r\n                        {\r\n                            log(child, ': Unarchived child found after an archived one');\r\n                            log('   ', item.id, ': Parent with incorrectly ordered children');\r\n                            localDataError = true;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        log(child, ': Child does not have a valid reference on our local database');\r\n                        localDataError = true;\r\n                    }\r\n\r\n                    if (!seen[child])\r\n                    {\r\n                        seen[child] = {\r\n                            'exist': false,\r\n                            'ref': item.id\r\n                        };\r\n                    }\r\n                    else\r\n                    {\r\n                        if (seen[child].ref)\r\n                        {\r\n                            if (DEBUG)\r\n                            {\r\n                                log(child, ': Item is referenced locally multiple times: ', (!!childInfo ? self.getItem(child).text : 'UNDEFINED'));\r\n                                log('   ', seen[child].ref, ': ', self.getItem(seen[child].ref).text);\r\n                                log('   ', item.id, ': ', self.getItem(item.id).text);\r\n                            }\r\n                            else\r\n                            {\r\n                                log(child, ': Item is referenced locally multiple times: ', (!!childInfo ? self.getItem(child).id : 'UNDEFINED'));\r\n                                log('   ', seen[child].ref, ': ', self.getItem(seen[child].ref).id);\r\n                                log('   ', item.id, ': <CLIENTDATA>');\r\n                            }\r\n\r\n                            localDataError = true;\r\n\r\n                            var newItems = item.items;\r\n                            newItems.removeAt(j);\r\n\r\n                            self.dbUpdateItem({\r\n                                id: id,\r\n                                changes: { items: newItems },\r\n                                saveFlags: SaveFlag.None\r\n                            });\r\n                        }\r\n                        else\r\n                        {\r\n                            seen[child].ref = item.id;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!rootSeen)\r\n        {\r\n            log('No root present');\r\n            localDataError = true;\r\n        }\r\n\r\n        for (var entryID in seen)\r\n        {\r\n            var entry = seen[entryID];\r\n\r\n            if (!entry.exist)\r\n            {\r\n                log(entryID, ': Item is referenced locally as a child but does not exist in the database');\r\n                //log('   : ', self.itemsById[entryID].text);\r\n\r\n                var item = self.getItem(entry.ref);\r\n\r\n                g.Assert(item, 'Parent of item must exist');\r\n\r\n                if (item)\r\n                {\r\n                    var newItems = item.items;\r\n\r\n                    if (newItems)\r\n                    {\r\n                        newItems.remove(entryID);\r\n                    }\r\n                    else\r\n                    {\r\n                        newItems = [ ];\r\n                    }\r\n\r\n                    self.dbUpdateItem({\r\n                        id: item.id,\r\n                        changes: {items: newItems},\r\n                        saveFlags: SaveFlag.None\r\n                    });\r\n                }\r\n            }\r\n\r\n            if (!entry.ref && !entry.isRoot && !entry.del)\r\n            {\r\n                log(entryID, ': Item exists locally but is not referenced by a parent');\r\n                if (DEBUG) { log('   : ', self.getItem(entryID).text); }\r\n\r\n                removeItemSubtree(entryID);\r\n            }\r\n\r\n            if (entry.ref && entry.del)\r\n            {\r\n                log(entryID, ': Item is referenced locally by a parent but has been deleted');\r\n                if (DEBUG) { log('   : ', self.getItem(entryID).text); }\r\n\r\n                var item = self.getItem(entry.ref);\r\n\r\n                g.Assert(item);\r\n\r\n                var newItems = item.items;\r\n\r\n                if (newItems)\r\n                {\r\n                    newItems.remove(entryID);\r\n                }\r\n                else\r\n                {\r\n                    newItems = [ ];\r\n                }\r\n\r\n                self.dbUpdateItem({\r\n                    id: item.id,\r\n                    changes:\r\n                    {\r\n                        items: newItems\r\n                    },\r\n                    saveFlags: SaveFlag.None\r\n                });\r\n            }\r\n\r\n            if (entry.isRoot && entry.ref)\r\n            {\r\n                log(entryID, ': Local root has a parent');\r\n                localDataError = true;\r\n            }\r\n\r\n            if (entry.del && !entry.ref)\r\n            {\r\n                var item = self.getItem(entryID);\r\n                if (g.isLocalItem(item))\r\n                {\r\n                    log('Deleting Unreferenced Local Item: ', entryID);\r\n                    self.dbDeleteItem(entryID);\r\n                }\r\n                else\r\n                {\r\n                    if (DEBUG)\r\n                    {\r\n                        log('Unreferenced local item - not deleting until pushed to server:', entryID, item.text);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (DEBUG) log('Done Verifying Local Data', log.now());\r\n        // self.printIndexedDB();\r\n\r\n        callback({ 'error': localDataError, 'local': localData });\r\n    });\r\n};\r\n\r\nself.removeDeletedItems = function(remoteSeen)\r\n{\r\n    for (var id in self.itemsById)\r\n    {\r\n        var localItem = self.getItem(id);\r\n\r\n        if (localItem && localItem.isDeleted)\r\n        {\r\n            if (!remoteSeen[id])\r\n            {\r\n                log('Deleting Removed Local Item: ', id);\r\n                self.dbDeleteItem(id);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nself.clearData = function(cb, skip)\r\n{\r\n    self.freezeUpdates = true;\r\n    // Functions rely on this being inside of a setTimeout for their execution, check callers\r\n    // before removing this. Additionally, having this inside of a setTimeout fixes issues on\r\n    // iOS where WebSQL drops calls silently when they are made inside an event handler.\r\n\r\n    setTimeout(function ()\r\n    {\r\n        g.pageDataCleared();\r\n\r\n        if (!self.dbi)\r\n        {\r\n            self.initializeIndexedDB(function () { self.clearData(cb, skip); });\r\n\r\n            return;\r\n        }\r\n\r\n        function clearLocalStorage()\r\n        {\r\n            self.clearContacts();\r\n            self.clearHelp();\r\n\r\n            g.settings.resetAll(skip);\r\n\r\n            if (cb)\r\n            {\r\n                cb();\r\n            }\r\n        }\r\n\r\n        function clearItems()\r\n        {\r\n            if (self.dbi.items)\r\n            {\r\n                self.dbi.items.clear().done(function ()\r\n                {\r\n                    clearLocalStorage();\r\n                }).fail(function ()\r\n                {\r\n                    log('Failed to reset items!', arguments);\r\n\r\n                    clearLocalStorage();\r\n                });\r\n            }\r\n        }\r\n\r\n        if (self.dbi.settings)\r\n        {\r\n            self.dbi.settings.clear().done(function ()\r\n            {\r\n                clearItems();\r\n            }).fail(function ()\r\n            {\r\n                log('Failed to reset settings!', arguments);\r\n\r\n                clearItems();\r\n            });\r\n        }\r\n    }, 0);\r\n};\r\n\r\nself.contactComparator = function(a, b)\r\n{\r\n    return a.text.localeCompare(b.text);\r\n};\r\n\r\nself.sortContacts = function()\r\n{\r\n    self.contacts.sort(self.contactComparator);\r\n};\r\n\r\nself.addContact = function(contact, sorted)\r\n{\r\n    g.Assert(contact.id, 'Incoming contacts must have a valid id');\r\n    g.Assert(contact.text, 'All contacts are expected to have a text');\r\n\r\n    if(sorted)\r\n    {\r\n        self.contacts.insertSorted(contact, self.contactComparator);\r\n    }\r\n    else\r\n    {\r\n        self.contacts.push(contact);\r\n    }\r\n\r\n\r\n    if (contact.text)\r\n    {\r\n        self.contactNames[contact.text] = '';\r\n        self.contactsByName[contact.text] = contact;\r\n    }\r\n\r\n    self.contactNames['___info___'].count = self.contacts.length;\r\n};\r\n\r\nself.updateContact = function(contact, sorted)\r\n{\r\n    g.Assert(contact.id, 'Incoming contacts must have a valid id');\r\n    g.Assert(contact.text, 'All contacts are expected to have a text');\r\n\r\n    var wasReplaced = false;\r\n    for (var i = 0; i < self.contacts.length; ++i)\r\n    {\r\n        if (self.contacts[i].id === contact.id)\r\n        {\r\n            self.contacts[i] = contact;\r\n            wasReplaced = true;\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!wasReplaced)\r\n    {\r\n        self.addContact(contact);\r\n        return true;\r\n    }\r\n};\r\n\r\nvar localContactsLoaded = false;\r\n\r\nself.clearLocalContacts = function()\r\n{\r\n    localContactsLoaded = false;\r\n\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        try\r\n        {\r\n            util.storage.setItem(DB_CONTACTS, '[]');\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n    }\r\n\r\n    self.contacts = [ ];\r\n\r\n    g.settings.set(Settings.lastContactSync, undefined);\r\n};\r\n\r\nself.loadLocalContacts = function ()\r\n{\r\n    if (!localContactsLoaded)\r\n    {\r\n        localContactsLoaded = true;\r\n\r\n        if (g.shouldWriteLocal())\r\n        {\r\n            try\r\n            {\r\n                self.loadContacts(JSON.parse(util.storage.getItem(DB_CONTACTS)), /*isDemo*/false);\r\n            }\r\n            catch (err)\r\n            {\r\n                g.reportError(err);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nself.loadContacts = function(contacts, isDemo)\r\n{\r\n    g.Assert(self.contacts.length === 0, 'Should only load contacts once');\r\n\r\n    self.contacts = contacts;\r\n\r\n    if (self.contacts)\r\n    {\r\n        var modifiedContact = false;\r\n        for (var i = 0; i < self.contacts.length; i++)\r\n        {\r\n            var contact = self.contacts[i];\r\n\r\n            // Migration: Was previously using name field and now using text\r\n            if(contact.name)\r\n            {\r\n                contact.text = contact.name;\r\n                self.contacts[i].text = contact.name;\r\n                delete self.contacts[i].name;\r\n                modifiedContact = true;\r\n            }\r\n\r\n            // Remove demo contact and empty contacts\r\n            if ((!isDemo && contact.isDemo) ||\r\n                (contact.text && !contact.phoneNumbers && !contact.emails))\r\n            {\r\n                self.contacts.removeAt(i--);\r\n                modifiedContact = true;\r\n\r\n                continue;\r\n            }\r\n\r\n            if (contact.text)\r\n            {\r\n                self.contactNames[contact.text] = '';\r\n                self.contactsByName[contact.text] = contact;\r\n            }\r\n\r\n            g.Assert(contact.id, 'Each contact must have a valid id');\r\n        }\r\n\r\n        if (modifiedContact)\r\n        {\r\n            self.saveContacts();\r\n        }\r\n\r\n        self.contactNames['___info___'].count = self.contacts.length;\r\n    }\r\n    else\r\n    {\r\n        self.contacts = [];\r\n        self.contactsByName = {};\r\n        self.contactNames = defaultContactNames;\r\n    }\r\n\r\n    log('Contacts Loaded: ', self.numContacts());\r\n};\r\n\r\nself.saveContacts = function()\r\n{\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        if (DEBUG) { log('Saving Modified Contacts'); }\r\n\r\n        util.storage.setItem(DB_CONTACTS, JSON.stringify(self.contacts));\r\n    }\r\n};\r\n\r\nself.clearContacts = function()\r\n{\r\n    g.settings.set(Settings.syncContacts, false);\r\n    g.settings.reset(Settings.lastContactSync);\r\n\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        util.storage.removeItem(DB_CONTACTS, undefined);\r\n    }\r\n};\r\n\r\nself.clearHelp = function()\r\n{\r\n    if (g.shouldWriteLocal())\r\n    {\r\n        util.storage.removeItem(DB_HELP_INTRO, undefined);\r\n        util.storage.removeItem(DB_HELP_NORMAL, undefined);\r\n    }\r\n};\r\n\r\nself.contactRelevanceComparator = function(a, b)\r\n{\r\n    if(a.index != b.index)\r\n        return a.index < b.index ? -1 : 1;\r\n\r\n    return a.object.text.localeCompare(b.object.text);\r\n};\r\n\r\nself.findContactsLike = function(like)\r\n{\r\n    var lower = like.toLowerCase();\r\n    var results = [];\r\n\r\n    var maxResults = 50;\r\n\r\n    for (var i = 0; i < self.contacts.length; ++i)\r\n    {\r\n        var index = self.contacts[i].text.toLowerCase().indexOf(lower);\r\n        if (index >= 0)\r\n        {\r\n            results.push({index: index, object: self.contacts[i]});\r\n            if(results.length > maxResults)\r\n                break;\r\n        }\r\n    }\r\n    results.sort(self.contactRelevanceComparator);\r\n    return results;\r\n};\r\n\r\nself.findContactsExact = function(exact)\r\n{\r\n    return self.contactsByName[exact];\r\n};\r\n\r\nself.findContactByEmail = function(email)\r\n{\r\n    for (var i = 0; i < self.contacts.length; ++i)\r\n    {\r\n        var contact = self.contacts[i];\r\n\r\n        if (contact.emails)\r\n        {\r\n            for (var u = 0; u < contact.emails.length; ++u)\r\n            {\r\n                if (contact.emails[u].address == email)\r\n                {\r\n                    return contact;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nself.getContacts = function()\r\n{\r\n    return self.contactNames;\r\n};\r\n\r\nself.numContacts = function()\r\n{\r\n    g.Assert(self.contacts.length === self.contactNames['___info___'].count, 'Contact names count should match contacts value');\r\n\r\n    return self.contacts.length;\r\n};\r\n\r\nself.areLocalContactsLoaded = function()\r\n{\r\n    return localContactsLoaded;\r\n};\r\n\r\n//\r\n// Data saving routines\r\n//\r\nself.insertItems = function (item, items, index)\r\n{\r\n    g.Assert(item, 'Must pass in a valid item');\r\n    g.Assert(index === undefined || index >= 0, 'Must pass in a valid index');\r\n\r\n    item.save({ 'items': item.getItemsArrayForSave() }, SaveFlag.Prop);\r\n\r\n    // TODO: Collapse into single function at gdata level?\r\n    if (items.length === 1)\r\n    {\r\n        gdata.itemAdded({\r\n            item: item,\r\n            addedItem: items[0],\r\n            index: index,\r\n            isArchived: false\r\n        });\r\n    }\r\n    else\r\n    {\r\n        gdata.itemsAdded({\r\n            item: item,\r\n            addedItems: items,\r\n            index: index,\r\n            isArchived: false\r\n        });\r\n    }\r\n};\r\n\r\nself.removeItem = function (item, index, removedItem, isArchived)\r\n{\r\n    g.Assert(item, 'Must pass in a valid item');\r\n    g.Assert(index === undefined || index >= 0, 'Must pass in a valid index');\r\n\r\n    item.save({ 'items': item.getItemsArrayForSave() }, SaveFlag.Prop);\r\n\r\n    if (removedItem && removedItem.data)\r\n    {\r\n        gdata.itemRemoved({\r\n            item: item,\r\n            index: index,\r\n            numToRemove: 1,\r\n            isArchived: isArchived\r\n        });\r\n    }\r\n};\r\n\r\nself.moveItem = function (params)\r\n{\r\n    var item = params.item;\r\n    var newInfo = params.newInfo;\r\n    var oldParent = params.oldParent;\r\n    var oldInfo = params.oldInfo;\r\n    var isRemoteChange = params.isRemoteChange;\r\n    var noVersion = params.noVersion;\r\n\r\n    var saveFlags = !isRemoteChange ? SaveFlag.Prop : SaveFlag.None;\r\n\r\n    g.Assert(item !== undefined && newInfo !== undefined && oldParent !== undefined && oldInfo !== undefined, 'moveItem is missing parameters');\r\n\r\n    // TODO: Reduce the number of saves that happen from a move\r\n    oldParent.save({ 'items': oldParent.getItemsArrayForSave() }, saveFlags);\r\n    item.parent().save({ 'items': item.parent().getItemsArrayForSave() }, saveFlags);\r\n\r\n    if (oldInfo.isArchived !== newInfo.isArchived)\r\n    {\r\n        item.isArchived(newInfo.isArchived);\r\n\r\n        item.save({ 'isArchived': newInfo.isArchived}, saveFlags);\r\n    }\r\n\r\n    if (!isRemoteChange)\r\n    {\r\n        // Incremement the local version\r\n        self.saveChanges(item, {}, saveFlags);\r\n\r\n        gdata.itemMoved({\r\n            item: item,\r\n            newInfo: newInfo,\r\n            oldParent: oldParent,\r\n            oldInfo: oldInfo,\r\n            noVersion: noVersion\r\n        });\r\n    }\r\n};\r\n\r\nfunction doArchive(item, archivedItem, value)\r\n{\r\n    item.save({\r\n        'items': item.getItemsArrayForSave()\r\n    }, SaveFlag.None);\r\n\r\n    archivedItem.save({\r\n        'isArchived': value\r\n    }, SaveFlag.None);\r\n\r\n    // if (archivedItem.data)\r\n    // {\r\n    //     gdata.saveChanges(archivedItem,\r\n    //     {\r\n    //         'isArchived': value\r\n    //     });\r\n    // }\r\n}\r\n\r\nself.archiveItem = function (item, index, archivedItem)\r\n{\r\n    g.Assert(index >= 0, 'Must have a valid index to remove from');\r\n\r\n    doArchive(item, archivedItem, true);\r\n\r\n    if (archivedItem.data)\r\n    {\r\n        gdata.itemArchived(item, archivedItem, index);\r\n    }\r\n};\r\n\r\nself.unarchiveItem = function (item, index, unarchivedItem)\r\n{\r\n    g.Assert(index >= 0, 'Must have a valid index to remove from');\r\n\r\n    doArchive(item, unarchivedItem, false);\r\n\r\n    if (unarchivedItem.data)\r\n    {\r\n        gdata.itemUnarchived(item, unarchivedItem, index, item.items().length - 1);\r\n    }\r\n};\r\n\r\n// self.spliceItems = function (item, index, numToRemove, insertedItem, removedItems)\r\n// {\r\n//     item.save({ 'items': item.getItemsArrayForSave() });\r\n\r\n//     var foundValid = false;\r\n//     for (var i = 0; i < removedItems.length; ++i)\r\n//     {\r\n//         if (removedItems[i].data)\r\n//         {\r\n//             if (!foundValid)\r\n//             {\r\n//                 foundValid = true;\r\n//                 index += i;\r\n//             }\r\n//         }\r\n//         else\r\n//         {\r\n//             numToRemove--;\r\n//         }\r\n//     }\r\n\r\n//     gdata.itemRemoved({ item: item,\r\n//                         index: index,\r\n//                         numToRemove: numToRemove,\r\n//                         isArchived: false});\r\n\r\n//     if (insertedItems)\r\n//     {\r\n//         gdata.itemAdded({item: item,\r\n//                          addedItem: insertedItem,\r\n//                          index: index,\r\n//                          isArchived: false});\r\n//     }\r\n// };\r\n\r\n// self.shiftItems = function (item, removedItem)\r\n// {\r\n//     item.save({ 'items': item.getItemsArrayForSave() });\r\n\r\n//     if (removedItem.data)\r\n//     {\r\n//         gdata.itemRemoved({ item: item,\r\n//                             index: 0,\r\n//                             numToRemove: 1,\r\n//                             isArchived: false});\r\n//     }\r\n// };\r\n\r\nself.modifyItemId = function (id, newId, callback)\r\n{\r\n    if (DEBUG) log('modifying', id, 'into', newId);\r\n\r\n    var item = self.getItem(id);\r\n    var model = self.getModel(id);\r\n\r\n    item.id = newId;\r\n    model.id = newId;\r\n\r\n    if (self.pendingRemoteUpdates[id])\r\n    {\r\n        self.pendingRemoteUpdates[id] = undefined;\r\n        self.pendingRemoteUpdates[newId] = true;\r\n    }\r\n\r\n    // Reset the version to undefined to match the newly created remote item\r\n    item.version = -1;\r\n    item.versionText = -1;\r\n\r\n    // Special case updating the ID for the root item - in this case also remove any unused children. This\r\n    // optimization helps avoid issues when loading the app for the first time and the remote data needs to\r\n    // be downloaded.\r\n    if (id === 'root')\r\n    {\r\n        for (var i = item.items.length - 1; i >= 0; i--)\r\n        {\r\n            var rootChild = self.getItem(item.items[i]);\r\n\r\n            if (g.isLocalItem(rootChild) && !rootChild.modifiedOffline && !rootChild.modifiedOfflineText)\r\n            {\r\n                item.items.removeAt(i);\r\n\r\n                g.Assert(model.items()[i].id === rootChild.id, 'Item arrays should match');\r\n\r\n                model.items().removeAt(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    self.itemsById[newId] = { data: item, model: self.itemsById[id].model };\r\n\r\n    self.dbDeleteItem(id);\r\n    self.dbUpdateItem({\r\n        changes: item,\r\n        callback: callback,\r\n        skipLocalModification: true,\r\n        saveFlags: SaveFlag.None\r\n    });\r\n\r\n    self.itemsById[id] = undefined;\r\n    delete self.itemsById[id];\r\n};\r\n\r\nself.deleteItem = function (item)\r\n{\r\n    g.Assert(!item.isDeleted, 'Should never try to delete an item that has already been deleted');\r\n\r\n    if (DEBUG) log('deleting item', item.id, item.getParsedText());\r\n\r\n    var localItem = self.getItem(item.id);\r\n    if (localItem)\r\n    {\r\n        item.isDeleted = true;\r\n\r\n        self.dbUpdateItem({\r\n            id: item.id,\r\n            changes: { isDeleted: true },\r\n            saveFlags: SaveFlag.Prop\r\n        });\r\n    }\r\n    else\r\n    {\r\n        g.Assert('Expected local item, didnt find one', item.id);\r\n    }\r\n};\r\n\r\nself.undeleteItem = function (item)\r\n{\r\n    var localItem = self.getItem(item.id);\r\n    if (localItem)\r\n    {\r\n        item.isDeleted = false;\r\n\r\n        self.dbUpdateItem({\r\n            id: item.id,\r\n            changes: { isDeleted: undefined },\r\n            saveFlags: SaveFlag.Prop\r\n        });\r\n    }\r\n    else\r\n    {\r\n        g.Assert('Expected local item, didnt find one', item.id);\r\n    }\r\n};\r\n\r\n//\r\n// Take the incoming item, the changes to the item and save them locally then\r\n// try to push them to the server.\r\n//\r\nself.saveChanges = function (item, changes, saveFlags)\r\n{\r\n    if (!item)\r\n    {\r\n        log('Incoming item to save has no item!', item, changes);\r\n\r\n        g.Assert(false, 'Incoming item to save has no item!');\r\n\r\n        return;\r\n    }\r\n\r\n    if (!changes)\r\n    {\r\n        changes = { };\r\n    }\r\n\r\n    //if (DEBUG) log('[', item.id, '] Save Changes: ', changes, noVersion);\r\n\r\n    self.dbUpdateItem({\r\n        id: item.id,\r\n        changes: changes,\r\n        saveFlags: saveFlags\r\n    });\r\n};\r\n\r\nself.addPendingUpdate = function(id)\r\n{\r\n    //var id = g.isString(item) ? item : item.id;\r\n    g.Assert(id, 'Invalid ID');\r\n    g.Assert(g.isString(id), 'Must provide a valid id string');\r\n\r\n    if (DEBUG) log('Add Pending Update: ', id);\r\n\r\n    if (!self.pendingRemoteUpdates[id])\r\n    {\r\n        self.pendingRemoteUpdates[id] = true;\r\n    }\r\n};\r\n\r\nself.clearPendingUpdates = function()\r\n{\r\n    for (var itemID in self.pendingRemoteUpdates)\r\n    {\r\n        g.Assert(self.pendingRemoteUpdates.hasOwnProperty(itemID));\r\n\r\n        if (DEBUG || DEBUG) log('Clear Pending Update: ', itemID);\r\n\r\n        var item = self.getModel(itemID);\r\n        var itemData = self.getItem(itemID);\r\n\r\n        if (itemData && itemData.isDeleted)\r\n        {\r\n            // Delete locally since we know it's been propagated to the server\r\n            if (DEBUG) log('%cDB delete item', 'color: red', itemID, itemData.text);\r\n\r\n            self.dbDeleteItem(itemID);\r\n        }\r\n        else if (item && item.data) // It's possible the item has been deleted so ignore it\r\n        {\r\n            var changes =\r\n            {\r\n                modifiedOffline: false,\r\n                modifiedOfflineText: false\r\n            };\r\n\r\n            item.modifiedOffline = false;\r\n            item.modifiedOfflineText = false;\r\n\r\n            var newVersion = gdata.getVersion(item.data, VersionType.Structure);\r\n            var newTextVersion = gdata.getVersion(item.data, VersionType.Text);\r\n\r\n            if (newVersion != item.getVersion(VersionType.Structure))\r\n            {\r\n                changes.version = newVersion;\r\n\r\n                item.setVersion(VersionType.Structure, newVersion);\r\n            }\r\n\r\n            if (newTextVersion != item.getVersion(VersionType.Text))\r\n            {\r\n                changes.versionText = newTextVersion;\r\n\r\n                item.setVersion(VersionType.Text, newTextVersion);\r\n            }\r\n\r\n            self.dbUpdateItem({\r\n                id: itemID,\r\n                changes: changes,\r\n                saveFlags: SaveFlag.None\r\n            });\r\n        }\r\n    }\r\n\r\n    self.pendingRemoteUpdates = { };\r\n    self.printIndexedDB('id', 'text', 'version', 'versionText', 'modifiedOffline', 'isArchived');\r\n};\r\n\r\nvar charMapHTML = {\r\n    '&': \"&amp;\",\r\n    '\\\"': \"&quot;\",\r\n    '<': \"&lt;\",\r\n    '>': \"&gt;\"\r\n};\r\n\r\nvar charMapJSON = {\r\n    '\\\"': '\\\\\\\"'\r\n};\r\n\r\n// TODO: Exporter functions should use only absolute dates!\r\nself.toHtml = function(item, allowArchived)\r\n{\r\n    var str = '<ul>';\r\n\r\n    if (item.items)\r\n    {\r\n        for(var i = 0; i < item.items.length; i ++)\r\n        {\r\n            var child = self.getItem(item.items[i]);\r\n            var model = self.getModel(child.id);\r\n\r\n            var text = String(model.getParsedText()).replace(/[&\\\"<>]/g, function (chr)\r\n            {\r\n                return charMapHTML[chr];\r\n            });\r\n\r\n            if (!child.isArchived || (child.isArchived && allowArchived))\r\n            {\r\n                str += '<li>' + text;\r\n                if (child.items && child.items.length > 0)\r\n                {\r\n                    str += self.toHtml(child);\r\n                }\r\n                str += '</li>';\r\n            }\r\n        }\r\n    }\r\n    str += '</ul>';\r\n    return str;\r\n};\r\n\r\nself.toPlainText = function(item, indent, allowArchived)\r\n{\r\n    if(isNaN(indent)) { indent = 0; }\r\n\r\n    var str = '';\r\n\r\n    if (item.items)\r\n    {\r\n        for(var i = 0; i < item.items.length; i ++)\r\n        {\r\n            var child = self.getItem(item.items[i]);\r\n            var model = self.getModel(child.id);\r\n\r\n            if (!child.isArchived || (child.isArchived && allowArchived))\r\n            {\r\n                for(var u = 0; u < indent; u ++)\r\n                {\r\n                    str += '\\t';\r\n                }\r\n\r\n                str += model.getParsedText() + '\\n';\r\n                if (child.items && child.items.length > 0)\r\n                {\r\n                    str += self.toPlainText(child, indent + 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return str;\r\n};\r\n\r\nfunction makePropString(item, field)\r\n{\r\n    var value = item[field];\r\n\r\n    if (value)\r\n    {\r\n        return ',\"' + field + '\":' + value;\r\n    }\r\n    else\r\n    {\r\n        return '';\r\n    }\r\n}\r\n\r\nfunction makeJSON(item, hasPrev, allowArchived)\r\n{\r\n    var str = '';\r\n    if (hasPrev)\r\n    {\r\n        str += ',';\r\n    }\r\n\r\n    var model = self.getModel(item.id);\r\n\r\n    var text = String(model.getParsedText()).replace(/[\\\"]/g, function (chr)\r\n    {\r\n        return charMapJSON[chr];\r\n    });\r\n\r\n    var item = self.getItem(item.id);\r\n\r\n    var dateCompletedString = makePropString(item, 'dateCompleted');\r\n    var priorityString = makePropString(item, 'priority');\r\n    var isCompleteString = makePropString(item, 'isComplete');\r\n    var isFlaggedString = makePropString(item, 'isFlagged');\r\n    var isArchivedString = makePropString(item, 'isArchived');\r\n\r\n    str += '{\"text\": \"' + text + '\"' + dateCompletedString + priorityString + isCompleteString + isFlaggedString + isArchivedString;\r\n\r\n    if (item.items && item.items.length > 0)\r\n    {\r\n        str += ',\"items\":[';\r\n        for(var i = 0; i < item.items.length; i ++)\r\n        {\r\n            var child = self.getItem(item.items[i]);\r\n\r\n            if (!child.isArchived || (child.isArchived && allowArchived))\r\n            {\r\n                str += makeJSON(child, i > 0);\r\n            }\r\n        }\r\n        str += ']';\r\n    }\r\n    str += '}';\r\n\r\n    return str;\r\n}\r\n\r\nself.toJSON = function(item, hasPrev, allowArchived)\r\n{\r\n    var rootItem = makeJSON(item, hasPrev, allowArchived);\r\n\r\n    return '{\"moodoVer\":' + g.settings.get(Settings.localDataVersion) + ',\"moodoRoot\":' + rootItem + '}';\r\n};\r\n\r\n//\r\n// Extern Functionality\r\n//\r\n\r\n// self.getExternEntry = function (id)\r\n// {\r\n//     var externQuery = self.dbExtern( { 'id': id }).limit(1);\r\n\r\n//     return externQuery.first();;\r\n// };\r\n\r\n// self.getItemForExternEntry = function (id)\r\n// {\r\n//     // TODO: What should this do now? Should extern be an index?\r\n//     g.Assert(false, 'TODO: Need to update the extern code in data.js');\r\n\r\n//     var itemQuery = self.dbItems( { 'extern': id }).limit(1);\r\n\r\n//     return itemQuery.first();\r\n// };\r\n\r\n// self.dbUpdateItemWithExtern = function (id)\r\n// {\r\n//     // TODO: What should this do now? Should extern be an index?\r\n//     g.Assert(false, 'TODO: Need to update the extern code in data.js');\r\n\r\n//     var itemQuery = self.dbItems( { 'id': id } ).limit(1);\r\n\r\n//     g.Assert(itemQuery.count() === 1);\r\n\r\n//     itemQuery.update( { 'extern': id });\r\n\r\n//     // Update the extern entry to be owned\r\n//     //var externQuery = self.dbExtern( { 'id': id }).limit(1);\r\n// };\r\n\r\n\r\n//\r\n// GAPI + Taffy Functionality\r\n//\r\n\r\n// self.processEventForStore = function (ev, item)\r\n// {\r\n//     ev.v = item ? item.v : 0;\r\n\r\n//     return ev;\r\n// };\r\n\r\n// self.storeEvent = function (ev)\r\n// {\r\n//     // TODO: What should this do now? Should extern be an index?\r\n//     g.Assert(false, 'TODO: Need to update the extern code in data.js');\r\n\r\n//     var result = { 'id': undefined, 'type': UpdateType.None };\r\n\r\n//     // There are three cases when storing an incoming event:\r\n//     //   #1: The event already exists in the database with an owner item\r\n//     //     a: The event needs to be updated\r\n//     //     b: The event is already up to date\r\n//     //   #2: The event already exists in the database, but does not have an owner item\r\n//     //     a: The event needs to be updated\r\n//     //     b: The event is already up to date\r\n//     //   #3: The event does not yet exist in the database\r\n\r\n//     // First check to see if there is an entry for the event\r\n//     var localEventQuery = self.dbExtern( { 'id': ev.id }).limit(1);\r\n//     if (localEventQuery.count())\r\n//     {\r\n//         var localEvent = localEventQuery.first();\r\n\r\n//         var localItemQuery = self.dbItems( { 'extern': localEvent.id }).limit(1);\r\n\r\n//         if (localItemQuery.count())\r\n//         {\r\n//             // Case #1\r\n//             if (localEvent.etag != ev.etag)\r\n//             {\r\n//                 // Case #1a: As there is already an owner for this item, simply update the\r\n//                 // extern entry in place.\r\n//                 var newEventData = self.processEventForStore(ev, localItemQuery.first());\r\n\r\n//                 localEventQuery.update(newEventData);\r\n\r\n//                 result = { 'id': localEvent.id, 'type': UpdateType.Update };\r\n//             }\r\n//         }\r\n//         else\r\n//         {\r\n//             // Case #2\r\n//             if (localEvent.etag != ev.etag)\r\n//             {\r\n//                 // Case #2a: As there is no owner for the item and there is new data, update\r\n//                 // the database, but pretend we did a full insert.\r\n//                 var newEventData = self.processEventForStore(ev);\r\n\r\n//                 localEventQuery.update(newEventData);\r\n//             }\r\n\r\n//             result = { 'id': localEvent.id, 'type': UpdateType.Insert };\r\n//         }\r\n//     }\r\n//     else\r\n//     {\r\n//         // Case #3: There is no entry in the database, create one.\r\n//         var newEventData = self.processEventForStore(ev);\r\n\r\n//         var newEvent = self.dbExtern.insert(newEventData);\r\n\r\n//         result = { 'id': newEvent.first().id, 'type': UpdateType.Insert };\r\n//     }\r\n\r\n//     return result;\r\n// };\r\n\r\n// self.deleteEvent = function (itemId)\r\n// {\r\n//     var result = false;\r\n\r\n//     var localItem = self.itemsById[itemId];\r\n//     if (localItem)\r\n//     {\r\n//         var externId = localItem.extern;\r\n//         self.dbUpdateItem({id: itemId, changes: { 'extern': undefined }});\r\n\r\n//         var localExternQuery = self.dbExtern({ 'id': externId }).limit(1);\r\n//         if (localExternQuery.count())\r\n//         {\r\n//             localExternQuery.remove();\r\n\r\n//             result = true;\r\n//         }\r\n//         else\r\n//         {\r\n//             g.Assert('No Extern found, expected one', externId);\r\n//         }\r\n//     }\r\n//     else\r\n//     {\r\n//         g.Assert('No item found, expected one', itemId);\r\n//     }\r\n\r\n//     return result;\r\n// }\r\n\r\n// self.getEvent = function (id)\r\n// {\r\n//     var localEventQuery = self.dbExtern({ 'id': id }).limit(1);\r\n\r\n//     return localEventQuery.first();\r\n// };\r\n\r\n// self.getExportableItems = function (calendarId)\r\n// {\r\n//     // TODO: What should this do now? Should extern be an index?\r\n//     g.Assert(false, 'TODO: Need to update the extern code in data.js');\r\n\r\n//     var today = Date.today();\r\n//     // Grab items that only exist locally and have not been exported that have dates.\r\n//     var localOnlyItems = self.dbItems(function ()\r\n//     {\r\n//         if (!this.extern && this.date && !this.isDeleted)\r\n//         {\r\n//             if (new Date(this.date) >= today)\r\n//             {\r\n//                 return true;\r\n//             }\r\n//         }\r\n\r\n//         return false;\r\n//     });\r\n\r\n//     // Grab all extern items that have been inserted for the given gcal\r\n//     var externdbUpdateItems = self.dbExtern({\r\n//         'calendarId': calendarId\r\n//     });\r\n\r\n//     // Get a list of all the extern IDs for the given gcal\r\n//     var externIDs = [ ];\r\n//     var externObjs = { };\r\n//     externdbUpdateItems.get().forEach(function(ele)\r\n//     {\r\n//         externIDs.push(ele.id);\r\n//         externObjs[ele.id] = ele;\r\n//     });\r\n\r\n//     // Grab items that have matching extern IDs for the given gcal\r\n//     var localExternItems = self.dbItems({\r\n//         'extern': externIDs\r\n//     });\r\n\r\n//     var exportItems = localOnlyItems.get();\r\n//     localExternItems.get().forEach(function (ele)\r\n//     {\r\n//         var externObj = externObjs[ele.extern];\r\n\r\n//         if (ele.v > externObj.v)\r\n//         {\r\n//             exportItems.push(ele);\r\n//         }\r\n//     })\r\n\r\n//     return { 'items': exportItems, 'externs': externObjs };\r\n// };\r\n\r\n//\r\n// Default Data\r\n//\r\n\r\nself.ensureLocalCache = function (callback)\r\n{\r\n    var root = self.getRootItem();\r\n    if (!root)\r\n    {\r\n        var oldLocalData = self.hasLocalData;\r\n\r\n        var tempID = g.generateTempId();\r\n\r\n        self.dbUpdateItem({\r\n            changes: {\r\n                id: 'root',\r\n                text: 'Home',\r\n                items: [ ]\r\n            },\r\n            skipLocalModification: true,\r\n            saveFlags: SaveFlag.None,\r\n            callback: function(){\r\n                self.setRoot('root');\r\n                self.hasLocalData = oldLocalData;\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n    else\r\n    {\r\n        if (self.loadedItemCount > 2)\r\n        {\r\n            self.hasLocalData = true;\r\n        }\r\n\r\n        callback();\r\n    }\r\n};\r\n\r\n\r\nself.printIndexedDB = function()\r\n{\r\n    if (DEBUG)\r\n    {\r\n        g.Assert(self.dbi);\r\n\r\n        var args = Array.prototype.slice.call(arguments);\r\n        for(var i = 0; i < args.length; i ++)\r\n        {\r\n            args[i] = g.translateFieldIn(args[i]);\r\n        }\r\n\r\n        var printAll = args.length === 0;\r\n        self.dbi.items.query().all().execute().done(function(results) {\r\n            log('---- Local DB ----')\r\n            for(var i = 0; i < results.length; i ++)\r\n            {\r\n                if(printAll)\r\n                {\r\n                    log(results[i]);\r\n                }\r\n                else\r\n                {\r\n                    var vals = [];\r\n                    for(var u = 0; u < args.length; u ++)\r\n                    {\r\n                        vals[u] = results[i][args[u]];\r\n                    }\r\n                    log.apply(this, vals);\r\n                }\r\n            }\r\n            log('------------------');\r\n        });\r\n    }\r\n};\r\n\r\nreturn self;\r\n});","asserts":[{"tag":989,"offset":1183},{"tag":990,"offset":1378},{"tag":991,"offset":1656},{"tag":992,"offset":1848},{"tag":993,"offset":7875},{"tag":994,"offset":8947},{"tag":995,"offset":9869},{"tag":996,"offset":11157},{"tag":997,"offset":12759},{"tag":998,"offset":13535},{"tag":999,"offset":13799},{"tag":1000,"offset":14295},{"tag":1001,"offset":15579},{"tag":1002,"offset":16771},{"tag":1003,"offset":17634},{"tag":1004,"offset":30297},{"tag":1005,"offset":31533},{"tag":1006,"offset":35231},{"tag":1007,"offset":35300},{"tag":1008,"offset":35805},{"tag":1009,"offset":35874},{"tag":1010,"offset":37209},{"tag":1011,"offset":38349},{"tag":1012,"offset":40816},{"tag":1013,"offset":41158},{"tag":1014,"offset":41208},{"tag":1015,"offset":41881},{"tag":1016,"offset":41931},{"tag":1017,"offset":42647},{"tag":1018,"offset":43991},{"tag":1019,"offset":44274},{"tag":1020,"offset":46966},{"tag":1021,"offset":47510},{"tag":1022,"offset":47965},{"tag":1023,"offset":48369},{"tag":1024,"offset":48723},{"tag":1025,"offset":49160},{"tag":1026,"offset":49193},{"tag":1027,"offset":49523},{"tag":1028,"offset":55118},{"tag":1029,"offset":55430},{"tag":1030,"offset":55573},{"tag":1031,"offset":56064},{"tag":1032,"offset":59026},{"tag":1033,"offset":59138},{"tag":1034,"offset":59524},{"tag":1035,"offset":61883}]},"gdata":{"path":"F:/p/bce/Duchess/public/js/gdata.js","data":"define(['ko', 'globals', 'data', 'platform'],\r\nfunction (ko, g, d, platform) {\r\nvar self = {\r\n    isClosed: true,\r\n    isInitialized: true,\r\n    wantCompoundOperation: false,\r\n    inCompoundOperation: false,\r\n    flushingDeferredActions: false,\r\n    itemsLoaded: false,\r\n    authenticatedUser: ko.observable()\r\n};\r\n\r\nvar CURRENT_VERSION = 5;\r\n\r\nvar itemCache = { };\r\n\r\nself.cacheItem = function(item)\r\n{\r\n    g.Assert(itemCache[item.id] === undefined || itemCache[item.id] === item, 'Should not be caching different items with the same ID');\r\n\r\n    itemCache[item.id] = item;\r\n};\r\n\r\nself.getState = function(obj)\r\n{\r\n    try\r\n    {\r\n        var gState = { };\r\n\r\n        if (self.doc)\r\n        {\r\n            try\r\n            {\r\n                var model = self.doc.getModel();\r\n\r\n                gState['isReadOnly'] = model.isReadOnly;\r\n                gState['serverVersion'] = model.serverVersion;\r\n                gState['size'] = model.bytesUsed;\r\n            }\r\n            catch (err2)\r\n            {\r\n                obj['docAccessError'] = true;\r\n            }\r\n        }\r\n\r\n        gState['lastPending'] = lastPending;\r\n        gState['lastSaving'] = lastSaving;\r\n        gState['isClosed'] = self.isClosed;\r\n        gState['initialized'] = self.initialized;\r\n\r\n        obj['gState'] = gState;\r\n    }\r\n    catch (err)\r\n    {\r\n        log('Error getting information in gdata::getState()' + err.message);\r\n    }\r\n};\r\n\r\nvar d;\r\nvar VMLI;\r\n\r\nif (DEBUG)\r\n{\r\n\r\nself.print = function(force)\r\n{\r\n    // No Write Ops //\r\n\r\n    if (DEBUG || force)\r\n    {\r\n        log('---- Remote Tree ----');\r\n        self.printDriveMap(self.rootItem, 0);\r\n        log('---------------------');\r\n    }\r\n\r\n    //printDriveItems(true);\r\n};\r\n\r\nfunction printDriveItems(includeSubItems)\r\n{\r\n    // No Write Ops //\r\n\r\n    log('----');\r\n\r\n    for (var itemID in itemCache)\r\n    {\r\n        var item = itemCache[itemID];\r\n        log(item.id, self.get(item.data, 'text'), self.getVersion(item.data, VersionType.Structure));\r\n\r\n        if (includeSubItems)\r\n        {\r\n            var subitems = self.get(item.data, 'items');\r\n            if (subitems)\r\n            {\r\n                for(var u = 0; u < subitems.length; u ++)\r\n                {\r\n                    log('    ', subitems.get(u));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    log('----');\r\n}\r\n\r\nself.printDriveMap = function(item, indent)\r\n{\r\n    // No Write Ops //\r\n\r\n    if (DEBUG)\r\n    {\r\n        g.Assert(item, 'invalid item');\r\n\r\n        if (item)\r\n        {\r\n            var text = self.get(item, 'text');\r\n\r\n            var str = '';\r\n            for (var i = 0; i < indent; i ++)\r\n            {\r\n                str += '  ';\r\n            }\r\n\r\n            if (text)\r\n            {\r\n                var txtstr = str;\r\n\r\n                // TODO: Update this method as isArchived is no longer used on gdrive\r\n                var isArchived = self.get(item, 'isArchived');\r\n                if (isArchived)\r\n                {\r\n                    txtstr += '[A] ';\r\n                }\r\n\r\n                log(txtstr + text, ': ', item.id, self.getVersion(item, VersionType.Structure), self.getVersion(item, VersionType.Text));\r\n            }\r\n\r\n            var items = self.get(item, 'items');\r\n            if (items && items.length > 0)\r\n            {\r\n                log(str + 'Items: ', item.id);\r\n                for (var i = 0; i < items.length; ++i)\r\n                {\r\n                    self.printDriveMap(items.get(i), indent + 1);\r\n                }\r\n            }\r\n\r\n            var archivedItems = self.get(item, 'archivedItems');\r\n            if (archivedItems && archivedItems.length > 0)\r\n            {\r\n                log(str + 'ArchivedItems: ', item.id);\r\n                for (var i = 0; i < archivedItems.length; ++i)\r\n                {\r\n                    self.printDriveMap(archivedItems.get(i), indent + 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n}\r\n\r\nself.checkRemoteIntegrity = function ()\r\n{\r\n    self.beginAction();\r\n\r\n    if (DEBUG) log('Verifying Remote Data: ', log.now());\r\n\r\n    var remoteDataError = false;\r\n\r\n    var seen = { };\r\n    var rootSeen = false;\r\n\r\n    for (var itemID in itemCache)\r\n    {\r\n        var item = itemCache[itemID];\r\n\r\n        // TODO: Verify item properties are all valid\r\n\r\n        if (!seen[item.id])\r\n        {\r\n            seen[item.id] = {\r\n                'exist': true,\r\n                'ref': false\r\n            };\r\n        }\r\n        else\r\n        {\r\n            if (seen[item.id].exist)\r\n            {\r\n                log(item.id, ': Duplicated IDs in the remote database', item);\r\n                remoteDataError = true;\r\n            }\r\n            else\r\n            {\r\n                seen[item.id].exist = true;\r\n            }\r\n        }\r\n\r\n        if (item.id == self.rootID)\r\n        {\r\n            if (rootSeen)\r\n            {\r\n                log(item.id, ': Multiple roots present remotely', item);\r\n                remoteDataError = true;\r\n            }\r\n\r\n            rootSeen = true;\r\n            seen[item.id].isRoot = true;\r\n        }\r\n\r\n        function verifyChildren(children, isArchived)\r\n        {\r\n            if (children)\r\n            {\r\n                for (var j = 0; j < children.length; ++j)\r\n                {\r\n                    var child = children.get(j).id;\r\n\r\n                    if (child)\r\n                    {\r\n                        // TODO: State verification\r\n                    }\r\n                    else\r\n                    {\r\n                        log(child, ': Child does not have a valid reference in our remote database');\r\n                        remoteDataError = true;\r\n                    }\r\n\r\n                    if (!seen[child])\r\n                    {\r\n                        seen[child] = {\r\n                            'exist': false,\r\n                            'arch': isArchived,\r\n                            'ref': item.id\r\n                        };\r\n                    }\r\n                    else\r\n                    {\r\n                        if (seen[child].ref)\r\n                        {\r\n                            log(child, ': Item is referenced remotely multiple times: ', self.get(children.get(j), 'text'));\r\n                            log('   ', seen[child].ref, ': ', self.get(itemCache[seen[child].ref], 'text'));\r\n                            log('   ', item.id, ': ', self.get(item, 'text'));\r\n                            remoteDataError = true;\r\n\r\n                            self.beginWriteAction();\r\n\r\n                            // Remove second instance of duplicated child reference\r\n                            children.remove(j);\r\n                        }\r\n                        else\r\n                        {\r\n                            seen[child].ref = item.id;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var childItems = self.get(item, 'items');\r\n        verifyChildren(childItems, /*isArchived*/false);\r\n\r\n        var childArchivedItems = self.get(item, 'archivedItems');\r\n        verifyChildren(childArchivedItems, /*isArchived*/true);\r\n    }\r\n\r\n    //\r\n    // Verification\r\n    //\r\n\r\n    if (!rootSeen)\r\n    {\r\n        log('No root present');\r\n        localDataError = true;\r\n    }\r\n\r\n    // if (DEBUG)\r\n    // {\r\n    //     //_UNSAFECheckRemote(self.model, seen);\r\n    // }\r\n\r\n    for (var entryID in seen)\r\n    {\r\n        var entry = seen[entryID];\r\n\r\n        if (!entry.exist)\r\n        {\r\n            g.Assert(false, 'This should never happen as the database is inline with the item tree now');\r\n\r\n            log(entryID, ': Item is referenced remotely as a child but does not exist in the database');\r\n\r\n            var parent = itemCache[entry.ref];\r\n            g.Assert(parent, 'Parent must exist otherwise it couldn\\'t reference this item');\r\n\r\n            var parentItems = self.getItemList(parent, entry.arch);\r\n            g.Assert(parentItems, 'If the item has been seen here, we will always have a valid parent list');\r\n\r\n            if (parentItems)\r\n            {\r\n                var remoteIndex = parentItems.indexOf(entryID);\r\n\r\n                if (remoteIndex >= 0)\r\n                {\r\n                    self.beginWriteAction();\r\n\r\n                    parentItems.remove(remoteIndex);\r\n                }\r\n                else\r\n                {\r\n                    g.Assert(false, 'If we previously saw this item, we expect to be able to delete it from the parent list');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!entry.ref && !entry.isRoot)\r\n        {\r\n            log(entryID, ': Item exists remotely but is not referenced by a parent');\r\n            log('   : ', self.get(itemCache[entryID], 'text'));\r\n\r\n            delete itemCache[entryID];\r\n        }\r\n\r\n        if (entry.isRoot && entry.ref)\r\n        {\r\n            log(entryID, ': Remote root has a parent');\r\n            localDataError = true;\r\n        }\r\n    }\r\n\r\n    // Remove any local items that don't have a corresponding remote item that have been deleted\r\n    d.removeDeletedItems(seen);\r\n\r\n    self.endAction();\r\n\r\n    if (DEBUG) log('Done Verifying Remote Data: ', log.now());\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    self.verifyLocalRemoteIntegrity = function()\r\n    {\r\n        try\r\n        {\r\n            function iterateRemote(data)\r\n            {\r\n                var remoteList = self.get(data, 'items');\r\n\r\n                var localModel = d.getModel(data.id);\r\n                g.Assert(localModel, 'For every remote item, there must be a corresponding local model');\r\n\r\n                var localList = localModel.items();\r\n\r\n                g.Assert((!remoteList && localList.length === 0) || remoteList.length === localList.length, 'After resolution both the local and remote item arrays should be the same length');\r\n\r\n                for (var i = 0; remoteList && i < remoteList.length; ++i)\r\n                {\r\n                    var remoteItem = remoteList.get(i);\r\n                    var localItem = localList[i];\r\n\r\n                    g.Assert(localItem && remoteItem, 'Both items must exist');\r\n\r\n                    if (localItem && remoteItem)\r\n                    {\r\n                        g.Assert(localItem.data === remoteItem, 'Local item data must match remote item');\r\n                        //g.Assert(localItem.id === remoteItem.id, 'Local item id must match remote item');\r\n                    }\r\n\r\n                    iterateRemote(remoteItem);\r\n                }\r\n            }\r\n\r\n            function iterateLocal(model)\r\n            {\r\n                var localList = model.items();\r\n\r\n                var remoteList = self.get(model.data, 'items');\r\n\r\n                g.Assert((!remoteList && localList.length === 0) || remoteList.length === localList.length, 'After resolution both the local and remote item arrays should be the same length');\r\n\r\n                for (var i = 0; i < localList.length; ++i)\r\n                {\r\n                    var localItem = localList[i];\r\n                    var remoteItem = remoteList.get(i);\r\n\r\n                    g.Assert(localItem && remoteItem, 'Both items must exist');\r\n\r\n                    if (localItem && remoteItem)\r\n                    {\r\n                        g.Assert(localItem.data === remoteItem, 'Local item data must match remote item');\r\n                        //g.Assert(localItem.id === remoteItem.id, 'Local item id must match remote item');\r\n                    }\r\n\r\n                    iterateLocal(localItem);\r\n                }\r\n            }\r\n\r\n            iterateRemote(self.rootItem);\r\n\r\n            iterateLocal(g.vmMain.root());\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n    }\r\n}\r\n\r\n// function _UNSAFECheckRemote(model, seen)\r\n// {\r\n//     // No Write Ops //\r\n\r\n//     if (DEBUG)\r\n//     {\r\n//         try\r\n//         {\r\n//             var unusedItems = { };\r\n//             var unusedLists = { };\r\n\r\n//             var totalStringSize = 0;\r\n\r\n//             var dataArray = model.b.b.a.e.R.n;\r\n\r\n//             //log('Remote Data: ', dataArray);\r\n//             log('Remote Size: ', (model.bytesUsed / 1024).toFixed(2), 'kB');\r\n\r\n//             var TypeStrings = ['Map', 'List', 'EditableString'];\r\n\r\n//             var Types = {\r\n//                 Map: 0,\r\n//                 List: 1,\r\n//                 EditableString: 2,\r\n//             };\r\n\r\n//             var typeCounts = [ ];\r\n//             for (var i = 0; i < TypeStrings.length; ++i)\r\n//             {\r\n//                 typeCounts[i] = 0;\r\n//             }\r\n\r\n//             var maxProps = 0;\r\n//             var numProps = 0;\r\n\r\n//             var propCounts = { };\r\n//             for (var id in dataArray)\r\n//             {\r\n//                 var type = (dataArray[id].hasOwnProperty('n') ? Types.List : (dataArray[id].hasOwnProperty('i') ? Types.Map : Types.EditableString));//TypeStrings.indexOf(dataArray[id].Ib);\r\n//                 typeCounts[type]++;\r\n\r\n//                 if (type === Types.Map)\r\n//                 {\r\n//                     //log('M: [', id, ']', dataArray[id].A.n);\r\n//                     var localId = dataArray[id].r;\r\n\r\n//                     if (!seen[localId])\r\n//                     {\r\n//                         unusedItems[localId] = dataArray[id];\r\n//                     }\r\n\r\n//                     // Aggregate Map Property Data\r\n//                     var itemKeys = Object.keys(dataArray[id].i.n);\r\n//                     numProps += itemKeys.length;\r\n//                     maxProps = (itemKeys.length > maxProps ? itemKeys.length : maxProps);\r\n\r\n//                     for (var i = 0; i < itemKeys.length; ++i)\r\n//                     {\r\n//                         if (itemKeys[i].startsWith(':'))\r\n//                         {\r\n//                             if (propCounts[itemKeys[i]] === undefined)\r\n//                             {\r\n//                                 propCounts[itemKeys[i]] = 1;\r\n//                             }\r\n//                             else\r\n//                             {\r\n//                                 propCounts[itemKeys[i]]++;\r\n//                             }\r\n\r\n//                             if (itemKeys[i] == ':t')\r\n//                             {\r\n//                                 totalStringSize += (dataArray[id].i.n[':t'].a.length - 2);\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 else if (type === Types.List)\r\n//                 {\r\n//                     //log('L: [', id, ']', dataArray[id].A.n);\r\n//                     //var parentID = Object.keys(dataArray[id].qa.l)[0].substring(1);\r\n\r\n//                     if (dataArray[id].f.e === 0)\r\n//                     {\r\n//                         unusedLists[id.substring(1)] = dataArray[id];\r\n//                     }\r\n//                 }\r\n//                 else if (type === Types.EditableString)\r\n//                 {\r\n//                     //log('S: [', id, ']', dataArray[id]);\r\n//                     //var text = dataArray[id].e.a.a;\r\n\r\n//                     //totalStringSize += text.length;\r\n//                 }\r\n//             }\r\n\r\n//             // Registered classes: C.ua.e.p[]\r\n\r\n//             log('Remote String Size: ', (totalStringSize / 1024).toFixed(2), 'kB');\r\n\r\n//             log('Final Remote Item Counts:');\r\n//             for (var i = 0; i < TypeStrings.length; ++i)\r\n//             {\r\n//                 log(' ', TypeStrings[i], ': ', typeCounts[i]);\r\n//             }\r\n\r\n//             var unusedItemCount = Object.keys(unusedItems).length - 2;\r\n//             if (unusedItemCount > 0)\r\n//             {\r\n//                 log('Total Inaccessible Items:', unusedItemCount);\r\n//                 //log(' ', unusedItems);\r\n//             }\r\n\r\n//             var unusedListCount = Object.keys(unusedLists).length;\r\n//             if (unusedListCount > 0)\r\n//             {\r\n//                 log('Total Unused Lists:', unusedListCount);\r\n//                 //log(' ', unusedLists);\r\n//             }\r\n\r\n//             log('Map Property Counts: ', propCounts);\r\n//             log('Total Properties: ', numProps);\r\n//             log('Max Properties: ', maxProps);\r\n//             log('Average Properties: ', numProps / typeCounts[Types.Map]);\r\n//         }\r\n//         catch(err)\r\n//         {\r\n//             log('%cException in UNSAFE code, time to update it', 'color: red');\r\n//             log(err.stack);\r\n//         }\r\n//     }\r\n// }\r\n\r\nself.migrateData = function()\r\n{\r\n    // Possible Write Ops //\r\n\r\n    var stopDocLoad = false;\r\n\r\n    // When migrating data, ensure that the user is unable to undo any changes that we make.\r\n    var requireLocalReload = false;\r\n    var requireRemoteReload = false;\r\n\r\n    var remoteVersion = self.root.get('dataVersion');\r\n    if (remoteVersion < CURRENT_VERSION)\r\n    {\r\n        self.beginAction();\r\n\r\n        log('Migrating to latest version: ', remoteVersion);\r\n\r\n        try\r\n        {\r\n            switch (remoteVersion)\r\n            {\r\n                case 1:\r\n                    migrateItemData_One(self.root);\r\n                case 2:\r\n                    migrateItemData_Two(self.root);\r\n                case 3:\r\n                    migrateItemData_Three(self.root);\r\n                    requireRemoteReload = true;\r\n                case 4:\r\n                    migrateItemData_Four(self.root);\r\n                default:\r\n                    log('Remote Migration Completed');\r\n                    break;\r\n            }\r\n        }\r\n        catch (err)\r\n        {\r\n            requireRemoteReload = true;\r\n            g.reportError(err);\r\n        }\r\n\r\n        self.endAction();\r\n\r\n        self.model.getRoot().set('dataVersion', CURRENT_VERSION);\r\n\r\n        log('Done Migrating Remote Data!', CURRENT_VERSION);\r\n    }\r\n    else if (remoteVersion > CURRENT_VERSION)\r\n    {\r\n        // When the remote version is larger than the local version, we need to update the app to the newest\r\n        // version, otherwise the data will not be migrated or interpreted properly.\r\n        requireLocalReload = true;\r\n\r\n        // When the remote version is higher than we can upgrade to, stop loading the remote doc and ensure that\r\n        // the page is refreshed with the newer version before loading the remote data.\r\n        stopDocLoad = true;\r\n\r\n        //g.Assert(false, 'Remote version should never be larger than the client version except in cases where using an older version from the AppCache.');\r\n    }\r\n\r\n    if (d.hasLocalData)\r\n    {\r\n        var localVersion = g.settings.get(Settings.localDataVersion) || 0;\r\n        if (localVersion < CURRENT_VERSION)\r\n        {\r\n            try\r\n            {\r\n                switch (localVersion)\r\n                {\r\n                    case 0:\r\n                        d.migrateLocalData_One();\r\n                        requireLocalReload = true;\r\n                        stopDocLoad = true;\r\n                    case 4:\r\n                        d.migrateLocalData_Two();\r\n                    default:\r\n                        log('Local Migration Completed');\r\n                        break;\r\n                }\r\n            }\r\n            catch (err)\r\n            {\r\n                requireLocalReload = true;\r\n                g.reportError(err);\r\n            }\r\n\r\n            g.settings.set(Settings.localDataVersion, CURRENT_VERSION);\r\n\r\n            log('Done Migrating Local Data!', CURRENT_VERSION);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // If there is no local data loaded, the local data will be the same version as the remote data.\r\n        g.settings.set(Settings.localDataVersion, remoteVersion);\r\n    }\r\n\r\n    if (requireLocalReload || requireRemoteReload)\r\n    {\r\n        if (requireLocalReload && !requireRemoteReload)\r\n        {\r\n            // Give the app cache a chance to complete its update before requesting a page reload.\r\n            g.AppCache.runOnFinish(function ()\r\n            {\r\n                g.reload();\r\n            }, /*isTerminal*/true);\r\n        }\r\n        else if (requireRemoteReload && !requireLocalReload)\r\n        {\r\n            self.registerSaveNotify(function ()\r\n            {\r\n                g.reload();\r\n            });\r\n        }\r\n        else\r\n        {\r\n            var reqCount = 0;\r\n\r\n            function reloadFn()\r\n            {\r\n                reqCount++;\r\n\r\n                if (reqCount === 2)\r\n                {\r\n                    g.reload();\r\n                }\r\n            }\r\n\r\n            g.AppCache.runOnFinish(reloadFn, /*isTerminal*/true);\r\n\r\n            self.registerSaveNotify(reloadFn);\r\n        }\r\n    }\r\n\r\n    return stopDocLoad;\r\n};\r\n\r\nfunction migrateItemData_Four(map)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(map, 'Must have a valid root item to migrate');\r\n\r\n    // Skip migration if no contacts are loaded.\r\n    if (d.contacts.length === 0)\r\n    {\r\n        log('Skipping remote data migration four');\r\n        return;\r\n    }\r\n\r\n    var rootItem = map.get('root');\r\n    //map.set('arch', map.createMap());\r\n\r\n    function iterateLink(items)\r\n    {\r\n        if (items)\r\n        {\r\n            for (var i = 0; i < items.length; ++i)\r\n            {\r\n                var item = items.get(i);\r\n                var text = self.get(item, 'text');\r\n\r\n                if (text.indexOf('@') >= 0)\r\n                {\r\n                    var words = text.split(' ');\r\n\r\n                    var lineIndex = 0;\r\n                    for (var i = 0; i < words.length; ++i)\r\n                    {\r\n                        if (words[i].indexOf('@') === 0)\r\n                        {\r\n                            var matchedName = undefined;\r\n                            var combined = words[i].substring(1);\r\n                            for (var u = 1; u < 4; u ++)\r\n                            {\r\n                                var compStr = (combined.indexOf(':', combined.length - 1) !== -1) ? combined.substr(0, combined.length - 1) : combined;\r\n\r\n                                if (d.contactsByName[compStr])\r\n                                {\r\n                                    matchedName = compStr;\r\n                                }\r\n\r\n                                if (i + u < words.length)\r\n                                if (i + u < words.length)\r\n                                {\r\n                                    combined += ' ' + words[i + u];\r\n                                }\r\n                                else\r\n                                {\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            if (matchedName)\r\n                            {\r\n                                g.Assert(text[lineIndex] == '@', 'Explicitly matching @, should always match');\r\n\r\n                                var newText = text.substr(0, lineIndex) + '+' + text.substr(lineIndex + 1);\r\n\r\n                                self.set(item, 'text', newText);\r\n                                setRemoteTextVersion(item);\r\n                            }\r\n                        }\r\n\r\n                        lineIndex += words[i].length + 1; // + 1 for space\r\n                    }\r\n                }\r\n\r\n                iterateRemoteLink(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    function iterateRemoteLink(remoteItem)\r\n    {\r\n        var collabItems = self.get(remoteItem, 'items');\r\n        if (collabItems)\r\n        {\r\n            iterateLink(collabItems);\r\n        }\r\n\r\n        var collabArchivedItems = self.get(remoteItem, 'archivedItems');\r\n        if (collabArchivedItems)\r\n        {\r\n            iterateLink(collabArchivedItems);\r\n        }\r\n    }\r\n\r\n    iterateRemoteLink(rootItem);\r\n}\r\n\r\nfunction migrateItemData_Three(map)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(map, 'Must have a valid root item to migrate');\r\n\r\n    var rootItem = map.get('root');\r\n    //map.set('arch', map.createMap());\r\n\r\n    function iterateLink(items)\r\n    {\r\n        if (items)\r\n        {\r\n            for (var i = 0; i < items.length; ++i)\r\n            {\r\n                var item = items.get(i);\r\n\r\n                var text = self.get(item, 'text');\r\n                if (text.startsWith('!'))\r\n                {\r\n                    self.set(item, 'priority', VMLIFlag.P0);\r\n                    self.set(item, 'text', text.substr(1));\r\n\r\n                    setRemoteTextVersion(item);\r\n                }\r\n                else if (text.startsWith('*'))\r\n                {\r\n                    self.set(item, 'isFlagged', true);\r\n                    self.set(item, 'text', text.substr(1));\r\n\r\n                    setRemoteTextVersion(item);\r\n                }\r\n                else if (text.startsWith('^'))\r\n                {\r\n                    self.set(item, 'isComplete', true);\r\n                    self.set(item, 'text', text.substr(1));\r\n\r\n                    setRemoteTextVersion(item);\r\n                }\r\n\r\n                iterateRemoteLink(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    function iterateRemoteLink(remoteItem)\r\n    {\r\n        var collabItems = self.get(remoteItem, 'items');\r\n        if (collabItems)\r\n        {\r\n            iterateLink(collabItems);\r\n        }\r\n\r\n        var collabArchivedItems = self.get(remoteItem, 'archivedItems');\r\n        if (collabArchivedItems)\r\n        {\r\n            iterateLink(collabArchivedItems);\r\n        }\r\n    }\r\n\r\n    iterateRemoteLink(rootItem);\r\n}\r\n\r\nfunction migrateItemData_Two(map)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(map, 'Must have a valid root item to migrate');\r\n\r\n    var rootItem = map.get('root');\r\n\r\n    function iterateLink(items)\r\n    {\r\n        if (items)\r\n        {\r\n            for (var i = 0; i < items.length; ++i)\r\n            {\r\n                var item = items.get(i);\r\n                g.Assert(item, 'Remote item must exist');\r\n                g.Assert(!g.isString(item), 'New items must be collab maps not strings');\r\n\r\n                iterateRemoteLink(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    function iterateRemoteLink(remoteItem)\r\n    {\r\n        var currentText = self.get(remoteItem, 'text');\r\n\r\n        if (!g.isString(currentText))\r\n        {\r\n            self.set(remoteItem, 'text', currentText.getText());\r\n\r\n            log('Updated Text: ', self.get(remoteItem, 'text'));\r\n        }\r\n\r\n        var collabItems = self.get(remoteItem, 'items');\r\n        if (collabItems)\r\n        {\r\n            iterateLink(collabItems);\r\n        }\r\n\r\n        var collabArchivedItems = self.get(remoteItem, 'archivedItems');\r\n        if (collabArchivedItems)\r\n        {\r\n            iterateLink(collabArchivedItems);\r\n        }\r\n    }\r\n\r\n    iterateRemoteLink(rootItem);\r\n};\r\n\r\nfunction migrateItemData_One(map)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(map, 'Must have a valid root item to migrate');\r\n\r\n    var rootItemID = map.get('root');\r\n    var lookupTable = map.get('items');\r\n\r\n    var rootItem = lookupTable.get(rootItemID);\r\n\r\n    function iterateLink(items)\r\n    {\r\n        var newItems = [ ];\r\n\r\n        if (items)\r\n        {\r\n            for (var i = 0; i < items.length; ++i)\r\n            {\r\n                var itemID = items.get(i);\r\n                g.Assert(g.isString(itemID), 'Must be a valid ID string');\r\n\r\n                var item = lookupTable.get(itemID);\r\n                g.Assert(item, 'Remote item must exist in DB');\r\n                g.Assert(!g.isString(item), 'New items must be collab maps not strings');\r\n\r\n                newItems.push(item);\r\n\r\n                iterateRemoteLink(item);\r\n            }\r\n        }\r\n\r\n        return newItems;\r\n    }\r\n\r\n    function iterateRemoteLink(remoteItem)\r\n    {\r\n        var collabItems = self.get(remoteItem, 'items');\r\n        if (collabItems)\r\n        {\r\n            var newItems = iterateLink(collabItems);\r\n\r\n            g.Assert(newItems.length === collabItems.length, 'New item list must be the same length as the old one');\r\n\r\n            if (newItems.length > 0)\r\n            {\r\n                collabItems.replaceRange(0, newItems);\r\n            }\r\n        }\r\n\r\n\r\n        var collabArchivedItems = self.get(remoteItem, 'archivedItems');\r\n        if (collabArchivedItems)\r\n        {\r\n            var newArchivedItems = iterateLink(collabArchivedItems);\r\n\r\n            g.Assert(newArchivedItems.length === collabArchivedItems.length, 'New item list must be the same length as the old one');\r\n\r\n            if (newArchivedItems.length > 0)\r\n            {\r\n                collabArchivedItems.replaceRange(0, newArchivedItems);\r\n            }\r\n        }\r\n    }\r\n\r\n    iterateRemoteLink(rootItem);\r\n\r\n    map.set('root', rootItem);\r\n};\r\n\r\n//\r\n// Batch actions to coalesce multiple data modifications into a single operation. This does\r\n// not have transactional safety, only that the actions performed get sent together.\r\n//\r\nself.beginAction = function()\r\n{\r\n    if (self.model)\r\n    {\r\n        g.Assert(!self.flushingDeferredActions, 'Should never begin a new action while flushing');\r\n\r\n        g.Assert(!self.inCompoundOperation, 'Should not nest compound operations');\r\n        g.Assert(!self.wantCompoundOperation, 'Should not nest compound operations');\r\n        g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n\r\n        if (DEBUG) log('<<<< Request Action >>>>');\r\n        self.wantCompoundOperation = true;\r\n    }\r\n};\r\n\r\nvar ensureActionTimeout = undefined;\r\nself.beginWriteAction = function()\r\n{\r\n    if (self.model)\r\n    {\r\n        // If currently flushing deferred operations, ignore any starts to begin flushing\r\n        if (!self.flushingDeferredActions)\r\n        {\r\n            g.Assert(self.inCompoundOperation || self.wantCompoundOperation, 'If performing an action, we should have already requested a compound operation');\r\n\r\n            if (!self.inCompoundOperation && self.wantCompoundOperation)\r\n            {\r\n                self.flushDeferredActions();\r\n\r\n                setTimeout(ensureWriteAction, 0);\r\n\r\n                if (DEBUG) log('<<<< Begin Action >>>>');\r\n                self.model.beginCompoundOperation();\r\n\r\n                self.inCompoundOperation = true;\r\n                self.wantCompoundOperation = false;\r\n            }\r\n            else\r\n            {\r\n                //log('<<<< Perform Action >>>>');\r\n                g.Assert(!self.wantCompoundOperation, 'Should not nest compound operations');\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nself.endAction = function()\r\n{\r\n    if (self.model)\r\n    {\r\n        g.Assert(!self.flushingDeferredActions, 'Should never end an action while flushing');\r\n\r\n        g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n        g.Assert(self.inCompoundOperation || self.wantCompoundOperation, 'If ending an action, a beginning should have happened');\r\n\r\n        try\r\n        {\r\n            if (self.inCompoundOperation)\r\n            {\r\n                self.model.endCompoundOperation();\r\n                if (DEBUG) log('<<<< Ending Action >>>>');\r\n            }\r\n            else\r\n            {\r\n                if (DEBUG) log('<<<< Action Skipped >>>>');\r\n            }\r\n        }\r\n        catch (err)\r\n        {\r\n            g.goog.recoverFromError(err);\r\n        }\r\n        finally\r\n        {\r\n            self.inCompoundOperation = false;\r\n            self.wantCompoundOperation = false;\r\n\r\n            clearTimeout(ensureActionTimeout);\r\n        }\r\n    }\r\n};\r\n\r\nfunction ensureWriteAction()\r\n{\r\n    g.Assert(!self.inCompoundOperation, 'Should never be in a compound operation after sync block finishes');\r\n    g.Assert(!self.wantCompoundOperation, 'Should never want a compound operation after a sync block finishes');\r\n\r\n    if (self.inCompoundOperation)\r\n    {\r\n        self.model.endCompoundOperation();\r\n        if (DEBUG) log('<<<< Ensure Ending Action >>>>');\r\n\r\n        g.reportError(new Error('Compound operation open after sync block finished'));\r\n    }\r\n\r\n    ensureActionTimeout = undefined;\r\n}\r\n\r\n// Default timeout for deferring actions\r\nvar DEFERRED_ACTION_TIMEOUT = 800;\r\n\r\n// Track deferred actions on a per-item basis\r\nvar deferredActions = { };\r\nvar hasPendingDeferredActions = false;\r\n\r\n// Setup a timer to flush deferred actions even if other actions that force a flush are never performed.\r\nvar flushDeferredActionsTimeout = undefined;\r\n\r\nself.performDeferredAction = function(item, action)\r\n{\r\n    g.Assert(item, 'Must supply a valid item to perform the action on');\r\n    g.Assert(action, 'Must supply a valid action to be performed');\r\n\r\n    if (self.model)\r\n    {\r\n        g.Assert(!self.inCompoundOperation, 'Cannot perform deferred action after a compound operation has started');\r\n\r\n        if (DEBUG)\r\n        {\r\n            // Verify only supported properties are being deferred\r\n\r\n        }\r\n\r\n        //log('Performing Deferred Action: ', action);\r\n\r\n        if (deferredActions[item.id])\r\n        {\r\n            for (var prop in action)\r\n            {\r\n                deferredActions[item.id].changes[prop] = action[prop];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            deferredActions[item.id] = { item: item, changes: action };\r\n        }\r\n\r\n        hasPendingDeferredActions = true;\r\n\r\n        clearTimeout(flushDeferredActionsTimeout);\r\n        flushDeferredActionsTimeout = setTimeout(self.flushDeferredActions, DEFERRED_ACTION_TIMEOUT);\r\n    }\r\n};\r\n\r\nself.flushDeferredActions = function()\r\n{\r\n    if (self.model && !self.isClosed)\r\n    {\r\n        g.Assert(!self.flushingDeferredActions, 'Should never recursively call flushDeferredActions');\r\n        g.Assert(!self.inCompoundOperation, 'Must flush deferred actions before starting a compound operation');\r\n\r\n        if (hasPendingDeferredActions)\r\n        {\r\n            clearTimeout(flushDeferredActionsTimeout);\r\n            flushDeferredActionsTimeout = undefined;\r\n\r\n            self.flushingDeferredActions = true;\r\n\r\n            try\r\n            {\r\n                self.model.beginCompoundOperation();\r\n\r\n                try\r\n                {\r\n                    for (var id in deferredActions)\r\n                    {\r\n                        if (DEBUG) log('Flushing Deferred Action: ', deferredActions[id]);\r\n\r\n                        saveChangesInternal(deferredActions[id].item, deferredActions[id].changes);\r\n                    }\r\n\r\n                    self.flushingDeferredActions = false;\r\n\r\n                    hasPendingDeferredActions = false;\r\n                    deferredActions = { };\r\n                }\r\n                catch (innerErr)\r\n                {\r\n                    g.reportError(err);\r\n                }\r\n\r\n                self.model.endCompoundOperation();\r\n            }\r\n            catch (err)\r\n            {\r\n                g.reportError(err);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nfunction attachEvents(item)\r\n{\r\n    // No Write Ops //\r\n\r\n    g.Assert(item, 'Must have a valid local item to attach events to');\r\n    g.Assert(item instanceof VMLI, 'Must pass in a valid instace of a local item');\r\n    g.Assert(item.data, 'Must have a valid remote item to attach events to');\r\n\r\n    item.data.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, item.onObjectChanged.bind(item));\r\n}\r\n\r\nself.createNewItem = function (item, hasItems, hasArchivedItems)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(item instanceof VMLI, 'Must pass in a valid instace of a local item');\r\n    g.Assert(self.inCompoundOperation, 'Should always create an item inside of a compound operation');\r\n    g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n    g.Assert(self.model, 'Need a valid model to create collaborative items');\r\n\r\n    g.Assert(!item.data, 'When initializing a new item, it should have no gdata components already');\r\n\r\n    var map = self.model.createMap();\r\n    item.data = map;\r\n\r\n    if (DEBUG) log('Creating New Item: ', map.id);\r\n\r\n    self.set(map, 'text', item.getRawText());\r\n\r\n    if (hasItems)\r\n    {\r\n        var collabList = self.model.createList();\r\n        self.set(map, 'items', collabList);\r\n    }\r\n\r\n    if (hasArchivedItems)\r\n    {\r\n        var collabArchiveList = self.model.createList();\r\n        self.set(map, 'archivedItems', collabArchiveList);\r\n    }\r\n\r\n    self.set(map, 'dateCreated', item.dateCreated.getTime());\r\n\r\n    item.id = map.id;\r\n\r\n    if (!itemCache[map.id])\r\n    {\r\n        itemCache[map.id] = map;\r\n    }\r\n\r\n    return map.id;\r\n};\r\n\r\nself.initializeNewItem = function (item)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(item instanceof VMLI, 'Must pass in a valid instace of a local item');\r\n    g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n    g.Assert(self.inCompoundOperation, 'Should always initialize an item inside of a compound operation');\r\n\r\n    if (item.hasChildren())\r\n    {\r\n        var items = item.items();\r\n        var collabList = ensureRemoteItemsArray(item);\r\n        g.Assert(collabList);\r\n\r\n        for (var i = 0; i < items.length; ++i)\r\n        {\r\n            g.Assert(items[i].data, 'Item must have a valid remote to be added to a collab list');\r\n            collabList.push(items[i].data);\r\n        }\r\n    }\r\n\r\n    if (item.hasArchivedChildren())\r\n    {\r\n        var archivedItems = item.archivedItems(/*underlying*/true);\r\n\r\n        var collabArchivedList = ensureRemoteArchiveArray(item);\r\n\r\n        g.Assert(collabArchivedList);\r\n\r\n        for (var i = 0; i < archivedItems.length; ++i)\r\n        {\r\n            g.Assert(archivedItems[i].data, 'Item must have a valid remote to be added to a collab list');\r\n            collabArchivedList.push(archivedItems[i].data);\r\n        }\r\n    }\r\n\r\n    attachEvents(item);\r\n};\r\n\r\n//\r\n// Given a VMLI, have it listen to gdrive events. This requires that the item has already loaded\r\n// its data from gdrive.\r\n//\r\nself.attachEventsToItem = function(item)\r\n{\r\n    // No Write Ops //\r\n\r\n    g.Assert(item instanceof VMLI, 'Must pass in a valid local item');\r\n    g.Assert(item.data, 'Must have loaded data from gdrive before attaching events to item');\r\n\r\n    attachEvents(item);\r\n};\r\n\r\n//\r\n// Allow clients to register themselves to be notified when the undo/redo state changes for the loaded model.\r\n//\r\nvar undoRedoStateChangeHandler;\r\nself.registerForUndoRedoStateChange = function (handler)\r\n{\r\n    // No Write Ops //\r\n\r\n    if (self.model)\r\n    {\r\n        self.model.addEventListener(gapi.drive.realtime.EventType.UNDO_REDO_STATE_CHANGED, handler.stateChangeForUndoRedo);\r\n\r\n        // Initialize the client requesting updates for undo/redo state with values stored in the model.\r\n        handler.stateChangeForUndoRedo({\r\n            'canUndo': self.model.canUndo,\r\n            'canRedo': self.model.canRedo\r\n        });\r\n    }\r\n    else\r\n    {\r\n        undoRedoStateChangeHandler = handler;\r\n    }\r\n};\r\n\r\nself.registerForSaveStateChange = function (handler)\r\n{\r\n    // No Write Ops //\r\n\r\n    g.Assert(self.doc);\r\n    self.doc.addEventListener(gapi.drive.realtime.EventType.DOCUMENT_SAVE_STATE_CHANGED, handler);\r\n};\r\n\r\nself.loadCollaborators = function ()\r\n{\r\n    var collabs = self.doc.getCollaborators();\r\n\r\n    var selfInfo = undefined;\r\n    for (var i = 0; i < collabs.length; ++i)\r\n    {\r\n        var collab = collabs[i];\r\n\r\n        if (collab.isMe)\r\n        {\r\n            selfInfo = collab;\r\n        }\r\n    }\r\n\r\n    self.authenticatedUser(selfInfo);\r\n};\r\n\r\n//\r\n// Callbacks to give clients the ability to request a redo or undo of their last action.\r\n//\r\nself.undoAction = function ()\r\n{\r\n    self.flushDeferredActions();\r\n\r\n    g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n\r\n    g.Assert(self.model.canUndo);\r\n\r\n    if (DEBUG) log('>>>> Begin GData Undo <<<<');\r\n\r\n    self.model.undo();\r\n\r\n    if (DEBUG) log('>>>> End GData Undo <<<<');\r\n};\r\n\r\nself.redoAction = function ()\r\n{\r\n    self.flushDeferredActions();\r\n\r\n    g.Assert(!self.isClosed, 'Document must be open to make changes');\r\n\r\n    g.Assert(self.model.canRedo);\r\n\r\n    if (DEBUG) log('>>>> Begin GData Redo <<<<');\r\n\r\n    self.model.redo();\r\n\r\n    if (DEBUG) log('>>>> End GData Redo <<<<');\r\n};\r\n\r\nself.getItemList = function(model, isArchived)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(!(model instanceof VMLI), 'Must pass in a valid remote item');\r\n\r\n    if (isArchived)\r\n    {\r\n        return self.get(model, 'archivedItems');\r\n    }\r\n    else\r\n    {\r\n        return self.get(model, 'items');\r\n    }\r\n}\r\n\r\nself.ensureItemList = function(item, isArchived)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(item instanceof VMLI, \"Must pass in a valid local item\");\r\n\r\n    if (isArchived)\r\n    {\r\n        return ensureRemoteArchiveArray(item);\r\n    }\r\n    else\r\n    {\r\n        return ensureRemoteItemsArray(item);\r\n    }\r\n}\r\n\r\nfunction ensureRemoteItemsArray(item)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(item instanceof VMLI);\r\n    g.Assert(item.data, 'Must have valid remote item to attach events to and create');\r\n\r\n    var itemList = self.get(item.data, 'items');\r\n\r\n    if (!itemList)\r\n    {\r\n        itemList = self.model.createList();\r\n        self.set(item.data, 'items', itemList);\r\n\r\n        //log('Creating a remote items array:', item.id);\r\n\r\n        // itemList.addEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, item.onListAdded.bind(item));\r\n        // itemList.addEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, item.onListRemoved.bind(item));\r\n        //itemList.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, item.onObjectChanged.bind(item));\r\n    }\r\n\r\n    return itemList;\r\n}\r\n\r\nfunction ensureRemoteArchiveArray(item)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(item instanceof VMLI);\r\n    g.Assert(item.data, 'Must have valid remote item to attach events to and create');\r\n\r\n    var archivedList = self.get(item.data, 'archivedItems');\r\n\r\n    if (!archivedList)\r\n    {\r\n        archivedList = self.model.createList();\r\n        self.set(item.data, 'archivedItems', archivedList);\r\n\r\n        //log('Creating a remote archive array:', item.id);\r\n\r\n        // archivedList.addEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, item.onListAdded.bind(item));\r\n        // archivedList.addEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, item.onListRemoved.bind(item));\r\n        //archivedList.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, item.onObjectChanged.bind(item));\r\n    }\r\n\r\n    return archivedList;\r\n}\r\n\r\n// function removeRemoteArchiveArrayIfNecessary(model)\r\n// {\r\n//     var clearedArray = false;\r\n\r\n//     // var archivedList = self.get(model, 'archivedItems');\r\n\r\n//     // if (archivedList && archivedList.length === 0)\r\n//     // {\r\n//     //     archivedList.removeEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, model.onListAdded);\r\n//     //     archivedList.removeEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, model.onListRemoved);\r\n\r\n//     //     // TODO: We should remove this in production.\r\n//     //     archivedList.removeEventListener(gapi.drive.realtime.EventType.VALUES_SET, model.onListSet);\r\n\r\n//     //     self.delete(model, 'archivedItems');\r\n\r\n//     //     clearedArray = true;\r\n//     // }\r\n\r\n//     return clearedArray;\r\n// }\r\n\r\nself.canSave = function(item)\r\n{\r\n    if(!self.initialized)\r\n        return;\r\n\r\n    var data = (item instanceof VMLI) ? item.data : item;\r\n    g.Assert(data && !self.isClosed, 'Document must be open to make changes');\r\n\r\n    return (data && !self.isClosed) ? data : false;\r\n};\r\n\r\nself.deleteTree = function(item)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(!(item instanceof VMLI), 'Must not be a VMLI, should be a remote item');\r\n    g.Assert(!g.isString(item), 'Must pass in a valid remote item not an ID');\r\n\r\n    //log('Delete Tree: ', id);\r\n\r\n    if (DEBUG) log('%cDelete tree from remote', 'color: red', item.id, self.get(item, 'text'));\r\n\r\n    var items = self.get(item, 'items');\r\n\r\n    if (items)\r\n    {\r\n        for(var i = 0; i < items.length; i ++)\r\n        {\r\n            var child = items.get(i);\r\n            self.deleteTree(child);\r\n        }\r\n    }\r\n\r\n    // TODO: Where are archived items handled during tree deletion?\r\n\r\n    delete itemCache[item.id];\r\n};\r\n\r\nif (DEBUG && DEBUG)\r\n{\r\n    window.__REMOTE_VERSION_UPDATES = g.createRingBuffer(50);\r\n    window.__LOCAL_VERSION_UPDATES = g.createRingBuffer(50);\r\n    window.__MEM_VERSION_UPDATES = g.createRingBuffer(50);\r\n\r\n    window.clearVersionUpdates = function()\r\n    {\r\n        window.__REMOTE_VERSION_UPDATES.reset();\r\n        window.__LOCAL_VERSION_UPDATES.reset();\r\n        window.__MEM_VERSION_UPDATES.reset();\r\n    };\r\n}\r\n\r\nfunction setRemoteVersion(data)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    var v = self.getVersion(data, VersionType.Structure);\r\n    v = v ? v + 1 : 1;\r\n\r\n    if (DEBUG && DEBUG)\r\n    {\r\n        var verStr = self.getVersion(data, VersionType.Structure) + ' -> ' + v;\r\n        window.__REMOTE_VERSION_UPDATES.push('VERSION: ' + data.id + ': ' + g.getCurrentStack(verStr));\r\n\r\n        if (DEBUG) log('Setting remote version ' + data.id + ': ', verStr);\r\n    }\r\n\r\n    self.set(data, 'version', v);\r\n}\r\n\r\nfunction setRemoteTextVersion(data)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    var v = self.getVersion(data, VersionType.Text);\r\n    v = v ? v + 1 : 1;\r\n\r\n    if (DEBUG && DEBUG)\r\n    {\r\n        var verStr = self.getVersion(data, VersionType.Text) + ' -> ' + v;\r\n        window.__REMOTE_VERSION_UPDATES.push('VERSIONTEXT: ' + data.id + ': ' + g.getCurrentStack(verStr));\r\n\r\n        if (DEBUG) log('Setting remote TEXT version ' + data.id + ': ', verStr);\r\n    }\r\n\r\n    self.set(data, 'versionText', v);\r\n}\r\n\r\n//\r\n// Notification that a single item has been added to the items array.\r\n//\r\nself.itemAdded = function(params)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    //log('--Add Remote Item: ', params);\r\n    //if (DEBUG) log('%cAdded:', 'color: red', params.item.id, params.item.text, params.addedItem.text);\r\n\r\n    var item = params.item;\r\n    var addedItem = params.addedItem;\r\n    var index = params.index;\r\n    var isArchived = params.isArchived;\r\n    var noVersion = params.noVersion;\r\n\r\n    g.Assert(item !== undefined && addedItem !== undefined && isArchived !== undefined, 'itemAdded is missing parameters');\r\n    g.Assert(index >= -1 || index === undefined, 'Invalid index', index);\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    var addedData = addedItem.data;\r\n    g.Assert(addedData, 'Must have valid gdata for the item being inserted', addedData);\r\n\r\n    d.addPendingUpdate(item.id);\r\n    d.addPendingUpdate(addedItem.id);\r\n\r\n    var arr = self.ensureItemList(item, isArchived);\r\n    g.Assert(arr, 'Must have a valid remote list to add the item to');\r\n\r\n    if (index < 0 || isNaN(index) || index > arr.length)\r\n    {\r\n        arr.push(addedData);\r\n    }\r\n    else\r\n    {\r\n        arr.insert(index, addedData);\r\n    }\r\n\r\n    // var wasArchived = self.get(addedData, 'isArchived');\r\n    // if (wasArchived !== isArchived)\r\n    // {\r\n    //     self.set(addedData, 'isArchived', isArchived);\r\n    // }\r\n\r\n    if (!noVersion)\r\n    {\r\n        setRemoteVersion(addedItem.data);\r\n    }\r\n\r\n    if (DEBUG) log('Item Added Locally: ', addedItem.id, self.getVersion(itemData, VersionType.Structure));\r\n};\r\n\r\n//\r\n// Notification that one or more entries has been added to the items array.\r\n//\r\nself.itemsAdded = function(params)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    //if (DEBUG)  log('%cItems Added:', 'color: red', params.item.id, params);\r\n    var item = params.item;\r\n    g.Assert((item instanceof VMLI), 'Passed in item must be a VMLI');\r\n\r\n    var addedItems = params.addedItems;\r\n    var index = params.index;\r\n    var isArchived = params.isArchived;\r\n    var noVersion = params.noVersion;\r\n\r\n    g.Assert(item !== undefined && addedItems !== undefined && isArchived !== undefined, 'itemsAdded is missing parameters');\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    var arr = self.ensureItemList(item, isArchived);\r\n    g.Assert(arr, 'Must have a valid remote list to add the item to');\r\n\r\n    // grab the google data objects out of the VMLIs to be inserted\r\n    var addedArr = new Array(addedItems.length);\r\n    for (var i = 0; i < addedItems.length; ++i)\r\n    {\r\n        addedArr[i] = addedItems[i].data;\r\n        d.addPendingUpdate(addedItems[i].id);\r\n\r\n        if (!noVersion && addedArr[i])\r\n        {\r\n            setRemoteVersion(addedArr[i]);\r\n        }\r\n    }\r\n\r\n    d.addPendingUpdate(item.id);\r\n\r\n    if (index < 0 || isNaN(index))\r\n    {\r\n        g.Assert(isArchived, 'Only archived items should be inserted into a list by pushing');\r\n\r\n        arr.pushAll(addedArr);\r\n    }\r\n    else\r\n    {\r\n        arr.insertAll(index, addedArr);\r\n    }\r\n\r\n    if (DEBUG) log('Items Added Locally To', item.id, self.getVersion(itemData, VersionType.Structure));\r\n};\r\n\r\n//\r\n// Notification that one or more entries has been removed from the items array.\r\n//\r\nself.itemRemoved = function(params)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    //if (DEBUG) log('%cItem(s) Removed:', 'color: red', params.item.id, params.item.text, params.index);\r\n    var item = params.item;\r\n    var index = params.index;\r\n    var numToRemove = params.numToRemove;\r\n    var isArchived = params.isArchived;\r\n    var noDelete = params.noDelete;\r\n    var noVersion = params.noVersion;\r\n\r\n    g.Assert(item !== undefined && index !== undefined && numToRemove !== undefined && isArchived !== undefined, 'itemRemoved is missing parameters');\r\n    g.Assert(index >= 0, 'Must have a valid index to remove from');\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    if (isNaN(numToRemove))\r\n    {\r\n        numToRemove = 1;\r\n    }\r\n\r\n    var arr = self.getItemList(itemData, isArchived);\r\n    g.Assert(arr, 'Must have a valid remote list to remove the item from');\r\n\r\n    // Iterate through each item that is going to be removed. For each mark it as pending an update and\r\n    // increment its version if necessary. If a delete is requested, perform that as well.\r\n    for (var i = index; i < (index + numToRemove); i ++)\r\n    {\r\n        var deleted = arr.get(i);\r\n\r\n        d.addPendingUpdate(deleted.id);\r\n\r\n        if (!noVersion)\r\n        {\r\n            setRemoteVersion(deleted);\r\n        }\r\n\r\n        if (!noDelete)\r\n        {\r\n            self.deleteTree(deleted);\r\n        }\r\n    }\r\n\r\n    d.addPendingUpdate(item.id);\r\n\r\n    if (numToRemove === 1)\r\n    {\r\n        arr.remove(index);\r\n    }\r\n    else\r\n    {\r\n        arr.removeRange(index, index + numToRemove);\r\n    }\r\n\r\n    //removeRemoteArchiveArrayIfNecessary(itemData);\r\n\r\n    //setRemoteVersion(itemData);\r\n\r\n    if (DEBUG) log('Items Removed Locally From: ', item.id, index, numToRemove, self.getVersion(itemData, VersionType.Structure));\r\n};\r\n\r\nself.itemMoved = function(params)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    // if (DEBUG) log('%cMoved:', 'color: red', params);\r\n    var item = params.item;\r\n    var newInfo = params.newInfo;\r\n    var oldParent = params.oldParent;\r\n    var oldInfo = params.oldInfo;\r\n    var noVersion = params.noVersion;\r\n\r\n    g.Assert(item !== undefined && newInfo !== undefined && oldParent !== undefined && oldInfo !== undefined, 'itemMoved is missing parameters');\r\n\r\n    g.Assert(newInfo && newInfo.index >= -1);\r\n    g.Assert(newInfo && newInfo.isArchived !== undefined);\r\n    g.Assert(oldParent);\r\n    g.Assert(oldInfo && oldInfo.index >= 0);\r\n    g.Assert(oldInfo && oldInfo.isArchived !== undefined);\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    d.addPendingUpdate(item.id);\r\n\r\n    self.itemRemoved({\r\n        item: oldParent,\r\n        index: oldInfo.index,\r\n        numToRemove: 1,\r\n        isArchived: oldInfo.isArchived,\r\n        noDelete: true,\r\n        noVersion: true // Only update the version info once when moving which will happen when adding the item\r\n    });\r\n\r\n    self.itemAdded({\r\n        item: item.parent(),\r\n        addedItem: item,\r\n        index: newInfo.index,\r\n        isArchived: newInfo.isArchived,\r\n        noVersion: noVersion\r\n    });\r\n\r\n    if (DEBUG) log('Item Moved Locally: ', item.id, 'from', oldParent.id, 'to', item.parent().id);\r\n};\r\n\r\nself.itemArchived = function(item, itemArchived, index)\r\n{\r\n    g.Assert(index >= 0, 'Must have a valid index to remove from');\r\n\r\n    self.beginWriteAction();\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    d.addPendingUpdate(item.id);\r\n    d.addPendingUpdate(itemArchived.id);\r\n\r\n    var items = self.get(itemData, 'items');\r\n    g.Assert(items, 'Must be an items array present');\r\n\r\n    var archivedItems = ensureRemoteArchiveArray(item);\r\n    g.Assert(archivedItems, 'Must be an archived items array present');\r\n\r\n    if (DEBUG) log('Removing item [', index, ']: ', self.get(items.get(index), 'text'));\r\n    items.remove(index);\r\n\r\n    if (DEBUG) log('Reinserting at: ', items.length);\r\n    archivedItems.push(itemArchived.data);\r\n\r\n    setRemoteVersion(itemArchived.data);\r\n\r\n    if (DEBUG) log('Item Archived Locally: ', itemArchived.id, self.getVersion(itemArchived, VersionType.Structure));\r\n};\r\n\r\nself.itemUnarchived = function(item, itemUnarchived, removeIndex, insertIndex)\r\n{\r\n    g.Assert(removeIndex >= 0, 'Must have a valid index to remove from');\r\n\r\n    self.beginWriteAction();\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    d.addPendingUpdate(item.id);\r\n    d.addPendingUpdate(itemUnarchived.id);\r\n\r\n    var items = self.get(itemData, 'items');\r\n    g.Assert(items, 'Must be an items array present');\r\n\r\n    var archivedItems = self.get(itemData, 'archivedItems');\r\n    g.Assert(archivedItems, 'Must be an archived items array present');\r\n\r\n    if (DEBUG) log('Removing item [', removeIndex, ']: ', self.get(archivedItems.get(removeIndex), 'text'));\r\n    archivedItems.remove(removeIndex);\r\n\r\n    if (DEBUG) log('Reinserting at: ', insertIndex);\r\n    items.insert(insertIndex, itemUnarchived.data);\r\n\r\n    // var removedArray = removeRemoteArchiveArrayIfNecessary(itemData);\r\n    // if (DEBUG) log('Removed archive array from ', item.id);\r\n\r\n    setRemoteVersion(itemUnarchived.data);\r\n\r\n    if (DEBUG) log('Item Unarchived Locally: ', itemUnarchived.id, self.getVersion(itemUnarchived, VersionType.Structure));\r\n};\r\n\r\n// if (DEBUG)\r\n// {\r\n//     window.__REMOTE_UPDATE_STACKS = g.createRingBuffer(50);\r\n// }\r\n\r\n//\r\n// Writes out the changes to a given item, only items that have been changed are written.\r\n//\r\nself.saveChanges = function(item, changes)\r\n{\r\n    if (self.inCompoundOperation)\r\n    {\r\n        saveChangesInternal(item, changes);\r\n    }\r\n    else\r\n    {\r\n        self.performDeferredAction(item, changes);\r\n    }\r\n};\r\n\r\nfunction saveChangesInternal(item, changes)\r\n{\r\n    // if (DEBUG)\r\n    // {\r\n    //     window.__REMOTE_UPDATE_STACKS.push(g.getCurrentStack(changes));\r\n    // }\r\n\r\n    var itemData = self.canSave(item);\r\n    if(!itemData)\r\n        return;\r\n\r\n    if (g.isEmpty(changes))\r\n    {\r\n        if (ShouldLog(LogLevels.Warning)) log('Skipped remote saving an empty object');\r\n        return;\r\n    }\r\n\r\n    self.beginWriteAction();\r\n\r\n    d.addPendingUpdate(item.id);\r\n\r\n\tfor (var prop in changes)\r\n\t{\r\n        g.Assert(changes.hasOwnProperty(prop), 'Changes should only contain properties they own');\r\n\r\n        if (changes.hasOwnProperty(prop))\r\n        {\r\n            switch (prop)\r\n            {\r\n                case 'text':\r\n                    g.Assert(g.isString(changes['text']));\r\n\r\n                    self.set(itemData, 'text', changes['text']);\r\n                    break;\r\n                case 'date':\r\n                    g.Assert(!changes['date'] || typeof changes['date'] == 'number');\r\n\r\n                    self.set(itemData, 'date', changes['date']);\r\n                    break;\r\n                case 'dateCreated':\r\n                    g.Assert(typeof changes['dateCreated'] == 'number');\r\n\r\n                    self.set(itemData, 'dateCreated', changes['dateCreated']);\r\n                    break;\r\n                case 'dateCompleted':\r\n                    g.Assert(!changes['dateCompleted'] || typeof changes['dateCompleted'] == 'number');\r\n\r\n                    self.set(itemData, 'dateCompleted', changes['dateCompleted']);\r\n                    break;\r\n                case 'allDayDate':\r\n                case 'priority':\r\n                case 'isComplete':\r\n                case 'isFlagged':\r\n                    self.set(itemData, prop, changes[prop]);\r\n                    break;\r\n                case 'isCollapsed':\r\n                case 'isArchived':\r\n                    g.Assert(false, 'These properties are not set this way');\r\n\r\n                    self.set(itemData, prop, changes[prop]);\r\n                    break;\r\n                case 'modifiedOfflineText':\r\n                case 'dateText':\r\n                    // Do Nothing - Not saved remotely\r\n                    break;\r\n                default:\r\n                    g.Assert(false, 'Attempting to remotely save an unknown field: ', prop);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // TODO: Are there cases where both the text and non-text versions need to be updated at the same time?\r\n    // if (isText)\r\n    // {\r\n        setRemoteTextVersion(itemData);\r\n    // }\r\n    // else\r\n    // {\r\n    //     setRemoteVersion(itemData);\r\n    // }\r\n\r\n    if (DEBUG) log('Item Changes Saved:', item.getVersion(VersionType.Text), changes);\r\n\r\n    // print();\r\n    // if (self.savedTimeout)\r\n    // {\r\n    //     clearTimeout(self.savedTimeout);\r\n    // }\r\n};\r\n\r\n// self.insertText = function (item, index, text)\r\n// {\r\n//     var itemData = self.canSave(item);\r\n//     if(!itemData)\r\n//         return;\r\n\r\n//     d.addPendingUpdate(item);\r\n\r\n\r\n//     self.get(itemData, 'text').insertString(index, text);\r\n\r\n\r\n//     setRemoteTextVersion(itemData);\r\n\r\n//     //log('Item Text Insert Saved:', index, text);\r\n\r\n//     if (self.savedTimeout)\r\n//     {\r\n//         clearTimeout(self.savedTimeout);\r\n//     }\r\n// };\r\n\r\nself.close = function(info)\r\n{\r\n    g.Assert(!self.wantCompoundOperation, 'Closing the doc with a deferred compound operation');\r\n\r\n    if (self.doc && !self.isClosed)\r\n    {\r\n        log('---- Closing Remote Document! ----');\r\n\r\n        self.isClosed = true;\r\n        self.initialized = false;\r\n        self.model = undefined;\r\n        self.doc = undefined;\r\n        self.root = undefined;\r\n\r\n        g.messageQueue.pushMessage(MessageID.DriveError);\r\n\r\n        g.vmMain.setGDriveStatus(DriveStatus.Offline);\r\n\r\n        try\r\n        {\r\n            self.doc.close();\r\n        }\r\n        catch (err)\r\n        {\r\n            log('Error Closing Doc: ', err);\r\n        }\r\n\r\n        g.reportError(new Error('Document closed'), info);\r\n    }\r\n};\r\n\r\nself.onInitialized = function(model)\r\n{\r\n    // Ops on Doc Create //\r\n    log('Initializing', model);\r\n\r\n    if (!d)\r\n    {\r\n        d = require('data');\r\n    }\r\n\r\n    if (!VMLI)\r\n    {\r\n        VMLI = require('VMLI');\r\n    }\r\n\r\n    // Create root item\r\n    var home = model.createMap();\r\n    var homeItems = model.createList();\r\n\r\n    self.set(home, 'text', 'Home');\r\n    self.set(home, 'items', homeItems);\r\n\r\n    self.set(home, 'archivedItems', model.createList());\r\n    self.set(home, 'dateCreated', Date.now());\r\n\r\n    // Create default empty child\r\n    var child = model.createMap();\r\n\r\n    self.set(child, 'text', '');\r\n    self.set(child, 'dateCreated', Date.now());\r\n\r\n    // Add default child to root item\r\n    homeItems.push(child);\r\n\r\n\r\n    var root = model.getRoot();\r\n    root.set('dataVersion', CURRENT_VERSION);\r\n    root.set('root', home);\r\n\r\n    // Create archived items depot\r\n    //root.set('arch', model.createMap());\r\n};\r\n\r\nself.saveSetting = function(e)\r\n{\r\n    self.flushDeferredActions();\r\n\r\n    g.Assert(self.settingsRemote, 'Remote settings required to sync');\r\n\r\n    if (!e.data.isRemote)\r\n    {\r\n        if (DEBUG) log('SETTINGS: Saving settings to remote ', e.data);\r\n\r\n        var value = e.data.value;\r\n        var property = e.data.property;\r\n\r\n        // Versions that get modified locally are negative.\r\n        if (property.startsWith(g.settings.prefix))\r\n        {\r\n            value = Math.abs(value);\r\n\r\n            g.settings.setVersion(property, value);\r\n        }\r\n\r\n        if (self.settingsLocal[property] !== value)\r\n        {\r\n            self.settingsLocal[property] = value;\r\n            self.settingsRemote.set(property, value);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (DEBUG) log('SETTINGS: Skipping saving settings to remote', e.data);\r\n    }\r\n};\r\n\r\nself.onRemoteSettingsLoad = function()\r\n{\r\n    if (g.settings.set(Settings.syncContacts, self.settingsLocal[Settings.syncContacts], self.settingsLocal[g.settings.prefix + Settings.syncContacts]))\r\n    {\r\n        g.goog.authAndLoadContacts();\r\n    }\r\n\r\n    if (g.settings.set(Settings.docSharing, self.settingsLocal[Settings.docSharing], self.settingsLocal[g.settings.prefix + Settings.docSharing]))\r\n    {\r\n        g.goog.authDocSharing();\r\n    }\r\n\r\n    window.addEventListener('settingsChange', self.saveSetting);\r\n};\r\n\r\nfunction onSettingsChanged(change)\r\n{\r\n    // TODO: Handle undo/redo?\r\n    var wasChanged = false;\r\n    for (var i = 0; i < change.events.length; ++i)\r\n    {\r\n        var ev = change.events[i];\r\n\r\n        if (!ev.isLocal)\r\n        {\r\n            // Only consider properties changed when non-version ones do.\r\n            if (!ev.property.startsWith(g.settings.prefix))\r\n            {\r\n                wasChanged = true;\r\n            }\r\n\r\n            self.settingsLocal[ev.property] = ev.newValue;\r\n\r\n            g.fireCustomEvent('settingsChange_' + ev.property, ev.newValue);\r\n        }\r\n    }\r\n\r\n    if (wasChanged)\r\n    {\r\n        self.onRemoteSettingsLoad();\r\n    }\r\n}\r\n\r\nself.loadSettings = function()\r\n{\r\n    // No Write Ops //\r\n\r\n    self.settingsLocal = { };\r\n    self.settingsRemote = self.root.get('settings');\r\n\r\n    // This is a write op, however the settigns field isnt shared by other changes and is flushed at will.\r\n    if (!self.settingsRemote)\r\n    {\r\n        self.settingsRemote = self.model.createMap();\r\n        self.root.set('settings', self.settingsRemote);\r\n    }\r\n\r\n    try\r\n    {\r\n        // Contacts\r\n        self.settingsLocal[Settings.syncContacts] = self.settingsRemote.get(Settings.syncContacts);\r\n\r\n        var syncContactsV = g.settings.prefix + Settings.syncContacts;\r\n        self.settingsLocal[syncContactsV] = self.settingsRemote.get(syncContactsV);\r\n\r\n        // Doc Sharing\r\n        self.settingsLocal[Settings.docSharing] = self.settingsRemote.get(Settings.docSharing);\r\n\r\n        var docSharingV = g.settings.prefix + Settings.docSharing;\r\n        self.settingsLocal[docSharingV] = self.settingsRemote.get(docSharingV);\r\n\r\n        // Theme\r\n        self.settingsLocal[Settings.theme] = self.settingsRemote.get(Settings.theme);\r\n\r\n        var themeV = g.settings.prefix + Settings.theme;\r\n        self.settingsLocal[themeV] = self.settingsRemote.get(themeV);\r\n\r\n        // Add event listener if settings are changed remotely\r\n        self.settingsRemote.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, onSettingsChanged.bind(self));\r\n    }\r\n    catch (err)\r\n    {\r\n        g.reportError(err);\r\n    }\r\n};\r\n\r\n// function onObjectChanged(event)\r\n// {\r\n//     log('Object Changed Event: ', event.target.id);\r\n// }\r\n\r\nself.poke = function()\r\n{\r\n    if (self.root && !self.isClosed)\r\n    {\r\n        try\r\n        {\r\n            var pk = self.root.get('poke');\r\n\r\n            if (DEBUG) { log('Poke: ' + pk); }\r\n\r\n            if (!pk)\r\n            {\r\n                self.root.set('poke', 1);\r\n            }\r\n            else\r\n            {\r\n                self.root.set('poke', pk + 1);\r\n            }\r\n        }\r\n        catch (err)\r\n        {\r\n            self.setGDriveStatus(DriveStatus.Offline);\r\n\r\n            self.isClosed = true;\r\n        }\r\n    }\r\n    else if (self.isClosed)\r\n    {\r\n        log('Failed to poke closed document');\r\n    }\r\n};\r\n\r\nwindow.__poke = self.poke;\r\n\r\nself.rootChanged = function(e)\r\n{\r\n    if (e.ocHandled || e.isLocal || self.root.id !== e.target.id) { return false; }\r\n\r\n    for (var i = 0; i < e.events.length; ++i)\r\n    {\r\n        switch (e.events[i].type)\r\n        {\r\n            case gapi.drive.realtime.EventType.VALUES_ADDED:\r\n            case gapi.drive.realtime.EventType.VALUES_REMOVED:\r\n\r\n                break;\r\n\r\n            case gapi.drive.realtime.EventType.VALUE_CHANGED:\r\n                {\r\n                    if (e.property === 'dataVersion')\r\n                    {\r\n                        if (e.newValue > CURRENT_VERSION)\r\n                        {\r\n                            g.AppCache.checkForUpdate(/*forceUpdate*/true);\r\n                        }\r\n                        else if (e.newVersion < CURRENT_VERSION)\r\n                        {\r\n                            g.reportError(new Error('Remote setting dataVersion to invalid value' + e.newVersion));\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case gapi.drive.realtime.EventType.TEXT_DELETED:\r\n            case gapi.drive.realtime.EventType.TEXT_INSERTED:\r\n            case gapi.drive.realtime.EventType.VALUES_SET:\r\n            default:\r\n                g.Assert(false, 'Unexpected event type');\r\n                break;\r\n        }\r\n    }\r\n};\r\n\r\nself.isConnected = function()\r\n{\r\n    return self.initialized && !self.isClosed && !!self.model;\r\n};\r\n\r\n//\r\n// Called once per document load when refreshing the page.\r\n//\r\nself.onLoad = function(doc)\r\n{\r\n    // No Write Ops //\r\n\r\n    try\r\n    {\r\n        // TODO: Only clear selection if within the document, leave search selection\r\n        //g.clearSelection();\r\n\r\n        g.Assert(self.isClosed, 'Document must not already be open when we are loading');\r\n        self.initialized = true;\r\n\r\n        if (DEBUG) log('Loading document from gdrive', log.now());\r\n        //console.timeStamp('Loading Remote Data');\r\n\r\n        if (!d)\r\n        {\r\n            d = require('data');\r\n        }\r\n\r\n        if (!VMLI)\r\n        {\r\n            VMLI = require('VMLI');\r\n        }\r\n\r\n        self.doc = doc;\r\n        self.model = doc.getModel();\r\n        self.root = self.model.getRoot();\r\n\r\n        self.root.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, self.rootChanged);\r\n\r\n        self.isClosed = false;\r\n\r\n        self.registerForSaveStateChange(self.onSaveStateChange);\r\n\r\n        // Ensure the remote schema is up to date\r\n        var stopLoadingRemote = self.migrateData();\r\n\r\n        if (!stopLoadingRemote)\r\n        {\r\n            self.loadSettings();\r\n\r\n            self.rootItem = self.root.get('root');\r\n\r\n            if (!self.rootItem)\r\n            {\r\n                g.messageQueue.pushMessage({\r\n                    text: 'Document is corrupted, ' + platform.actionVerb() + ' to reload. If the problem persists, please contact support.',\r\n                    type: MessageType.Fatal,\r\n                    action: MessageAction.ResetClient\r\n                });\r\n\r\n                return;\r\n            }\r\n\r\n            //self.rootItem.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, d.getModel(self.rootItem.id).onObjectChanged.bind(d.getModel(self.rootItem.id)));\r\n\r\n            self.rootID = self.rootItem.id;\r\n\r\n            self.itemsLoaded = false;\r\n\r\n            //self.root.addEventListener(gapi.drive.realtime.EventType.OBJECT_CHANGED, onObjectChanged);\r\n\r\n\r\n            // Debug only - print the corresponding information stored in google drive\r\n            //printDriveItems(false);\r\n\r\n            window.__remoteDoc = doc;\r\n\r\n            if (DEBUG)\r\n            {\r\n                window.printRemote = (function () { self.print(/*force*/true); }).bind(self);\r\n\r\n                self.print();\r\n            }\r\n\r\n            if (undoRedoStateChangeHandler)\r\n            {\r\n                self.registerForUndoRedoStateChange(undoRedoStateChangeHandler);\r\n                undoRedoStateChangeHandler = undefined;\r\n            }\r\n\r\n            //VMCollab.init(self.doc);\r\n\r\n            if (g.vmMain && g.vmMain.root())\r\n            {\r\n                g.vmMain.loadGDriveData();\r\n            }\r\n            else\r\n            {\r\n                g.requireGDriveDataCallback = true;\r\n            }\r\n\r\n            self.loadCollaborators();\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            log('---- Skipping Document Load! ----');\r\n\r\n            self.isClosed = true;\r\n            self.initialized = false;\r\n\r\n            self.doc = undefined;\r\n            self.model = undefined;\r\n            self.root = undefined;\r\n\r\n            return false;\r\n        }\r\n    }\r\n    catch (err)\r\n    {\r\n        g.reportError(err);\r\n    }\r\n};\r\n\r\nself.getServerVersion = function()\r\n{\r\n    if (self.model && !self.isClosed)\r\n    {\r\n        return self.model.serverVersion;\r\n    }\r\n\r\n    return undefined;\r\n};\r\n\r\n// Replace registration with event listener for gdataSaved\r\nvar notifyOfSaveChange = [ ];\r\nself.registerSaveNotify = function(fn)\r\n{\r\n    notifyOfSaveChange.push(fn);\r\n}\r\n\r\nvar lastPending = false;\r\nvar lastSaving = false;\r\nvar saveTimeout;\r\nself.onSaveStateChange = function(e)\r\n{\r\n    // No Write Ops //\r\n\r\n    if (lastPending !== e.isPending || lastSaving !== e.isSaving)\r\n    {\r\n        if (DEBUG) log('%cStatus - Pending[' + e.isPending + '] Saving[' + e.isSaving + ']', 'color: green');\r\n\r\n        if (!e.isSaving && !e.isPending)\r\n        {\r\n            g.vmMain.setGDriveStatus(DriveStatus.Saved);\r\n\r\n            d.clearPendingUpdates();\r\n\r\n            //g.events.emit('gdataSaved');\r\n            clearTimeout(saveTimeout);\r\n            saveTimeout = undefined;\r\n\r\n            g.messageQueue.clearMessage(MessageID.ConnectionError);\r\n\r\n            for (var i = 0; i < notifyOfSaveChange.length; ++i)\r\n            {\r\n                notifyOfSaveChange[i]();\r\n            }\r\n        }\r\n        else if (navigator.onLine)\r\n        {\r\n            if (e.isSaving)\r\n            {\r\n                if (!e.isPending)\r\n                {\r\n                    g.vmMain.setGDriveStatus(DriveStatus.Saving);\r\n                }\r\n\r\n                clearTimeout(saveTimeout);\r\n\r\n                if (platform.mobile)\r\n                {\r\n                    saveTimeout = setTimeout(self.onErrorSaving, 12000);\r\n                }\r\n                else\r\n                {\r\n                    saveTimeout = setTimeout(self.onErrorSaving, 8000);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            g.vmMain.setGDriveStatus(DriveStatus.Offline);\r\n        }\r\n\r\n        lastPending = e.isPending;\r\n        lastSaving = e.isSaving;\r\n    }\r\n};\r\n\r\nself.onErrorSaving = function()\r\n{\r\n    //g.messageQueue.pushConnectionError();\r\n    g.vmMain.setGDriveStatus(DriveStatus.Offline);\r\n    saveTimeout = undefined;\r\n};\r\n\r\nif (DEBUG)\r\n{\r\n    window.remoteGets = { };\r\n}\r\n\r\nself.getVersion = function(map, type)\r\n{\r\n    g.Assert(!(map instanceof VMLI), 'Must pass in a valid remote item');\r\n\r\n    if (DEBUG)\r\n    {\r\n        var field = ((type === VersionType.Structure) ? 'version' : 'versionText');\r\n        window.remoteGets[field] = (window.remoteGets[field] ? window.remoteGets[field] + 1 : 1);\r\n    }\r\n\r\n    var v;\r\n    switch (type)\r\n    {\r\n        case VersionType.Structure:\r\n            v = map.get(g.translateFieldIn('version'));\r\n            break;\r\n        case VersionType.Text:\r\n            v = map.get(g.translateFieldIn('versionText'));\r\n            break;\r\n        default:\r\n            v = -2;\r\n            g.Assert(false, 'Invalid version type');\r\n            break;\r\n    }\r\n\r\n    return v ? v : 0;\r\n};\r\n\r\nself.get = function(map, field)\r\n{\r\n    g.Assert(!(map instanceof VMLI), 'Must pass in a valid remote item');\r\n\r\n    if (DEBUG)\r\n    {\r\n        window.remoteGets[field] = (window.remoteGets[field] ? window.remoteGets[field] + 1 : 1);\r\n    }\r\n\r\n    return map.get(g.translateFieldIn(field));\r\n};\r\n\r\nself.set = function(map, field, value)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(!(map instanceof VMLI), 'Must pass in a valid remote item');\r\n\r\n    if (value === undefined)\r\n    {\r\n        value = null;\r\n    }\r\n\r\n    return map.set(g.translateFieldIn(field), value);\r\n};\r\n\r\nself.delete = function(map, field)\r\n{\r\n    self.beginWriteAction();\r\n\r\n    g.Assert(!(map instanceof VMLI), 'Must pass in a valid remote item');\r\n\r\n    return map.delete(g.translateFieldIn(field));\r\n};\r\n\r\n// self.item = function(id)\r\n// {\r\n//     self.beginWriteAction();\r\n\r\n//     g.Assert(g.isString(id), 'Trying to get a gdrive item with an invalid id');\r\n//     g.Assert(self.itemsLoaded, 'Items must be loaded before querying');\r\n\r\n//     // TODO: Remove in favor of using d.getModelById(id).data\r\n//     return itemCache[id];\r\n// };\r\n\r\nself.findInTree = function(item, searched)\r\n{\r\n    // No Write Ops //\r\n\r\n    if (!searched)\r\n    {\r\n        searched = self.rootItem;\r\n    }\r\n\r\n    function findItemInTree(arr, isArchived)\r\n    {\r\n        if (!arr)\r\n            return false;\r\n\r\n        for (var i = 0; i < arr.length; i++)\r\n        {\r\n            var result = arr.get(i);\r\n\r\n            if (result.id == item.id)\r\n            {\r\n                return { 'parent': searched, 'index': i, 'isArchived': isArchived };\r\n            }\r\n\r\n            var found = self.findInTree(item, result);\r\n            if (found)\r\n            {\r\n                return found;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    var items = self.get(searched, 'items');\r\n\r\n    var foundItem = findItemInTree(items, /*isArchived*/false);\r\n\r\n    if (!foundItem)\r\n    {\r\n        var archivedItems = self.get(searched, 'archivedItems');\r\n\r\n        foundItem = findItemInTree(archivedItems, /*isArchived*/true);\r\n    }\r\n\r\n    return foundItem;\r\n}\r\n\r\nreturn self;\r\n});\r\n","asserts":[{"tag":873,"offset":409},{"tag":874,"offset":2456},{"tag":875,"offset":7519},{"tag":876,"offset":7784},{"tag":877,"offset":7950},{"tag":878,"offset":8403},{"tag":879,"offset":9495},{"tag":880,"offset":9659},{"tag":881,"offset":10063},{"tag":882,"offset":10223},{"tag":883,"offset":10333},{"tag":884,"offset":10715},{"tag":885,"offset":11104},{"tag":886,"offset":11264},{"tag":887,"offset":11374},{"tag":888,"offset":18413},{"tag":889,"offset":20796},{"tag":890,"offset":22780},{"tag":891,"offset":23857},{"tag":892,"offset":25571},{"tag":893,"offset":25866},{"tag":894,"offset":25925},{"tag":895,"offset":26833},{"tag":896,"offset":27255},{"tag":897,"offset":27386},{"tag":898,"offset":27451},{"tag":899,"offset":27887},{"tag":900,"offset":28338},{"tag":901,"offset":28962},{"tag":902,"offset":29064},{"tag":903,"offset":29149},{"tag":904,"offset":29236},{"tag":905,"offset":29679},{"tag":906,"offset":30354},{"tag":907,"offset":30540},{"tag":908,"offset":30637},{"tag":909,"offset":30713},{"tag":910,"offset":31489},{"tag":911,"offset":31600},{"tag":912,"offset":32410},{"tag":913,"offset":32484},{"tag":914,"offset":32587},{"tag":915,"offset":33494},{"tag":916,"offset":33598},{"tag":917,"offset":34885},{"tag":918,"offset":34958},{"tag":919,"offset":35043},{"tag":920,"offset":35342},{"tag":921,"offset":35427},{"tag":922,"offset":35531},{"tag":923,"offset":35603},{"tag":924,"offset":35684},{"tag":925,"offset":36519},{"tag":926,"offset":36604},{"tag":927,"offset":36676},{"tag":928,"offset":36917},{"tag":929,"offset":37013},{"tag":930,"offset":37357},{"tag":931,"offset":37469},{"tag":932,"offset":37884},{"tag":933,"offset":37956},{"tag":934,"offset":38893},{"tag":935,"offset":39537},{"tag":936,"offset":39611},{"tag":937,"offset":39852},{"tag":938,"offset":39926},{"tag":939,"offset":40180},{"tag":940,"offset":40500},{"tag":941,"offset":40806},{"tag":942,"offset":40843},{"tag":943,"offset":41626},{"tag":944,"offset":41663},{"tag":945,"offset":43337},{"tag":946,"offset":43547},{"tag":947,"offset":43634},{"tag":948,"offset":46089},{"tag":949,"offset":46214},{"tag":950,"offset":46406},{"tag":951,"offset":46627},{"tag":952,"offset":47510},{"tag":953,"offset":47738},{"tag":954,"offset":47999},{"tag":955,"offset":48538},{"tag":956,"offset":49340},{"tag":957,"offset":49492},{"tag":958,"offset":49767},{"tag":959,"offset":51095},{"tag":960,"offset":51244},{"tag":961,"offset":51291},{"tag":962,"offset":51351},{"tag":963,"offset":51377},{"tag":964,"offset":51423},{"tag":965,"offset":52252},{"tag":966,"offset":52557},{"tag":967,"offset":52672},{"tag":968,"offset":53218},{"tag":969,"offset":53531},{"tag":970,"offset":53651},{"tag":971,"offset":55217},{"tag":972,"offset":55457},{"tag":973,"offset":55643},{"tag":974,"offset":55863},{"tag":975,"offset":56086},{"tag":976,"offset":56609},{"tag":977,"offset":56969},{"tag":978,"offset":58068},{"tag":979,"offset":59796},{"tag":980,"offset":65292},{"tag":981,"offset":65756},{"tag":982,"offset":70967},{"tag":983,"offset":71572},{"tag":984,"offset":71712},{"tag":985,"offset":72049},{"tag":986,"offset":72327},{"tag":987,"offset":72534},{"tag":988,"offset":72618}]},"db":{"path":"F:/p/bce/Duchess/public/js/lib/db.js","data":"define(['IndexedDBShim'],\nfunction(idbpoly)\n{\n    'use strict';\n\n    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB,\n        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,\n        transactionModes = {\n            readonly: 'readonly',\n            readwrite: 'readwrite'\n        };\n        \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    if ( !indexedDB ) {\n        console.log('IndexedDB is not available');\n        return;\n    }\n\n    var defaultMapper = function (value) {\n        return value;\n    };\n\n    var CallbackList = function () {\n        var state,\n            list = [];\n\n        var exec = function ( context , args ) {\n            if ( list ) {\n                args = args || [];\n                state = state || [ context , args ];\n\n                for ( var i = 0 , il = list.length ; i < il ; i++ ) {\n                    list[ i ].apply( state[ 0 ] , state[ 1 ] );\n                }\n\n                list = [];\n            }\n        };\n\n        this.add = function () {\n            for ( var i = 0 , il = arguments.length ; i < il ; i ++ ) {\n                list.push( arguments[ i ] );\n            }\n\n            if ( state ) {\n                exec();\n            }\n\n            return this;\n        };\n\n        this.execute = function () {\n            exec( this , arguments );\n            return this;\n        };\n    };\n\n    var Deferred = function ( func ) {\n        var state = 'progress',\n            actions = [\n                [ 'resolve' , 'done' , new CallbackList() , 'resolved' ],\n                [ 'reject' , 'fail' , new CallbackList() , 'rejected' ],\n                [ 'notify' , 'progress' , new CallbackList() ],\n            ],\n            deferred = {},\n            promise = {\n                state: function () {\n                    return state;\n                },\n                then: function ( /* doneHandler , failedHandler , progressHandler */ ) {\n                    var handlers = arguments;\n\n                    return Deferred(function ( newDefer ) {\n                        actions.forEach(function ( action , i ) {\n                            var handler = handlers[ i ];\n\n                            deferred[ action[ 1 ] ]( typeof handler === 'function' ?\n                                function () {\n                                    var returned = handler.apply( this , arguments );\n\n                                    if ( returned && typeof returned.promise === 'function' ) {\n                                        returned.promise()\n                                            .done( newDefer.resolve )\n                                            .fail( newDefer.reject )\n                                            .progress( newDefer.notify );\n                                    }\n                                } : newDefer[ action[ 0 ] ]\n                            );\n                        });\n                    }).promise();\n                },\n                promise: function ( obj ) {\n                    if ( obj ) {\n                        Object.keys( promise )\n                            .forEach(function ( key ) {\n                                obj[ key ] = promise[ key ];\n                            });\n\n                        return obj;\n                    }\n                    return promise;\n                }\n            };\n\n        actions.forEach(function ( action , i ) {\n            var list = action[ 2 ],\n                actionState = action[ 3 ];\n\n            promise[ action[ 1 ] ] = list.add;\n\n            if ( actionState ) {\n                list.add(function () {\n                    state = actionState;\n                });\n            }\n\n            deferred[ action[ 0 ] ] = list.execute;\n        });\n\n        promise.promise( deferred );\n\n        if ( func ) {\n            func.call( deferred , deferred );\n        }\n\n        return deferred;\n    };\n\n    var Server = function ( db , name ) {\n        var that = this,\n            closed = false;\n\n        this.add = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            var counter = 0;\n\n            for (var i = 0; i < arguments.length - 1; i++) {\n                if (Array.isArray(arguments[i + 1])) {\n                    for (var j = 0; j < (arguments[i + 1]).length; j++) {\n                        records[counter] = (arguments[i + 1])[j];\n                        counter++;\n                    }\n                } else {\n                    records[counter] = arguments[i + 1];\n                    counter++;\n                }\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.add( record , key );\n                } else {\n                    req = store.add( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    var target = e.target;\n                    var keyPath = target.source.keyPath;\n                    if ( keyPath === null ) {\n                        keyPath = '__id__';\n                    }\n                    Object.defineProperty( record , keyPath , {\n                        value: target.result,\n                        enumerable: true\n                    });\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n\n        this.update = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            for ( var i = 0 ; i < arguments.length - 1 ; i++ ) {\n                records[ i ] = arguments[ i + 1 ];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.put( record , key );\n                } else {\n                    req = store.put( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n\n        this.updateObject = function (table) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var records = arguments[1];\n\n            for (var id in records)\n            {\n                store.put( records[id] );\n            }\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n\n            return deferred.promise();\n        };\n        \n        this.remove = function ( table , key ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            var req = store.delete( key );\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( key );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.clear = function ( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.clear();\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n        \n        this.close = function ( ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            db.close();\n            closed = true;\n            delete dbCache[ name ];\n        };\n\n        this.get = function ( table , id ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.get( id );\n            req.onsuccess = function ( e ) {\n                deferred.resolve( e.target.result );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.query = function ( table , index ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            return new IndexQuery( table , db , index );\n        };\n\n        for ( var i = 0 , il = db.objectStoreNames.length ; i < il ; i++ ) {\n            (function ( storeName ) {\n                that[ storeName ] = { };\n                for ( var i in that ) {\n                    if ( !hasOwn.call( that , i ) || i === 'close' ) {\n                        continue;\n                    }\n                    that[ storeName ][ i ] = (function ( i ) {\n                        return function () {\n                            var args = [ storeName ].concat( [].slice.call( arguments , 0 ) );\n                            return that[ i ].apply( that , args );\n                        };\n                    })( i );\n                }\n            })( db.objectStoreNames[ i ] );\n        }\n    };\n\n    var IndexQuery = function ( table , db , indexName ) {\n        var that = this;\n        var modifyObj = false;\n\n        var runQuery = function ( type, args , cursorType , direction, limitRange, filters , mapper ) {\n            var transaction = db.transaction( table, modifyObj ? transactionModes.readwrite : transactionModes.readonly ),\n                store = transaction.objectStore( table ),\n                index = indexName ? store.index( indexName ) : store,\n                keyRange = type ? IDBKeyRange[ type ].apply( null, args ) : null,\n                results = [],\n                deferred = Deferred(),\n                indexArgs = [ keyRange ],\n                limitRange = limitRange ? limitRange : null,\n                filters = filters ? filters : undefined,\n                counter = 0;\n\n            if ( cursorType !== 'count' ) {\n                indexArgs.push( direction || 'next' );\n            };\n\n            // create a function that will set in the modifyObj properties into\n            // the passed record.\n            var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;\n            var modifyRecord = function(record) {\n                for(var i = 0; i < modifyKeys.length; i++) {\n                    var key = modifyKeys[i];\n                    var val = modifyObj[key];\n                    if(val instanceof Function) val = val(record);\n                    record[key] = val;\n                }\n                return record;\n            };\n\n            index[cursorType].apply( index , indexArgs ).onsuccess = function ( e ) {\n                var cursor = e.target.result;\n                if ( typeof cursor === typeof 0 ) {\n                    results = cursor;\n                } else if ( cursor ) {\n                    if ( limitRange !== null && limitRange[0] > counter) {\n                        counter = limitRange[0];\n                        cursor.advance(limitRange[0]);\n                    } else if ( limitRange !== null && counter >= (limitRange[0] + limitRange[1]) ) {\n                        //out of limit range... skip\n                    } else {\n                        var matchFilter = true;\n                        var result = 'value' in cursor ? cursor.value : cursor.key;\n\n                        if (filters)\n                        {\n                            filters.forEach( function ( filter ) {\n                                if ( !filter || !filter.length ) {\n                                    //Invalid filter do nothing\n                                } else if ( filter.length === 2 ) {\n                                    matchFilter = (result[filter[0]] === filter[1])\n                                } else {\n                                    matchFilter = filter[0].apply(undefined,[result]);\n                                }\n                            });\n                        }\n\n                        if (matchFilter) {\n                            counter++;\n                            results.push( mapper(result) );\n                            // if we're doing a modify, run it now\n                            if(modifyObj) {\n                                result = modifyRecord(result);\n                                cursor.update(result);\n                            }\n                        }\n                        cursor.continue();\n                    }\n                }\n            };\n\n            transaction.oncomplete = function () {\n                deferred.resolve( results );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        var Query = function ( type , args ) {\n            var direction = 'next',\n                cursorType = 'openCursor',\n                filters = [],\n                limitRange = null,\n                mapper = defaultMapper,\n                unique = false;\n\n            var execute = function () {\n                return runQuery( type , args , cursorType , unique ? direction + 'unique' : direction, limitRange, filters , mapper );\n            };\n\n            var limit = function () {\n                limitRange = Array.prototype.slice.call( arguments , 0 , 2 )\n                if (limitRange.length == 1) {\n                    limitRange.unshift(0)\n                }\n\n                return {\n                    execute: execute\n                };\n            };\n            var count = function () {\n                direction = null;\n                cursorType = 'count';\n\n                return {\n                    execute: execute\n                };\n            };\n            var keys = function () {\n                cursorType = 'openKeyCursor';\n\n                return {\n                    desc: desc,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    map: map\n                };\n            };\n            var filter = function ( ) {\n                filters.push( Array.prototype.slice.call( arguments , 0 , 2 ) );\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    limit: limit,\n                    map: map\n                };\n            };\n            var desc = function () {\n                direction = 'prev';\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    modify: modify,\n                    map: map\n                };\n            };\n            var distinct = function () {\n                unique = true;\n                return {\n                    keys: keys,\n                    count: count,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    modify: modify,\n                    map: map\n                };\n            };\n            var modify = function(update) {\n                modifyObj = update;\n                return {\n                    execute: execute\n                };\n            };\n            var map = function (fn) {\n                mapper = fn;\n\n                return {\n                    execute: execute,\n                    count: count,\n                    keys: keys,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    limit: limit,\n                    map: map\n                };\n            };\n\n            return {\n                execute: execute,\n                count: count,\n                keys: keys,\n                filter: filter,\n                desc: desc,\n                distinct: distinct,\n                modify: modify,\n                limit: limit,\n                map: map\n            };\n        };\n        \n        'only bound upperBound lowerBound'.split(' ').forEach(function (name) {\n            that[name] = function () {\n                return new Query( name , arguments );\n            };\n        });\n\n        this.filter = function () {\n            var query = new Query( null , null );\n            return query.filter.apply( query , arguments );\n        };\n\n        this.all = function () {\n            return this.filter();\n        };\n    };\n    \n    var createSchema = function ( e , schema , db ) {\n        if ( typeof schema === 'function' ) {\n            schema = schema();\n        }\n        \n        for ( var tableName in schema ) {\n            var table = schema[ tableName ];\n            var store;\n            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {\n                store = e.currentTarget.transaction.objectStore(tableName);\n            } else {\n                store = db.createObjectStore(tableName, table.key);\n            }\n\n            for ( var indexKey in table.indexes ) {\n                if (store.indexNames.contains(indexKey)) {\n                    continue;\n                }\n                \n                var index = table.indexes[ indexKey ];\n                store.createIndex( indexKey , index.key || indexKey , Object.keys(index).length ? index : { unique: false } );\n            }\n        }\n    };\n    \n    var open = function ( e , server , version , schema ) {\n        var db = e.target.result;\n        var s = new Server( db , server );\n        var upgrade;\n\n        var deferred = Deferred();\n        deferred.resolve( s );\n        dbCache[ server ] = db;\n\n        return deferred.promise();\n    };\n\n    var dbCache = {};\n\n    var db = {\n        version: '0.9.0',\n        open: function ( options ) {\n            var request;\n\n            var deferred = Deferred();\n\n            if ( dbCache[ options.server ] ) {\n                open( {\n                    target: {\n                        result: dbCache[ options.server ]\n                    }\n                } , options.server , options.version , options.schema )\n                .done(deferred.resolve)\n                .fail(deferred.reject)\n                .progress(deferred.notify);\n            } else {\n                request = indexedDB.open( options.server , options.version );\n                            \n                request.onsuccess = function ( e ) {\n                    open( e , options.server , options.version , options.schema )\n                        .done(deferred.resolve)\n                        .fail(deferred.reject)\n                        .progress(deferred.notify);\n                };\n            \n                request.onupgradeneeded = function ( e ) {\n                    createSchema( e , options.schema , e.target.result );\n                };\n                request.onerror = function ( e ) {\n                    deferred.reject( e );\n                };\n            }\n\n            return deferred.promise();\n        }\n    };\n\n    return db;\n});\n","asserts":[]},"IndexedDBShim":{"path":"F:/p/bce/Duchess/public/js/lib/IndexedDBShim.js","data":"/*jshint globalstrict: true*/\n'use strict';\n/**\n * An initialization file that checks for conditions, removes console.log and warn, etc\n */\nvar idbModules = {};\n\nvar cleanInterface = false;\n(function () {\n    var testObject = {test: true};\n    //Test whether Object.defineProperty really works.\n    if (Object.defineProperty) {\n        try {\n            Object.defineProperty(testObject, 'test', { enumerable: false });\n            if (testObject.test) {\n                cleanInterface = true;\n            }\n        } catch (e) {\n        //Object.defineProperty does not work as intended.\n        }\n    }\n})();\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules) {\n    /**\n     * A utility method to callback onsuccess, onerror, etc as soon as the calling function's context is over\n     * @param {Object} fn\n     * @param {Object} context\n     * @param {Object} argArray\n     */\n\n    function callback(fn, context, event, func) {\n        //window.setTimeout(function(){\n        event.target = context;\n        (typeof context[fn] === \"function\") && context[fn].apply(context, [event]);\n        (typeof func === \"function\") && func();\n        //}, 1);\n    }\n\n    /**\n     * Throws a new DOM Exception,\n     * @param {Object} name\n     * @param {Object} message\n     * @param {Object} error\n     */\n\n    function throwDOMException(name, message, error) {\n        var e = new DOMException.prototype.constructor(0, message);\n        e.name = name;\n        e.message = message;\n        // if (\n        //     console.trace && console.trace();\n        // }\n        throw e;\n    }\n\n    /**\n     * Shim the DOMStringList object.\n     *\n     */\n    var StringList = function() {\n        this.length = 0;\n        this._items = [];\n        //Internal functions on the prototype have been made non-enumerable below.\n        if (cleanInterface) {\n            Object.defineProperty(this, '_items', {\n                enumerable: false\n            });\n        }\n    };\n    StringList.prototype = {\n        // Interface.\n        contains: function(str) {\n            return -1 !== this._items.indexOf(str);\n        },\n        item: function(key) {\n            return this._items[key];\n        },\n\n        // Helpers. Should only be used internally.\n        indexOf: function(str) {\n            return this._items.indexOf(str);\n        },\n        push: function(item) {\n            this._items.push(item);\n            this.length += 1;\n            for (var i = 0; i < this._items.length; i++) {\n                this[i] = this._items[i];\n            }\n        },\n        splice: function( /*index, howmany, item1, ..., itemX*/ ) {\n            this._items.splice.apply(this._items, arguments);\n            this.length = this._items.length;\n            for (var i in this) {\n                if (i === String(parseInt(i, 10))) {\n                    delete this[i];\n                }\n            }\n            for (i = 0; i < this._items.length; i++) {\n                this[i] = this._items[i];\n            }\n        }\n    };\n    if (cleanInterface) {\n        for (var i in {\n            'indexOf': false,\n            'push': false,\n            'splice': false\n        }) {\n            Object.defineProperty(StringList.prototype, i, {\n                enumerable: false\n            });\n        }\n    }\n    idbModules.util = {\n        \"throwDOMException\": throwDOMException,\n        \"callback\": callback,\n        \"quote\": function(arg) {\n            return \"'\" + arg + \"'\";\n        },\n        \"StringList\": StringList\n    };\n}(idbModules));\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    /**\n     * Implementation of the Structured Cloning Algorithm.  Supports the\n     * following object types:\n     * - Blob\n     * - Boolean\n     * - Date object\n     * - File object (deserialized as Blob object).\n     * - Number object\n     * - RegExp object\n     * - String object\n     * This is accomplished by doing the following:\n     * 1) Using the cycle/decycle functions from:\n     *    https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n     * 2) Serializing/deserializing objects to/from string that don't work with\n     *    JSON.stringify and JSON.parse by using object specific logic (eg use \n     *    the FileReader API to convert a Blob or File object to a data URL.   \n     * 3) JSON.stringify and JSON.parse do the final conversion to/from string.\n     */\n    var Sca = (function(){\n        return {\n            decycle: function(object, callback) {\n                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n                // Contains additional logic to convert the following object types to string\n                // so that they can properly be encoded using JSON.stringify:\n                //  *Boolean\n                //  *Date\n                //  *File\n                //  *Blob\n                //  *Number\n                //  *Regex\n                // Make a deep copy of an object or array, assuring that there is at most\n                // one instance of each object or array in the resulting structure. The\n                // duplicate references (which might be forming cycles) are replaced with\n                // an object of the form\n                //      {$ref: PATH}\n                // where the PATH is a JSONPath string that locates the first occurance.\n                // So,\n                //      var a = [];\n                //      a[0] = a;\n                //      return JSON.stringify(JSON.decycle(a));\n                // produces the string '[{\"$ref\":\"$\"}]'.\n\n                // JSONPath is used to locate the unique object. $ indicates the top level of\n                // the object or array. [NUMBER] or [STRING] indicates a child member or\n                // property.\n\n                var objects = [],   // Keep a reference to each unique object or array\n                paths = [],     // Keep the path to each unique object or array\n                queuedObjects = [],\n                returnCallback = callback;\n\n                /**\n                 * Check the queue to see if all objects have been processed.\n                 * if they have, call the callback with the converted object.\n                 */\n                function checkForCompletion() {\n                    if (queuedObjects.length === 0) {\n                        returnCallback(derezObj);\n                    }    \n                }\n\n                /**\n                 * Convert a blob to a data URL.\n                 * @param {Blob} blob to convert.\n                 * @param {String} path of blob in object being encoded.\n                 */\n                function readBlobAsDataURL(blob, path) {\n                    var reader = new FileReader();\n                    reader.onloadend = function(loadedEvent) {\n                        var dataURL = loadedEvent.target.result;\n                        var blobtype = 'blob'; \n                        if (blob instanceof File) {\n                            //blobtype = 'file';\n                        }\n                        updateEncodedBlob(dataURL, path, blobtype);\n                    };\n                    reader.readAsDataURL(blob);\n                }\n                \n                /**\n                 * Async handler to update a blob object to a data URL for encoding.\n                 * @param {String} dataURL\n                 * @param {String} path\n                 * @param {String} blobtype - file if the blob is a file; blob otherwise\n                 */\n                function updateEncodedBlob(dataURL, path, blobtype) {\n                    var encoded = queuedObjects.indexOf(path);\n                    path = path.replace('$','derezObj');\n                    eval(path+'.$enc=\"'+dataURL+'\"');\n                    eval(path+'.$type=\"'+blobtype+'\"');\n                    queuedObjects.splice(encoded, 1);\n                    checkForCompletion();\n                }\n\n                function derez(value, path) {\n\n                    // The derez recurses through the object, producing the deep copy.\n\n                    var i,          // The loop counter\n                    name,       // Property name\n                    nu;         // The new object or array\n\n                    // typeof null === 'object', so go on if this value is really an object but not\n                    // one of the weird builtin objects.\n\n                    if (typeof value === 'object' && value !== null &&\n                        !(value instanceof Boolean) &&\n                        !(value instanceof Date)    &&\n                        !(value instanceof Number)  &&\n                        !(value instanceof RegExp)  &&\n                        !(value instanceof Blob)  &&\n                        !(value instanceof String)) {\n\n                        // If the value is an object or array, look to see if we have already\n                        // encountered it. If so, return a $ref/path object. This is a hard way,\n                        // linear search that will get slower as the number of unique objects grows.\n\n                        for (i = 0; i < objects.length; i += 1) {\n                            if (objects[i] === value) {\n                                return {$ref: paths[i]};\n                            }\n                        }\n\n                        // Otherwise, accumulate the unique value and its path.\n\n                        objects.push(value);\n                        paths.push(path);\n\n                        // If it is an array, replicate the array.\n\n                        if (Object.prototype.toString.apply(value) === '[object Array]') {\n                            nu = [];\n                            for (i = 0; i < value.length; i += 1) {\n                                nu[i] = derez(value[i], path + '[' + i + ']');\n                            }\n                        } else {\n                            // If it is an object, replicate the object.\n                            nu = {};\n                            for (name in value) {\n                                if (Object.prototype.hasOwnProperty.call(value, name)) {\n                                    nu[name] = derez(value[name],\n                                     path + '[' + JSON.stringify(name) + ']');\n                                }\n                            }\n                        }\n\n                        return nu;\n                    } else if (value instanceof Blob) {\n                        //Queue blob for conversion\n                        queuedObjects.push(path);\n                        readBlobAsDataURL(value, path);\n                    } else if (value instanceof Boolean) {\n                        value = {\n                            '$type': 'bool',\n                            '$enc': value.toString()\n                        };\n                    } else if (value instanceof Date) {\n                        value = {\n                            '$type': 'date',\n                            '$enc': value.getTime()\n                        };\n                    } else if (value instanceof Number) {\n                        value = {\n                            '$type': 'num',\n                            '$enc': value.toString()\n                        };\n                    } else if (value instanceof RegExp) {\n                        value = {\n                            '$type': 'regex',\n                            '$enc': value.toString()\n                        }; \n                    }\n                    return value;\n                }\n                var derezObj = derez(object, '$');\n                checkForCompletion();\n            },\n                \n            retrocycle: function retrocycle($) {\n                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n                // Contains additional logic to convert strings to the following object types \n                // so that they can properly be decoded:\n                //  *Boolean\n                //  *Date\n                //  *File\n                //  *Blob\n                //  *Number\n                //  *Regex\n                // Restore an object that was reduced by decycle. Members whose values are\n                // objects of the form\n                //      {$ref: PATH}\n                // are replaced with references to the value found by the PATH. This will\n                // restore cycles. The object will be mutated.\n\n                // The eval function is used to locate the values described by a PATH. The\n                // root object is kept in a $ variable. A regular expression is used to\n                // assure that the PATH is extremely well formed. The regexp contains nested\n                // * quantifiers. That has been known to have extremely bad performance\n                // problems on some browsers for very long strings. A PATH is expected to be\n                // reasonably short. A PATH is allowed to belong to a very restricted subset of\n                // Goessner's JSONPath.\n\n                // So,\n                //      var s = '[{\"$ref\":\"$\"}]';\n                //      return JSON.retrocycle(JSON.parse(s));\n                // produces an array containing a single element which is the array itself.\n\n                var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n                \n                /**\n                 * Converts the specified data URL to a Blob object\n                 * @param {String} dataURL to convert to a Blob\n                 * @returns {Blob} the converted Blob object\n                 */\n                function dataURLToBlob(dataURL) {\n                    var BASE64_MARKER = ';base64,',\n                        contentType,\n                        parts,\n                        raw;\n                    if (dataURL.indexOf(BASE64_MARKER) === -1) {\n                        parts = dataURL.split(',');\n                        contentType = parts[0].split(':')[1];\n                        raw = parts[1];\n\n                        return new Blob([raw], {type: contentType});\n                    }\n\n                    parts = dataURL.split(BASE64_MARKER);\n                    contentType = parts[0].split(':')[1];\n                    raw = window.atob(parts[1]);\n                    var rawLength = raw.length;\n                    var uInt8Array = new Uint8Array(rawLength);\n\n                    for (var i = 0; i < rawLength; ++i) {\n                        uInt8Array[i] = raw.charCodeAt(i);\n                    }\n                    return new Blob([uInt8Array.buffer], {type: contentType});\n                }\n                \n                function rez(value) {\n                    // The rez function walks recursively through the object looking for $ref\n                    // properties. When it finds one that has a value that is a path, then it\n                    // replaces the $ref object with a reference to the value that is found by\n                    // the path.\n\n                    var i, item, name, path;\n\n                    if (value && typeof value === 'object') {\n                        if (Object.prototype.toString.apply(value) === '[object Array]') {\n                            for (i = 0; i < value.length; i += 1) {\n                                item = value[i];\n                                if (item && typeof item === 'object') {\n                                    path = item.$ref;\n                                    if (typeof path === 'string' && px.test(path)) {\n                                        value[i] = eval(path);\n                                    } else {\n                                        value[i] = rez(item);\n                                    }\n                                }\n                            }\n                        } else {\n                            if (value.$type !== undefined) {\n                                switch(value.$type) {\n                                    case 'blob':\n                                    case 'file': \n                                        value = dataURLToBlob(value.$enc);\n                                        break;\n                                    case 'bool':\n                                        value = Boolean(value.$enc === 'true');\n                                        break;\n                                    case 'date':\n                                        value = new Date(value.$enc);\n                                        break;\n                                    case 'num':\n                                        value = Number(value.$enc);\n                                        break;\n                                    case 'regex':\n                                        value = eval(value.$enc);\n                                        break;\n                                }\n                            } else {\n                                for (name in value) {\n                                    if (typeof value[name] === 'object') {\n                                        item = value[name];\n                                        if (item) {\n                                            path = item.$ref;\n                                            if (typeof path === 'string' && px.test(path)) {\n                                                value[name] = eval(path);\n                                            } else {\n                                                value[name] = rez(item);\n                                            }\n                                        }\n                                    }   \n                                }\n                            }\n                        }\n                    }\n                    return value;\n                }\n                rez($);\n                return $;\n\n            },\n\n            /**\n             * Encode the specified object as a string.  Because of the asynchronus\n             * conversion of Blob/File to string, the encode function requires\n             * a callback\n             * @param {Object} val the value to convert.\n             * @param {function} callback the function to call once conversion is\n             * complete.  The callback gets called with the converted value.\n             */\n            \"encode\": function(val, callback){\n                function finishEncode(val) {\n                    callback(JSON.stringify(val));\n                }\n                this.decycle(val, finishEncode);                        \n            },\n                    \n            /**\n             * Deserialize the specified string to an object\n             * @param {String} val the serialized string\n             * @returns {Object} the deserialized object\n             */\n            \"decode\": function(val){\n                return this.retrocycle(JSON.parse(val));\n            }\n        };\n    }());\n    idbModules.Sca = Sca;\n}(idbModules));\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    /**\n     * Encodes the keys and values based on their types. This is required to maintain collations\n     */\n    var collations = [\"\", \"number\", \"string\", \"boolean\", \"object\", \"undefined\"];\n    var getGenericEncoder = function(){\n        return {\n            \"encode\": function(key){\n                return collations.indexOf(typeof key) + \"-\" + JSON.stringify(key);\n            },\n            \"decode\": function(key){\n                if (typeof key === \"undefined\") {\n                    return undefined;\n                }\n                else {\n                    return JSON.parse(key.substring(2));\n                }\n            }\n        };\n    };\n    \n    var types = {\n        \"number\": getGenericEncoder(\"number\"), // decoder will fail for NaN\n        \"boolean\": getGenericEncoder(),\n        \"object\": getGenericEncoder(),\n        \"string\": {\n            \"encode\": function(key){\n                return collations.indexOf(\"string\") + \"-\" + key;\n            },\n            \"decode\": function(key){\n                return \"\" + key.substring(2);\n            }\n        },\n        \"undefined\": {\n            \"encode\": function(key){\n                return collations.indexOf(\"undefined\") + \"-undefined\";\n            },\n            \"decode\": function(key){\n                return undefined;\n            }\n        }\n    };\n\t\n    var Key = (function(){\n        return {\n            encode: function(key){\n                return types[typeof key].encode(key);\n            },\n            decode: function(key){\n                return types[collations[key.substring(0, 1)]].decode(key);\n            }\n        };\n    }());\n    idbModules.Key = Key;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n\t// The event interface used for IndexedBD Actions.\n\tvar Event = function(type, debug){\n\t\t// Returning an object instead of an even as the event's target cannot be set to IndexedDB Objects\n\t\t// We still need to have event.target.result as the result of the IDB request\n\t\treturn {\n\t\t\t\"type\": type,\n\t\t\tdebug: debug,\n\t\t\tbubbles: false,\n\t\t\tcancelable: false,\n\t\t\teventPhase: 0,\n\t\t\ttimeStamp: new Date()\n\t\t};\n\t};\n\tidbModules.Event = Event;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * The IDBRequest Object that is returns for all async calls\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#request-api\n     */\n    var IDBRequest = function(){\n        this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null;\n        this.readyState = \"pending\";\n    };\n    /**\n     * The IDBOpen Request called when a database is opened\n     */\n    var IDBOpenRequest = function(){\n        this.onblocked = this.onupgradeneeded = null;\n    };\n    IDBOpenRequest.prototype = IDBRequest;\n    \n    idbModules.IDBRequest = IDBRequest;\n    idbModules.IDBOpenRequest = IDBOpenRequest;\n    \n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * The IndexedDB KeyRange object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     * @param {Object} lower\n     * @param {Object} upper\n     * @param {Object} lowerOpen\n     * @param {Object} upperOpen\n     */\n    var IDBKeyRange = function(lower, upper, lowerOpen, upperOpen){\n        this.lower = lower;\n        this.upper = upper;\n        this.lowerOpen = lowerOpen;\n        this.upperOpen = upperOpen;\n    };\n    \n    IDBKeyRange.only = function(value){\n        return new IDBKeyRange(value, value, false, false);\n    };\n    \n    IDBKeyRange.lowerBound = function(value, open){\n        return new IDBKeyRange(value, undefined, open, undefined);\n    };\n    IDBKeyRange.upperBound = function(value){\n        return new IDBKeyRange(undefined, value, undefined, open);\n    };\n    IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen){\n        return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);\n    };\n    \n    idbModules.IDBKeyRange = IDBKeyRange;\n    \n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * The IndexedDB Cursor Object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBCursor\n     * @param {Object} range\n     * @param {Object} direction\n     * @param {Object} idbObjectStore\n     * @param {Object} cursorRequest\n     */\n    function IDBCursor(range, direction, idbObjectStore, cursorRequest, keyColumnName, valueColumnName){\n        this.__range = range;\n        this.source = this.__idbObjectStore = idbObjectStore;\n        this.__req = cursorRequest;\n\n        this.key = undefined;\n        this.direction = direction;\n\n        this.__keyColumnName = keyColumnName;\n        this.__valueColumnName = valueColumnName;\n        this.__valueDecoder = valueColumnName === \"value\" ? idbModules.Sca : idbModules.Key;\n\n        if (!this.source.transaction.__active) {\n            idbModules.util.throwDOMException(\"TransactionInactiveError - The transaction this IDBObjectStore belongs to is not active.\");\n        }\n        // Setting this to -1 as continue will set it to 0 anyway\n        this.__offset = -1;\n\n        this.__lastKeyContinued = undefined; // Used when continuing with a key\n\n        this[\"continue\"]();\n    }\n\n    IDBCursor.prototype.__find = function (key, tx, success, error, recordsToLoad) {\n        recordsToLoad = recordsToLoad || 1;\n\n        var me = this;\n        var sql = [\"SELECT * FROM \", idbModules.util.quote(me.__idbObjectStore.name)];\n        var sqlValues = [];\n        sql.push(\"WHERE \", me.__keyColumnName, \" NOT NULL\");\n        if (me.__range && (me.__range.lower || me.__range.upper)) {\n            sql.push(\"AND\");\n            if (me.__range.lower) {\n                sql.push(me.__keyColumnName + (me.__range.lowerOpen ? \" >\" : \" >= \") + \" ?\");\n                sqlValues.push(idbModules.Key.encode(me.__range.lower));\n            }\n            (me.__range.lower && me.__range.upper) && sql.push(\"AND\");\n            if (me.__range.upper) {\n                sql.push(me.__keyColumnName + (me.__range.upperOpen ? \" < \" : \" <= \") + \" ?\");\n                sqlValues.push(idbModules.Key.encode(me.__range.upper));\n            }\n        }\n        if (typeof key !== \"undefined\") {\n            me.__lastKeyContinued = key;\n            me.__offset = 0;\n        }\n        if (me.__lastKeyContinued !== undefined) {\n            sql.push(\"AND \" + me.__keyColumnName + \" >= ?\");\n            sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued));\n        }\n        sql.push(\"ORDER BY \", me.__keyColumnName);\n        sql.push(\"LIMIT \" + recordsToLoad + \" OFFSET \" + me.__offset);\n        \n\n        me.__prefetchedData = null;\n        tx.executeSql(sql.join(\" \"), sqlValues, function (tx, data) {\n\n            if (data.rows.length > 1) {\n                me.__prefetchedData = data.rows;\n                me.__prefetchedIndex = 0;\n                \n                me.__decode(data.rows.item(0), success);\n            }\n            else if (data.rows.length === 1) {\n                me.__decode(data.rows.item(0), success);\n            }\n            else {\n                \n                success(undefined, undefined);\n            }\n        }, function (tx, data) {\n            \n            error(data);\n        });\n    };\n\n    IDBCursor.prototype.__decode = function (rowItem, callback) {\n        var key = idbModules.Key.decode(rowItem[this.__keyColumnName]);\n        var val = this.__valueDecoder.decode(rowItem[this.__valueColumnName]);\n        var primaryKey = idbModules.Key.decode(rowItem.key);\n        callback(key, val, primaryKey);\n    };\n\n    IDBCursor.prototype[\"continue\"] = function (key) {\n        var recordsToPreloadOnContinue = idbModules.cursorPreloadPackSize || 10000;\n        var me = this;\n\n        this.__idbObjectStore.transaction.__addToTransactionQueue(function (tx, args, success, error) {\n\n            me.__offset++;\n\n            var successCallback = function(key, val, primaryKey) {\n                me.key = key;\n                me.value = val;\n                me.primaryKey = primaryKey;\n                success(typeof me.key !== \"undefined\" ? me : undefined, me.__req);\n            };\n\n            if (me.__prefetchedData) {\n                // We have pre-loaded data for the cursor\n                me.__prefetchedIndex++;\n                if (me.__prefetchedIndex < me.__prefetchedData.length) {\n                    me.__decode(me.__prefetchedData.item(me.__prefetchedIndex), successCallback);\n                    return;\n                }\n            }\n            // No pre-fetched data, do query\n            me.__find(key, tx, successCallback, error, recordsToPreloadOnContinue);\n\n        });\n    };\n\n    IDBCursor.prototype.advance = function(count){\n        if (count <= 0) {\n            idbModules.util.throwDOMException(\"Type Error - Count is invalid - 0 or negative\", count);\n        }\n        var me = this;\n        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__offset += count;\n            me.__find(undefined, tx, function(key, value){\n                me.key = key;\n                me.value = value;\n                success(typeof me.key !== \"undefined\" ? me : undefined, me.__req);\n            }, error);\n        });\n    };\n\n    IDBCursor.prototype.update = function(valueToUpdate){\n        var me = this,\n                request = this.__idbObjectStore.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(valueToUpdate, function(encoded) {\n            me.__idbObjectStore.transaction.__pushToQueue(request, function(tx, args, success, error){\n                me.__find(undefined, tx, function(key, value, primaryKey){\n                    var sql = \"UPDATE \" + idbModules.util.quote(me.__idbObjectStore.name) + \" SET value = ? WHERE key = ?\";\n                    \n                    tx.executeSql(sql, [encoded, idbModules.Key.encode(primaryKey)], function(tx, data){\n                        if (data.rowsAffected === 1) {\n                            success(key);\n                        }\n                        else {\n                            error(\"No rows with key found\" + key);\n                        }\n                    }, function(tx, data){\n                        error(data);\n                    });\n                }, error);\n            });\n        });\n        return request;\n    };\n\n    IDBCursor.prototype[\"delete\"] = function(){\n        var me = this;\n        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__find(undefined, tx, function(key, value, primaryKey){\n                var sql = \"DELETE FROM  \" + idbModules.util.quote(me.__idbObjectStore.name) + \" WHERE key = ?\";\n                \n                tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data){\n                    if (data.rowsAffected === 1) {\n                        // lower the offset or we will miss a row\n                        me.__offset--;\n                        success(undefined);\n                    }\n                    else {\n                        error(\"No rows with key found\" + key);\n                    }\n                }, function(tx, data){\n                    error(data);\n                });\n            }, error);\n        });\n    };\n\n    idbModules.IDBCursor = IDBCursor;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * IDB Index\n     * http://www.w3.org/TR/IndexedDB/#idl-def-IDBIndex\n     * @param {Object} name;\n     * @param {Object} objectStore;\n     */\n    function IDBIndex(indexName, idbObjectStore){\n        this.indexName = this.name = indexName;\n        this.__idbObjectStore = this.objectStore = this.source = idbObjectStore;\n        \n        var indexList = idbObjectStore.__storeProps && idbObjectStore.__storeProps.indexList;\n        indexList && (indexList = JSON.parse(indexList));\n        \n        this.keyPath = ((indexList && indexList[indexName] && indexList[indexName].keyPath) || indexName);\n        ['multiEntry','unique'].forEach(function(prop){\n            this[prop] = !!indexList && !!indexList[indexName] && !!indexList[indexName].optionalParams && !!indexList[indexName].optionalParams[prop];\n        }, this);\n    }\n    \n    IDBIndex.prototype.__createIndex = function(indexName, keyPath, optionalParameters){\n        var me = this;\n        var transaction = me.__idbObjectStore.transaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            me.__idbObjectStore.__getStoreProps(tx, function(){\n                function error(){\n                    idbModules.util.throwDOMException(0, \"Could not create new index\", arguments);\n                }\n                if (transaction.mode !== 2) {\n                    idbModules.util.throwDOMException(0, \"Invalid State error, not a version transaction\", me.transaction);\n                }\n                var idxList = JSON.parse(me.__idbObjectStore.__storeProps.indexList);\n                if (typeof idxList[indexName] !== \"undefined\") {\n                    idbModules.util.throwDOMException(0, \"Index already exists on store\", idxList);\n                }\n                var columnName = indexName;\n                idxList[indexName] = {\n                    \"columnName\": columnName,\n                    \"keyPath\": keyPath,\n                    \"optionalParams\": optionalParameters\n                };\n                // For this index, first create a column\n                me.__idbObjectStore.__storeProps.indexList = JSON.stringify(idxList);\n                var sql = [\"ALTER TABLE\", idbModules.util.quote(me.__idbObjectStore.name), \"ADD\", columnName, \"BLOB\"].join(\" \");\n                \n                tx.executeSql(sql, [], function(tx, data){\n                    // Once a column is created, put existing records into the index\n                    tx.executeSql(\"SELECT * FROM \" + idbModules.util.quote(me.__idbObjectStore.name), [], function(tx, data){\n                        (function initIndexForRow(i){\n                            if (i < data.rows.length) {\n                                try {\n                                    var value = idbModules.Sca.decode(data.rows.item(i).value);\n                                    var indexKey = eval(\"value['\" + keyPath + \"']\");\n                                    tx.executeSql(\"UPDATE \" + idbModules.util.quote(me.__idbObjectStore.name) + \" set \" + columnName + \" = ? where key = ?\", [idbModules.Key.encode(indexKey), data.rows.item(i).key], function(tx, data){\n                                        initIndexForRow(i + 1);\n                                    }, error);\n                                } \n                                catch (e) {\n                                    // Not a valid value to insert into index, so just continue\n                                    initIndexForRow(i + 1);\n                                }\n                            }\n                            else {\n                                \n                                tx.executeSql(\"UPDATE __sys__ set indexList = ? where name = ?\", [me.__idbObjectStore.__storeProps.indexList, me.__idbObjectStore.name], function(){\n                                    me.__idbObjectStore.__setReadyState(\"createIndex\", true);\n                                    success(me);\n                                }, error);\n                            }\n                        }(0));\n                    }, error);\n                }, error);\n            }, \"createObjectStore\");\n        });\n    };\n    \n    IDBIndex.prototype.openCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, \"value\");\n        return cursorRequest;\n    };\n    \n    IDBIndex.prototype.openKeyCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, \"key\");\n        return cursorRequest;\n    };\n    \n    IDBIndex.prototype.__fetchIndexData = function(key, opType){\n        var me = this;\n        return me.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            var sql = [\"SELECT * FROM \", idbModules.util.quote(me.__idbObjectStore.name), \" WHERE\", me.indexName, \"NOT NULL\"];\n            var sqlValues = [];\n            if (typeof key !== \"undefined\") {\n                sql.push(\"AND\", me.indexName, \" = ?\");\n                sqlValues.push(idbModules.Key.encode(key));\n            }\n            \n            tx.executeSql(sql.join(\" \"), sqlValues, function(tx, data){\n                var d;\n                if (opType === \"count\") {\n                    d = data.rows.length;\n                }\n                else \n                    if (data.rows.length === 0) {\n                        d = undefined;\n                    }\n                    else \n                        if (opType === \"key\") {\n                            d = idbModules.Key.decode(data.rows.item(0).key);\n                        }\n                        else { // when opType is value\n                            d = idbModules.Sca.decode(data.rows.item(0).value);\n                        }\n                success(d);\n            }, error);\n        });\n    };\n    \n    IDBIndex.prototype.get = function(key){\n        return this.__fetchIndexData(key, \"value\");\n    };\n    \n    IDBIndex.prototype.getKey = function(key){\n        return this.__fetchIndexData(key, \"key\");\n    };\n    \n    IDBIndex.prototype.count = function(key){\n        return this.__fetchIndexData(key, \"count\");\n    };\n    \n    idbModules.IDBIndex = IDBIndex;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * IndexedDB Object Store\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBObjectStore\n     * @param {Object} name\n     * @param {Object} transaction\n     */\n    var IDBObjectStore = function(name, idbTransaction, ready){\n        this.name = name;\n        this.transaction = idbTransaction;\n        this.__ready = {};\n        this.__setReadyState(\"createObjectStore\", typeof ready === \"undefined\" ? true : ready);\n        this.indexNames = new idbModules.util.StringList();\n    };\n    \n    /**\n     * Need this flag as createObjectStore is synchronous. So, we simply return when create ObjectStore is called\n     * but do the processing in the background. All other operations should wait till ready is set\n     * @param {Object} val\n     */\n    IDBObjectStore.prototype.__setReadyState = function(key, val){\n        this.__ready[key] = val;\n    };\n    \n    /**\n     * Called by all operations on the object store, waits till the store is ready, and then performs the operation\n     * @param {Object} callback\n     */\n    IDBObjectStore.prototype.__waitForReady = function(callback, key){\n        var ready = true;\n        if (typeof key !== \"undefined\") {\n            ready = (typeof this.__ready[key] === \"undefined\") ? true : this.__ready[key];\n        }\n        else {\n            for (var x in this.__ready) {\n                if (!this.__ready[x]) {\n                    ready = false;\n                }\n            }\n        }\n        \n        if (ready) {\n            callback();\n        }\n        else {\n            \n            var me = this;\n            window.setTimeout(function(){\n                me.__waitForReady(callback, key);\n            }, 100);\n        }\n    };\n    \n    /**\n     * Gets (and optionally caches) the properties like keyPath, autoincrement, etc for this objectStore\n     * @param {Object} callback\n     */\n    IDBObjectStore.prototype.__getStoreProps = function(tx, callback, waitOnProperty){\n        var me = this;\n        this.__waitForReady(function(){\n            if (me.__storeProps) {\n                \n                callback(me.__storeProps);\n            }\n            else {\n                tx.executeSql(\"SELECT * FROM __sys__ where name = ?\", [me.name], function(tx, data){\n                    if (data.rows.length !== 1) {\n                        callback();\n                    }\n                    else {\n                        me.__storeProps = {\n                            \"name\": data.rows.item(0).name,\n                            \"indexList\": data.rows.item(0).indexList,\n                            \"autoInc\": data.rows.item(0).autoInc,\n                            \"keyPath\": data.rows.item(0).keyPath\n                        };\n                        \n                        callback(me.__storeProps);\n                    }\n                }, function(){\n                    callback();\n                });\n            }\n        }, waitOnProperty);\n    };\n    \n    /**\n     * From the store properties and object, extracts the value for the key in hte object Store\n     * If the table has auto increment, get the next in sequence\n     * @param {Object} props\n     * @param {Object} value\n     * @param {Object} key\n     */\n    IDBObjectStore.prototype.__deriveKey = function(tx, value, key, callback){\n        function getNextAutoIncKey(){\n            tx.executeSql(\"SELECT * FROM sqlite_sequence where name like ?\", [me.name], function(tx, data){\n                if (data.rows.length !== 1) {\n                    callback(0);\n                }\n                else {\n                    callback(data.rows.item(0).seq);\n                }\n            }, function(tx, error){\n                idbModules.util.throwDOMException(0, \"Data Error - Could not get the auto increment value for key\", error);\n            });\n        }\n        \n        var me = this;\n        me.__getStoreProps(tx, function(props){\n            if (!props) {\n                idbModules.util.throwDOMException(0, \"Data Error - Could not locate defination for this table\", props);\n            }\n            if (props.keyPath) {\n                if (typeof key !== \"undefined\") {\n                    idbModules.util.throwDOMException(0, \"Data Error - The object store uses in-line keys and the key parameter was provided\", props);\n                }\n                if (value) {\n                    try {\n                        var primaryKey = eval(\"value['\" + props.keyPath + \"']\");\n                        if (!primaryKey) {\n                            if (props.autoInc === \"true\") {\n                                getNextAutoIncKey();\n                            }\n                            else {\n                                idbModules.util.throwDOMException(0, \"Data Error - Could not eval key from keyPath\");\n                            }\n                        }\n                        else {\n                            callback(primaryKey);\n                        }\n                    } \n                    catch (e) {\n                        idbModules.util.throwDOMException(0, \"Data Error - Could not eval key from keyPath\", e);\n                    }\n                }\n                else {\n                    idbModules.util.throwDOMException(0, \"Data Error - KeyPath was specified, but value was not\");\n                }\n            }\n            else {\n                if (typeof key !== \"undefined\") {\n                    callback(key);\n                }\n                else {\n                    if (props.autoInc === \"false\") {\n                        idbModules.util.throwDOMException(0, \"Data Error - The object store uses out-of-line keys and has no key generator and the key parameter was not provided. \", props);\n                    }\n                    else {\n                        // Looks like this has autoInc, so lets get the next in sequence and return that.\n                        getNextAutoIncKey();\n                    }\n                }\n            }\n        });\n    };\n    \n    IDBObjectStore.prototype.__insertData = function(tx, encoded, value, primaryKey, success, error){\n        var paramMap = {};\n        if (typeof primaryKey !== \"undefined\") {\n            paramMap.key = idbModules.Key.encode(primaryKey);\n        }\n        var indexes = JSON.parse(this.__storeProps.indexList);\n        for (var key in indexes) {\n            try {\n                paramMap[indexes[key].columnName] = idbModules.Key.encode(eval(\"value['\" + indexes[key].keyPath + \"']\"));\n            } \n            catch (e) {\n                error(e);\n            }\n        }\n        var sqlStart = [\"INSERT INTO \", idbModules.util.quote(this.name), \"(\"];\n        var sqlEnd = [\" VALUES (\"];\n        var sqlValues = [];\n        for (key in paramMap) {\n            sqlStart.push(key + \",\");\n            sqlEnd.push(\"?,\");\n            sqlValues.push(paramMap[key]);\n        }\n        // removing the trailing comma\n        sqlStart.push(\"value )\");\n        sqlEnd.push(\"?)\");\n        sqlValues.push(encoded);\n        \n        var sql = sqlStart.join(\" \") + sqlEnd.join(\" \");\n        \n        \n        tx.executeSql(sql, sqlValues, function(tx, data){\n            success(primaryKey);\n        }, function(tx, err){\n            error(err);\n        });\n    };\n    \n    IDBObjectStore.prototype.add = function(value, key){\n        var me = this,\n            request = me.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(value, function(encoded) {\n            me.transaction.__pushToQueue(request, function(tx, args, success, error){\n                me.__deriveKey(tx, value, key, function(primaryKey){\n                    me.__insertData(tx, encoded, value, primaryKey, success, error);\n                });\n            });\n        });\n        return request;\n    };\n    \n    IDBObjectStore.prototype.put = function(value, key){\n        var me = this,\n            request = me.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(value, function(encoded) {\n            me.transaction.__pushToQueue(request, function(tx, args, success, error){\n                me.__deriveKey(tx, value, key, function(primaryKey){\n                    // First try to delete if the record exists\n                    var sql = \"DELETE FROM \" + idbModules.util.quote(me.name) + \" where key = ?\";\n                    tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data){\n                        \n                        me.__insertData(tx, encoded, value, primaryKey, success, error);\n                    }, function(tx, err){\n                        error(err);\n                    });\n                });\n            });\n        });\n        return request;\n    };\n    \n    IDBObjectStore.prototype.get = function(key){\n        // TODO Key should also be a key range\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var primaryKey = idbModules.Key.encode(key);\n                \n                tx.executeSql(\"SELECT * FROM \" + idbModules.util.quote(me.name) + \" where key = ?\", [primaryKey], function(tx, data){\n                    \n                    try {\n                        // Opera can't deal with the try-catch here.\n                        if (0 === data.rows.length) {\n                            return success();\n                        }\n                        \n                        success(idbModules.Sca.decode(data.rows.item(0).value));\n                    } \n                    catch (e) {\n                        \n                        // If no result is returned, or error occurs when parsing JSON\n                        success(undefined);\n                    }\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype[\"delete\"] = function(key){\n        // TODO key should also support key ranges\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var primaryKey = idbModules.Key.encode(key);\n                \n                tx.executeSql(\"DELETE FROM \" + idbModules.util.quote(me.name) + \" where key = ?\", [primaryKey], function(tx, data){\n                    \n                    success();\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.clear = function(){\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                tx.executeSql(\"DELETE FROM \" + idbModules.util.quote(me.name), [], function(tx, data){\n                    \n                    success();\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.count = function(key){\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var sql = \"SELECT * FROM \" + idbModules.util.quote(me.name) + ((typeof key !== \"undefined\") ? \" WHERE key = ?\" : \"\");\n                var sqlValues = [];\n                (typeof key !== \"undefined\") && sqlValues.push(idbModules.Key.encode(key));\n                tx.executeSql(sql, sqlValues, function(tx, data){\n                    success(data.rows.length);\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.openCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this, cursorRequest, \"key\", \"value\");\n        return cursorRequest;\n    };\n    \n    IDBObjectStore.prototype.index = function(indexName){\n        var index = new idbModules.IDBIndex(indexName, this);\n        return index;\n    };\n    \n    IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters){\n        var me = this;\n        optionalParameters = optionalParameters || {};\n        me.__setReadyState(\"createIndex\", false);\n        var result = new idbModules.IDBIndex(indexName, me);\n        me.__waitForReady(function(){\n            result.__createIndex(indexName, keyPath, optionalParameters);\n        }, \"createObjectStore\");\n        me.indexNames.push(indexName);\n        return result;\n    };\n    \n    IDBObjectStore.prototype.deleteIndex = function(indexName){\n        var result = new idbModules.IDBIndex(indexName, this, false);\n        result.__deleteIndex(indexName);\n        return result;\n    };\n    \n    idbModules.IDBObjectStore = IDBObjectStore;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * The IndexedDB Transaction\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBTransaction\n     * @param {Object} storeNames\n     * @param {Object} mode\n     * @param {Object} db\n     */\n    var READ = 0;\n    var READ_WRITE = 1;\n    var VERSION_TRANSACTION = 2;\n    \n    var IDBTransaction = function(storeNames, mode, db){\n        if (typeof mode === \"number\") {\n            this.mode = mode;\n            \n        }\n        else \n            if (typeof mode === \"string\") {\n                switch (mode) {\n                    case \"readwrite\":\n                        this.mode = READ_WRITE;\n                        break;\n                    case \"readonly\":\n                        this.mode = READ;\n                        break;\n                    default:\n                        this.mode = READ;\n                        break;\n                }\n            }\n        \n        this.storeNames = typeof storeNames === \"string\" ? [storeNames] : storeNames;\n        for (var i = 0; i < this.storeNames.length; i++) {\n            if (!db.objectStoreNames.contains(this.storeNames[i])) {\n                idbModules.util.throwDOMException(0, \"The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.\", this.storeNames[i]);\n            }\n        }\n        this.__active = true;\n        this.__running = false;\n        this.__requests = [];\n        this.__aborted = false;\n        this.db = db;\n        this.error = null;\n        this.onabort = this.onerror = this.oncomplete = null;\n        var me = this;\n    };\n    \n    IDBTransaction.prototype.__executeRequests = function(){\n        if (this.__running && this.mode !== VERSION_TRANSACTION) {\n            \n            return;\n        }\n        this.__running = true;\n        var me = this;\n        window.setTimeout(function(){\n            if (me.mode !== 2 && !me.__active) {\n                idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished\", me.__active);\n            }\n            // Start using the version transaction\n            me.db.__db.transaction(function(tx){\n                me.__tx = tx;\n                var q = null, i = 0;\n                function success(result, req){\n                    if (req) {\n                        q.req = req;// Need to do this in case of cursors\n                    }\n                    q.req.readyState = \"done\";\n                    q.req.result = result;\n                    delete q.req.error;\n                    var e = idbModules.Event(\"success\");\n                    idbModules.util.callback(\"onsuccess\", q.req, e);\n                    i++;\n                    executeRequest();\n                }\n                \n                function error(errorVal){\n                    q.req.readyState = \"done\";\n                    q.req.error = \"DOMError\";\n                    var e = idbModules.Event(\"error\", arguments);\n                    idbModules.util.callback(\"onerror\", q.req, e);\n                    i++;\n                    executeRequest();\n                }\n                function executeRequest(){\n                    if (i >= me.__requests.length) {\n                        me.__active = false; // All requests in the transaction is done\n                        me.__requests = [];\n                        return;\n                    }\n                    q = me.__requests[i];\n                    q.op(tx, q.args, success, error);\n                }\n                try {\n                    executeRequest();\n                } \n                catch (e) {\n                    \n                    typeof me.onerror === \"function\" && me.onerror();\n                }\n            }, function(){\n                \n                typeof me.onerror === \"function\" && me.onerror();\n            }, function(){\n                \n                typeof me.oncomplete === \"function\" && me.oncomplete();\n            });\n        }, 1);\n    };\n    \n    IDBTransaction.prototype.__addToTransactionQueue = function(callback, args){\n        if (!this.__active && this.mode !== VERSION_TRANSACTION) {\n            idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished.\", this.__mode);\n        }\n        var request = this.__createRequest();\n        this.__pushToQueue(request, callback, args);       \n        return request;\n    };\n    \n    IDBTransaction.prototype.__createRequest = function(){\n        var request = new idbModules.IDBRequest();\n        request.source = this.db;\n        request.transaction = this;\n        return request;\n    };\n    \n    IDBTransaction.prototype.__pushToQueue = function(request, callback, args) {\n        this.__requests.push({\n            \"op\": callback,\n            \"args\": args,\n            \"req\": request\n        });\n        // Start the queue for executing the requests\n        this.__executeRequests();\n    };\n    \n    IDBTransaction.prototype.objectStore = function(objectStoreName){\n        return new idbModules.IDBObjectStore(objectStoreName, this);\n    };\n    \n    IDBTransaction.prototype.abort = function(){\n        !this.__active && idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished\", this.__active);\n        \n    };\n    \n    IDBTransaction.prototype.READ_ONLY = 0;\n    IDBTransaction.prototype.READ_WRITE = 1;\n    IDBTransaction.prototype.VERSION_CHANGE = 2;\n    \n    idbModules.IDBTransaction = IDBTransaction;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * IDB Database Object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#database-interface\n     * @param {Object} db\n     */\n    var IDBDatabase = function(db, name, version, storeProperties){\n        this.__db = db;\n        this.version = version;\n        this.__storeProperties = storeProperties;\n        this.objectStoreNames = new idbModules.util.StringList();\n        for (var i = 0; i < storeProperties.rows.length; i++) {\n            this.objectStoreNames.push(storeProperties.rows.item(i).name);\n        }\n        this.name = name;\n        this.onabort = this.onerror = this.onversionchange = null;\n    };\n    \n    IDBDatabase.prototype.createObjectStore = function(storeName, createOptions){\n        var me = this;\n        createOptions = createOptions || {};\n        createOptions.keyPath = createOptions.keyPath || null;\n        var result = new idbModules.IDBObjectStore(storeName, me.__versionTransaction, false);\n        \n        var transaction = me.__versionTransaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            function error(){\n                idbModules.util.throwDOMException(0, \"Could not create new object store\", arguments);\n            }\n            \n            if (!me.__versionTransaction) {\n                idbModules.util.throwDOMException(0, \"Invalid State error\", me.transaction);\n            }\n            //key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE\n            var sql = [\"CREATE TABLE\", idbModules.util.quote(storeName), \"(key BLOB\", createOptions.autoIncrement ? \", inc INTEGER PRIMARY KEY AUTOINCREMENT\" : \"PRIMARY KEY\", \", value BLOB)\"].join(\" \");\n            \n            tx.executeSql(sql, [], function(tx, data){\n                tx.executeSql(\"INSERT INTO __sys__ VALUES (?,?,?,?)\", [storeName, createOptions.keyPath, createOptions.autoIncrement ? true : false, \"{}\"], function(){\n                    result.__setReadyState(\"createObjectStore\", true);\n                    success(result);\n                }, error);\n            }, error);\n        });\n        \n        // The IndexedDB Specification needs us to return an Object Store immediatly, but WebSQL does not create and return the store immediatly\n        // Hence, this can technically be unusable, and we hack around it, by setting the ready value to false\n        me.objectStoreNames.push(storeName);\n        return result;\n    };\n    \n    IDBDatabase.prototype.deleteObjectStore = function(storeName){\n        var error = function(){\n            idbModules.util.throwDOMException(0, \"Could not delete ObjectStore\", arguments);\n        };\n        var me = this;\n        !me.objectStoreNames.contains(storeName) && error(\"Object Store does not exist\");\n        me.objectStoreNames.splice(me.objectStoreNames.indexOf(storeName), 1);\n        \n        var transaction = me.__versionTransaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            if (!me.__versionTransaction) {\n                idbModules.util.throwDOMException(0, \"Invalid State error\", me.transaction);\n            }\n            me.__db.transaction(function(tx){\n                tx.executeSql(\"SELECT * FROM __sys__ where name = ?\", [storeName], function(tx, data){\n                    if (data.rows.length > 0) {\n                        tx.executeSql(\"DROP TABLE \" + idbModules.util.quote(storeName), [], function(){\n                            tx.executeSql(\"DELETE FROM __sys__ WHERE name = ?\", [storeName], function(){\n                            }, error);\n                        }, error);\n                    }\n                });\n            });\n        });\n    };\n    \n    IDBDatabase.prototype.close = function(){\n        // Don't do anything coz the database automatically closes\n    };\n    \n    IDBDatabase.prototype.transaction = function(storeNames, mode){\n        var transaction = new idbModules.IDBTransaction(storeNames, mode || 1, this);\n        return transaction;\n    };\n    \n    idbModules.IDBDatabase = IDBDatabase;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    var DEFAULT_DB_SIZE = 2 * 1024 * 1024;\n    if (!window.openDatabase) {\n        return;\n    }\n    // The sysDB to keep track of version numbers for databases\n    var sysdb = window.openDatabase(\"__sysdb__\", 1, \"System Database\", DEFAULT_DB_SIZE);\n    sysdb.transaction(function(tx){\n        tx.executeSql(\"SELECT * FROM dbVersions\", [], function(t, data){\n            // dbVersions already exists\n            shimIndexedDB.notifyIsReady(true);\n        }, function(){\n            // dbVersions does not exist, so creating it\n            sysdb.transaction(function(tx){\n                tx.executeSql(\"CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);\", [], function(){\n                    shimIndexedDB.notifyIsReady(true);\n                }, function(){\n                    shimIndexedDB.notifyIsReady(false);\n                    //idbModules.util.throwDOMException(\"Could not create table __sysdb__ to save DB versions\");\n                });\n            });\n        });\n    }, function(){\n        // sysdb Transaction failed\n       \n    });\n    \n    var shimInitSuccess = false;\n    var isShimReady = false;\n    var isReadyCallbacks = undefined;\n\n    var shimIndexedDB = {\n        notifyIsReady: function(success)\n        {\n            isShimReady = true;\n            shimInitSuccess = success;\n\n            if (isReadyCallbacks)\n            {\n                for (var i = 0; i < isReadyCallbacks.length; ++i)\n                {\n                    isReadyCallbacks[i](/*initSuccess*/shimInitSuccess);\n                }\n\n                isReadyCallbacks = undefined;\n            }\n        },\n        onIsReady: function(cb)\n        {\n            if (!isShimReady)\n            {\n                if (isReadyCallbacks)\n                {\n                    isReadyCallbacks.push(cb);\n                }\n                else\n                {\n                    isReadyCallbacks = [ cb ];\n                }\n            }\n            else\n            {\n                setTimeout(function () { cb(/*initSuccess*/shimInitSuccess); }, 0);\n            }\n        },\n\n        /**\n         * The IndexedDB Method to create a new database and return the DB\n         * @param {Object} name\n         * @param {Object} version\n         */\n        open: function(name, version){\n            var req = new idbModules.IDBOpenRequest();\n            var calledDbCreateError = false;\n            \n            function dbCreateError(){\n                if (calledDbCreateError) {\n                    return;\n                }\n                var e = idbModules.Event(\"error\", arguments);\n                req.readyState = \"done\";\n                req.error = \"DOMError\";\n                idbModules.util.callback(\"onerror\", req, e);\n                calledDbCreateError = true;\n            }\n            \n            function openDB(oldVersion){\n                var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);\n                req.readyState = \"done\";\n                if (typeof version === \"undefined\") {\n                    version = oldVersion || 1;\n                }\n                if (version <= 0 || oldVersion > version) {\n                    idbModules.util.throwDOMException(0, \"An attempt was made to open a database using a lower version than the existing version.\", version);\n                }\n                \n                db.transaction(function(tx){\n                    tx.executeSql(\"CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)\", [], function(){\n                        tx.executeSql(\"SELECT * FROM __sys__\", [], function(tx, data){\n                            var e = idbModules.Event(\"success\");\n                            req.source = req.result = new idbModules.IDBDatabase(db, name, version, data);\n                            if (oldVersion < version) {\n                                // DB Upgrade in progress \n                                sysdb.transaction(function(systx){\n                                    systx.executeSql(\"UPDATE dbVersions set version = ? where name = ?\", [version, name], function(){\n                                        var e = idbModules.Event(\"upgradeneeded\");\n                                        e.oldVersion = oldVersion;\n                                        e.newVersion = version;\n                                        req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction([], 2, req.source);\n                                        idbModules.util.callback(\"onupgradeneeded\", req, e, function(){\n                                            var e = idbModules.Event(\"success\");\n                                            idbModules.util.callback(\"onsuccess\", req, e);\n                                        });\n                                    }, dbCreateError);\n                                }, dbCreateError);\n                            } else {\n                                idbModules.util.callback(\"onsuccess\", req, e);\n                            }\n                        }, dbCreateError);\n                    }, dbCreateError);\n                }, dbCreateError);\n            }\n            \n            sysdb.transaction(function(tx){\n                tx.executeSql(\"SELECT * FROM dbVersions where name = ?\", [name], function(tx, data){\n                    if (data.rows.length === 0) {\n                        // Database with this name does not exist\n                        tx.executeSql(\"INSERT INTO dbVersions VALUES (?,?)\", [name, version || 1], function(){\n                            openDB(0);\n                        }, dbCreateError);\n                    } else {\n                        openDB(data.rows.item(0).version);\n                    }\n                }, dbCreateError);\n            }, dbCreateError);\n            \n            return req;\n        },\n        \n        \"deleteDatabase\": function(name){\n            var req = new idbModules.IDBOpenRequest();\n            var calledDBError = false;\n            function dbError(msg){\n                if (calledDBError) {\n                    return;\n                }\n                req.readyState = \"done\";\n                req.error = \"DOMError\";\n                var e = idbModules.Event(\"error\");\n                e.message = msg;\n                e.debug = arguments;\n                idbModules.util.callback(\"onerror\", req, e);\n                calledDBError = true;\n            }\n            var version = null;\n            function deleteFromDbVersions(){\n                sysdb.transaction(function(systx){\n                    systx.executeSql(\"DELETE FROM dbVersions where name = ? \", [name], function(){\n                        req.result = undefined;\n                        var e = idbModules.Event(\"success\");\n                        e.newVersion = null;\n                        e.oldVersion = version;\n                        idbModules.util.callback(\"onsuccess\", req, e);\n                    }, dbError);\n                }, dbError);\n            }\n            sysdb.transaction(function(systx){\n                systx.executeSql(\"SELECT * FROM dbVersions where name = ?\", [name], function(tx, data){\n                    if (data.rows.length === 0) {\n                        req.result = undefined;\n                        var e = idbModules.Event(\"success\");\n                        e.newVersion = null;\n                        e.oldVersion = version;\n                        idbModules.util.callback(\"onsuccess\", req, e);\n                        return;\n                    }\n                    version = data.rows.item(0).version;\n                    var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);\n                    db.transaction(function(tx){\n                        tx.executeSql(\"SELECT * FROM __sys__\", [], function(tx, data){\n                            var tables = data.rows;\n                            (function deleteTables(i){\n                                if (i >= tables.length) {\n                                    // If all tables are deleted, delete the housekeeping tables\n                                    tx.executeSql(\"DROP TABLE __sys__\", [], function(){\n                                        // Finally, delete the record for this DB from sysdb\n                                        deleteFromDbVersions();\n                                    }, dbError);\n                                } else {\n                                    // Delete all tables in this database, maintained in the sys table\n                                    tx.executeSql(\"DROP TABLE \" + idbModules.util.quote(tables.item(i).name), [], function(){\n                                        deleteTables(i + 1);\n                                    }, function(){\n                                        deleteTables(i + 1);\n                                    });\n                                }\n                            }(0));\n                        }, function(e){\n                            // __sysdb table does not exist, but that does not mean delete did not happen\n                            deleteFromDbVersions();\n                        });\n                    }, dbError);\n                });\n            }, dbError);\n            return req;\n        },\n        \"cmp\": function(key1, key2){\n            return idbModules.Key.encode(key1) > idbModules.Key.encode(key2) ? 1 : key1 === key2 ? 0 : -1;\n        }\n    };\n    \n    idbModules.shimIndexedDB = shimIndexedDB;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(window, idbModules){\n    if (typeof window.openDatabase !== \"undefined\") {\n        window.shimIndexedDB = idbModules.shimIndexedDB;\n        if (window.shimIndexedDB) {\n            window.shimIndexedDB.__useShim = function(){\n                console.log('---- Using SQL Shim ----');\n                window.indexedDB = idbModules.shimIndexedDB;\n                window.IDBDatabase = idbModules.IDBDatabase;\n                window.IDBTransaction = idbModules.IDBTransaction;\n                window.IDBCursor = idbModules.IDBCursor;\n                window.IDBKeyRange = idbModules.IDBKeyRange;\n                // On some browsers the assignment fails, overwrite with the defineProperty method\n                if (window.indexedDB !== idbModules.shimIndexedDB && Object.defineProperty) {\n                    Object.defineProperty(window, 'indexedDB', {\n                        value: idbModules.shimIndexedDB\n                    });\n                }\n            };\n            window.shimIndexedDB.__debug = function(val){\n                \n            };\n        }\n    }\n    \n    /*\n    prevent error in Firefox\n    */\n    if(!('indexedDB' in window)) {\n        window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB;\n    }\n    \n    /*\n    detect browsers with known IndexedDb issues (e.g. Android pre-4.4)\n    */\n    var poorIndexedDbSupport = false;\n    if (navigator.userAgent.match(/Android 2/) || navigator.userAgent.match(/Android 3/) || navigator.userAgent.match(/Android 4\\.[0-3]/)) {\n        /* Chrome is an exception. It supports IndexedDb */\n        if (!navigator.userAgent.match(/Chrome/)) {\n            poorIndexedDbSupport = true;\n        }\n    }\n\n    var forceSQL = window.location.hash.indexOf('forcesql=true') >= 0;\n\n    if (forceSQL || ((typeof window.indexedDB === \"undefined\" || poorIndexedDbSupport) && typeof window.openDatabase !== \"undefined\")) {\n        window.shimIndexedDB.__useShim();\n    } else {\n        window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase;\n        window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;\n        window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;\n        window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;\n        if(!window.IDBTransaction){\n            window.IDBTransaction = {};\n        }\n        /* Some browsers (e.g. Chrome 18 on Android) support IndexedDb but do not allow writing of these properties */\n        try {\n            window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || \"readonly\";\n            window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || \"readwrite\";\n        } catch (e) {}\n    }\n    \n}(window, idbModules));\n","asserts":[]},"demo":{"path":"F:/p/bce/Duchess/public/js/demo.js","data":"define(function ()\n{\n  return function (dataIndex)\n  {\n    if(!dataIndex)\n    {\n        return [{\n          \"text\": \"Home\",\n          \"items\": [\n            {\n              \"text\": \"\"\n            }]\n        }];\n    }\n    else if (dataIndex === 1)\n    {\n        return [\n          {\n            \"text\": \"Home:\",\n            \"items\": [\n              {\n                \"text\": \"Entertainment:\",\n                \"items\": [\n                  {\n                    \"text\": \"Movies:\",\n                    \"items\": [\n                      {\n                        \"text\": \"In Theaters:\",\n                        \"items\": [\n                          {\n                            \"text\": \"Despicable Me 2 @11:00am +Miller Harris\"\n                          },\n                          {\n                            \"text\": \"The Wolverine @Tuesday +Jane Johnson\"\n                          }\n                        ]\n                      },\n                      {\n                        \"text\": \"Netflix:\",\n                        \"items\": [\n                          {\n                            \"text\": \"Moonrise Kingdom\",\n                            \"isComplete\": true\n                          },\n                          {\n                            \"text\": \"Citizen Kane\",\n                            \"isComplete\": true\n                          },\n                          {\n                            \"text\": \"Tampopo\"\n                          },\n                          {\n                            \"text\": \"Wreck it Ralph\"\n                          },\n                          {\n                            \"text\": \"The Raid\"\n                          }\n                        ]\n                      }\n                    ]\n                  },\n                  {\n                    \"text\": \"TV:\",\n                    \"items\": [\n                      {\n                        \"text\": \"King of the Nerds\"\n                      },\n                      {\n                        \"text\": \"Sherlock\"\n                      },\n                      {\n                        \"text\": \"Legend of Korra\"\n                      },\n                      {\n                        \"text\": \"What the Ancients Knew\",\n                        \"priority\": VMLIFlag.P1\n                      },\n                      {\n                        \"text\": \"Black Mirror\"\n                      },\n                      {\n                        \"text\": \"Men at Work\"\n                      },\n                      {\n                        \"text\": \"Psych\"\n                      }\n                    ]\n                  },\n                  {\n                    \"text\": \"Games:\",\n                    \"items\": [\n                      {\n                        \"text\": \"Amnesia\"\n                      },\n                      {\n                        \"text\": \"Strike Suit Zero\"\n                      }\n                    ]\n                  },\n                  {\n                    \"text\": \"Books:\",\n                    \"items\": [\n                      {\n                        \"text\": \"How to Win Friends and Influence People\"\n                      },\n                      {\n                        \"text\": \"On the Road\"\n                      },\n                      {\n                        \"text\": \"The Beat Generation\"\n                      },\n                      {\n                        \"text\": \"Outliers\"\n                      },\n                      {\n                        \"text\": \"Innovators Dilemma\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"text\": \"Todo List\",\n                \"items\": [\n                  {\n                    \"text\": \"Call +Jim Joseph about fixing the blinds\"\n                  },\n                  {\n                    \"text\": \"Upload pictures from trip to Barbados\"\n                  },\n                  {\n                    \"text\": \"Insurance before @4/25\"\n                  },\n                  {\n                    \"text\": \"Buy bitcoins\"\n                  },\n                  {\n                    \"text\": \"Taxes @april\"\n                  },\n                  {\n                    \"text\": \"Pay rent\"\n                  },\n                  {\n                    \"text\": \"Lunch with +Miller Harris @12:30\"\n                  },\n                  {\n                    \"text\": \"Dinner date with +Emily Edwards @8pm\"\n                  },\n                  {\n                    \"text\": \"Check the mail @today\"\n                  },\n                  {\n                    \"text\": \"Ask +Jane Johnson who her dentist is\"\n                  },\n                  {\n                    \"text\": \"Learn Japanese\",\n                    \"priority\": VMLIFlag.P0,\n                    \"items\": [\n                      {\n                        \"text\": \"http://memrise.com\"\n                      },\n                      {\n                        \"text\": \"Try the new iPhone app\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"text\": \"Grocery List:\",\n                \"isFlagged\": true,\n                \"items\": [\n                  {\n                    \"text\": \"Apples\"\n                  },\n                  {\n                    \"text\": \"Carrots\"\n                  },\n                  {\n                    \"text\": \"Yogurt\"\n                  },\n                  {\n                    \"text\": \"Celery\"\n                  },\n                  {\n                    \"text\": \"Eggs\"\n                  },\n                  {\n                    \"text\": \"Almond Milk\"\n                  }\n                ]\n              },\n              {\n                \"text\": \"Restaurants:\",\n                \"items\": [\n                  {\n                    \"text\": \"SF:\",\n                    \"items\": [\n                      {\n                        \"text\": \"Ike's Sandwiches\"\n                      },\n                      {\n                        \"text\": \"Sweet Woodruff\"\n                      },\n                      {\n                        \"text\": \"Suzu Ramen\"\n                      },\n                      {\n                        \"text\": \"Kate's Kitchen\"\n                      },\n                      {\n                        \"text\": \"Otoro Sushi in Hayes Valley\"\n                      },\n                      {\n                        \"text\": \"Domo in Hayes Valley\"\n                      }\n                    ]\n                  },\n                  {\n                    \"text\": \"New York:\",\n                    \"items\": [\n                      {\n                        \"text\": \"Grammarcy Tavern\"\n                      },\n                      {\n                        \"text\": \"Cornelia Street Cafe\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"text\": \"Trip to Tobago:\",\n                \"items\": [\n                  {\n                    \"text\": \"Hotels:\",\n                    \"items\": [\n                      {\n                        \"text\": \"Trinidad:\",\n                        \"items\": [\n                          {\n                            \"text\": \"Port of Spain\",\n                            \"items\": [\n                              {\n                                \"text\": \"The Carlton Savannah - $150 per night\"\n                              },\n                              {\n                                \"text\": \"Marriott Courtyard - $200 per night\"\n                              }\n                            ]\n                          }\n                        ]\n                      },\n                      {\n                        \"text\": \"Tobago:\",\n                        \"items\": [\n                          {\n                            \"text\": \"Scarborough:\",\n                            \"items\": [\n                              {\n                                \"text\": \"Bacolet Beach Club - $170 per night\"\n                              },\n                              {\n                                \"text\": \"Coco Reef - $200\"\n                              },\n                              {\n                                \"text\": \"Blue Haven Hotel - $299\"\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"Castara:\",\n                            \"items\": [\n                              {\n                                \"text\": \"http://naturalist-tobago.com/bookings.html\",\n                                \"items\": [\n                                  {\n                                    \"text\": \"Has optional car rental\"\n                                  },\n                                  {\n                                    \"text\": \"Dolphin $90, ocean view veranda\"\n                                  },\n                                  {\n                                    \"text\": \"Tuna $85 ocean view + garden view\"\n                                  },\n                                  {\n                                    \"text\": \"We probably should do this - it's right on the beach\"\n                                  },\n                                  {\n                                    \"text\": \"Have to fill form to book\"\n                                  }\n                                ]\n                              },\n                              {\n                                \"text\": \"http://www.hiddencottagetobago.com/hummingbird.htm\",\n                                \"items\": [\n                                  {\"text\": \"3 minute walk to beach, can rent jeep\"}\n                                ]\n                              },\n                              {\n                                \"text\": \"http://www.angel-apartments.com/new.html\",\n                                \"items\": [\n                                  {\"text\": \"60-80 pounds per night\"}\n                                ]\n                              },\n                              {\n                                \"text\": \"http://www.blue-mango.com/contact.php\",\n                                \"items\": [\n                                  {\"text\": \"$70 - $150\"}\n                                ]\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"Manzanilla:\",\n                            \"items\": [\n                              {\n                                \"text\": \"http://dcoconutcove.com/rooms.php\",\n                                \"items\": [\n                                  {\"text\": \"Seems like the only option here - have to book via email\"}\n                                ]\n                              }\n                            ]\n                          }\n                        ]\n                      }\n                    ]\n                  },\n                  {\n                    \"text\": \"Activities:\",\n                    \"items\": [\n                      {\n                        \"text\": \"Things to do:\",\n                        \"items\": [\n                          {\n                            \"text\": \"Argyle Waterfall\"\n                          },\n                          {\n                            \"text\": \"Plantation Beach Watersports/Island Girl Cruises\"\n                          },\n                          {\n                            \"text\": \"Nylon Pool\"\n                          },\n                          {\n                            \"text\": \"Pigeon Point Beach - Jet Skiing\"\n                          }\n                        ]\n                      },\n                      {\n                        \"text\": \"Tour operators:\",\n                        \"items\": [\n                          {\n                            \"text\": \"http://www.caribbeandiscoverytours.com\",\n                            \"items\": [\n                              {\n                                \"text\": \"Hikes, safaris, kayaking, waterfalls\"\n                              },\n                              {\n                                \"text\": \"http://www.caribbeandiscoverytours.com/Tour4_nariva.html\"\n                              },\n                              {\n                                \"text\": \"seems too expensive - $100 for a day hike\"\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"http://chagdev.com\",\n                            \"items\": [\n                              {\n                                \"text\": \"waterfall and walking tours around Tucker Valley, caves\"\n                              },\n                              {\n                                \"text\": \"I like this, $20-$30 tours\"\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"Gasparee Caves Tour\"\n                          },\n                          {\n                            \"text\": \"Steel pan: http://islandexperiencestt.com\",\n                            \"items\": [\n                              {\n                                \"text\": \"meh\"\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"pariasprings.com\",\n                            \"items\": [\n                              {\n                                \"text\": \"Jungle camps http://pariasprings.com/events/kayaking.html\"\n                              },\n                              {\n                                \"text\": \"A day of fun with rainforests, waterfalls, and kayaking\"\n                              }\n                            ]\n                          },\n                          {\n                            \"text\": \"\"\n                          }\n                        ]\n                      }\n                    ]\n                  }\n                ]\n              }\n            ]\n          }\n        ];\n    }\n    // else if (dataIndex === 2)\n    // {\n    //     return [\n    //       {\n    //         \"text\": \"Home:\",\n    //         \"items\": [\n    //           {\n    //                 \"text\": \"Movies:\",\n    //                 \"items\": [\n    //                   {\n    //                     \"text\": \"In Theaters:\",\n    //                     \"items\": [\n    //                       {\n    //                         \"id\": \"dateItem\",\n    //                         \"text\": \"The Lego Movie 3D\"\n    //                       },\n    //                       {\n    //                         \"text\": \"Frozen\"\n    //                       }\n    //                     ]\n    //                   }\n    //                 ]\n    //           },\n    //           {\n    //             \"text\": \"Todo List:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Upload pictures from party\"\n    //               },\n    //               {\n    //                 \"id\": \"contactItem\",\n    //                 \"text\": \"Pay rent\"\n    //               }\n    //             ]\n    //           },\n    //           {\n    //             \"id\": \"dateItem2\",\n    //             \"text\": \"Groceries:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Apples\"\n    //               },\n    //               {\n    //                 \"text\": \"Eggs\"\n    //               },\n    //               {\n    //                 \"text\": \"Carrots\"\n    //               }\n    //             ]\n    //           },\n    //           {\n    //             \"text\": \"Trips:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Trinidad / Tobago:\",\n    //                 \"items\": [\n    //                   {\n    //                       \"text\": \"Port of Spain:\",\n    //                       \"items\": [\n    //                         {\n    //                           \"text\": \"The Carlton Savannah - $150 per night\"\n    //                         },\n    //                         {\n    //                           \"text\": \"Marriott Courtyard - $200 per night\"\n    //                         }\n    //                       ]\n    //                   },\n    //                   {\n    //                     \"text\": \"Argyle Waterfall\"\n    //                   },\n    //                   {\n    //                     \"text\": \"Nylon Pool\"\n    //                   },\n    //                   {\n    //                     \"text\": \"Pigeon Point Beach - Jet Skiing\"\n    //                   }\n    //                 ]\n    //               }\n    //             ]\n    //           }\n    //         ]\n    //       }\n    //     ];\n    // }\n    // else if (dataIndex === 3) // Focus\n    // {\n    //     return [\n    //       {\n    //         \"text\": \"Home:\",\n    //         \"items\": [\n    //           {\n    //                 \"text\": \"Movies:\",\n    //                 \"items\": [\n    //                   {\n    //                     \"text\": \"In Theaters:\",\n    //                     \"items\": [\n    //                       {\n    //                         \"id\": \"dateItem\",\n    //                         \"text\": \"Despicable Me 2\"\n    //                       },\n    //                       {\n    //                         \"text\": \"The Wolverine\"\n    //                       }\n    //                     ]\n    //                   }\n    //                 ]\n    //           },\n    //           {\n    //             \"text\": \"Todo List:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Upload pictures from party\"\n    //               },\n    //               {\n    //                 \"id\": \"contactItem\",\n    //                 \"text\": \"Pay rent\"\n    //               }\n    //             ]\n    //           },\n    //           {\n    //             \"id\": \"dateItem2\",\n    //             \"text\": \"Groceries:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Apples\"\n    //               },\n    //               {\n    //                 \"text\": \"Eggs\"\n    //               },\n    //               {\n    //                 \"text\": \"Carrots\"\n    //               }\n    //             ]\n    //           },\n    //           {\n    //             \"text\": \"Trips:\",\n    //             \"items\": [\n    //               {\n    //                 \"text\": \"Trinidad / Tobago:\",\n    //                 \"items\": [\n    //                   {\n    //                       \"text\": \"Port of Spain:\",\n    //                       \"items\": [\n    //                         {\n    //                           \"text\": \"The Carlton Savannah - $150 per night\"\n    //                         },\n    //                         {\n    //                           \"text\": \"Marriott Courtyard - $200 per night\"\n    //                         }\n    //                       ]\n    //                   },\n    //                   {\n    //                     \"text\": \"Argyle Waterfall\"\n    //                   },\n    //                   {\n    //                     \"text\": \"Nylon Pool\"\n    //                   },\n    //                   {\n    //                     \"text\": \"Pigeon Point Beach - Jet Skiing\"\n    //                   }\n    //                 ]\n    //               }\n    //             ]\n    //           }\n    //         ]\n    //       }\n    //     ];\n    // }\n    else if (dataIndex === 4) // Active Demo\n    {\n        return [\n          {\n            \"text\": \"Home\",\n            \"items\": [\n              {\n                \"text\": \"Movies\",\n                \"items\": [\n                  {\n                    \"text\": \"In Theaters\",\n                    \"items\": [\n                      {\n                        \"id\": \"movieItem\",\n                        \"text\": \"The Lego Movie 3D\"\n                      },\n                      {\n                        \"id\": \"movieItem2\",\n                        \"text\": \"Frozen\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"id\": \"todoItem\",\n                \"text\": \"Todo List\",\n                \"items\": [\n                  {\n                    \"id\": \"rentItem\",\n                    \"text\": \"Pay rent\"\n                  },\n                  {\n                    \"id\": \"groceriesItem\",\n                    \"text\": \"Get groceries\"\n                  },\n                ]\n              },\n              {\n                \"id\": \"shoppingItem\",\n                \"text\": \"Shopping\",\n                \"items\": [\n                  {\n                    \"text\": \"Shorts\",\n                  },\n                  {\n                    \"text\": \"New Camera\"\n                  },\n                  {\n                    \"id\": \"laptopItem\",\n                    \"text\": \"Laptop for Dad\",\n                    \"items\": [\n                      {\n                        \"text\": \"15\\\", touch screen, plus a mouse\",\n                      },\n                      {\n                        \"text\": \"A hard case because he'll drop it a lot\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              // {\n              //   \"text\": \"Cooking:\",\n              //   \"items\": [\n              //     {\n              //       \"text\": \"Vegetable stir-fry\"\n              //     },\n              //     {\n              //       \"text\": \"Chocolate covered chocolate\"\n              //     }\n              //   ]\n              // },\n              {\n                \"text\": \"Blog topics\",\n                \"items\": [\n                  {\n                    \"text\": \"Traveling in New Zealand\"\n                  },\n                  {\n                    \"text\": \"Inner workings of web browsers\"\n                  }\n                ]\n              },\n              {\n                \"id\": \"vacationItem\",\n                \"text\": \"Vacation Plan\"\n              }\n            ]\n          }\n        ];\n    }\n    else if (dataIndex === 5) // Professional\n    {\n        return [\n          {\n           \"text\":\"Home\",\n           \"items\":[\n              {\n                 \"text\":\"Action Items\",\n                 \"items\":[\n                    {\n                       \"text\":\"Follow up on expense reports with +Mike Thomas for team\"\n                    },\n                    {\n                       \"text\":\"File brief with +Bill Wilson before board meeting about ethics policy @3/14\"\n                    },\n                    {\n                       \"text\":\"Meeting with +Mike Thomas and +Joe Lewis to discuss quarterly earning projections @3/12 2:00pm\"\n                    },\n                    {\n                       \"text\":\"Lunch with +Bill Wilson at Revel @3/13 12:30pm\",\n                       \"items\":[\n                          {\n                             \"text\":\"Discuss travel plans\"\n                          }\n                       ]\n                    },\n                    {\n                       \"text\":\"Confirm hotel booking for @3/20 for +Canyon Ranch\"\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"Board Meeting @3/17\",\n                 \"items\":[\n                    {\n                       \"text\":\"Touch base with +Bill Wilson and +Bob Johnson about voting proxy\"\n                    },\n                    {\n                       \"text\":\"Confirm catering with +Emily Edwards\"\n                    },\n                    {\n                       \"text\":\"Agenda\",\n                       \"items\":[\n                          {\n                             \"text\":\"Approve previous board meeting minutes\"\n                          },\n                          {\n                             \"text\":\"Offices report\",\n                             \"items\":[\n                                {\n                                   \"text\":\"Contact +Emily Edwards about proper filing of report before\"\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Old business\",\n                             \"items\":[\n                                {\n                                   \"text\":\"Talk about raise in maximum expenses per person for discretionary use\"\n                                },\n                                {\n                                   \"text\":\"Change in business code of ethics policy\"\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Items for board approval\",\n                             \"items\":[\n                                {\n                                   \"text\":\"Increase in vacation days\"\n                                },\n                                {\n                                   \"text\":\"Executive compensation\"\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Feedback session\"\n                          },\n                          {\n                             \"text\":\"Requests for action items\"\n                          }\n                       ]\n                    }\n                 ]\n              }\n           ]\n        }\n        ];\n    }\n    else if (dataIndex === 6) // Student\n    {\n      return [\n        {\n         \"text\":\"Home\",\n         \"items\":[\n            {\n               \"text\":\"Physics\",\n               \"items\":[\n                  {\n                     \"text\":\"Homework\",\n                     \"items\":[\n                        {\n                           \"text\":\"Read chapter 2 in Hawking @3/4\"\n                        },\n                        {\n                           \"text\":\"4pg writeup on black holes @3/11\",\n                           \"items\":[\n                              {\n                                 \"text\":\"http://www.nation.com.pk/snippets/27-Jan-2014/stephen-hawking-says-black-holes-don-t-exist\"\n                              }\n                           ]\n                        }\n                     ]\n                  },\n                  {\n                     \"text\":\"Lab report @3/11\",\n                     \"items\":[\n                        {\n                           \"text\":\"Talk to +Jim Joseph about conclusion section and proofread introduction\"\n                        },\n                        {\n                           \"text\":\"Create graphs for data section on air temperature increase over time\"\n                        }\n                     ]\n                  }\n               ]\n            },\n            {\n               \"text\":\"Chemistry\",\n               \"items\":[\n                  {\n                     \"text\":\"Order aluminum oxide @3/21\",\n                     \"isFlagged\": true,\n                  }\n               ]\n            },\n            {\n               \"text\":\"Business Ethics\",\n               \"items\":[\n                  {\n                     \"text\":\"Homework\",\n                     \"items\":[\n                        {\n                           \"text\":\"Read chapter 5 and write 500 word summary on one case study @3/5\",\n                        },\n                        {\n                           \"text\":\"Read sections 6.1 through 6.5 and answer end of section questions @3/12\"\n                        }\n                     ]\n                  }\n               ]\n            },\n            {\n               \"text\":\"Technical Writing\",\n               \"items\":[\n                  {\n                     \"text\":\"Bring Alred book to class! @3/10\"\n                  },\n                  {\n                     \"text\":\"Talk to +Mike Thomas about experience writing docs at a large company\"\n                  },\n                  {\n                     \"text\":\"Prepare presentation for REST API documentation on example data @3/13\"\n                  }\n               ]\n            }\n         ]\n      }\n      ];\n    }\n    else if (dataIndex === 7) // Teacher\n    {\n      return [\n        {\n         \"text\":\"Home\",\n         \"items\":[\n            {\n               \"text\":\"Open House @3/14\",\n               \"items\":[\n                  {\n                     \"text\":\"Talk to +Emily Edwards to coordinate handouts for parents\",\n                     \"items\":[\n                        {\n                           \"text\":\"Finalize date of parent teacher conferences\"\n                        },\n                        {\n                           \"text\":\"Double check PTA meeting agenda and date\"\n                        }\n                     ]\n                  },\n                  {\n                     \"text\":\"Get pencils for open house parent excercise\",\n                     \"priority\": VMLIFlag.P1\n                  }\n               ]\n            },\n            {\n               \"text\":\"Lesson Plans\",\n               \"items\":[\n                  {\n                     \"text\":\"Teaching the Seasons @3/17\",\n                     \"items\":[\n                        {\n                           \"text\":\"Objective\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Teach students the difference between Spring, Summer, Fall and Winter.\"\n                              }\n                           ]\n                        },\n                        {\n                           \"text\":\"Materials\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Construction paper, calendar, photos of each season, arts and craft supplies, four childrens books\"\n                              }\n                           ]\n                        },\n                        {\n                           \"text\":\"Procedure\",\n                           \"items\":[\n                              {\n                                 \"text\":\"@3/17 12:00pm Show different pictures of each season. Start with spring and progress through to winter. Explain the weather in each season with visual aid.\"\n                              },\n                              {\n                                 \"text\":\"@3/17 12:15pm Read four short children's books, each telling a story about a different season.\"\n                              },\n                              {\n                                 \"text\":\"@3/17 12:30pm Put the children at different tables and hand out art supplies. Demonstrate the project: a large piece of construction paper split into four parts, one for each season.\"\n                              },\n                              {\n                                 \"text\":\"@3/17 12:45pm Walk around to help children with their projects, ask questions while helping about what occurs during each season.\"\n                              },\n                              {\n                                 \"text\":\"@3/17 2:00pm Clean up art projects and hang them around classroom.\"\n                              },\n                              {\n                                 \"text\":\"@3/17 2:15pm Final wrap up and discussion with Q&A for each season. Ask about the types of things they associate with each season including weather and personal memories.\"\n                              }\n                           ]\n                        }\n                     ]\n                  },\n                  {\n                     \"text\":\"Farm Animals @3/18:\",\n                     \"items\":[\n                        {\n                           \"text\":\"Objective:\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Teach students about the different types of animals that live on the farm.\"\n                              }\n                           ]\n                        },\n                        {\n                           \"text\":\"Materials:\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Picture book, animal posters, soundboard, short story\"\n                              }\n                           ]\n                        },\n                        {\n                           \"text\":\"Procedure:\",\n                           \"items\":[\n                              {\n                                 \"text\":\"@3/18 12:00pm Talk about what happens on a farm and broadly about the animals that live there. Show pictures of a few farm settings containing different animals.\"\n                              },\n                              {\n                                 \"text\":\"@3/18 12:20pm Discuss anyones experience with farms or their favorite animals. See if the children have been to the petting zoo or visited a farm.\"\n                              },\n                              {\n                                 \"text\":\"@3/18 12:45pm Go through the posters of farm animals and associate the noises the animals make with the pictures.\"\n                              },\n                              {\n                                 \"text\":\"@3/18 1:15pm Read short story set on the farm to children and hold Q&A session. Check to see what animals they like and discuss life on a farm.\"\n                              }\n                           ]\n                        }\n                     ]\n                  }\n               ]\n            }\n         ]\n      }\n      ];\n    }\n    else if (dataIndex === 8) // Developer\n    {\n      return [\n      {\n         \"text\":\"Home\",\n         \"items\":[\n            {\n               \"text\":\"Talk to +Joe Lewis about getting the checkin queue optimized\",\n               \"isFlagged\": true,\n            },\n            {\n               \"text\":\"Work Projects\",\n               \"items\":[\n                  {\n                     \"text\":\"Code Reviews\",\n                     \"items\":[\n                        {\n                           \"text\":\"Talk to +Miller Harris about UX update @today 3:00pm\"\n                        },\n                        {\n                           \"text\":\"Review code from +Emily Edwards for performance optimization during tap handling @tomorrow 11:00am\"\n                        }\n                     ]\n                  },\n                  {\n                     \"text\":\"Active Development\",\n                     \"items\":[\n                        {\n                           \"text\":\"Finish uploading design documents for improved UX\"\n                        },\n                        {\n                           \"text\":\"Proofread wiki entry from +Jane Johnson for OS migration @friday\"\n                        },\n                        {\n                           \"text\":\"Blocking Bugs\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Investigate sync issues when multiple clients are offline for long periods of time and three people edit\",\n                                 \"priority\": VMLIFlag.P0\n                              },\n                              {\n                                 \"text\":\"#mobile Find consistent repro scenario for input errors for fast typing on iOS\"\n                              },\n                              {\n                                 \"text\":\"#norepro Error at 'Deleting local item'\",\n                                 \"items\":[\n                                    {\n                                       \"text\":\"See globals.js:1672 for additional reference\"\n                                    }\n                                 ]\n                              }\n                           ]\n                        },\n                        {\n                           \"text\":\"Minor Bugs\",\n                           \"items\":[\n                              {\n                                 \"text\":\"Flashing during pull to refresh after app running for long periods of time\",\n                                 \"priority\": VMLIFlag.P1\n                              },\n                              {\n                                 \"text\":\"Ensure copy/paste is correctly pulling from clipboard when html data is used\"\n                              }\n                           ]\n                        }\n                     ]\n                  }\n               ]\n            },\n            {\n               \"text\":\"Personal Projects\",\n               \"items\":[\n                  {\n                     \"text\":\"Knockout Addon\",\n                     \"items\":[\n                        {\n                           \"text\":\"Ensure throttled observables plugin continues to work\"\n                        },\n                        {\n                           \"text\":\"Add flush method for throttled observables\"\n                        },\n                        {\n                           \"text\":\"Finish performance optimizations for large array sizes\"\n                        },\n                        {\n                           \"text\":\"Prevent applyBindings from being called twice when elements get reused\"\n                        }\n                     ]\n                  }\n               ]\n            }\n         ]\n      }\n      ];\n    }\n    else if (dataIndex === 9) // Traveler\n    {\n      return [\n        {\n           \"text\":\"Home\",\n           \"items\":[\n              {\n                 \"text\":\"Whistler\",\n                 \"items\":[\n                    {\n                       \"text\":\"Action Items\",\n                       \"items\":[\n                          {\n                             \"text\":\"Reserve rental car\",\n                             \"priority\": VMLIFlag.P0\n                          },\n                          {\n                             \"text\":\"Talk to +Bill Wilson about parking\"\n                          }\n                       ]\n                    },\n                    {\n                       \"text\":\"Itinerary\",\n                       \"items\":[\n                          {\n                             \"text\":\"Leave SEA -> Whistler @1/16/14\"\n                          },\n                          {\n                             \"text\":\"Pickup +Emily Edwards @1/16/14 9:00pm from SEA Flight: 739\"\n                          },\n                          {\n                             \"text\":\"Lodging at Whistler at Aspens 349\"\n                          },\n                          {\n                             \"text\":\"Leave Whistler -> Vancouver @1/19/14 5:00pm\"\n                          },\n                          {\n                             \"text\":\"Lodging in Vancouver: +Ramada\",\n                             \"items\":[\n                                {\n                                   \"text\":\"Confirmation Number: 5245682\",\n                                   \"isFlagged\": true\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Leave Vancouver -> SEA @1/20/14 3:00pm\"\n                          },\n                          {\n                             \"text\":\"Drop +Emily Edwards @1/20/14 8:00pm at SEA Flight: 264\"\n                          }\n                       ]\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"Tobago Planning\",\n                 \"items\":[\n                    {\n                       \"text\":\"Hotels\",\n                       \"items\":[\n                          {\n                             \"text\":\"Scarborough\",\n                             \"items\":[\n                                {\n                                   \"text\":\"Bacolet Beach Club - $170 / night\"\n                                },\n                                {\n                                   \"text\":\"Coco Reef - $200\"\n                                },\n                                {\n                                   \"text\":\"Blue Haven Hotel $300\"\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Castara\",\n                             \"items\":[\n                                {\n                                   \"text\":\"http://naturalist-tobago.com/bookings.html\",\n                                   \"items\":[\n                                      {\n                                         \"text\":\"Ocean view, right on the beach\"\n                                      },\n                                      {\n                                         \"text\":\"Optional car rental\"\n                                      }\n                                   ]\n                                },\n                                {\n                                   \"text\":\"http://www.hiddencottagetobago.com/hummingbird.htm\",\n                                   \"items\":[\n                                      {\n                                         \"text\":\"Three minute walk to beach\"\n                                      },\n                                      {\n                                         \"text\":\"Can rent jeep\"\n                                      }\n                                   ]\n                                },\n                                {\n                                   \"text\":\"http://www.angel-apartments.com/new.html\",\n                                   \"items\":[\n                                      {\n                                         \"text\":\"$100 - 150 / night\"\n                                      }\n                                   ]\n                                },\n                                {\n                                   \"text\":\"http://www.blue-mango.com/contact.php\",\n                                   \"items\":[\n                                      {\n                                         \"text\":\"$70 - $150 / night\"\n                                      }\n                                   ]\n                                }\n                             ]\n                          },\n                          {\n                             \"text\":\"Manzanilla\",\n                             \"items\":[\n                                {\n                                   \"text\":\"http://dcoconutcove.com/rooms.php\",\n                                   \"items\":[\n                                      {\n                                         \"text\":\"Only option?\"\n                                      },\n                                      {\n                                         \"text\":\"Book by email\"\n                                      }\n                                   ]\n                                }\n                             ]\n                          }\n                       ]\n                    },\n                    {\n                       \"text\":\"Activities\",\n                       \"items\":[\n                          {\n                             \"text\":\"Argyle Waterfall\"\n                          },\n                          {\n                             \"text\":\"Plantation Beach Watersports / Island Girl Cruises\"\n                          },\n                          {\n                             \"text\":\"Nylon Pool\"\n                          },\n                          {\n                             \"text\":\"Pigeon Point Beach - Jet Skiing\"\n                          },\n                          {\n                             \"text\":\"Tour Operators\",\n                             \"items\":[\n                                {\n                                   \"text\":\"http://www.caribbeandiscoverytours.com\"\n                                },\n                                {\n                                   \"text\":\"http://chagdev.com\"\n                                },\n                                {\n                                   \"text\":\"http://islandexperiencestt.com\"\n                                },\n                                {\n                                   \"text\":\"http://pariasprings.com\"\n                                }\n                             ]\n                          }\n                       ]\n                    }\n                 ]\n              }\n           ]\n        }\n      ];\n    }\n    else if (dataIndex === 10) // Everyone\n    {\n      return [\n        {\n           \"text\":\"Home\",\n           \"items\":[\n              {\n                 \"text\":\"Events\",\n                 \"items\":[\n                    {\n                       \"text\":\"Frozen +Emily Edwards @Friday 6:55pm\"\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"Restaurants\",\n                 \"items\":[\n                    {\n                       \"text\":\"Seattle\",\n                       \"items\":[\n                          {\n                             \"text\":\"Chan\"\n                          },\n                          {\n                             \"text\":\"Joule\"\n                          },\n                          {\n                             \"text\":\"Serious Pie\"\n                          },\n                          {\n                             \"text\":\"Lola\"\n                          }\n                       ]\n                    },\n                    {\n                       \"text\":\"San Francisco\",\n                       \"items\":[\n                          {\n                             \"text\":\"Ike's Sandwhiches\"\n                          },\n                          {\n                             \"text\":\"Sweet Woodruff\"\n                          },\n                          {\n                             \"text\":\"Suzu Ramen\"\n                          },\n                          {\n                             \"text\":\"Kate's Kitchen\"\n                          }\n                       ]\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"Movies\",\n                 \"items\":[\n                    {\n                       \"text\":\"Despicable Me 2\"\n                    },\n                    {\n                       \"text\":\"Total Recall\"\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"TV\",\n                 \"items\":[\n                    {\n                       \"text\":\"Sherlock - Season 3\"\n                    },\n                    {\n                       \"text\":\"Legend of Korra\"\n                    },\n                    {\n                       \"text\":\"Psych\"\n                    },\n                    {\n                       \"text\":\"House of Cards\"\n                    }\n                 ]\n              },\n              {\n                \"text\": \"Todo List\",\n                \"items\": [\n                  {\n                    \"text\": \"Call +Jim Joseph about fixing the blinds\"\n                  },\n                  {\n                    \"text\": \"Upload pictures from trip to Barbados\"\n                  },\n                  {\n                    \"text\": \"Insurance before @4/25\"\n                  },\n                  {\n                    \"text\": \"Buy bitcoins\"\n                  },\n                  {\n                    \"text\": \"Taxes @april\"\n                  },\n                  {\n                    \"text\": \"Pay rent\"\n                  },\n                  {\n                    \"text\": \"Lunch with +Miller Harris @12:30\"\n                  },\n                  {\n                    \"text\": \"Dinner date with +Emily Edwards @8pm\"\n                  },\n                  {\n                    \"text\": \"Check the mail @today\"\n                  },\n                  {\n                    \"text\": \"Ask +Jane Johnson who her dentist is\"\n                  },\n                  {\n                    \"text\": \"Learn Japanese\",\n                    \"priority\": VMLIFlag.P0,\n                    \"items\": [\n                      {\n                        \"text\": \"http://memrise.com\"\n                      },\n                      {\n                        \"text\": \"Try the new iPhone app\"\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"text\": \"Grocery List:\",\n                \"isFlagged\": true,\n                \"items\": [\n                  {\n                    \"text\": \"Apples\"\n                  },\n                  {\n                    \"text\": \"Carrots\"\n                  },\n                  {\n                    \"text\": \"Yogurt\"\n                  },\n                  {\n                    \"text\": \"Celery\"\n                  },\n                  {\n                    \"text\": \"Eggs\"\n                  },\n                  {\n                    \"text\": \"Almond Milk\"\n                  }\n                ]\n              },\n              {\n                 \"text\":\"Games\",\n                 \"items\":[\n                    {\n                       \"text\":\"Amnesia\"\n                    },\n                    {\n                       \"text\":\"XCOM\"\n                    },\n                    {\n                       \"text\":\"Far Cry 3\"\n                    }\n                 ]\n              },\n              {\n                 \"text\":\"Chores\",\n                 \"items\":[\n                    {\n                       \"text\":\"Clean bathroom @wednesday\"\n                    },\n                    {\n                       \"text\":\"Sweep floors @thursday\"\n                    },\n                    {\n                       \"text\":\"Take out trash @thursday\"\n                    },\n                    {\n                       \"text\":\"Check mail @soon\"\n                    },\n                    {\n                       \"text\":\"Haircut @today 4:00pm\"\n                    }\n                 ]\n              }\n           ]\n        }\n      ];\n    }\n    else if (dataIndex === 11) // Indenting\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Title of a list\"\n          },\n          {\n            \"id\": \"itemIndent\",\n            \"text\": \"Something to do\"\n          }\n        ]\n      }];\n    }\n    else if (dataIndex === 12) // Contacts\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Get a present for +Miller Harris\"\n          },\n          {\n            \"text\": \"Ask +Emily Edwards how she's doing\"\n          }\n        ]\n      }];\n    }\n    else if (dataIndex === 13) // Prioritization\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"House work\",\n            \"items\": [\n              {\n                \"id\": \"yard\",\n                \"text\": \"Get around to cleaning the yard\"\n              },\n              {\n                \"id\": \"roof\",\n                \"text\": \"Fix the hole in the roof\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Around Town\",\n            \"items\": [\n              {\n                \"text\": \"Ask +Emily Edwards how she's doing\"\n              },\n              {\n                \"text\": \"Try that new restaurant I heard about\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Vacations\",\n            \"items\": [\n              {\n                \"id\": \"vacation\",\n                \"text\": \"Plan next year's vacation\"\n              },\n              {\n                \"text\": \"+Jane Johnson said her trip to Japan was amazing\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Birthday party for +Miller Harris\",\n            \"items\": [\n              {\n                \"id\": \"chips\",\n                \"text\": \"Buy chips before the party\"\n              },\n              {\n                \"id\": \"present\",\n                \"text\": \"Get a present for +Miller Harris\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Shopping\",\n            \"items\": [\n              {\n                \"id\": \"shorts\",\n                \"text\": \"Shorts\",\n              },\n              {\n                \"text\": \"New Camera\"\n              },\n              {\n                \"id\": \"laptop\",\n                \"text\": \"Laptop for Dad\",\n                \"items\": [\n                  {\n                    \"text\": \"15\\\", touch screen, plus a mouse\",\n                  },\n                  {\n                    \"text\": \"A hard case because he'll drop it a lot\"\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            \"text\": \"Reference\",\n            \"items\": [\n              {\n                \"text\": \"New PIN number: 1234\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Massive lack of organization in my life\",\n            \"items\": [\n              {\n                \"id\": \"app\",\n                \"text\": \"Check out this sweet app: http://www.moo.do\"\n              }\n            ]\n          }\n        ]\n      }];\n    }\n    else if (dataIndex === 14) // Focus\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Todo List\",\n            \"items\": [\n              {\n                \"text\": \"Check the mail @today #out\"\n              },\n              {\n                \"text\": \"Buy bitcoins. $900 is a great price!\",\n                \"isComplete\": true\n              },\n              {\n                \"text\": \"Lunch with +Miller Harris @12:30\"\n              },\n              {\n                \"text\": \"Get a new drill from the hardware store #out\"\n              },\n              {\n                \"text\": \"Dinner date with +Emily Edwards @8pm\"\n              },\n              {\n                \"text\": \"Learn Japanese\",\n                \"priority\": VMLIFlag.P2,\n                \"items\": [\n                  {\n                    \"text\": \"http://memrise.com\"\n                  },\n                  {\n                    \"text\": \"Try the new iPhone app\"\n                  }\n                ]\n              },\n              {\n                \"text\": \"Go see that fancy new 3D movie\"\n              },\n              {\n                \"text\": \"Check out this sweet app: http://www.moo.do\",\n                \"priority\": VMLIFlag.P0\n              }\n            ]\n          },\n          {\n            \"text\": \"Work Projects\",\n            \"items\": [\n              {\n                \"text\": \"Write article about having solved cold fusion\"\n              },\n              {\n                \"text\": \"Fix the explosion problem everybody is complaining about\",\n                \"priority\": VMLIFlag.P1\n              },\n              {\n                \"text\": \"Get a computer for the new intern #out\"\n              },\n              {\n                \"text\": \"Hide the evidence\",\n                \"isComplete\": true\n              },\n              {\n                \"text\": \"Email +Miller Harris re: new diagrams\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Japan trip\",\n            \"items\": [\n              {\n                \"text\": \"Find the best cities to visit\"\n              },\n              {\n                \"text\": \"Book some hotels\"\n              },\n              {\n                \"text\": \"Get some Japanese candy I've been craving #out\",\n                \"priority\": VMLIFlag.P2\n              }\n            ]\n          }\n        ]\n      }];\n    }\n    else if (dataIndex === 15) // One Place\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"You have projects and todo lists\",\n          },\n          {\n            \"text\": \"Appointments to get to @Friday 4pm\",\n          },\n          {\n            \"text\": \"Important things to get done\",\n            \"priority\": VMLIFlag.P0\n          },\n          {\n            \"text\": \"Friends and family to talk to +Miller Harris\",\n          },\n          {\n            \"text\": \"Exciting places to visit online http://www.moo.do\",\n          },\n          {\n            \"text\": \"Complete things when you're done\",\n            \"isComplete\": true\n          },\n        ]\n      }];\n    }\n    else if (dataIndex === 16) // Just Text\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"List titles automatically becomes bold\",\n            \"items\": [\n              {\n                \"text\": \"When you indent text under it.\"\n              },\n              {\n                \"text\": \"Your project hierarchy can be as deep\",\n                \"items\": [\n                  {\n                    \"text\": \"As you want it to be.\"\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            \"text\": \"To use dates or contacts, type @date or +contact\",\n            \"items\": [\n              {\n                \"text\": \"Call +Jane Johnson @tomorrow\"\n              }\n            ]\n          }\n        ]\n      }];\n    }\n    else if (dataIndex === 17) // Agenda\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Dates can be specific @tomorrow 4:30pm\"\n          },\n          {\n            \"text\": \"Or they can be more vague @soon\"\n          },\n          {\n            \"text\": \"Mark as high priority\",\n            \"priority\": VMLIFlag.P0\n          },\n          {\n            \"text\": \"Highlight this to come back to it\",\n            \"isFlagged\": true\n          },\n        ]\n      }];\n    }\n    else if (dataIndex === 18) // Search\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Search for a #tag\"\n          },\n          {\n            \"text\": \"Show priority items\",\n            \"priority\": VMLIFlag.P2\n          },\n          {\n            \"text\": \"Or only the highest priority\",\n            \"priority\": VMLIFlag.P0\n          },\n          // {\n          //   \"text\": \"Flag items and come back to them with a search\",\n          //   \"isFlagged\": true\n          // },\n          {\n            \"id\": \"searchItem\",\n            \"text\": \"Focus on a project\",\n            \"items\": [\n              {\n                \"text\": \"To ignore other distractions\",\n                // \"isFlagged\": true\n              },\n              {\n                \"text\": \"Then you can search just within a list #tag\"\n              }\n            ]\n          },\n          {\n            \"text\": \"See a list of things to talk to +Jane Johnson about\"\n          }\n        ]\n      }];\n    }\n    else if (DEBUG && dataIndex === 20)\n    {\n      return [{\n        \"text\": \"Home\",\n        \"items\": [\n          {\n            \"text\": \"Child One\",\n            \"items\": [\n              {\n                \"text\": \"GrandChild One\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Child Two\",\n            \"items\": [\n              {\n                \"text\": \"GC One\"\n              },\n              {\n                \"text\": \"GC Two\"\n              },\n              {\n                \"text\": \"GC Three\"\n              },\n              {\n                \"text\": \"GC Four\"\n              }\n            ]\n          },\n          {\n            \"text\": \"Child Three\",\n            \"items\": [\n              {\n                \"text\": \"AAA\"\n              },\n              {\n                \"text\": \"BBB\"\n              },\n              {\n                \"text\": \"AAA\"\n              }\n            ]\n          }]\n      }];\n    }\n    else\n    {\n      debugger;\n\n      log('Invalid Data Index');\n    }\n  };\n});","asserts":[]},"VMSetup":{"path":"F:/p/bce/Duchess/public/js/VMSetup.js","data":"define(['ko', 'data', 'globals', 'util', 'platform', 'goog', 'AScript'],\nfunction (ko, d, g, util, platform, goog, AScript) {\n\nfunction VMSetup ()\n{\n    this.loginState = ko.observable(LoginState.NONE);\n\n    this.loginEnabled = ko.observable(true);\n    this.loginStatus = ko.observable('');\n\n    if (!goog.gapiLoaded && !DEBUG)\n    {\n        this.loginDisableTimeout = setTimeout(function()\n        {\n            this.loginEnabled(false);\n            this.loginStatus('Must be online to login');\n        }.bind(this), 1000);\n\n        // g.events.on('gapi_loaded', (function()\n        // {\n        //     clearTimeout(this.loginDisableTimeout);\n        //     this.loginEnabled(true);\n        //     this.loginStatus('');\n        // }).bind(this));\n\n        window.addEventListener('gapiLoaded', function()\n        {\n            clearTimeout(this.loginDisableTimeout);\n            this.loginEnabled(true);\n            this.loginStatus('');\n        }.bind(this), true);\n    }\n\n    //this.areAccountsSetup = ko.observable(true);\n    //this.loggedInUser = ko.observable('');\n    //this.passwordStatusText = ko.observable('');\n}\n\nVMSetup.prototype = {\n    init: function()\n    {\n        if (!g.isDemoMode())\n        {\n            var loginState = g.getLoginState();\n\n            this.setLoginState(loginState);\n\n            g.applyBindings(this, 'setup');\n\n\n            window.addEventListener('offline', function(evt)\n            {\n                log('Browser going offline.');\n\n                g.vmMain.setGDriveStatus(DriveStatus.Offline);\n            });\n\n            window.addEventListener('online', function(evt)\n            {\n                log('Browser going online.');\n\n                if (g.getLoginState() == LoginState.LOGGED_IN && !platform.offline)\n                {\n                    g.vmMain.setGDriveStatus(DriveStatus.Connecting);\n\n                    var alreadyOnline = goog.goOnline();\n                    log('Coming online. Already online:', alreadyOnline);\n                }\n            });\n\n            if (DEBUG)\n            {\n                this.setLoginState(LoginState.LOGGED_IN);\n\n                return LoginState.LOGGED_IN;\n            }\n\n            /*if (loginState == LoginState.LOGGED_OUT)\n            {\n                var forceLogin = util.getURLParam('login');\n\n                if (forceLogin == 'true')\n                {\n                    this.userLogin();\n                }\n            }*/\n\n            return loginState;\n        }\n        else\n        {\n            // if (!platform.mobile)\n            // {\n            //     ko.applyBindings(this, document.getElementById('authArea'));\n            // }\n\n            return LoginState.LOGGED_OUT;\n        }\n    },\n    // Helper functions to reflect state information in the UI\n    // _statusText: function()\n    // {\n    //     if (this.loginState() == LoginState.USER_LOGIN)\n    //     {\n    //         return 'Welcome back';\n    //     }\n    //     else if (this.loginState() == LoginState.USER_CREATE)\n    //     {\n    //         return 'Sign up';\n    //     }\n    //     else\n    //     {\n    //         return '';\n    //     }\n    // },\n    // _statusTextColor: function ()\n    // {\n    //     if (this.loginState() == LoginState.USER_LOGIN)\n    //     {\n    //         return 'rgb(45, 230, 45)';\n    //     }\n    //     else\n    //     {\n    //         return '#ddd';\n    //     }\n    // },\n    // _buttonText: function()\n    // {\n    //     if (this.loginState() == LoginState.USER_CREATE)\n    //     {\n    //         return 'Sign up';\n    //     }\n    //     else if(this.loginState() == LoginState.USER_LOGIN)\n    //     {\n    //         return 'Log in';\n    //     }\n    //     else\n    //     {\n    //         return 'Sign up / Log in';\n    //     }\n    // },\n    logoutButtonText: function()\n    {\n        if (g.isDemoMode())\n        {\n            return 'Leave Introduction';\n        }\n        /*else if (this.loginState() == LoginState.OFFLINE)\n        {\n            return 'Login';\n        }*/\n        else\n        {\n            return 'Logout';\n        }\n    },\n    setLoginState: function(state)\n    {\n        if (state != this.loginState())\n        {\n            g.setLoginState(state);\n\n            this.loginState(state);\n        }\n    },\n    //\n    // User Authentication\n    //\n    userLogin: function ()\n    {\n        goog.runAuthenticate(goog.requiredScopes, /*runImmediate*/false, /*retry*/true, function (token)\n        {\n            if (token && !token.error)\n            {\n                // When loading for the first time, mark the last remote load as successful\n                g.settings.set(Settings.localIntegrity, true);\n\n                this.setLoginState(LoginState.LOGGED_IN);\n\n                gapi.load('drive-realtime', function()\n                {\n                    goog.loadClientDefaultFile();\n                });\n            }\n            else\n            {\n                log('Invalid token returned when calling userLogin');\n            }\n        }.bind(this));\n    },\n    openLogin: function ()\n    {\n        // g.removeClass(document.getElementById('setupContents'), 'trans');\n        // setupContents.css({webkitTransform: 'translate3d(0px,0,0)'});\n\n        this.loginState(LoginState.NONE);\n\n        g.StopSpinner();\n    },\n    logout: function()\n    {\n        g.settings.reset();\n\n        this.setLoginState(LoginState.LOGGED_OUT);\n\n        d.clearData(function ()\n        {\n            if (util.hasURLParam('login'))\n            {\n                util.removeURLParam('login');\n            }\n            else if (!platform.app)\n            {\n                g.reload();\n            }\n            else if (platform.app)\n            {\n                platform.sendToApp('logout');\n            }\n        });\n    },\n    logoutClicked: function ()\n    {\n        if (g.isDemoMode())\n        {\n            // Leave demo\n            util.removeURLParam('demo');\n        }\n        else\n        {\n            /*if (this.loginState() == LoginState.OFFLINE)\n            {\n                goog.goOnline();\n\n                this.userLogin();\n                g.vmMain.hideMenu();\n            }\n            else*/\n            {\n                var ok = true;\n                for (var itemID in d.pendingRemoteUpdates)\n                {\n                    if (d.pendingRemoteUpdates.hasOwnProperty(itemID))\n                    {\n                        if (!platform.packagedApp)\n                        {\n                            ok = confirm('You have unsaved changes which will be lost if you log out. Are you sure?');\n                        }\n\n                        break;\n                    }\n                }\n\n                if (ok)\n                {\n                    this.logout();\n                }\n            }\n        }\n    },\n    isLocal: function()\n    {\n        return window.location.hostname == 'localhost';\n    },\n    onlineStatusToggle: function ()\n    {\n        platform.offline ? util.removeURLParam('offline') : util.insertURLParam('offline', 'true');\n    },\n    // startIntroduction: function ()\n    // {\n    //     // g.intro = new intro(function ()\n    //     // {\n    //     //     g.intro = undefined;\n    //     // });\n\n    //     // g.intro.run();\n    // },\n    runScript: function(id)\n    {\n        if (!g.AScript)\n        {\n            g.AScript = new AScript();\n        }\n\n        g.AScript.runScript(id, /*repeat*/true);\n    },\n    onTapLogin: function()\n    {\n        if (g.vmMain.isOnline())\n        {\n            this.userLogin();\n        }\n    },\n    // onTapOffline: {\n    //     onStart: function(e) {\n    //         this.setLoginState(LoginState.OFFLINE);\n    //     }\n    // },\n    onTapInput: {\n        onClick: function(e) {\n            if(platform.ios)\n            {\n                e.srcElement.focus();\n                g.enforceScroll();\n            }\n        }\n    },\n    onTap: {\n        onMove: function(e) {\n            if(e.diffY < 0)\n            {\n                e.preventDefault();\n            }\n        }\n    },\n    // onTapDemo: function()\n    // {\n    //     util.insertURLParam('demo', 'true');\n    // },\n    onTapLanding: function()\n    {\n        window.location.pathname = '/about/';\n    },\n    onPrivacyPolicy: {\n        onClick: function(e) {\n            open('/privacy');\n        }\n    }\n};\n\nreturn VMSetup;\n});\n","asserts":[]},"AScript":{"path":"F:/p/bce/Duchess/public/js/AScript.js","data":"define(['globals', 'platform', 'data', 'tracker', 'VMLI', 'edit'],\nfunction (g, platform, d, tracker, VMLI, edit) {\n\nfunction AScript()\n{\n    this.hasSelection = false;\n    this.isTyping = false;\n    this.isRunning = false;\n    this.isDisabled = false;\n    this.activeScript = undefined;\n    this.index = 0;\n    this.repeat = false;\n    this.onScriptDone = undefined;\n    // This might not be good enough if needing to track selection across multiple panes\n    this.selectedItem = undefined;\n    this.needsFinish = false;\n    this.lastCreatedItem = undefined;\n    this.lastLoadedData = 5;\n\n    this._scriptQueue = [ ];\n    this.startText = {};\n\n    window.addEventListener('message', function (e)\n    {\n        // Don't allow JSON strings from Google through\n        if (e.data.indexOf('{') < 0)\n        {\n            var params = e.data.split(':');\n\n            g.Assert(params.length >= 0, 'Invalid number of params in message');\n\n            switch (params[0])\n            {\n                case 'script':\n                    this.finishAndRunScript(params[1]);\n                    break;\n                case 'data':\n                    this.loadScriptData(params[1]);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }.bind(this), false);\n\n    window.pauseScript = function()\n    {\n        if(!this.isDisabled)\n        {\n            log('pause script');\n            this.isDisabled = true;\n        }\n    }.bind(this);\n}\n\nvar ActionType = { Run: 1, Reset: 2 };\n\nAScript.prototype = {\n    /////// Public Functions ///////\n    runScript: function(id, repeat)\n    {\n        if (this.isDisabled)\n        {\n            return;\n        }\n\n        if (DEBUG) { log('---- Running Script: ', id, '----'); }\n\n        switch (id)\n        {\n            case \"power\":\n                this._scriptQueue.push(this.demoPower(\"power0\", 0));\n                this._scriptQueue.push(this.demoPower(\"power1\", 1));\n                this._scriptQueue.push(this.demoPower(\"power2\", 2));\n                this._scriptQueue.push(this.demoPower(\"power3\", 3));\n                this._scriptQueue.push(this.demoPower(\"power4\", 4));\n\n                var script = this.createScript(\"delay\");\n                script.queue(ActionType.Run, 'delay', 5000);\n                this._scriptQueue.push(script);\n\n                break;\n            case \"main\":\n                this._scriptQueue.push(this.demoMain(id));\n                break;\n            case \"mainp\":\n                this._scriptQueue.push(this.demoMain(id, /*phone*/true));\n                break;\n            case \"search\":\n                this._scriptQueue.push(this.demoSearch(id));\n                break;\n            // case \"focus\":\n            //     this._scriptQueue.push(this.demoFocus(id));\n            //     break;\n            case \"power0\":\n            case \"power1\":\n            case \"power2\":\n            case \"power3\":\n            case \"power4\":\n                var index = parseInt(id.replace('power', ''), 10);\n                this._scriptQueue.push(this.demoPower(id, index));\n                break;\n            case 'p0':\n            case 'p1':\n            case 'p2':\n            case 'p3':\n            case 'p4':\n            case 'p5':\n                var index = parseInt(id.replace('p', ''), 10);\n                this._scriptQueue.push(this.demoPrioritize(id, index));\n                repeat = false;\n                break;\n            case 'f0':\n            case 'f1':\n            case 'f2':\n            case 'f3':\n            case 'f4':\n            case 'f5':\n                var index = parseInt(id.replace('f', ''), 10);\n                this._scriptQueue.push(this.demoFocus(id, index));\n                repeat = false;\n                break;\n            case \"indent\":\n                this._scriptQueue.push(this.demoIndent(id));\n                break;\n            case \"none\":\n                return;\n            default:\n                g.Assert(false, 'Invalid script request');\n                break;\n        }\n\n        this.repeat = repeat;\n        this.activeScript = this._scriptQueue[0];\n\n        if (!this.isRunning && this.activeScript)\n        {\n            this.onScriptStart(this.activeScript);\n\n            this.reset();\n            this.run();\n        }\n    },\n    forceFinish: function(cb)\n    {\n        g.Assert(cb, 'Must supply a callback to force finish');\n        if (this.isRunning)\n        {\n            this.needsFinish = true;\n            if(this.delayTimeout)\n            {\n                clearTimeout(this.delayTimeout);\n                this.delayCb();\n                this.delayCb = this.delayTimeout = undefined;\n            }\n\n            this.onScriptDone = function()\n            {\n                this.needsFinish = false;\n\n                cb();\n\n                this.onScriptDone = undefined;\n            }.bind(this);\n        }\n        else\n        {\n            g.Assert(this.needsFinish === false, 'Should never be forcing a finish if not actively running');\n\n            cb();\n        }\n    },\n    finishAndRunScript: function(id)\n    {\n        this._scriptQueue = [ ];\n        this.repeat = false;\n\n        this.forceFinish(function ()\n        {\n            this.runScript(id, /*repeat*/false);\n        }.bind(this));\n\n        // if (this.isRunning)\n        // {\n        //     this.needsFinish = true;\n\n        //     this.onScriptDone = function()\n        //     {\n        //         this.needsFinish = false;\n        //         this.runScript(id, /*repeat*/false);\n        //         this.onScriptDone = undefined;\n        //     }.bind(this);\n        // }\n        // else\n        // {\n        //     g.Assert(this.needsFinish === false, 'Should never be forcing a finish if not actively running');\n        //     this.runScript(id, /*repeat*/false);\n        // }\n    },\n    loadScriptData: function(dataId)\n    {\n        log('Load Script Data: ', dataId);\n\n        this._scriptQueue = [ ];\n        this.repeat = false;\n\n        if (this.lastLoadedData !== dataId)\n        {\n            function runLoadData()\n            {\n                this.lastLoadedData = dataId;\n\n                g.vmMain.resetScrollOffsets();\n\n                d.loadDemoData(dataId, g.vmMain.changeRoot);\n            }\n\n            // if (this.isRunning)\n            // {\n            //     this.forceFinish(runLoadData.bind(this));\n            // }\n            // else\n            {\n                runLoadData();\n            }\n        }\n    },\n    onScriptStart: function(script)\n    {\n        if (script)\n        {\n            window.parent.postMessage(script.getName(), '*');\n        }\n    },\n\n    /////// Helper Functions ///////\n    getRoot: function()\n    {\n        return d.getRootModel();\n    },\n    getFirstItem: function()\n    {\n        return d.getRootModel().getChild(0);\n    },\n\n    /////// Scripted Functions ///////\n    setSelection: function(item, paneIndex, offset, cb)\n    {\n        g.Assert(item, 'Must provide a valid item to select');\n\n        if (g.focusedPaneID !== paneIndex)\n        {\n            g.vmMain.setFocusedPane(g.vmMain.panes[paneIndex]);\n        }\n\n        if (offset === undefined || offset === null)\n        {\n            offset = 0;\n        }\n        else if (offset < 0)\n        {\n            offset = item.getParsedText().length + offset + 1;\n        }\n\n        g.selectChildren(item, offset, 0);\n\n        this.hasSelection = true;\n        this.selectedItem = item;\n\n        if(cb) cb();\n    },\n    selectEndOfLine: function(item, paneIndex, cb)\n    {\n        this.setSelection(item, paneIndex, -1, cb);\n    },\n    clearSelection: function(cb)\n    {\n        g.clearSelection();\n\n        this.hasSelection = false;\n        this.selectedItem = undefined;\n\n        if(cb) cb();\n    },\n    scrollTo: function(index, offset, cb)\n    {\n        var pane = g.vmMain.panes()[index];\n        g.Assert(pane, 'Must have selected a valid pane');\n        pane.setScrollOffset(offset);\n\n        if(cb) cb();\n    },\n    setText: function(item, str, cb)\n    {\n        item.setText(str, true);\n\n        if(cb) cb();\n    },\n    appendText: function(item, str, cb)\n    {\n        item.setText(item.getRawText() + str, true);\n\n        if(cb) cb();\n    },\n    removeText: function(item, str, cb)\n    {\n        var text = item.getRawText().replace(str, '');\n        item.setText(text, true);\n\n        if(cb) cb();\n    },\n    setPriority: function(item, priority, cb)\n    {\n        item.priority(priority);\n\n        if(cb) cb();\n    },\n    setFlagged: function(item, isFlagged, cb)\n    {\n        item.isFlagged(isFlagged);\n\n        if(cb) cb();\n    },\n    setComplete: function(item, isComplete, date, cb)\n    {\n        item.dateCompleted = date;\n        item.isComplete(isComplete);\n\n        if(cb) cb();\n    },\n    indent: function(outdent, cb)\n    {\n        var keyData = { normCode: KeyCode.Tab, shiftKey: outdent };\n\n        // var vars = {normCode: KeyCode.Tab, which: KeyCode.Tab, preventDefault: function(){}};\n\n        // if (outdent)\n        // {\n        //     vars.shiftKey = true;\n        // }\n\n        // edit.keypress(undefined, vars, true);\n        // edit.keyup(undefined, vars);\n\n        g.fireKeyEvent(undefined, keyData);\n\n        if(cb) cb();\n    },\n    _deleteChildren: function(item)\n    {\n        for(var i = 0; i < item.items().length; i ++)\n        {\n            this._deleteChildren(item.items()[i]);\n            delete d.itemsById[item.items()[i].id];\n        }\n    },\n    clearChildren: function(item, cb)\n    {\n        this._deleteChildren(item);\n        item.items.removeAll();\n\n        if(cb) cb();\n    },\n    typeString: function(item, str, charDelay, cb)\n    {\n        g.Assert(cb, 'typeString should always have a callback');\n\n        if (this.needsFinish)\n        {\n            charDelay = 0;\n        }\n\n        this.selectEndOfLine(item || this.lastCreatedItem, 0);\n\n        g.Assert(this.hasSelection, 'Must set selection before typing');\n        g.Assert(!this.isTyping, 'Must wait until previous typing is finished');\n\n        g.Assert(str !== undefined, 'Must supply a string to be typed');\n        g.Assert(charDelay !== undefined, 'Must specify a delay between each typed character');\n\n        this.isTyping = true;\n\n        var i = 0;\n        var typeInterval;\n        function typeChar()\n        {\n            g.fireKeyEvent(undefined, { normCode: str.charCodeAt(i) });\n\n            if (++i >= str.length)\n            {\n                if (typeInterval)\n                {\n                    clearInterval(typeInterval);\n                }\n\n                this.isTyping = false;\n\n                if(cb) cb();\n            }\n        }\n\n        typeInterval = setInterval(typeChar.bind(this), charDelay);\n    },\n    resetSearch: function(cb)\n    {\n        for(var i = 0; i < g.vmMain.panes().length; i ++)\n        {\n            g.vmMain.panes()[i].vmSearch.setSearch('');\n        }\n\n        if(cb) cb();\n    },\n    hideAutoComplete: function(cb)\n    {\n        if (g.autocomplete)\n        {\n            g.autocomplete.hide();\n        }\n\n        if(cb) cb();\n    },\n    setSearch: function(search, paneIndex, cb)\n    {\n        g.vmMain.panes()[paneIndex].vmSearch.setSearch(search);\n\n        if(cb) cb();\n    },\n    searchString: function(str, charDelay, clearFirst, paneIndex, cb)\n    {\n        g.Assert(!this.isTyping, 'Must wait until previous typing is finished');\n\n        g.Assert(str !== undefined, 'Must supply a string to be typed');\n        g.Assert(charDelay !== undefined, 'Must specify a delay between each typed character');\n\n        this.isTyping = true;\n\n        var vmSearch = g.vmMain.panes()[paneIndex].vmSearch;\n\n        var startStr = clearFirst ? '' : vmSearch.search();\n\n        var i = 0;\n        var typeInterval = setInterval(function()\n        {\n            vmSearch.setSearch(startStr + str.substr(0, i + 1));\n\n            if (++i >= str.length)\n            {\n                clearInterval(typeInterval);\n\n                this.isTyping = false;\n\n                if(cb) cb();\n            }\n        }.bind(this), charDelay);\n    },\n    createItemAfter: function(item, cb)\n    {\n        if (item)\n        {\n            this.setSelection(item, 0, item.getParsedText().length);\n        }\n        else\n        {\n            item = this.selectedItem || this.lastCreatedItem;\n        }\n\n        g.fireKeyEvent(undefined, { normCode: KeyCode.Enter });\n\n        this.clearSelection(function()\n        {\n            var newItem;\n\n            if (item.isHeader())\n            {\n                newItem = item.getChild(0);\n            }\n            else\n            {\n                newItem = item.parent().getChild(item.getIndex() + 1);\n            }\n\n            this.lastCreatedItem = newItem;\n            this.setSelection(newItem, 0, -1, cb);\n        }.bind(this));\n    },\n    clickElement: function(ele, cb)\n    {\n        g.Assert(ele, 'Requesting selection in an invalid element');\n\n        g.fireClickEvent(ele, Button.Left);\n\n        if(cb) cb();\n    },\n    zoomItem: function(item, cb)\n    {\n        g.vmMain.zoomin(item, false);\n\n        if(cb) cb();\n    },\n    openOutline: function(paneIndex, cb)\n    {\n        var pane = g.vmMain.panes()[paneIndex];\n        if(!pane.outlineVisible())\n        {\n            pane.toggleOutlineVisibility();\n        }\n        if(cb) cb();\n    },\n    closeOutline: function(paneIndex, cb)\n    {\n        var pane = g.vmMain.panes()[paneIndex];\n        if(pane.outlineVisible())\n        {\n            pane.toggleOutlineVisibility();\n        }\n        if(cb) cb();\n    },\n    openContextMenu: function(item, cb)\n    {\n        g.Assert(item, 'Requesting selection in an invalid item');\n\n        var box = item.getElement().getBoundingClientRect();\n\n        var left = box.left + 150;\n        var top = box.top + 10;\n\n        g.menus.openItemMenu(item, {x: left, y: top});\n\n        if(cb) cb();\n    },\n    closeContextMenu: function(cb)\n    {\n        g.menus.closeItemMenu();\n\n        if(cb) cb();\n    },\n    hoverMenuItem: function(ele, cb)\n    {\n        g.Assert(ele, 'Requesting selection in an invalid element');\n        g.Assert(!g.hasClass(ele, 'menuHover'), 'Dont apply hover twice to an element');\n\n        g.addClass(ele, 'menuHover');\n\n        if(cb) cb();\n    },\n    unhoverMenuItem: function(ele, cb)\n    {\n        g.Assert(ele, 'Requesting selection in an invalid element');\n        g.Assert(g.hasClass(ele, 'menuHover'), 'Cant unhover when not previously hovered');\n\n        g.removeClass(ele, 'menuHover');\n\n        if(cb) cb();\n    },\n    delay: function(ms, cb)\n    {\n        if(!cb)\n            return;\n        //g.Assert(cb, 'Must supply a callback to delay');\n\n        if (this.needsFinish)\n        {\n            if(cb) cb();\n        }\n        else\n        {\n            this.delayCb = cb;\n            this.delayTimeout = setTimeout(function()\n            {\n                this.delayCb = this.delayTimeout = undefined;\n                cb();\n            }.bind(this), ms);\n        }\n    },\n    setPaneModeAnim: function(paneID, mode, cb)\n    {\n        var button = document.getElementsByClassName('paneOptionsButton')[paneID];\n\n        this.clickElement(button);\n\n        this.delay(function ()\n        {\n            var menuName = ((mode === PaneMode.Timeline) ? 'paneTimelineView' : 'paneListView');\n            var menuItem = document.getElementsByClassName(menuName)[paneID];\n\n            this.hoverMenuItem(menuItem);\n\n            this.delay(function ()\n            {\n                this.clickElement(menuItem);\n                this.unhoverMenuItem(menuItem);\n\n                if(cb) cb();\n            }.bind(this), 800);\n        }.bind(this), 300);\n    },\n    setPaneModeInstant: function(paneID, mode, cb)\n    {\n        var pane = g.vmMain.panes()[paneID];\n\n        pane.mode(mode);\n\n        if(cb) cb();\n    },\n    addPane: function(mode, cb)\n    {\n        g.vmMain.addPaneToRight(mode);\n\n        if(cb) cb();\n    },\n    removePaneAnim: function(paneID, cb)\n    {\n        var button = document.getElementsByClassName('paneOptionsButton')[paneID];\n\n        this.clickElement(button);\n\n        this.delay(function ()\n        {\n            var menuItem = document.getElementsByClassName('paneClose')[paneID];\n\n            this.hoverMenuItem(menuItem);\n\n            this.delay(function ()\n            {\n                this.clickElement(menuItem);\n                this.unhoverMenuItem(menuItem);\n\n                if(cb) cb();\n            }.bind(this), 800);\n        }.bind(this), 300);\n    },\n    removePaneInstant: function(paneID, cb)\n    {\n        var pane = g.vmMain.panes()[paneID];\n\n        g.vmMain.removePane(pane);\n\n        if(cb) cb();\n    },\n    setSubtitle: function(text, time, cb)\n    {\n        var message = g.messageQueue.pushMessage({text: text, type: MessageType.Subtitle});\n        setTimeout(function ()\n        {\n            g.messageQueue.clearMessage(message);\n\n            if(cb) cb();\n        }.bind(this), time);\n    },\n\n    createScript: function (name, repeat)\n    {\n        var script =\n        {\n            owner: this,\n            _name: name,\n            index: 0,\n            isResetting: false,\n            _repeat: false,\n            noDelay: false,\n\n            runQueue: [ ],\n            resetQueue: [ ],\n\n            _activeQueue: function()\n            {\n                return this.isResetting ? this.resetQueue : this.runQueue;\n            },\n\n            queue: function(type, fnName)\n            {\n                var args = Array.prototype.slice.call(arguments, 2);\n\n                var arr = (type == ActionType.Run) ? this.runQueue : this.resetQueue;\n\n                arr.push({\n                    name: fnName,\n                    args: args\n                });\n\n                return arr;\n            },\n            repeat: function(val)\n            {\n                this._repeat = val;\n            },\n            reset: function()\n            {\n                this.index = 0;\n\n                for (var i = 0; i < this.resetQueue.length; i ++)\n                {\n                    var next = this.resetQueue[i];\n                    this.owner[next.name].apply(this.owner, next.args);\n                }\n            },\n            nextStep: function()\n            {\n                var queue = this.runQueue;\n\n                //g.Assert(this.index < queue.length);\n\n                return queue[this.index++];\n            },\n            getName: function()\n            {\n                return this._name;\n            }\n        };\n\n        return script;\n    },\n    reset: function ()\n    {\n        this.index = 0;\n\n        for (var i = 0; i < this._scriptQueue.length; i ++)\n        {\n            this._scriptQueue[i].reset();\n        }\n    },\n    run: function ()\n    {\n        if (this.isDisabled) { return; }\n\n        g.Assert(this.activeScript, 'Must have a script active to be running');\n\n        var next = this.activeScript.nextStep();\n\n        // If there is no next step of the active script, check to see if we should continue\n        // on to the next script in the queue.\n        if (!next)\n        {\n            this.index++;\n\n            // If the end of the queue has been reached, determine if we should repeat the scripts\n            // in the queue or if no repeat is necessary.\n            if (this.index >= this._scriptQueue.length)\n            {\n                // If no repeating is necessary, stop running scripts and notify that the script is complete.\n                if (!this.repeat)\n                {\n                    this.isRunning = false;\n\n                    if (this.onScriptDone)\n                    {\n                        this.onScriptDone();\n                    }\n\n                    return;\n                }\n\n                this.reset();\n            }\n\n            // Start the next script in the queue\n            this.activeScript = this._scriptQueue[this.index];\n            this.activeScript.reset();\n\n            this.onScriptStart(this.activeScript);\n\n            next = this.activeScript.nextStep();\n        }\n\n        var args = next.args;\n        args.push(this.run.bind(this));\n        args.push(this.activeScript);\n\n        this.isRunning = true;\n\n        setTimeout(function ()\n        {\n            try\n            {\n                this[next.name].apply(this, args);\n            }\n            catch (err)\n            {\n                g.reportError(err);\n\n                this.onDisable();\n            }\n        }.bind(this), 0);\n    },\n    onDisable: function ()\n    {\n        this.isDisabled = true;\n    },\n\n    /////// Script Functions ///////\n    demoIndent: function (id)\n    {\n        var s = this.createScript(id);\n\n        var item = d.itemsById['itemIndent'].model;\n\n        s.queue(ActionType.Run, 'delay', 2000);\n        s.queue(ActionType.Run, 'setSelection', item, 0, 0);\n        s.queue(ActionType.Run, 'indent', false);\n        s.queue(ActionType.Run, 'delay', 2000);\n        s.queue(ActionType.Run, 'setSelection', item, 0, 0);\n        s.queue(ActionType.Run, 'indent', true);\n\n        return s;\n    },\n    demoMain: function (id)\n    {\n        var s = this.createScript(id);\n\n        s.queue(ActionType.Run, 'delay', 500);\n        s.queue(ActionType.Reset, 'delay', 500);\n\n        return s;\n\n\n        var dateItem = d.itemsById['dateItem'].model;\n        var dateItem2 = d.itemsById['dateItem2'].model;\n        var contactItem = d.itemsById['contactItem'].model;\n\n        var s = this.createScript(id);\n\n        var date = ' @Fri 4pm';\n        var date2 = ' @Mon 6pm';\n        var name = ' @Jane Johnson';\n\n        //var listActions = [ ];\n        s.queue(ActionType.Run, 'delay', 2500);\n        s.queue(ActionType.Run, 'typeString', dateItem, date, 100);\n        s.queue(ActionType.Run, 'delay', 500);\n        s.queue(ActionType.Run, 'typeString', dateItem2, date2, 100);\n        s.queue(ActionType.Run, 'delay', 500);\n        // this.queue(listActions, 'openContextMenu', dateItem);\n        // this.queue(listActions, 'delay', 1000);\n        // this.queue(listActions, 'hoverMenuItem', document.getElementById('itemPriorityMed'));\n        // this.queue(listActions, 'delay', 1000);\n        s.queue(ActionType.Run, 'setPriority', dateItem, VMLIFlag.P1);\n        // s.queue(ActionType.Run, 'closeContextMenu');\n        s.queue(ActionType.Run, 'delay', 500);\n        s.queue(ActionType.Run, 'typeString', contactItem, name, 100);\n        s.queue(ActionType.Run, 'delay', 1000);\n        s.queue(ActionType.Run, 'clickElement', dateItem.getElement());\n        // s.queue(ActionType.Run, 'setSelectionSearch', 0);\n        s.queue(ActionType.Run, 'searchString', 'Movies', 100, true, 0);\n        s.queue(ActionType.Run, 'delay', 500);\n\n        // Reset\n        s.queue(ActionType.Reset, 'removeText', dateItem, date);\n        s.queue(ActionType.Reset, 'removeText', dateItem2, date2);\n        s.queue(ActionType.Reset, 'removeText', contactItem, name);\n        // this.queue(listActions, 'unhoverMenuItem', document.getElementById('itemPriorityMed'));\n        s.queue(ActionType.Reset, 'setPriority', dateItem, VMLIFlag.None);\n        s.queue(ActionType.Reset, 'resetSearch');\n        s.queue(ActionType.Reset, 'clearSelection');\n        //s.queue(ActionType.Reset, 'demoMain', phone, 0);\n\n        // var subtitleActions = [];\n        // this.queue(subtitleActions, 'setSubtitle', 'Organize any way you want.', 2000);\n        // this.queue(subtitleActions, 'setSubtitle', 'A date puts an item on your agenda.', 4000);\n        // this.queue(subtitleActions, 'setSubtitle', 'Set priorities to know what\\'s important.', 4000);\n        // this.queue(subtitleActions, 'setSubtitle', 'Adding a name lets you quickly contact someone.', 100);\n        // this.queue(subtitleActions, 'setSubtitle', 'Search lets you focus on anything.', 100);\n\n        //this.run(listActions);\n        // this.run(subtitleActions);\n\n        return s;\n    },\n    // demoFocus: function (id)\n    // {\n    //     var s = this.createScript(id);\n\n    //     s.queue(ActionType.Run, 'delay', 500);\n    //     s.queue(ActionType.Reset, 'delay', 500);\n\n    //     return s;\n    // },\n    demoSearch: function (id)\n    {\n        var s = this.createScript(id);\n        var time = 2000;\n\n        var item = d.itemsById['searchItem'].model;\n\n        s.queue(ActionType.Run, 'delay', time);\n        // Tag\n        s.queue(ActionType.Run, 'setSearch', '#tag', 0);\n        s.queue(ActionType.Run, 'delay', time);\n        // -\n        s.queue(ActionType.Run, 'resetSearch');\n        s.queue(ActionType.Run, 'delay', time);\n        // Pri 2\n        s.queue(ActionType.Run, 'setSearch', '!', 0);\n        s.queue(ActionType.Run, 'delay', time);\n        // Pri 0\n        s.queue(ActionType.Run, 'setSearch', '!!!', 0);\n        s.queue(ActionType.Run, 'delay', time);\n        // -\n        s.queue(ActionType.Run, 'resetSearch');\n        s.queue(ActionType.Run, 'delay', time);\n        // Flag\n        // s.queue(ActionType.Run, 'setSearch', \"''\", 0);\n        // s.queue(ActionType.Run, 'delay', time);\n        // // -\n        // s.queue(ActionType.Run, 'resetSearch');\n        // s.queue(ActionType.Run, 'delay', time);\n        // Focus\n        s.queue(ActionType.Run, 'zoomItem', item);\n        s.queue(ActionType.Run, 'delay', time);\n        // Focus + Tag\n        s.queue(ActionType.Run, 'setSearch', '#tag', 0);\n        s.queue(ActionType.Run, 'delay', time);\n        // -\n        s.queue(ActionType.Run, 'zoomItem', this.getRoot());\n        s.queue(ActionType.Run, 'resetSearch');\n        s.queue(ActionType.Run, 'delay', time);\n        // Contact\n        s.queue(ActionType.Run, 'setSearch', \"+Jane\", 0);\n        s.queue(ActionType.Run, 'delay', time);\n\n\n        s.queue(ActionType.Reset, 'resetSearch');\n\n        return s;\n    },\n    loadItemAndReset: function(name, s)\n    {\n        var item = d.itemsById[name].model;\n        var text;\n        if(!this.startText[name])\n        {\n            text = this.startText[name] = d.itemsById[name].data.text;\n        }\n        else\n        {\n            text = this.startText[name];\n        }\n        log('reset text = ', text);\n        s.queue(ActionType.Reset, 'setText', item, text);\n        s.queue(ActionType.Reset, 'setPriority', item, VMLIFlag.None);\n        s.queue(ActionType.Reset, 'setFlagged', item, false);\n        s.queue(ActionType.Reset, 'setComplete', item, false, undefined);\n        return item;\n\n    },\n    demoPrioritize: function (id, index)\n    {\n        var s = this.createScript(id);\n\n        var yard = this.loadItemAndReset('yard', s);\n        var roof = this.loadItemAndReset('roof', s);\n        var vacation = this.loadItemAndReset('vacation', s);\n        var chips = this.loadItemAndReset('chips', s);\n        var present = this.loadItemAndReset('present', s);\n        var shorts = this.loadItemAndReset('shorts', s);\n        var laptop = this.loadItemAndReset('laptop', s);\n        var app = this.loadItemAndReset('app', s);\n\n        if(index === 0) // Urgency\n        {\n            s.queue(ActionType.Run, 'appendText', yard, ' @later');\n            s.queue(ActionType.Run, 'appendText', roof, ' @soon');\n            s.queue(ActionType.Run, 'appendText', vacation, ' @later');\n            s.queue(ActionType.Run, 'appendText', chips, ' @now');\n            s.queue(ActionType.Run, 'appendText', present, ' @now');\n            s.queue(ActionType.Run, 'appendText', shorts, ' @later');\n            s.queue(ActionType.Run, 'appendText', laptop, ' @soon');\n            s.queue(ActionType.Run, 'appendText', app, ' @now');\n        }\n        else if(index === 1) // Date and time\n        {\n            s.queue(ActionType.Run, 'appendText', yard, ' @next friday');\n            s.queue(ActionType.Run, 'appendText', roof, ' @tomorrow');\n            s.queue(ActionType.Run, 'appendText', vacation, ' @' + Date.today().addDays(42).toString(\"M/dd\"));\n            s.queue(ActionType.Run, 'appendText', chips, ' @today 6pm');\n            s.queue(ActionType.Run, 'appendText', present, ' @today 3pm');\n            s.queue(ActionType.Run, 'appendText', shorts, ' @' + Date.today().addDays(4).toString(\"M/dd\"));\n            s.queue(ActionType.Run, 'appendText', laptop, ' @' + Date.today().addDays(3).toString(\"M/dd\"));\n            s.queue(ActionType.Run, 'appendText', app, ' @today ' + new Date().toString(\"h:mmtt\"));\n        }\n        else if(index === 2) // Priority\n        {\n            s.queue(ActionType.Run, 'setPriority', yard, VMLIFlag.P2);\n            s.queue(ActionType.Run, 'setPriority', roof, VMLIFlag.P1);\n            s.queue(ActionType.Run, 'setPriority', vacation, VMLIFlag.P2);\n            s.queue(ActionType.Run, 'setPriority', chips, VMLIFlag.P0);\n            s.queue(ActionType.Run, 'setPriority', present, VMLIFlag.P0);\n            s.queue(ActionType.Run, 'setPriority', shorts, VMLIFlag.P2);\n            s.queue(ActionType.Run, 'setPriority', laptop, VMLIFlag.P1);\n            s.queue(ActionType.Run, 'setPriority', app, VMLIFlag.P0);\n        }\n        else if(index === 3) // Flag\n        {\n            s.queue(ActionType.Run, 'setFlagged', chips, true);\n            s.queue(ActionType.Run, 'setFlagged', present, true);\n            s.queue(ActionType.Run, 'setFlagged', app, true);\n        }\n        else if(index === 4) // Completion\n        {\n            s.queue(ActionType.Run, 'setComplete', roof, true, new Date().addDays(-2));\n            s.queue(ActionType.Run, 'setComplete', chips, true, new Date().addMinutes(-10));\n            s.queue(ActionType.Run, 'setComplete', present, true, new Date().addMinutes(-10));\n            s.queue(ActionType.Run, 'setComplete', laptop, true, new Date().addDays(-11));\n            s.queue(ActionType.Run, 'setComplete', app, true, new Date());\n        }\n        else if(index === 5) // All together\n        {\n            s.queue(ActionType.Run, 'appendText', yard, ' @later');\n            s.queue(ActionType.Run, 'setPriority', roof, VMLIFlag.P1);\n            s.queue(ActionType.Run, 'appendText', vacation, ' @tomorrow');\n            s.queue(ActionType.Run, 'appendText', chips, ' @today 6pm');\n            s.queue(ActionType.Run, 'appendText', present, ' @today 3pm');\n            s.queue(ActionType.Run, 'setPriority', present, VMLIFlag.P0);\n            s.queue(ActionType.Run, 'setPriority', shorts, VMLIFlag.P2);\n            s.queue(ActionType.Run, 'setComplete', laptop, true, new Date().addDays(-1));\n            s.queue(ActionType.Run, 'setFlagged', app, true);\n            s.queue(ActionType.Run, 'appendText', app, ' @now');\n        }\n\n        return s;\n    },\n    demoFocus: function(id, index)\n    {\n        var s = this.createScript(id);\n\n        // s.queue(ActionType.Reset, 'resetSearch');\n\n        if(index === 0) // Tags\n        {\n            s.queue(ActionType.Run, 'setSearch', '#out', 1);\n        }\n        else if(index === 1) // Priority\n        {\n            s.queue(ActionType.Run, 'setSearch', '!', 1);\n            s.queue(ActionType.Run, 'delay', 2000);\n            s.queue(ActionType.Run, 'setSearch', '!!!', 1);\n        }\n        else if(index === 2) // Contact\n        {\n            s.queue(ActionType.Run, 'setSearch', '+Miller Harris', 1);\n        }\n        else if(index === 3) // Not\n        {\n            s.queue(ActionType.Run, 'setSearch', '-//', 1);\n        }\n        else if(index === 4) // Just Text\n        {\n            s.queue(ActionType.Run, 'setSearch', 'Japan', 1);\n        }\n        else if(index === 5) // All Together\n        {\n            s.queue(ActionType.Run, 'setSearch', '!', 1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'setSearch', '! todo', 1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'setSearch', '! todo ! app', 1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'setSearch', '! todo ! app -jap', 1);\n        }\n\n\n        return s;\n    },\n    demoPower: function (id, index)\n    {\n        var s = this.createScript(id);\n\n        // Hierarchy: Fills out \"Vacation Plan\" and \"Get groceries\"\n        // Dates: Add date to \"Pay rent\" and \"The Lego Movie\"\n        // Flag and priority: Set priority on \"Pay rent\", \"Groceries\",\n        //                    Flag \"Vacation plan\"\n        // Contacts: Add friends to \"Vacation plan\" and \"Honey Bear\" to \"Groceries\"\n        // Tags: Tag \"Get groceries\" and \"Shopping\"\n\n        // Hierarchy\n        if(index === 0)\n        {\n            var groceriesItem = d.itemsById['groceriesItem'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'createItemAfter', groceriesItem);\n            s.queue(ActionType.Run, 'indent', false);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Peaches', 60);\n            s.queue(ActionType.Run, 'createItemAfter', undefined);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Apples', 60);\n            s.queue(ActionType.Run, 'createItemAfter', undefined);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Almonds', 60);\n            var vacationItem = d.itemsById['vacationItem'].model;\n            s.queue(ActionType.Run, 'createItemAfter', vacationItem);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Hotels', 60);\n            s.queue(ActionType.Run, 'createItemAfter', undefined);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Cliff Cottage - $199 - View of beach', 30);\n            s.queue(ActionType.Run, 'createItemAfter', undefined);\n            s.queue(ActionType.Run, 'typeString', undefined, 'Beach Resort - $399 - On the beach', 30);\n            s.queue(ActionType.Run, 'delay', 500);\n\n            s.queue(ActionType.Reset, 'clearChildren', vacationItem);\n            s.queue(ActionType.Reset, 'clearChildren', groceriesItem);\n            s.queue(ActionType.Reset, 'removeText', vacationItem, ':');\n            s.queue(ActionType.Reset, 'removeText', groceriesItem, ':');\n        }\n        // Agenda\n        else if(index === 1)\n        {\n            var date = ' @Fri 4pm';\n            var date2 = ' @Tues 8pm';\n            var date3 = ' @Monday';\n            var movieItem = d.itemsById['movieItem'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'typeString', movieItem, date, 40);\n            var movieItem2 = d.itemsById['movieItem2'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'typeString', movieItem2, date2, 40);\n            var rentItem = d.itemsById['rentItem'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'typeString', rentItem, date3, 40);\n            s.queue(ActionType.Run, 'delay', 500);\n\n            s.queue(ActionType.Reset, 'removeText', movieItem, date);\n            s.queue(ActionType.Reset, 'removeText', movieItem2, date2);\n            s.queue(ActionType.Reset, 'removeText', rentItem, date3);\n\n\n            // var rentItem = d.itemsById['rentItem'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'hideAutoComplete');\n            s.queue(ActionType.Run, 'setPriority', rentItem, VMLIFlag.P1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            var groceriesItem = d.itemsById['groceriesItem'].model;\n            s.queue(ActionType.Run, 'setPriority', groceriesItem, VMLIFlag.P2);\n            s.queue(ActionType.Run, 'delay', 1000);\n            var laptopItem = d.itemsById['laptopItem'].model;\n            s.queue(ActionType.Run, 'setPriority', laptopItem, VMLIFlag.P0);\n            s.queue(ActionType.Run, 'delay', 1000);\n            var vacationItem = d.itemsById['vacationItem'].model;\n            s.queue(ActionType.Run, 'setFlagged', vacationItem, true);\n            s.queue(ActionType.Run, 'delay', 1000);\n\n            s.queue(ActionType.Reset, 'setPriority', rentItem, VMLIFlag.None);\n            s.queue(ActionType.Reset, 'setPriority', groceriesItem, VMLIFlag.None);\n            s.queue(ActionType.Reset, 'setFlagged', vacationItem, false);\n        }\n        // Contacts\n        else if(index === 2)\n        {\n            var name = ' +Jay';\n            var name2 = ' +Grant';\n            var name3 = ' +Honey Bear';\n            var movieItem = d.itemsById['movieItem'].model;\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'typeString', movieItem, name, 50);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'typeString', movieItem, name2, 50);\n            s.queue(ActionType.Run, 'delay', 1000);\n            var groceriesItem = d.itemsById['groceriesItem'].model;\n            s.queue(ActionType.Run, 'typeString', groceriesItem, name3, 50);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'hideAutoComplete');\n\n            s.queue(ActionType.Reset, 'removeText', movieItem, name);\n            s.queue(ActionType.Reset, 'removeText', movieItem, name2);\n            s.queue(ActionType.Reset, 'removeText', groceriesItem, name3);\n        }\n        // Focus\n        else if(index === 3)\n        {\n            var todoItem = d.itemsById['todoItem'].model;\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'delay', 500);\n\n            s.queue(ActionType.Run, 'openOutline', 0);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'zoomItem', todoItem);\n            s.queue(ActionType.Run, 'delay', 300);\n            s.queue(ActionType.Run, 'closeOutline', 0);\n            s.queue(ActionType.Run, 'delay', 2000);\n\n            s.queue(ActionType.Run, 'openOutline', 0);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'zoomItem', this.getRoot());\n            s.queue(ActionType.Run, 'delay', 300);\n            s.queue(ActionType.Run, 'closeOutline', 0);\n            s.queue(ActionType.Run, 'delay', 500);\n\n            s.queue(ActionType.Reset, 'zoomItem', this.getRoot());\n        }\n        else if(index === 4)\n        {\n            // Tags\n\n            // TODO: Ensure items have priority so they show up in search?\n            var tag = ' #out';\n            var groceriesItem = d.itemsById['groceriesItem'].model;\n            var groceriesItemText = groceriesItem.getRawText();\n            s.queue(ActionType.Run, 'delay', 500);\n            s.queue(ActionType.Run, 'resetSearch');\n            s.queue(ActionType.Run, 'typeString', groceriesItem, tag, 40);\n            s.queue(ActionType.Run, 'delay', 500);\n            var shoppingItem = d.itemsById['shoppingItem'].model;\n            var shoppingItemText = shoppingItem.getRawText();\n            s.queue(ActionType.Run, 'typeString', shoppingItem, tag, 40);\n            s.queue(ActionType.Run, 'delay', 1000);\n            // s.queue(ActionType.Run, 'setSelectionSearch', 0);\n            s.queue(ActionType.Run, 'searchString', '#out', 40, true, 0);\n            s.queue(ActionType.Run, 'delay', 1500);\n            s.queue(ActionType.Run, 'searchString', ' !', 40, false, 0);\n            s.queue(ActionType.Run, 'delay', 1500);\n            s.queue(ActionType.Run, 'searchString', ' -gro', 40, false, 0);\n            s.queue(ActionType.Run, 'scrollTo', 0, 0);\n            s.queue(ActionType.Run, 'delay', 1500);\n            s.queue(ActionType.Run, 'searchString', '!', 40, true, 1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'searchString', '!', 40, false, 1);\n            s.queue(ActionType.Run, 'delay', 1000);\n            s.queue(ActionType.Run, 'searchString', '!', 40, false, 1);\n\n\n            s.queue(ActionType.Reset, 'removeText', shoppingItem, tag);\n            s.queue(ActionType.Reset, 'removeText', groceriesItem, tag);\n            s.queue(ActionType.Reset, 'resetSearch');\n            s.queue(ActionType.Reset, 'scrollTo', 0, 30);\n        }\n\n        return s;\n    }\n};\n\nreturn AScript;\n});\n","asserts":[{"tag":1266,"offset":863},{"tag":1267,"offset":3952},{"tag":1268,"offset":4333},{"tag":1269,"offset":4911},{"tag":1270,"offset":5656},{"tag":1271,"offset":6932},{"tag":1272,"offset":7854},{"tag":1273,"offset":9650},{"tag":1274,"offset":9859},{"tag":1275,"offset":9932},{"tag":1276,"offset":10014},{"tag":1277,"offset":10087},{"tag":1278,"offset":11283},{"tag":1279,"offset":11365},{"tag":1280,"offset":11438},{"tag":1281,"offset":12831},{"tag":1282,"offset":13570},{"tag":1283,"offset":13998},{"tag":1284,"offset":14067},{"tag":1285,"offset":14269},{"tag":1286,"offset":14338},{"tag":1287,"offset":14573},{"tag":1288,"offset":18247},{"tag":1289,"offset":18741}]},"tracker":{"path":"F:/p/bce/Duchess/public/js/tracker.js","data":"define(['globals', 'platform', 'data', 'gdata', 'VMLI'],\nfunction (g, platform, d, gdata, VMLI) {\n    var self =\n    {\n        disabled: false, // Use to disable the event tracking functionality completely.\n        allowOfflineUndo: DEBUG, // Use to diable offline undo/redo.\n        cursor: -1, // Pointer to the current group that will be acted on.\n        groupID: 0, // Monotonically increasing ID counter.\n        groups: [],\n        externalUndoRedo: false,\n        undoRedoActive: false,\n        canRedo: false,\n        canUndo: false\n    };\n\n    // Insert Fields [Text]\n    //   ItemID\n    //   Position\n    //   Text\n\n    // Remove Fields [Text]\n    //   ItemID\n    //   Position\n    //   Text\n\n    // Create Fields [Item]\n    //   ItemID\n    //   Parent\n    //   Position\n    //   text (Currently Unused)\n\n    // Delete Fields [Item]\n    //   ItemID\n    //   Parent\n    //   Position\n\n    // Move Fields [Item]\n    //   ItemID\n    //   OldParent\n    //   OldPosition\n    //   NewParent\n    //   NewPosition\n\n    // Update Fields [Property]\n    //   ItemID\n    //   Field\n    //   NewValue\n    //   OldValue\n\n    // Format Fields [Property]\n    //   ItemID\n    //   FormatType\n    //   Position\n    //   Length\n\n    // Zoom Fields [Property]\n    //   ItemID\n    //   OldItemID\n    //   ZoomIn | ZoomOut\n    //   Time\n\n    // UIAction Fields [Action]\n    //   type\n    //   data\n\n    window.TrackerType =\n    {\n        Insert:   1,  // Text\n        Remove:   2,  // Text\n        SetText:  3,  // Text\n        Create:   4,  // Item\n        Delete:   5,  // Item\n        Move:     6,  // Item\n        Update:   7,  // Property\n        Format:   8,  // Property\n        Zoom:     9,  // Property\n        UIAction: 10, // Action\n        Misc:     11, // NOP\n    };\n\n    window.TrackerMisc =\n    {\n        ToggleOutline: 1,\n        RightClick:    2,\n        CloseMessage:  3,\n        ChangeDate:    4,\n        AddContact:    5,\n        DropItem:      6,\n        SyncContacts:  7,\n        OpenContact:   8,\n        // CallContact:   8,\n        // EmailContact:  9,\n        SearchChanged: 10,\n        ToggleSidebar: 11,\n        AddDocument:   12,\n        OpenDocument:  13,\n        OpenDocSharing:14,\n        Copy:          15,\n        Paste:         16,\n        OpenImport:    17,\n        OpenExport:    18,\n        UndoRedo:      19\n    };\n\n    window.TrackerUIAction =\n    {\n        AddPane:        1,\n        RemovePane:     2,\n        SwitchPaneMode: 3,\n    };\n\n    // window.FormatType =\n    // {\n    //     Bold:      1,\n    //     Italic:    2,\n    //     Underline: 3\n    // };\n\n    // The maximum number of groups to store at any given time. If the array of groups grows beyond this,\n    // then the oldest groups are evicted and their resources deleted.\n    var MaxGroups = 75;\n\n    function getNextGroupID ()\n    {\n        return self.groupID + 1;\n    }\n\n    function useNextGroupID ()\n    {\n        return ++self.groupID;\n    }\n\n    function getCurrentGroup ()\n    {\n        return self.groups[self.cursor];\n    }\n\n    function getCurrentAction ()\n    {\n        return self.groups[self.cursor].events[self.groups[self.cursor].events.length - 1];\n    }\n\n    // When items are deleted, they may still have their models sticking around as we may need\n    // to reuse their data. This function is responsible for actually deleting the in-memory\n    // models from the lookup table for groups/actions that we can't get back to.\n    function handleGroupTrimmed (group)\n    {\n        // TODO: Ensure that resources for potentially deleted models get free'd\n        for (var i = 0; i < group.events.length; ++i)\n        {\n            var action = group.events[i];\n\n            switch (action.type)\n            {\n                case TrackerType.Insert:\n                    break;\n                case TrackerType.Remove:\n                    break;\n                case TrackerType.Create:\n                    break;\n                case TrackerType.Delete:\n                    break;\n                case TrackerType.Move:\n                    break;\n                case TrackerType.Update:\n                    break;\n                case TrackerType.Format:\n                    break;\n                case TrackerType.Zoom:\n                    break;\n                case TrackerType.UIAction:\n                    break;\n                default:\n                    g.Assert(false, \"Expected TrackerType, received: \", type);\n                    break;\n            }\n        }\n    }\n\n    // Pushes a new group into the queue. Additionally, if the queue grows out of bounds, it will trim off\n    // the actions furthest in the past.\n    function pushGroup ()\n    {\n        var id = useNextGroupID();\n\n        //console.log('Tracker Pushing New Group: ', id);\n\n        self.groups.push({\n            'id': id,\n            'events': [],\n            'persisted': false\n        });\n\n        if (self.cursor < (MaxGroups - 1))\n        {\n            self.cursor++;\n        }\n\n        if (self.groups.length > MaxGroups)\n        {\n            handleGroupTrimmed(self.groups.shift());\n        }\n\n        return id;\n    }\n\n    // Function responsible for actually performing an action by pushing the action into the current group. This\n    // will only happen when the incoming action could not be merged with the previous action.\n    function doAction (type, data)\n    {\n        //console.log('Tracker Action Added: ', type, data);\n\n        var group = getCurrentGroup();\n        g.Assert(group, \"Expected group to exist\");\n\n        var action = { 'type': type, 'data': data };\n\n        switch (type)\n        {\n            case TrackerType.Insert:\n                action['cb'] = { 'undo': undoInsert, 'redo': redoInsert };\n                break;\n            case TrackerType.Remove:\n                action['cb'] = { 'undo': undoRemove, 'redo': redoRemove };\n                break;\n            case TrackerType.Create:\n                action['cb'] = { 'undo': undoCreate, 'redo': redoCreate };\n                break;\n            case TrackerType.Delete:\n                action['cb'] = { 'undo': undoDelete, 'redo': redoDelete };\n                break;\n            case TrackerType.Move:\n                action['cb'] = { 'undo': undoMove, 'redo': redoMove };\n                break;\n            case TrackerType.Update:\n                action['cb'] = { 'undo': undoUpdate, 'redo': redoUpdate };\n                break;\n            case TrackerType.Format:\n                action['cb'] = { 'undo': undoFormat, 'redo': redoFormat };\n                break;\n            case TrackerType.Zoom:\n                action['cb'] = { 'undo': undoZoom, 'redo': redoZoom };\n                break;\n            case TrackerType.UIAction:\n                action['cb'] = { 'undo': undoUIAction, 'redo': redoUIAction };\n                break;\n            default:\n                g.Assert(false, \"Expected TrackerType, received: \", type);\n                break;\n        }\n\n        group.events.push(action);\n    }\n\n    // When receiving updates from the server, actions will need to account for the incoming updates. Since\n    // the updates are just actions performed by another client, the current actions in the queue should be\n    // updated. This is currently not implemented as we do not receive realtime updates form the server.\n    function doExternalAction (type, data)\n    {\n\n    }\n\n    // Function to actually merge a new action with the most recently grouped action. The result\n    // is that no new action will be added to the group, instead the data of the two actions will\n    // be aggregated in a single action.\n    function mergeAction (type, data)\n    {\n        log('Tracker Action Merged: ', type, data);\n\n        var action = getCurrentAction();\n        g.Assert(action, \"Expected action to exist\");\n\n        switch (type)\n        {\n            case TrackerType.Insert:\n                break;\n            case TrackerType.Remove:\n                break;\n            case TrackerType.Create:\n                break;\n            case TrackerType.Delete:\n                break;\n            case TrackerType.Move:\n                break;\n            case TrackerType.Update:\n                break;\n            case TrackerType.Format:\n                g.Assert(false, 'Formats cannot be merged');\n                break;\n            case TrackerType.Zoom:\n                g.Assert(false, 'Zooms cannot be merged');\n                break;\n            case TrackerType.UIAction:\n                g.Assert(false, 'UIActions cannot be merged');\n                break;\n            default:\n                g.Assert(false, \"Expected TrackerType, received: \", type);\n                break;\n        }\n    }\n\n\n    // Determine if an action type can be merged into the last performed action in\n    // the current group. You cannot merge across groups.\n    function canMerge (type)\n    {\n        var shouldMerge = false;\n\n        var group = getCurrentGroup();\n\n        if (group && group.events.length > 0)\n        {\n            // Currently the only supported merged action is text insertion\n            if (group.events[group.events.length - 1].type === type)\n            {\n                if (type === TrackerType.Insert)\n                {\n                    shouldMerge = true;\n                }\n            }\n            else\n            {\n                shouldMerge = false;\n            }\n        }\n\n        return shouldMerge;\n    }\n\n    // Determine if the given action type can be added to the current group, or if a new\n    // group needs to be added for the action.\n    function canCombine (type, groupID)\n    {\n        var group = getCurrentGroup();\n\n        return group && (group.id === groupID || group.events.length === 0);\n    }\n\n    //\n    // Undo/Redo Callbacks\n    //\n\n    // Insert Fields [Text]\n    //   ItemID\n    //   Position\n    //   Text\n    function undoInsert (data)\n    {\n        //console.log('Undo [Insert]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var model = d.getModel(entry.itemID);\n            g.Assert(model, \"Expected model to exist: \", entry);\n\n            var oldText = model.getParsedText();\n\n            var startIndex = 0;\n            if (oldText[0] == '\\uFEFF')\n            {\n                startIndex = 1;\n            }\n\n            var newText = oldText.slice(startIndex, entry.position) + oldText.slice(entry.position + entry.text.length);\n\n            model.setText(newText, /*setImmediate*/true);\n\n            g.selectChildren(model, entry.position, 0);\n        }\n    }\n\n    function redoInsert (data)\n    {\n        //console.log('Redo [Insert]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var model = d.getModel(entry.itemID);\n            g.Assert(model, \"Expected model to exist: \", entry);\n\n            var oldText = model.getParsedText();\n\n            var newText = oldText.slice(0, entry.position) + entry.text + oldText.slice(entry.position);\n\n            if (newText.length === 0)\n            {\n                newText = '\\uFEFF';\n            }\n\n            model.setText(newText, /*setImmediate*/true);\n\n            g.selectChildren(model, entry.position, entry.text.length);\n        }\n    }\n\n    // Remove Fields [Text]\n    //   ItemID\n    //   Position\n    //   Text\n    function undoRemove (data)\n    {\n        //console.log('Undo [Remove]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var model = d.getModel(entry.itemID);\n            g.Assert(model, \"Expected model to exist: \", entry);\n\n            var oldText = model.getParsedText();\n\n            var startIndex = 0;\n            if (oldText[0] == '\\uFEFF')\n            {\n                startIndex = 1;\n            }\n\n            var newText = oldText.slice(startIndex, entry.position) + entry.text + oldText.slice(entry.position);\n\n            model.setText(newText, /*setImmediate*/true);\n\n            g.selectChildren(model, entry.position, entry.text.length);\n        }\n    }\n\n    function redoRemove (data)\n    {\n        //console.log('Redo [Remove]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var model = d.getModel(entry.itemID);\n            g.Assert(model, \"Expected model to exist: \", entry);\n\n            var oldText = model.getParsedText();\n\n            var newText = oldText.slice(0, entry.position) + oldText.slice(entry.position + entry.text.length);\n\n            if (newText.length === 0)\n            {\n                newText = '\\uFEFF';\n            }\n\n            model.setText(newText, /*setImmediate*/true);\n\n            g.selectChildren(model, entry.position, 0);\n        }\n    }\n\n    // Create Fields [Item]\n    //   ItemID\n    //   Parent\n    //   Position\n    //   Text\n    function undoCreate (data)\n    {\n        //console.log('Undo [Create]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var parentModel = d.getModel(entry.parent);\n            g.Assert(parentModel, \"Expected model to exist: \", entry);\n\n            var removedChild = parentModel.removeChildAtIndex(entry.position);\n            g.Assert(removedChild.id === entry.itemID, \"Expected data to match removed child: \", removedChild, entry);\n\n            removedChild.parent(undefined);\n\n            d.deleteItem(removedChild);\n\n            var selectionChild = parentModel;\n            if (entry.position > 0)\n            {\n                selectionChild = parentModel.getChild(entry.position - 1);\n            }\n\n            g.selectChildren(selectionChild, selectionChild.getParsedText().length, 0);\n\n            parentModel.save({ 'items': parentModel.getItemsArrayForSave() }, SaveFlag.None);\n        }\n    }\n\n    function redoCreate (data)\n    {\n        //console.log('Redo [Create]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var parentModel = d.getModel(entry.parent);\n            g.Assert(parentModel, \"Expected parent model to exist: \", entry);\n\n            var newChild = d.getModel(entry.itemID);\n            g.Assert(newChild, \"Expected child model to exist: \", entry);\n            //g.Assert(newChild.parent() === parentModel, \"Child has mismatching parent\", newChild, parentModel);\n\n            d.undeleteItem(newChild);\n\n            parentModel.items.splice(entry.position, 0, newChild);\n            newChild.parent(parentModel);\n\n            g.selectChildren(newChild, 0, 0);\n\n            parentModel.save({ 'items': parentModel.getItemsArrayForSave() }, SaveFlag.None);\n        }\n\n        // TODO: What to do if the model has been vacated from the local cache?\n    }\n\n    // Delete Fields [Item]\n    //   ItemID\n    //   Parent\n    //   Position\n    function undoDelete (data)\n    {\n        //console.log('Undo [Delete]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var parentModel = d.getModel(entry.parent);\n            g.Assert(parentModel, \"Expected model to exist: \", entry);\n\n            var childModel = d.getModel(entry.itemID);\n            g.Assert(childModel, \"Expected model to exist: \", entry);\n            //g.Assert(childModel.parent() === parentModel, \"Child has mismatching parent\", childModel, parentModel);\n\n            d.undeleteItem(childModel);\n\n            parentModel.items.splice(entry.position, 0, childModel);\n            childModel.parent(parentModel);\n\n            g.selectChildren(childModel, 0, 0);\n\n            parentModel.save({ 'items': parentModel.getItemsArrayForSave() }, SaveFlag.None);\n        }\n\n        // TODO: What to do if the model has been vacated from the local cache?\n    }\n\n    function redoDelete (data)\n    {\n        //console.log('Redo [Delete]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var parentModel = d.getModel(entry.parent);\n            g.Assert(parentModel, \"Expected model to exist: \", entry);\n\n            var removedChild = parentModel.removeChildAtIndex(entry.position);\n            g.Assert(removedChild.id === entry.itemID, \"Expected data to match removed child: \", removedChild, entry);\n\n            removedChild.parent(undefined);\n\n            d.deleteItem(removedChild);\n\n            var selectionChild = parentModel;\n            if (entry.position > 0)\n            {\n                selectionChild = parentModel.getChild(entry.position - 1);\n            }\n\n            g.selectChildren(selectionChild, selectionChild.getParsedText().length, 0);\n\n            parentModel.save({ 'items': parentModel.getItemsArrayForSave() }, SaveFlag.None);\n        }\n    }\n\n    // Move Fields [Item]\n    //   ItemID\n    //   OldParent\n    //   OldPosition\n    //   NewParent\n    //   NewPosition\n    function undoMove (data)\n    {\n        //console.log('Undo [Move]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var oldParent = d.getModel(entry.oldParent);\n            g.Assert(oldParent, \"Expected oldParent model to exist: \", entry);\n\n            var newParent = d.getModel(entry.newParent);\n            g.Assert(newParent, \"Expected newParent model to exist: \", entry);\n\n            var child = newParent.removeChildAtIndex(entry.newPosition);\n            g.Assert(child.id === entry.itemID, \"Expected data to match child: \", child, entry);\n\n            child.parent(oldParent);\n            oldParent.items.splice(entry.oldPosition, 0, child);\n\n            g.selectChildren(child, 0, 0);\n\n            newParent.save({ 'items': newParent.getItemsArrayForSave() }, SaveFlag.None);\n            oldParent.save({ 'items': oldParent.getItemsArrayForSave() }, SaveFlag.None);\n        }\n\n        // TODO: Ensure that parent models persist/exist properly\n    }\n\n    function redoMove (data)\n    {\n        //console.log('Redo [Move]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var oldParent = d.getModel(entry.oldParent);\n            g.Assert(oldParent, \"Expected oldParent model to exist: \", entry);\n\n            var newParent = d.getModel(entry.newParent);\n            g.Assert(newParent, \"Expected newParent model to exist: \", entry);\n\n            var child = oldParent.removeChildAtIndex(entry.oldPosition);\n            g.Assert(child.id === entry.itemID);\n\n            child.parent(newParent);\n            newParent.items.splice(entry.newPosition, 0, child);\n\n            g.selectChildren(child, 0, 0);\n\n            newParent.save({ 'items': newParent.getItemsArrayForSave() }, SaveFlag.None);\n            oldParent.save({ 'items': oldParent.getItemsArrayForSave() }, SaveFlag.None);\n        }\n\n        // TODO: Ensure that parent models persist/exist properly\n    }\n\n    // Update Fields [Property]\n    //   ItemID\n    //   Field\n    //   NewValue\n    //   OldValue\n    function undoUpdate (data)\n    {\n        //console.log('Undo [Update]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var item = d.getModel(entry.itemID);\n            g.Assert(item, \"Expected model to exist: \", entry);\n\n            g.Assert(item[entry.field], \"Expected field to exist: \", entry);\n            item[entry.field](entry.oldValue);\n        }\n\n        // TODO: Support non-observable propeties?\n    }\n\n    function redoUpdate (data)\n    {\n        //console.log('Redo [Update]: ', data);\n\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var item = d.getModel(entry.itemID);\n            g.Assert(item, \"Expected model to exist: \", entry);\n\n            g.Assert(item[entry.field], \"Expected field to exist: \", entry);\n            item[entry.field](entry.newValue);\n        }\n\n        // TODO: Support non-observable properties?\n    }\n\n    // Format Fields [Property]\n    //   ItemID\n    //   FormatType\n    //   Position\n    //   Length\n    function undoFormat (data)\n    {\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var item = d.getModel(entry.itemID);\n            g.Assert(item, \"Expected model to exist: \", entry);\n\n            // TODO: finish implementation\n        }\n    }\n\n    function redoFormat (data)\n    {\n        for (var i = 0; i < data.length; ++i)\n        {\n            var entry = data[i];\n\n            var item = d.getModel(entry.itemID);\n            g.Assert(item, \"Expected model to exist: \", entry);\n\n            // TODO: finish implementation\n        }\n    }\n\n    // Zoom Fields [Property]\n    //   ItemID\n    //   OldItemID\n    //   ZoomIn | ZoomOut\n    //   Time\n    function undoZoom (data)\n    {\n        //console.log('Undo [Zoom]: ', data);\n\n        var entry = data[0];\n\n        var oldItem = d.getModel(entry.oldItemID);\n        g.Assert(oldItem, \"Expected model to exist: \", entry);\n\n        if (entry.zoomIn)\n        {\n            oldItem.zoomOut(entry.time);\n        }\n        else if (entry.zoomOut)\n        {\n            oldItem.zoomin({ 'time': entry.time });\n        }\n        else\n        {\n            g.Assert(false, \"Zoom action must define either zoomIn or zoomOut\");\n        }\n    }\n\n    function redoZoom (data)\n    {\n        //console.log('Redo [Zoom]: ', data);\n\n        var entry = data[0];\n\n        var item = d.getModel(entry.itemID);\n        g.Assert(item, \"Expected model to exist: \", entry);\n\n        if (entry.zoomIn)\n        {\n            item.zoomin({ 'time': entry.time });\n        }\n        else if (entry.zoomOut)\n        {\n            item.zoomOut(entry.time);\n        }\n        else\n        {\n            g.Assert(false, \"Zoom action must define either zoomIn or zoomOut\");\n        }\n    }\n\n    function undoUIAction (data)\n    {\n        var entry = data[0];\n\n        switch (entry.type)\n        {\n            case TrackerUIAction.RemovePane:\n                break;\n            case TrackerUIAction.SwitchPaneMode:\n                break;\n            default:\n                g.Assert(false, 'Invalid UIAction');\n                break;\n        }\n    }\n\n    function redoUIAction (data)\n    {\n\n    }\n\n\n    //\n    // External Functions\n    //\n\n    // Add a list of actions to the front of the queue. This function is responsible for determining the best\n    // way to add the given list of actions. This means that it may combine the incoming actions into pre-existing\n    // groups, or may merge two actions together.\n    var performingActions = false;\n    self.performActions = function (actions)\n    {\n        g.Assert(!self.disabled || g.intro);\n        g.Assert(!performingActions);\n\n        performingActions = true;\n\n        if (actions && actions.length > 0)\n        {\n            if (!self.disabled)\n            {\n                var groupID = undefined;\n                if (self.cursor != self.groups.length - 1)\n                {\n                    self.groups.splice(self.cursor + 1, self.groups.length - (self.cursor + 1));\n                    groupID = pushGroup();\n                }\n                else\n                {\n                    groupID = getNextGroupID();\n                }\n            }\n\n            for (var i = 0; i < actions.length; ++i)\n            {\n                var action = actions[i];\n\n                if (g.intro)\n                {\n                    g.intro.onAction(action);\n                }\n\n                if (!self.disabled)\n                {\n                    if (!canCombine(action.type, groupID))\n                    {\n                        groupID = pushGroup();\n\n                        doAction(action.type, action.data);\n                    }\n                    else if (canMerge(action.type))\n                    {\n                        mergeAction(action.type, action.data);\n                    }\n                    else\n                    {\n                        doAction(action.type, action.data);\n                    }\n                }\n            }\n        }\n\n        performingActions = false;\n    };\n\n    //\n    // Helper functions to make it easy to turn a single user-action into a list of internal actions. For example,\n    // pressing the delete key may cause an item to be deleted and children reparented. This requries mutliple\n    // internal actions to represent.\n    //\n    var currentAction = [ ];\n\n    var aggregateActions = 0;\n    self.beginAction = function ()\n    {\n        g.Assert(!performingActions);\n\n        if (aggregateActions === 0)\n        {\n            gdata.beginAction();\n\n            g.Assert(currentAction.length === 0, 'Current actions should always be empty when starting a new action');\n        }\n        else\n        {\n            if (DEBUG) log('  -- Beginning Nested Action --');\n        }\n\n        aggregateActions++;\n    };\n\n    function isActionFromLoad()\n    {\n        return !g.vmMain.isLoaded || g.isLoadingRemote;\n    }\n\n    self.performAction = function (type, data)\n    {\n        g.Assert(!performingActions);\n\n        var isFromLoad = isActionFromLoad();\n\n        if (!self.disabled)\n        {\n            if (DEBUG) log('Performing Action: ', type, data);\n\n            if (aggregateActions)\n            {\n                currentAction.push({ 'type': type, 'data': [data] });\n            }\n            else\n            {\n                self.performActions([{ 'type': type, 'data': [data] }]);\n            }\n        }\n        else if (g.intro)\n        {\n            if (!isFromLoad)\n            {\n                if (DEBUG) log('Performing Action For Intro: ', type, data);\n\n                self.performActions([{ 'type': type, 'data': [data] }]);\n            }\n            else\n            {\n                if (DEBUG) log('Skipping Action For Intro: ', type, data);\n            }\n        }\n        else\n        {\n            if (DEBUG) log('Performing Disabled Action: ', type, data);\n        }\n    };\n\n    self.endAction = function ()\n    {\n        g.Assert(!performingActions);\n        g.Assert(aggregateActions !== 0, 'Must have called beginAction before calling endAction');\n\n        // If this is the last nested called to aggregateActions, then perform the coalesced actions.\n        if (aggregateActions === 1)\n        {\n            if (!self.disabled || g.intro)\n            {\n                self.performActions(currentAction);\n            }\n\n            currentAction.length = 0;\n\n            gdata.endAction();\n        }\n        else\n        {\n            if (DEBUG) log('  -- Ending Nested Action --');\n        }\n\n        aggregateActions--;\n    };\n\n    // Used to process the state that was updated as a result of an undo/redo action to set\n    // the selection cursor properly.\n    var externalStateChanged = [ ];\n    function processStateChangedSelection(stateChanged)\n    {\n        g.Assert(!self.undoRedoActive);\n\n        var finalModel = undefined;\n        var finalPosition = 0;\n        var finalLength = 0;\n\n        for (var i = 0; i < stateChanged.length; ++i)\n        {\n            var entry = stateChanged[i];\n            var data = entry.data;\n\n            var model = d.getModel(data.itemID);\n            g.Assert(model, \"Expected model to exist: \", data);\n\n            switch (entry.type)\n            {\n                case TrackerType.Insert:\n                    finalModel = model;\n                    finalPosition = data.position;\n                    finalLength = data.text.length;\n\n                    break;\n                case TrackerType.Remove:\n                    finalModel = model;\n                    finalPosition = data.position;\n                    finalLength = 0;\n\n                    break;\n                case TrackerType.SetText:\n                    if (!model.deleteTimeout)\n                    {\n                        finalModel = model;\n                        finalPosition = data.position;\n                        finalLength = 0; // TODO: Can do better than this, can detect if insert/delete based on string length\n                    }\n\n                    break;\n                case TrackerType.Create:\n                    finalModel = model;\n                    finalPosition = 0;\n                    finalLength = 0;\n\n                    break;\n                case TrackerType.Delete:\n                    {\n                        var selectionChild = d.getModel(data.previous);\n\n                        finalModel = selectionChild;\n                        finalPosition = selectionChild.getParsedText().length;\n                        finalLength = 0;\n                    }\n                    break;\n                default:\n                    // Do Nothing\n                    break;\n            }\n        }\n\n        if (finalModel)\n        {\n            g.selectChildren(finalModel, finalPosition, finalLength);\n\n            g.scrollIntoView(finalModel.getSpan(), 200);\n        }\n\n        externalStateChanged = [ ];\n    }\n\n    // Used to externally keep\n    self.notifyStateChangedFromUndoRedo = function (type, data)\n    {\n        g.Assert(self.undoRedoActive);\n\n        if (DEBUG) log('Tracker notified of state change: ', data);\n\n        externalStateChanged.push({'type': type, 'data': data});\n    };\n\n    // ctrl+z\n    self.undoAction = function ()\n    {\n        if (!g.vmMain.isOnline() && !self.allowOfflineUndo)\n        {\n            g.messageQueue.pushMessage(MessageID.OfflineUndo);\n        }\n\n        self.undoRedoActive = true;\n\n        //console.log('Undo Requested', self.groups);\n        g.Assert(!performingActions);\n\n        // var useRemoteRedo = self.disabled && self.canUndo;\n\n        // if (useRemoteRedo)\n        // {\n        //     //gdata.beginAction();\n        // }\n\n        if (!self.disabled && self.allowOfflineUndo)\n        {\n            if (self.cursor >= 0)\n            {\n                var group = self.groups[self.cursor--];\n\n                for (var i = group.events.length - 1; i >= 0; i--)\n                {\n                    var action = group.events[i];\n\n                    action.cb.undo(action.data);\n                }\n            }\n        }\n        else if (self.canUndo)\n        {\n            g.Assert(self.externalUndoRedo);\n\n            gdata.undoAction();\n        }\n\n        self.undoRedoActive = false;\n\n        // if (useRemoteRedo)\n        // {\n        //     //gdata.endAction();\n        // }\n\n        processStateChangedSelection(externalStateChanged);\n\n        self.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.UndoRedo,\n            data: [\n            {\n                undo: true\n            }]\n        });\n    };\n\n    // ctrl+y\n    self.redoAction = function ()\n    {\n        if (!g.vmMain.isOnline() && !self.allowOfflineUndo)\n        {\n            g.messageQueue.pushMessage(MessageID.OfflineUndo);\n        }\n\n        self.undoRedoActive = true;\n\n        //console.log('Redo Requested', self.groups);\n        g.Assert(!performingActions);\n\n        // var useRemoteRedo = self.disabled && self.canRedo;\n\n        // if (useRemoteRedo)\n        // {\n        //     //gdata.beginAction();\n        // }\n\n        if (!self.disabled && self.allowOfflineUndo)\n        {\n            if (self.cursor >= -1 && self.cursor < self.groups.length - 1)\n            {\n                var group = self.groups[++self.cursor];\n\n                for (var i = 0; i < group.events.length; ++i)\n                {\n                    var action = group.events[i];\n\n                    action.cb.redo(action.data);\n                }\n            }\n        }\n        else if (self.canRedo)\n        {\n            g.Assert(self.externalUndoRedo);\n\n            gdata.redoAction();\n        }\n\n        self.undoRedoActive = false;\n\n        // if (useRemoteRedo)\n        // {\n        //     //gdata.endAction();\n        // }\n\n        processStateChangedSelection(externalStateChanged);\n\n        self.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.UndoRedo,\n            data: [\n            {\n                redo: true\n            }]\n        });\n    };\n\n    self.miscAction = function (e)\n    {\n        if (g.intro)\n        {\n            g.intro.onAction(e);\n        }\n    };\n\n    self.resetState = function()\n    {\n        performingActions = false;\n        externalStateChanged = [ ];\n        currentAction = [ ];\n\n        self.undoRedoActive = false;\n        self.cursor = -1;\n        self.groupID = 0;\n        self.groups = [ ];\n    };\n\n    // if (DEBUG)\n    // {\n    //     self.printState = function()\n    //     {\n    //         if (!self.disabled && self.allowOfflineUndo)\n    //         {\n    //             for (var i = 0; i < cursor; ++i)\n    //             {\n    //                 var group = self.groups[i];\n\n    //                 for (var j = group.events.length - 1; j >= 0; --j)\n    //                 {\n    //                     var action = group.events[j];\n\n\n    //                 }\n    //             }\n    //         }\n    //     };\n    // }\n\n    function getOrderedGroups()\n    {\n        return self.groups.slice(self.cursor).concat(self.groups.slice(0, self.cursor));\n    }\n\n    self.stringifyGroups = function()\n    {\n        var groups = getOrderedGroups();\n\n        return 'Tracker: ' + groups.length;\n    };\n\n    // Receive notifications from an external source that it will handle undo/redo state.\n    // TODO: Support external source going offline and falling back to using tracker handling\n    self.stateChangeForUndoRedo = function (event)\n    {\n        self.externalUndoRedo = true;\n        self.disabled = true;\n\n        self.canRedo = event.canRedo;\n        self.canUndo = event.canUndo;\n    };\n\n    function updateExternalID(oldID, newID)\n    {\n        Assert(false, 'This should never be called');\n    }\n\n    gdata.registerForUndoRedoStateChange(self);\n\n    return self;\n});\n","asserts":[{"tag":1182,"offset":4373},{"tag":1183,"offset":5477},{"tag":1184,"offset":6854},{"tag":1185,"offset":7749},{"tag":1186,"offset":8239},{"tag":1187,"offset":8358},{"tag":1188,"offset":8479},{"tag":1189,"offset":8586},{"tag":1190,"offset":10080},{"tag":1191,"offset":10809},{"tag":1192,"offset":11584},{"tag":1193,"offset":12322},{"tag":1194,"offset":13110},{"tag":1195,"offset":13261},{"tag":1196,"offset":14085},{"tag":1197,"offset":14217},{"tag":1198,"offset":14293},{"tag":1199,"offset":15104},{"tag":1200,"offset":15231},{"tag":1201,"offset":15303},{"tag":1202,"offset":16048},{"tag":1203,"offset":16199},{"tag":1204,"offset":17142},{"tag":1205,"offset":17279},{"tag":1206,"offset":17432},{"tag":1207,"offset":18170},{"tag":1208,"offset":18307},{"tag":1209,"offset":18460},{"tag":1210,"offset":19245},{"tag":1211,"offset":19310},{"tag":1212,"offset":19728},{"tag":1213,"offset":19793},{"tag":1214,"offset":20265},{"tag":1215,"offset":20566},{"tag":1216,"offset":20955},{"tag":1217,"offset":21237},{"tag":1218,"offset":21488},{"tag":1219,"offset":21761},{"tag":1220,"offset":22131},{"tag":1221,"offset":22666},{"tag":1222,"offset":22711},{"tag":1223,"offset":24519},{"tag":1224,"offset":24642},{"tag":1225,"offset":25054},{"tag":1226,"offset":26027},{"tag":1227,"offset":26065},{"tag":1228,"offset":26875},{"tag":1229,"offset":27207},{"tag":1230,"offset":29079},{"tag":1231,"offset":29550},{"tag":1232,"offset":30187},{"tag":1233,"offset":30951},{"tag":1234,"offset":31624}]},"VMLI":{"path":"F:/p/bce/Duchess/public/js/VMLI.js","data":"'use strict';\r\ndefine(['ko', 'globals', 'platform', 'data', 'gdata', 'VMLI_TapHandlers', 'VMLI_Text', 'VMLI_Drive', 'tracker', 'sounds'],\r\nfunction (ko, g, platform, d, gdata, VMLI_TapHandlers, VMLI_Text, VMLI_Drive, tracker, sounds) {\r\n\r\nwindow.__TOTAL_ITEMS = 0;\r\nwindow.__TOTAL_ARCHIVED_ITEMS = 0;\r\n\r\nwindow.__TOTAL_ARCHIVE_PARENTS = 0;\r\n\r\nfunction VMLI(p, extraInfo)\r\n{\r\n    //\r\n    // Before creating a new VMLI, see if we already have one loaded for the given ID. This may\r\n    // happen in scenarios where remote items are added/removed or we are simply being lazy about\r\n    // recreating items.\r\n    //\r\n    if (!p.id && p.data && p.data.id)\r\n    {\r\n        p.id = p.data.id;\r\n    }\r\n    else\r\n    {\r\n        if (p.id && p.data)\r\n        {\r\n            g.Assert(p.id == p.data.id, 'If passing in a local id and a remote ID, they should match');\r\n        }\r\n    }\r\n\r\n    if (p.id && d.getModel[p.id])\r\n    {\r\n        if (ShouldLog(LogLevels.Warning)) log('Attempting to create an already created VMLI: ', p.id);\r\n\r\n        g.Assert(false, \"Should not be constructing a VMLI here\");\r\n\r\n        return d.getModel[p.id];\r\n    }\r\n\r\n    g.Assert(p.v === undefined, 'We should never be passing in \\'v\\'');\r\n    g.Assert(p.extern === undefined, 'We should never be passing in \\'extern\\'');\r\n\r\n    this._parent = (extraInfo ? extraInfo.parent : undefined);\r\n    //this.formats = p.formats || []; // TODO: Default to undefined\r\n    this._rawText = (!p.data ? p.text : '');\r\n    this._searchText = (!p.data ? (p.text ? p.text.toLowerCase() : '') : '');\r\n    this._parsedText = undefined;\r\n    this._styledText = ko.observable('');\r\n    this._isArchived = p.isArchived || false; // TODO: Propagate archived value from parent down\r\n    this.items = ko.observableArray();\r\n    this._archivedItems = undefined;\r\n    this._date = ko.observable(undefined);\r\n\r\n    var origFlags = VMLIFlag.None;\r\n    if (p.isCollapsed)\r\n    {\r\n        origFlags |= VMLIFlag.Collapsed;\r\n    }\r\n\r\n    if(p.isComplete)\r\n    {\r\n        origFlags |= VMLIFlag.Complete;\r\n    }\r\n\r\n    if(p.isFlagged)\r\n    {\r\n        origFlags |= VMLIFlag.Flagged;\r\n    }\r\n\r\n    if (p.priority)\r\n    {\r\n        origFlags |= p.priority;\r\n    }\r\n\r\n    this._flags = ko.observable(origFlags);\r\n\r\n    this.styleLength = 0;\r\n    this.dateText = p.dateText;\r\n    this.allDayDate = undefined;\r\n    this.dateCreated = (p.dateCreated ? new Date(p.dateCreated) : new Date());\r\n    this.dateCompleted = (p.dateCompleted ? new Date(p.dateCompleted) : undefined);\r\n    this.elements = [];\r\n    this.outlineElements = [];\r\n\r\n    // TODO: Combine into single _propFlags\r\n    //this.inRoot = (!extraInfo || extraInfo.inRoot !== false);\r\n    this.isLoaded = false;\r\n    this.isDeleted = p.isDeleted || false;\r\n    this.isStyled = false;\r\n    //this.spanStart = false;\r\n    this.modifiedOffline = undefined;\r\n    this.modifiedOfflineText = undefined;\r\n\r\n    //this.isItemMenuOpen = false;\r\n    this.deleteTimeout = undefined; // TODO: Remove in favor of global delete handler\r\n    this.highlightTimeout = undefined; // TODO: Remove in favor of using animationEnd and add/remove class\r\n\r\n    this.data = undefined;\r\n\r\n    // GWTODO: Is -1 the correct value to initialize to?\r\n    this._version = -1;\r\n    this._versionText = -1;\r\n\r\n    this._versionRemote = undefined;\r\n    this._versionRemoteText = undefined;\r\n\r\n    //this.lastModified = 0;\r\n\r\n    this.levelsDeep = this._parent ? ko.observable(this._parent.levelsDeep() + 1) : ko.observable(0);\r\n\r\n    __TOTAL_ITEMS++;\r\n    if (p.isArchived)\r\n    {\r\n        __TOTAL_ARCHIVED_ITEMS++;\r\n    }\r\n\r\n    this._needsParse = false;\r\n    if (DEBUG)\r\n    {\r\n        this._DEBUGNeedsStyle = true;\r\n        this._DEBUGLoadCount = 0;\r\n\r\n        //this._DEBUGStylePaddingCalls = 0;\r\n    }\r\n\r\n    this.init(p, extraInfo);\r\n\r\n    // We take a perf hit from sealing objects\r\n    //Object.seal(this);\r\n}\r\n\r\nVMLI.prototype = {\r\n    _getLineStyle: function ()\r\n    {\r\n        return this._flags() & g.LSMask;\r\n    },\r\n    _getPriority: function ()\r\n    {\r\n        return this._flags() & g.PMask;\r\n    },\r\n    stylePadding: function (context)\r\n    {\r\n        var paddingStart;\r\n        var paddingLevels;\r\n        if (context)\r\n        {\r\n            paddingStart = platform.phone ? 15 : 24;\r\n            var pane = context.$parents[context.$parents.length - 2];\r\n            g.Assert(pane && pane.item.peek(), 'Invalid pane');\r\n            var rootDepth = pane.item.peek().levelsDeep.peek();\r\n\r\n            paddingLevels = this.levelsDeep() - rootDepth - 1;\r\n        }\r\n        else\r\n        {\r\n            paddingStart = platform.phone ? 40 : 25;\r\n            paddingLevels = this.levelsDeep() - 1;\r\n        }\r\n        return (paddingStart + (paddingLevels * 20)) + 'px';\r\n    },\r\n    _updateStylePadding: function (parentDepth, forceChange)\r\n    {\r\n        g.Assert(this._parent, 'Must have a valid parent to update padding, root should never change');\r\n\r\n        var newDepth = parentDepth + 1;\r\n        var hasChanged = (this.levelsDeep.peek() !== newDepth);\r\n\r\n        if (hasChanged || forceChange)\r\n        {\r\n            if (hasChanged)\r\n            {\r\n                this.levelsDeep(newDepth);\r\n            }\r\n            else\r\n            {\r\n                this.levelsDeep.valueHasMutated();\r\n            }\r\n\r\n            var children = this.items.peek();\r\n            for (var i = 0; i < children.length; ++i)\r\n            {\r\n                children[i]._updateStylePadding(newDepth, forceChange);\r\n            }\r\n        }\r\n    },\r\n    styleProps: function ()\r\n    {\r\n        var localFlags = this._flags();\r\n\r\n        var styleProps = (localFlags & VMLIFlag.Header) ? 'pHeader ' : '';\r\n\r\n        if (localFlags & VMLIFlag.Collapsed)\r\n        {\r\n            styleProps += 'collapsed ';\r\n        }\r\n\r\n        if (localFlags & VMLIFlag.Selected)\r\n        {\r\n            styleProps += 'selected ';\r\n        }\r\n\r\n        if (localFlags & VMLIFlag.Highlighted)\r\n        {\r\n            styleProps += 'highlight ';\r\n        }\r\n\r\n        if (localFlags & VMLIFlag.NumList)\r\n        {\r\n            styleProps += 'pNumList ';\r\n        }\r\n\r\n        if (this.isArchived())\r\n        {\r\n            styleProps += 'archived ';\r\n        }\r\n\r\n        // if(localFlags & g.LSMask)\r\n        // {\r\n        //     styleProps += g.flagMapOut[localFlags & g.LSMask];\r\n        // }\r\n        if(localFlags & VMLIFlag.Complete)\r\n        {\r\n            styleProps += 'pComplete ';\r\n        }\r\n        else if(localFlags & g.PMask)\r\n        {\r\n            styleProps += g.priorityMapOut[localFlags & g.PMask] + ' ';\r\n        }\r\n        else\r\n        {\r\n            styleProps += 'pNormal ';\r\n        }\r\n\r\n        if(localFlags & VMLIFlag.Flagged)\r\n        {\r\n            styleProps += 'pStar ';\r\n        }\r\n\r\n        return styleProps;\r\n    },\r\n    copyProperties: function(src)\r\n    {\r\n        this.isFlagged(src.isFlagged());\r\n        this.isComplete(src.isComplete());\r\n        this.priority(src.priority());\r\n    },\r\n    parent: function ()\r\n    {\r\n        if (arguments.length === 1)\r\n        {\r\n            g.Assert(arguments[0] instanceof VMLI || arguments[0] === undefined, 'Parent must be a VMLI');\r\n\r\n            this._parent = arguments[0];\r\n\r\n            if (arguments[0] !== undefined)\r\n            {\r\n                this._updateStylePadding(this._parent.levelsDeep(), /*forceChange*/false);\r\n            }\r\n        }\r\n\r\n        return this._parent;\r\n    },\r\n    archivedItems: function (underlying)\r\n    {\r\n        if (!this._archivedItems)\r\n        {\r\n            this._archivedItems = ko.observableArray();\r\n\r\n            window.__TOTAL_ARCHIVE_PARENTS++;\r\n        }\r\n\r\n        return underlying ? this._archivedItems() : this._archivedItems;\r\n    },\r\n    hasArchivedChildren: function ()\r\n    {\r\n        if (this._archivedItems !== undefined)\r\n        {\r\n            return this._archivedItems().length > 0;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    headers: function ()\r\n    {\r\n        var headers = [ ];\r\n\r\n        var items = this.items();\r\n        for (var i = 0; i < items.length; ++i)\r\n        {\r\n            if (items[i].isHeader())\r\n            {\r\n                headers.push(items[i]);\r\n            }\r\n        }\r\n\r\n        return headers;\r\n    },\r\n    isArchived: function ()\r\n    {\r\n        if (arguments.length === 1)\r\n        {\r\n            var oldValue = this._isArchived;\r\n\r\n            this._isArchived = arguments[0];\r\n\r\n            if (arguments[0] !== oldValue)\r\n            {\r\n                g.timeline.notifyStateChanged(this, PropChangeType.Archive);\r\n            }\r\n        }\r\n\r\n        return this._isArchived;\r\n    },\r\n    getRawText: function ()\r\n    {\r\n        return this._rawText;\r\n    },\r\n    getParsedText: function ()\r\n    {\r\n        // TODO: This assert will fail if you call setText with immediateParse to false\r\n        g.Assert(this._needsParse === false, 'Text should be parsed before calling get');\r\n\r\n        return (this._parsedText ? this._parsedText : this._rawText);\r\n    },\r\n    getStyledText: function ()\r\n    {\r\n        if (DEBUG)\r\n        {\r\n            g.Assert(this._DEBUGNeedsStyle === false, 'Text should be styled before calling get');\r\n        }\r\n\r\n        return this._styledText();\r\n    },\r\n    getSearchText: function()\r\n    {\r\n        g.Assert(this._searchText !== undefined, 'Item should always have search text');\r\n        return this._searchText;\r\n    },\r\n    setRawText: function (text)\r\n    {\r\n        if (text === undefined || text === null)\r\n        {\r\n            text = '';\r\n        }\r\n\r\n        this._rawText = text;\r\n        if(text)\r\n        {\r\n            this._searchText = text.toLowerCase();\r\n        }\r\n        this._parsedText = undefined;\r\n\r\n        this._needsParse = true;\r\n\r\n        if (DEBUG) this._DEBUGNeedsStyle = true;\r\n    },\r\n    setParsedText: function (text)\r\n    {\r\n        //g.Assert(this._needsParse === true, 'Text should only be parsed once each time it is set');\r\n\r\n        var changed = (this._parsedText === text) || (text === undefined);\r\n\r\n        this._parsedText = text;\r\n        if(text)\r\n        {\r\n            this._searchText = text.toLowerCase();\r\n        }\r\n\r\n        this._needsParse = false;\r\n    },\r\n    setStyledText: function (text)\r\n    {\r\n        //g.Assert(this._DEBUGNeedsStyle === true, 'Text should only be styled once each time it is set');\r\n\r\n        this._styledText(text);\r\n\r\n        if (DEBUG) this._DEBUGNeedsStyle = false;\r\n    },\r\n    priority: function (pri, fromRemote)\r\n    {\r\n        if (pri !== undefined)\r\n        {\r\n            g.Assert(g.priorityMapOut[pri], 'Priority must be defined in globals');\r\n\r\n            var oldPriority = this._getPriority();\r\n            if (pri !== oldPriority)\r\n            {\r\n                var newFlags = (this._flags() & ~g.PCMask) | pri;\r\n                this._flags(newFlags);\r\n\r\n                if (this.isLoaded)\r\n                {\r\n                    var saveData = { priority: pri };\r\n\r\n                    // if (this.isComplete())\r\n                    // {\r\n                    //     saveData.isComplete = false;\r\n                    //     saveData.dateCompleted = undefined;\r\n                    // }\r\n\r\n                    if (!fromRemote)\r\n                    {\r\n                        gdata.saveChanges(this, saveData);\r\n                        saveData = g.clone(saveData);\r\n                    }\r\n\r\n                    var saveFlags = !fromRemote ? SaveFlag.Text : SaveFlag.None;\r\n                    this.save(saveData, saveFlags);\r\n\r\n                    g.timeline.notifyStateChanged(this, PropChangeType.Priority | PropChangeType.Complete);\r\n\r\n                    tracker.performAction(TrackerType.Update, {\r\n                        'itemID': this.id,\r\n                        'field': 'priority',\r\n                        'newValue': pri,\r\n                        'oldValue': oldPriority\r\n                    });\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        return this._getPriority();\r\n    },\r\n    date: function (date, fromRemote)\r\n    {\r\n        if (date !== undefined)\r\n        {\r\n            if (date !== this._date())\r\n            {\r\n                if (date === null)\r\n                {\r\n                    date = undefined;\r\n                }\r\n\r\n                this._date(date);\r\n\r\n                g.timeline.notifyStateChanged(this, PropChangeType.Date);\r\n\r\n                if (this.isLoaded && !fromRemote)\r\n                {\r\n                    tracker.miscAction({\r\n                        type: TrackerType.Misc,\r\n                        misc: TrackerMisc.ChangeDate,\r\n                        data: [\r\n                        {\r\n                            itemID: this.id,\r\n                            date: date\r\n                        }]\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._date();\r\n    },\r\n    _isFlagHelper: function (flag, value)\r\n    {\r\n        if (value !== undefined)\r\n        {\r\n            var newFlags = value ? (this._flags() | flag) : (this._flags() & ~flag);\r\n\r\n            this._flags(newFlags);\r\n\r\n            return;\r\n        }\r\n\r\n        return !!(this._flags() & flag);\r\n    },\r\n    isImportant: function ()\r\n    {\r\n        return this._getPriority();\r\n    },\r\n    isComplete: function (value, fromRemote)\r\n    {\r\n        if (value !== undefined)\r\n        {\r\n            var saveData = { isComplete: value };\r\n\r\n            // This code makes it so that when an item is marked as completed it will remove any priority\r\n            // and flagging from the item.\r\n            //\r\n            // if(this.isFlagged())\r\n            // {\r\n            //     saveData.isFlagged = false;\r\n            // }\r\n            // if(this.priority())\r\n            // {\r\n            //     saveData.priority = VMLIFlag.None;\r\n            // }\r\n            // var newFlags = value ?\r\n            //                     ((this._flags() & ~g.PFMask) | VMLIFlag.Complete) :\r\n            //                     (this._flags() & ~VMLIFlag.Complete);\r\n            //\r\n            // this._flags(newFlags);\r\n\r\n            if (value !== this._isFlagHelper(VMLIFlag.Complete))\r\n            {\r\n                this._isFlagHelper(VMLIFlag.Complete, value);\r\n\r\n                if (this.isLoaded)\r\n                {\r\n                    if (value)\r\n                    {\r\n                        if (!this.dateCompleted)\r\n                        {\r\n                            this.dateCompleted = new Date();\r\n                            saveData.dateCompleted = this.getDateCompletedTime();\r\n                        }\r\n\r\n                        // TODO: Enable sounds\r\n                        // setTimeout(function()\r\n                        // {\r\n                        //     sounds.play(sounds.complete);\r\n                        // }, 0);\r\n\r\n                        if (g.vmMain.isLoaded)\r\n                        {\r\n                            g.aggregateEvent('ItemCompleted');\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        this.dateCompleted = undefined;\r\n                        saveData.dateCompleted = undefined;\r\n                    }\r\n\r\n                    if (!fromRemote)\r\n                    {\r\n                        gdata.saveChanges(this, saveData);\r\n                        saveData = g.clone(saveData);\r\n                    }\r\n\r\n                    var saveFlags = !fromRemote ? SaveFlag.Text : SaveFlag.None;\r\n                    this.save(saveData, saveFlags);\r\n\r\n                    g.timeline.notifyStateChanged(this, PropChangeType.Complete);\r\n\r\n                    tracker.performAction(TrackerType.Update, {\r\n                        'itemID': this.id,\r\n                        'field': 'isComplete',\r\n                        'newValue': value,\r\n                        'oldValue': !value\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return this._isFlagHelper(VMLIFlag.Complete);\r\n        }\r\n    },\r\n    isFlagged: function (value, fromRemote)\r\n    {\r\n        if (value !== undefined)\r\n        {\r\n            if (value !== this._isFlagHelper(VMLIFlag.Flagged))\r\n            {\r\n                var origFlags = value ? (this._flags() & ~VMLIFlag.Complete) : this._flags();\r\n                var newFlags = value ? (origFlags | VMLIFlag.Flagged) : (origFlags & ~VMLIFlag.Flagged);\r\n\r\n                this._flags(newFlags);\r\n\r\n                if (this.isLoaded)\r\n                {\r\n                    var saveData = { isFlagged: value };\r\n\r\n                    // if (this.isComplete() && !fromRemote)\r\n                    // {\r\n                    //     saveData.isComplete = false;\r\n                    //     saveData.dateCompleted = undefined;\r\n                    // }\r\n\r\n                    if (!fromRemote)\r\n                    {\r\n                        gdata.saveChanges(this, saveData);\r\n                        saveData = g.clone(saveData);\r\n                    }\r\n\r\n                    var saveFlags = !fromRemote ? SaveFlag.Text : SaveFlag.None;\r\n                    this.save(saveData, saveFlags);\r\n\r\n                    g.timeline.notifyStateChanged(this, PropChangeType.Flagged | PropChangeType.Complete);\r\n                }\r\n\r\n                tracker.performAction(TrackerType.Update, {\r\n                    'itemID': this.id,\r\n                    'field': 'isFlagged',\r\n                    'newValue': value,\r\n                    'oldValue': !value\r\n                });\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return this._isFlagHelper(VMLIFlag.Flagged);\r\n        }\r\n    },\r\n    isHeader: function ()\r\n    {\r\n        g.Assert(arguments.length === 0, 'Shouldnt be passing arguemtns to isHeader');\r\n\r\n        var value = this.items().length > 0;\r\n        // if (value !== undefined)\r\n        // {\r\n            var currStyle = this._flags();\r\n\r\n            if (!!(currStyle & VMLIFlag.Header) !== value)\r\n            {\r\n                var newFlags = value ? (currStyle | VMLIFlag.Header) : (currStyle & ~VMLIFlag.Header);\r\n\r\n                this._flags(newFlags);\r\n\r\n                if (this._parent && this._parent.isFullscreen())\r\n                {\r\n                    this._updateStylePadding(this._parent.levelsDeep(), /*forceChange*/true);\r\n                }\r\n            }\r\n\r\n        //     return;\r\n        // }\r\n\r\n        // return !!(this._flags() & VMLIFlag.Header);\r\n\r\n        return value;\r\n    },\r\n    isCollapsed: function (value)\r\n    {\r\n        return this._isFlagHelper(VMLIFlag.Collapsed, value);\r\n    },\r\n    isSelected: function (value)\r\n    {\r\n        // Selected is only used on mobile devices\r\n        if (platform.mobile)\r\n        {\r\n            return this._isFlagHelper(VMLIFlag.Selected, value);\r\n        }\r\n\r\n        return false;\r\n    },\r\n    isHighlighted: function (value)\r\n    {\r\n        return this._isFlagHelper(VMLIFlag.Highlighted, value);\r\n    },\r\n    isNumList: function (value)\r\n    {\r\n        return this._isFlagHelper(VMLIFlag.NumList, value);\r\n    },\r\n    hasCompletedAncestor: function()\r\n    {\r\n        var parent = this.parent();\r\n        while(parent)\r\n        {\r\n            if(parent.isComplete())\r\n                return true;\r\n\r\n            parent = parent.parent();\r\n        }\r\n    },\r\n    hasTime: function ()\r\n    {\r\n        if (!this.date())\r\n        {\r\n            return this.dateCompleted;\r\n        }\r\n        else\r\n        {\r\n            return this.date().toString('h:mmtt') !== '12:00am';\r\n        }\r\n    },\r\n    time: function ()\r\n    {\r\n        if (!this.date())\r\n        {\r\n            if (this.dateCompleted)\r\n            {\r\n                return this.dateCompleted.toString('h:mmtt');\r\n            }\r\n            else\r\n            {\r\n                return '';\r\n            }\r\n        }\r\n\r\n        if (this.date().toString('h:mmtt') == '12:00am')\r\n            return 'Any Time';\r\n\r\n        return this.date().toString('h:mm tt');\r\n    },\r\n    createDateString: function (dt)\r\n    {\r\n        if (dt.isBefore(Date.today().addWeeks(1)))\r\n        {\r\n            return dt.toString('dddd h:mm tt');\r\n        }\r\n        else\r\n        {\r\n            return dt.toString('MM/dd h:mm tt');\r\n        }\r\n    },\r\n    fullTime: function ()\r\n    {\r\n        var date = this.date();\r\n\r\n        if (!date)\r\n        {\r\n            return '';\r\n        }\r\n        else\r\n        {\r\n            this.createDateString(date);\r\n        }\r\n    },\r\n    setVersion: function(type, v)\r\n    {\r\n        if (DEBUG && DEBUG)\r\n        {\r\n            var verStr = ((type === VersionType.Structure) ? this._version : this._versionText) + ' -> ' + v;\r\n            window.__MEM_VERSION_UPDATES.push('MEMVERSION ' + type + ': ' + this.id + ': ' + g.getCurrentStack(verStr));\r\n\r\n            if (DEBUG) log('Setting local memversion ' + type + ': ' + this.id + ': ', verStr);\r\n        }\r\n\r\n        switch (type)\r\n        {\r\n            case VersionType.Structure:\r\n                this._version = v;\r\n                break;\r\n            case VersionType.Text:\r\n                this._versionText = v;\r\n                break;\r\n            default:\r\n                g.Assert(false, 'Invalid version type');\r\n                break;\r\n        }\r\n    },\r\n    getVersion: function(type)\r\n    {\r\n        var v;\r\n        switch (type)\r\n        {\r\n            case VersionType.Structure:\r\n                v = this._version;\r\n                break;\r\n            case VersionType.Text:\r\n                v = this._versionText;\r\n                break;\r\n            default:\r\n                v = -2;\r\n                g.Assert(false, 'Invalid version type');\r\n                break;\r\n        }\r\n\r\n        return v ? v : 0;\r\n    },\r\n    setRemoteVersion: function(type, v)\r\n    {\r\n        if (DEBUG && DEBUG)\r\n        {\r\n            var verStr = ((type === VersionType.Structure) ? this._versionRemote : this._versionRemoteText) + ' -> ' + v;\r\n            window.__MEM_VERSION_UPDATES.push('REMOTEMEMVERSION ' + type + ': ' + this.id + ': ' + g.getCurrentStack(verStr));\r\n\r\n            if (DEBUG) log('Setting remote memversion ' + type + ': ' + this.id + ': ', verStr);\r\n        }\r\n\r\n        switch (type)\r\n        {\r\n            case VersionType.Structure:\r\n                this._versionRemote = v;\r\n                break;\r\n            case VersionType.Text:\r\n                this._versionRemoteText = v;\r\n                break;\r\n            default:\r\n                g.Assert(false, 'Invalid version type');\r\n                break;\r\n        }\r\n    },\r\n    getRemoteVersion: function(type)\r\n    {\r\n        var v;\r\n        switch (type)\r\n        {\r\n            case VersionType.Structure:\r\n                v = this._versionRemote;\r\n                break;\r\n            case VersionType.Text:\r\n                v = this._versionRemoteText;\r\n                break;\r\n            default:\r\n                v = -2;\r\n                g.Assert(false, 'Invalid version type');\r\n                break;\r\n        }\r\n\r\n        return v ? v : 0;\r\n    },\r\n    isLocalVersionNewer: function(type)\r\n    {\r\n        return this.getVersion(type) == this.getRemoteVersion(type);\r\n    },\r\n    isRemoteVersionNewer: function(type)\r\n    {\r\n        return !this.isLocalVersionNewer(type);\r\n    },\r\n    init: function(p, extraInfo)\r\n    {\r\n        // Initialize this item in one of three ways:\r\n        //   1) This item is being initialized with data directly from gdrive, in which case\r\n        //      do a direct initialization of this items members using that data.\r\n        //   2) This item is being initialized while online, but there is no corresponding data\r\n        //      from gdrive to match the item yet, in which case initialize the members to use\r\n        //      gdrive and create new collaborative objects.\r\n        //   3) This item is being created in offline mode/we have not connected to gdrive yet.\r\n        //      In this case, simply initialize the local instance of the item amd wait until\r\n        //      we come back online to sync the data to gdrive.\r\n\r\n        //log('Initialize: ', p.id, ': ', p.text);\r\n\r\n        if (!p.data)\r\n        {\r\n            this.setVersion(VersionType.Structure, p.version);\r\n            this.setVersion(VersionType.Text, p.versionText);\r\n\r\n            this.modifiedOffline = p.modifiedOffline;\r\n            this.modifiedOfflineText = p.modifiedOfflineText;\r\n\r\n            if (this.modifiedOffline)\r\n            {\r\n                if (DEBUG) log('%cMODIFIED offline:', 'color: green', this.getRawText(), this.getVersion(VersionType.Structure));\r\n            }\r\n\r\n            if (this.modifiedOfflineText)\r\n            {\r\n                if (DEBUG) log('%cMODIFIED TEXT offline:', 'color: green', this.getRawText(), this.getVersion(VersionType.Text));\r\n            }\r\n\r\n            // ID has to come first so the tracker can know which item had its\r\n            // date updated\r\n            if (g.vmMain.isLoaded && gdata.isConnected())\r\n            {\r\n                d.initializeItem(this);\r\n            }\r\n            else\r\n            {\r\n                this.id = p.id || g.generateTempId();\r\n            }\r\n\r\n            if (p.date)\r\n            {\r\n                this.allDayDate = p.allDayDate;\r\n                this.date(new Date(p.date));\r\n                this.date()._explicitTime = !this.allDayDate;\r\n            }\r\n\r\n            if (p.dateCompleted)\r\n            {\r\n                this.dateCompleted = new Date(p.dateCompleted);\r\n            }\r\n\r\n            if (p.items)\r\n            {\r\n                this.updateItems(p.items, extraInfo && extraInfo.forceSave, extraInfo && extraInfo.parse);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var verStructure = gdata.getVersion(p.data, VersionType.Structure);\r\n            var verText = gdata.getVersion(p.data, VersionType.Text);\r\n\r\n            this.setRemoteVersion(VersionType.Structure, verStructure);\r\n            this.setRemoteVersion(VersionType.Text, verText);\r\n\r\n            tracker.beginAction(); // BEGIN TRACKER <----\r\n\r\n            this.initFromGDrive(p.data, (extraInfo && extraInfo.parse));\r\n\r\n            tracker.endAction(); // END TRACKER <----\r\n\r\n            // this.setVersion(VersionType.Structure, verStructure);\r\n            // this.setVersion(VersionType.Text, verText);\r\n\r\n            this.setRemoteVersion(VersionType.Structure, undefined);\r\n            this.setRemoteVersion(VersionType.Text, undefined);\r\n        }\r\n\r\n        // if (!this.parent() && p.isRoot)\r\n        // {\r\n        //     g.root = this;\r\n        // }\r\n        // if (this.text == 'Unsorted' + HeaderSuffix)\r\n        // {\r\n        //     this.parent().unsortedList = this;\r\n        // }\r\n        // else if (this.text == 'Calendar Import' + HeaderSuffix)\r\n        // {\r\n        //     this.parent().calendarList = this;\r\n        // }\r\n\r\n        this.parseText(/*immediateParse*/(extraInfo && extraInfo.parse));\r\n\r\n        // Items created through editing may need to be saved as soon as they are initialized.\r\n        if (extraInfo && extraInfo.forceSave)\r\n        {\r\n            this.save(undefined, SaveFlag.Prop);\r\n\r\n            if (this.date())\r\n            {\r\n                gdata.saveChanges(this, this.getMetaTextSaveData());\r\n            }\r\n        }\r\n\r\n        if (g.vmMain.isLoaded)\r\n        {\r\n            g.aggregateEvent('ItemCreated');\r\n        }\r\n\r\n        d.setModel(this.id, this);\r\n    },\r\n    onLoad: function(element, pModel)\r\n    {\r\n        if (DEBUG) { this._DEBUGLoadCount++; }\r\n\r\n        // On mobile the outline is not a child of the pane\r\n        if(platform.mobile)\r\n        {\r\n            pModel = g.focusedPane;\r\n        }\r\n\r\n        if (pModel && pModel.trackDOM && pModel.trackDOM())\r\n        {\r\n            g.Assert(pModel, 'Items must be added to a pane');\r\n\r\n            var paneID = pModel.id;\r\n\r\n            if (DEBUG) log('OnLoad: ', this.id, ': ', paneID);\r\n\r\n            // g.Assert($element.children().length === 2, \"Invalid number of children for item\");\r\n            //g.Assert($(element).children('span').length === 1, \"Invalid number of child spans for item\");\r\n\r\n            this.isLoaded = true;\r\n\r\n            if (g.hasClass(element, 'outlineItem'))\r\n            {\r\n                this.outlineElements[paneID] = element;\r\n                // Only check search if on first load or not currently editing\r\n                pModel.vmSearch.checkItem(this, true, false);\r\n            }\r\n            else\r\n            {\r\n                this.elements[paneID] = element;\r\n\r\n                g.Assert(g.hasClass(this.elements[paneID].firstElementChild, 'text'));\r\n\r\n                //ko.utils.domNodeDisposal.addDisposeCallback(element, this.onUnload.bind(this));\r\n\r\n                // Only check search if on first load or not currently editing\r\n                if (!g.vmMain.isLoaded || pModel != g.focusedPane || pModel.reloading)\r\n                {\r\n                    pModel.vmSearch.checkItem(this, false, true);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    // onUnload: function(element)\r\n    // {\r\n    //     var paneID = 0;\r\n    //     var pane = g.getPaneForElement(element);\r\n\r\n    //     if (pane)\r\n    //     {\r\n    //         if (DEBUG) log('OnUnload: ', this.id, ': ', pane.id);\r\n\r\n    //         this.elements[paneID] = undefined;\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         //log('Undefined OnUnload', element);\r\n    //     }\r\n    // },\r\n    isFullscreen: function()\r\n    {\r\n        //log('is', g.focusedItem._rawText, this._rawText);\r\n        return g.focusedItem === this;\r\n    },\r\n    findItem: function (id)\r\n    {\r\n        var found = this.getIndexOf(id, /*isArchived*/false);\r\n        if (found >= 0)\r\n        {\r\n            return { 'index': found, 'arr': this.items, 'isArchived': false };\r\n        }\r\n        else if (this.hasArchivedChildren())\r\n        {\r\n            found = this.getIndexOf(id, /*isArchived*/true);\r\n            if (found >= 0)\r\n            {\r\n                return { 'index': found, 'arr': this.archivedItems(), 'isArchived': true };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    },\r\n    updateItems: function (newItems, forceSave, parse)\r\n    {\r\n        var collabItemList;\r\n        var collabArchivedItemList;\r\n\r\n        if (this.data)\r\n        {\r\n            collabItemList = gdata.get(this.data, 'items');\r\n            collabArchivedItemList = gdata.get(this.data, 'archivedItems');\r\n        }\r\n\r\n        g.Assert(!this.hasChildren(), 'Update items should only be called from initialize when there are no items already loaded');\r\n        g.Assert(!this.hasArchivedChildren(), 'Update items should only be called from initialize when there are no items already loaded');\r\n\r\n        var itemsModified = false;\r\n        var archivedItemsModified = false;\r\n\r\n        for (var i = 0; i < newItems.length; ++i)\r\n        {\r\n            var item = newItems[i];\r\n            var itemVM = d.getModel(item);\r\n\r\n            if (!itemVM)\r\n            {\r\n                if (typeof item !== \"object\")\r\n                {\r\n                    var itemInfo = d.getItem(item);\r\n\r\n                    g.Assert(itemInfo, \"Referenced item doesn't exist\", item);\r\n\r\n                    if (itemInfo)\r\n                    {\r\n                        itemVM = new VMLI(itemInfo, {'parent': this, 'forceSave': forceSave, 'parse': parse});\r\n                    }\r\n                    else\r\n                    {\r\n                        g.Assert(false);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    g.Assert(item, 'Item must exist otherwise we arent creating anything');\r\n\r\n                    if (item)\r\n                    {\r\n                        itemVM = new VMLI(item, {'parent': this, 'forceSave': forceSave, 'parse': parse});\r\n                    }\r\n                    else\r\n                    {\r\n                        g.Assert(false);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // If there is already a VM loaded that has this item as a child, thats bad.\r\n                var oldParentInfo = d.getItem(itemVM.parent().id);\r\n                var oldParentIndex = oldParentInfo.items.indexOf(itemVM.id);\r\n\r\n                g.Assert(oldParentIndex === -1, \"Expect that the old parent has been notified\");\r\n\r\n                var childModelIndex = itemVM.getIndex();\r\n\r\n                if (childModelIndex > -1)\r\n                {\r\n                    itemVM.parent().removeChildAtIndex(childModelIndex);\r\n                }\r\n\r\n                itemVM.parent(this);\r\n            }\r\n\r\n            g.Assert(itemVM, 'There must be a model at this point');\r\n\r\n            if (itemVM)\r\n            {\r\n                // TODO: Switch to call to addChild which puts the item in the correct list\r\n                if (!itemVM.isArchived())\r\n                {\r\n                    itemsModified = true;\r\n                    this.items().push(itemVM);\r\n\r\n                    if (!collabItemList && !!this.data)\r\n                    {\r\n                        collabItemList = gdata.ensureItemList(this, /*isArchived*/false);\r\n                    }\r\n\r\n                    if (collabItemList)\r\n                    {\r\n                        collabItemList.push(itemVM.data);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    archivedItemsModified = true;\r\n                    this.archivedItems(/*underlying*/true).push(itemVM);\r\n\r\n                    if (!collabArchivedItemList && !!this.data)\r\n                    {\r\n                        collabArchivedItemList = gdata.ensureItemList(this, /*isArchived*/true);\r\n                    }\r\n\r\n                    if (collabArchivedItemList)\r\n                    {\r\n                        collabArchivedItemList.push(itemVM.data);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (itemsModified)\r\n        {\r\n            this.items.valueHasMutated();\r\n        }\r\n\r\n        if (archivedItemsModified)\r\n        {\r\n            this.archivedItems().valueHasMutated();\r\n        }\r\n    },\r\n    insertItem: function (item, index, underlying)\r\n    {\r\n        var arr = underlying ? this.items() : this.items;\r\n        if (isNaN(index))\r\n        {\r\n            arr.push(item);\r\n        }\r\n        else\r\n        {\r\n            arr.splice(index, 0, item);\r\n        }\r\n\r\n        d.insertItems(this, [item], index);\r\n\r\n        //g.events.emit('itemAdded', item, /*force*/false);\r\n        g.fireCustomEvent('itemAdded', { item: item, force: false });\r\n    },\r\n    moveTo: function (params)\r\n    {\r\n        var parent = params.parent;\r\n        var index = params.index;\r\n        var isRemoteChange = params.isRemoteChange;\r\n        var shouldBeArchived = params.shouldBeArchived;\r\n        var noVersion = params.noVersion;\r\n        var underlying = params.underlying;\r\n\r\n        g.Assert(parent instanceof VMLI);\r\n\r\n        if (index === undefined) { index = -1; }\r\n        if (isRemoteChange === undefined) { isRemoteChange = false; }\r\n        if (shouldBeArchived === undefined) { shouldBeArchived = false; }\r\n\r\n        var oldParent = this.parent();\r\n        var oldInfo = oldParent.findItem(this);\r\n\r\n        if (oldInfo)\r\n        {\r\n            // If moving within a single parent, ensure that if an item is moving to after itself that it still\r\n            // ends up at the correct location in the list.\r\n            if (oldParent === parent)\r\n            {\r\n                if (oldInfo.index === index)\r\n                {\r\n                    // Moving to the same location in the list, this is a noop\r\n                    return;\r\n                }\r\n                else if (oldInfo.index < index)\r\n                {\r\n                    // If moving to an index after the current index, account for the fact that the moving item\r\n                    // will be removed from the list before it is added at the new index.\r\n                    index--;\r\n                }\r\n            }\r\n\r\n            if (underlying)\r\n            {\r\n                oldInfo.arr = oldInfo.arr();\r\n            }\r\n\r\n            oldInfo.arr.splice(oldInfo.index, 1);\r\n\r\n            this.parent(parent);\r\n\r\n            var arr = (shouldBeArchived ? parent.archivedItems() : parent.items);\r\n            if (underlying)\r\n            {\r\n                arr = arr();\r\n            }\r\n\r\n            if (index < 0)\r\n            {\r\n                arr.push(this);\r\n            }\r\n            else\r\n            {\r\n                arr.splice(index, 0, this);\r\n            }\r\n\r\n            var newInfo = { 'index': index, 'isArchived': shouldBeArchived };\r\n\r\n            d.moveItem({\r\n                item: this,\r\n                newInfo: newInfo,\r\n                oldParent: oldParent,\r\n                oldInfo: oldInfo,\r\n                isRemoteChange: isRemoteChange,\r\n                noVersion: noVersion\r\n            });\r\n        }\r\n    },\r\n    // spliceItems: function(index, numRemove, item, underlying)\r\n    // {\r\n    //     var arr = underlying ? this.items() : this.items;\r\n    //     var removedItems;\r\n    //     if (item)\r\n    //     {\r\n    //         removedItems = arr.splice(index, numRemove, item);\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         removedItems = arr.splice(index, numRemove);\r\n    //     }\r\n\r\n    //     d.spliceItems(this, index, numRemove, item, removedItems);\r\n    // },\r\n    // shiftItem: function(underlying)\r\n    // {\r\n    //     var arr = underlying ? this.items() : this.items;\r\n    //     var shifted = arr.shift();\r\n\r\n    //     d.shiftItems(this, shifted);\r\n\r\n    //     return shifted;\r\n    // },\r\n    getItemsArrayForSave: function ()\r\n    {\r\n        var saveItems = [ ];\r\n\r\n        var items = this.items();\r\n        for (var i = 0; i < items.length; ++i)\r\n        {\r\n            saveItems.push(items[i].id);\r\n        }\r\n\r\n        if (this.hasArchivedChildren())\r\n        {\r\n            var archivedItems = this.archivedItems(/*underlying*/true);\r\n            for (var i = 0; i < archivedItems.length; ++i)\r\n            {\r\n                saveItems.push(archivedItems[i].id);\r\n            }\r\n        }\r\n\r\n        return saveItems;\r\n    },\r\n    getDateTime: function ()\r\n    {\r\n        if (this.date())\r\n        {\r\n            return this.date().getTime();\r\n        }\r\n\r\n        return undefined;\r\n    },\r\n    getDateCompletedTime: function ()\r\n    {\r\n        if (this.dateCompleted)\r\n        {\r\n            return this.dateCompleted.getTime();\r\n        }\r\n\r\n        return undefined;\r\n    },\r\n    getMetaTextSaveData: function ()\r\n    {\r\n        var currentDate = this.date();\r\n        var numDate;\r\n        var allDayDate;\r\n\r\n        if (currentDate !== undefined)\r\n        {\r\n            numDate = currentDate.getTime();\r\n            allDayDate = !currentDate._explicitTime;\r\n        }\r\n\r\n        return {\r\n            date: numDate,\r\n            allDayDate: allDayDate,\r\n            dateCompleted: this.getDateCompletedTime()\r\n        };\r\n    },\r\n    getBasicJSON: function()\r\n    {\r\n        g.Assert(this.date(), 'Must have a valid date');\r\n\r\n        g.Assert(!this.allDayDate, 'All day dates should not be scheduled');\r\n\r\n        if(this.allDayDate)\r\n            return '';\r\n\r\n        var dateJSON = this.date().toJSON();\r\n        var alertDateJSON;\r\n        if(this.allDayDate)\r\n        {\r\n            alertDateJSON = this.date().addDays(-1).setHours(17).toJSON();\r\n        }\r\n        else\r\n        {\r\n            alertDateJSON = this.date().addMinutes(-30).toJSON();\r\n        }\r\n\r\n        return '{' +\r\n            '\"id\":\"' + this.id + '\",' +\r\n            '\"text\":\"' + this.getRawText() + '\",' +\r\n            '\"date\":\"' + dateJSON + '\",' +\r\n            '\"alertDate\":\"' + alertDateJSON + '\"' +\r\n        '}';\r\n    },\r\n    getDebugData: function()\r\n    {\r\n        var data =\r\n        {\r\n            id: this.id,\r\n            parent: this._parent ? this._parent.id : undefined,\r\n            items: this.getItemsArrayForSave(),\r\n            text: this.getRawText(),\r\n            isArchived: this.isArchived(),\r\n            isDeleted: this.isDeleted,\r\n            version: this.getVersion(VersionType.Structure),\r\n            versionText: this.getVersion(VersionType.Text),\r\n            modifiedOffline: this.modifiedOffline,\r\n            modifiedOfflineText: this.modifiedOfflineText\r\n        };\r\n\r\n        return data;\r\n    },\r\n    getFullSaveData: function ()\r\n    {\r\n        var data =\r\n        {\r\n            id: this.id,\r\n            text: this.getRawText(),\r\n            date: this.getDateTime(),\r\n            dateCreated: this.dateCreated.getTime(),\r\n            dateCompleted: this.getDateCompletedTime(),\r\n            priority: this._getPriority() || undefined,\r\n            isComplete: this.isComplete() || undefined,\r\n            isFlagged: this.isFlagged() || undefined,\r\n            //extern: this.extern,\r\n            isCollapsed: this.isCollapsed() || undefined,\r\n            allDayDate: this.allDayDate || undefined,\r\n            isArchived: this.isArchived() || undefined,\r\n            isDeleted: undefined,\r\n            version: this.getVersion(VersionType.Structure),\r\n            versionText: this.getVersion(VersionType.Text),\r\n            modifiedOffline: this.modifiedOffline,\r\n            modifiedOfflineText: this.modifiedOfflineText\r\n        };\r\n\r\n        data.items = this.getItemsArrayForSave();\r\n\r\n        return data;\r\n    },\r\n    save: function (changes, saveFlags)\r\n    {\r\n        g.Assert(saveFlags !== undefined, 'Must specify saveFlags for the changes that are being saved');\r\n\r\n        if (!changes)\r\n        {\r\n            changes = this.getFullSaveData();\r\n        }\r\n        else\r\n        {\r\n            var existingItem = d.getItem(this.id);\r\n\r\n            if (!existingItem && !changes.id)\r\n            {\r\n                if (DEBUG) log('%cSaving changes on an item that has not had a full save', 'color: purple', this.id, changes);\r\n                changes = this.getFullSaveData();\r\n            }\r\n            else\r\n            {\r\n                if (changes.items)\r\n                {\r\n                    changes.items = this.getItemsArrayForSave();\r\n                }\r\n\r\n                if (changes.date && !changes.allDayDate)\r\n                {\r\n                    changes.allDayDate = this.allDayDate || undefined;\r\n                }\r\n\r\n                if (changes.text)\r\n                {\r\n                    //g.events.emit('itemTextChanged', this, saveFlags === SaveFlag.None);\r\n                    g.fireCustomEvent('itemTextChanged', { item: this, force: (saveFlags === SaveFlag.None) });\r\n                }\r\n            }\r\n        }\r\n\r\n        //log('Saving: ', changes);\r\n\r\n        d.saveChanges(this, changes, saveFlags);\r\n    },\r\n    toggleCollapsed: function()\r\n    {\r\n        if (this.items().length <= 0)\r\n            return;\r\n\r\n        var isCollapsed = this.isCollapsed();\r\n\r\n        var self = this;\r\n\r\n        var element = g.firstChildTag(this.getElement(), 'ul');\r\n        function toggleFunc()\r\n        {\r\n            tracker.performAction(TrackerType.Update, {\r\n                'itemID': self.id,\r\n                'field': 'isCollapsed',\r\n                'newValue': !self.isCollapsed(),\r\n                'oldValue': self.isCollapsed()\r\n            });\r\n\r\n            self.isCollapsed(!self.isCollapsed());\r\n            self.save({ isCollapsed: self.isCollapsed() }, SaveFlag.Text);\r\n        };\r\n\r\n        // If the source element is the span in the main page, then set the collapsed flag\r\n        // on the element to hide it and remember it on the next page load.\r\n        if (isCollapsed)\r\n        {\r\n            toggleFunc();\r\n\r\n            g.animateTransform(element,\r\n            {\r\n                time: 200,\r\n                delay: 0,\r\n                transform: 'scale(1, 1) translate3d(0,0,0)',\r\n                clearTransform: true,\r\n                origin: '50% 0'\r\n            });\r\n        }\r\n        else\r\n        {\r\n            g.animateTransform(element,\r\n            {\r\n                time: 200,\r\n                transform: 'scale(1, 0)',\r\n                origin: '50% 0',\r\n                onComplete: function()\r\n                {\r\n                    toggleFunc();\r\n                }\r\n            });\r\n        }\r\n    },\r\n    highlight: function()\r\n    {\r\n        var self = this;\r\n        if(this.highlightTimeout)\r\n        {\r\n            this.isHighlighted(false);\r\n            clearTimeout(this.highlightTimeout);\r\n            this.highlightTimeout = 0;\r\n            setTimeout(function()\r\n            {\r\n                self.isHighlighted(true);\r\n            }, 0);\r\n        }\r\n        else\r\n            this.isHighlighted(true);\r\n\r\n        this.highlightTimeout = setTimeout(function()\r\n        {\r\n            self.isHighlighted(false);\r\n        }, 2000);\r\n    },\r\n    getElement: function (paneID)\r\n    {\r\n        if (paneID === undefined)\r\n        {\r\n            paneID = g.focusedPaneID;\r\n        }\r\n\r\n        // g.Assert(g.vmMain.panes()[paneID].mode() === PaneMode.Normal,\r\n        //         'getElement should not be called by anything but the normal pane');\r\n\r\n        return this.elements[paneID];\r\n    },\r\n    getSpan: function (paneID)\r\n    {\r\n        var ele = this.getElement(paneID);\r\n\r\n        return ele ? ele.firstElementChild : undefined;\r\n    },\r\n    getOutlineElement: function (paneID)\r\n    {\r\n        if (paneID === undefined)\r\n        {\r\n            paneID = g.focusedPaneID;\r\n        }\r\n\r\n        // g.Assert(g.vmMain.panes()[paneID].mode() === PaneMode.Normal,\r\n        //         'getElement should not be called by anything but the normal pane');\r\n\r\n        return this.outlineElements[paneID];\r\n    },\r\n\r\n    // Item Processing\r\n    // addChild: function (child)\r\n    // {\r\n    //     g.Assert(!child.isArchived());\r\n\r\n    //     this.items.push(child);\r\n\r\n    //     d.insertItems(this, [child], this.items.length);\r\n\r\n    //     child.parent(this);\r\n    // },\r\n    // addChildAtIndex: function (child, index)\r\n    // {\r\n    //     g.Assert(!child.isArchived());\r\n\r\n    //     this.items.splice(index, 0, child);\r\n\r\n    //     d.insertItems(this, [child], index);\r\n\r\n    //     child.parent(this);\r\n    // },\r\n    removeChild: function (child)\r\n    {\r\n        var removedIndex;\r\n\r\n        if (!child.isArchived())\r\n        {\r\n            removedIndex = this.items().remove(child);\r\n\r\n            d.removeItem(this, removedIndex, child, /*isArchived*/false);\r\n\r\n            this.items.valueHasMutated();\r\n        }\r\n        else\r\n        {\r\n            g.Assert(this.hasArchivedChildren(), 'For a child to be archived, this item must have valid archived children');\r\n\r\n            if (this.hasArchivedChildren())\r\n            {\r\n                removedIndex = this.archivedItems(/*underlying*/true).remove(child);\r\n\r\n                d.removeItem(this, removedIndex, child, /*isArchived*/true);\r\n\r\n                this.archivedItems().valueHasMutated();\r\n            }\r\n        }\r\n\r\n        return removedIndex;\r\n    },\r\n    removeChildAtIndex: function (index)\r\n    {\r\n        g.Assert(!this.items()[index].isArchived());\r\n\r\n        var removed = this.items().removeAt(index);\r\n\r\n        d.removeItem(this, index, removed, /*isArchived*/false);\r\n\r\n        this.items.valueHasMutated();\r\n\r\n        return removed;\r\n    },\r\n    archiveChild: function (child)\r\n    {\r\n        var retVal = false;\r\n\r\n        if (!child.isArchived())\r\n        {\r\n            tracker.beginAction(); // <---- TRACKER BEGIN ACTION\r\n\r\n            child.isArchived(true);\r\n            this.archivedItems().push(child);\r\n\r\n            var removedIndex = this.items().remove(child);\r\n\r\n            d.archiveItem(this, removedIndex, child);\r\n\r\n            this.items.valueHasMutated();\r\n\r\n            tracker.endAction(); // <---- TRACKER END ACTION\r\n\r\n            retVal = true;\r\n        }\r\n\r\n        return retVal;\r\n    },\r\n    unarchiveChild: function (child)\r\n    {\r\n        var retVal = false;\r\n\r\n        if (child.isArchived())\r\n        {\r\n            tracker.beginAction(); // <---- TRACKER BEGIN ACTION\r\n\r\n            g.Assert(child.isArchived(), 'Child must be archived to be unarchived');\r\n            g.Assert(this.hasArchivedChildren(), 'Parent must have archived children to unarchive a child');\r\n\r\n            child.isArchived(false);\r\n\r\n            var removedIndex = this.archivedItems(/*underlying*/true).remove(child);\r\n\r\n            this.items.push(child);\r\n\r\n            d.unarchiveItem(this, removedIndex, child);\r\n\r\n            this.archivedItems().valueHasMutated();\r\n\r\n            tracker.endAction(); // <---- TRACKER END ACTION\r\n\r\n            retVal = true;\r\n        }\r\n\r\n        return retVal;\r\n    },\r\n    _moveChildrenHelper: function(params)\r\n    {\r\n        var newParent = params.newParent;\r\n        var index = params.index;\r\n        var isArchived = params.isArchived;\r\n\r\n        g.Assert(newParent !== undefined && isArchived !== undefined, '_moveChildrenHelper is missing parameters');\r\n\r\n        var oldItems = isArchived ? this.archivedItems() : this.items;\r\n        var children = oldItems();\r\n\r\n        if (children.length > 0)\r\n        {\r\n            var newItems = isArchived ? newParent.archivedItems() : newParent.items;\r\n\r\n            if (!isArchived && (isNaN(index) || index < 0))\r\n            {\r\n                // Invalid index = push\r\n                index = newItems().length;\r\n            }\r\n\r\n            var i = 0;\r\n            while(children.length > 0)\r\n            {\r\n                g.Assert(children[i] != newParent);\r\n                var id = children[0];\r\n\r\n                children[0].moveTo({\r\n                    parent: newParent,\r\n                    index: index + i,\r\n                    shouldBeArchived: isArchived,\r\n                    underlying: true\r\n                });\r\n\r\n                tracker.performAction(TrackerType.Move,\r\n                {\r\n                    'itemID': id,\r\n                    'oldParent': this.id,\r\n                    'oldPosition': i,\r\n                    'newParent': newParent.id,\r\n                    'newPosition': index + i\r\n                });\r\n\r\n                i ++;\r\n            }\r\n\r\n            oldItems.valueHasMutated();\r\n            newItems.valueHasMutated();\r\n        }\r\n    },\r\n    // Move all children to newParent at the position specified by index\r\n    moveChildren: function (newParent, index)\r\n    {\r\n        g.Assert(this.id !== newParent.id);\r\n\r\n        if (newParent.parent() === this)\r\n        {\r\n            var oldIndex = this.removeChild(newParent);\r\n\r\n            tracker.performAction(TrackerType.Delete, {\r\n                'itemID': newParent.id,\r\n                'parent': this.id,\r\n                'position': oldIndex\r\n            });\r\n        }\r\n\r\n        this._moveChildrenHelper({newParent: newParent,\r\n                                  index: index,\r\n                                  isArchived: false});\r\n        this._moveChildrenHelper({newParent: newParent,\r\n                                  index: index,\r\n                                  isArchived: true});\r\n    },\r\n    // deleteArchivedChild: function (child)\r\n    // {\r\n    //     var oldIndex = this.removeChild(child);\r\n\r\n    //     tracker.performAction(TrackerType.Delete, {\r\n    //         'itemID': child.id,\r\n    //         'parent': this.id,\r\n    //         'position': oldIndex\r\n    //     });\r\n\r\n    //     d.deleteItem(child);\r\n\r\n    //     g.timeline.notifyStateChanged(child);\r\n\r\n    //     while (child.hasChildren())\r\n    //     {\r\n    //         child.deleteChild(child.items()[0]);\r\n    //     }\r\n\r\n    //     // delete child;\r\n    // },\r\n    deleteSelf: function()\r\n    {\r\n        this.parent().deleteChild(this);\r\n        this.parent(undefined);\r\n    },\r\n    deleteChild: function (child, newParent, newIndex)\r\n    {\r\n        tracker.beginAction(); // BEGIN TRACKER <----\r\n\r\n        if (child.hasChildren() || child.hasArchivedChildren())\r\n        {\r\n            // The children for the item will either be reparented or deleted\r\n            if (newParent)\r\n            {\r\n                child.moveChildren(newParent, newIndex);\r\n            }\r\n            else\r\n            {\r\n                var childItems = child.items();\r\n\r\n                // Recursively delete all children as well\r\n                for (var i = childItems.length - 1; i >= 0; i--)\r\n                {\r\n                    child.deleteChild(childItems[i]);\r\n                }\r\n\r\n                // TODO: Archived items?\r\n            }\r\n        }\r\n\r\n        if (!child.isDeleted)\r\n        {\r\n            var oldIndex = this.removeChild(child);\r\n\r\n            tracker.performAction(TrackerType.Delete,\r\n            {\r\n                'itemID': child.id,\r\n                'parent': this.id,\r\n                'position': oldIndex\r\n            });\r\n\r\n            d.deleteItem(child);\r\n        }\r\n\r\n        g.timeline.notifyStateChanged(child);\r\n\r\n        tracker.endAction(); // END TRACKER <----\r\n    },\r\n    replaceChild: function (oldChild, newChild)\r\n    {\r\n        var index = oldChild.getIndex();\r\n\r\n        this.items().removeAt(index);\r\n\r\n        tracker.performAction(TrackerType.Delete, {\r\n            'itemID': oldChild.id,\r\n            'parent': this.id,\r\n            'position': index\r\n        });\r\n\r\n        d.deleteItem(oldChild);\r\n\r\n        newChild.moveTo({parent: this, index: index});\r\n\r\n        // The new child has been inserted at 'index' pushing the old child to be at 'index + 1'\r\n        d.removeItem(this, index + 1, oldChild, /*isArchived*/false);\r\n\r\n        oldChild.moveChildren(newChild, newChild.numChildren());\r\n\r\n        // Move the new child from its previous parent to the parent\r\n        //this.addChildAtIndex(newChild, index);\r\n\r\n        var newChildOldParentID = newChild.parent().id;\r\n        if (newChildOldParentID !== this.id)\r\n        {\r\n            var newChildOldIndex = newChild.parent().items().remove(newChild);\r\n\r\n            tracker.performAction(TrackerType.Move, {\r\n                'itemID': newChild.id,\r\n                'oldParent': newChildOldParentID,\r\n                'oldPosition': newChildOldIndex,\r\n                'newParent': this.id,\r\n                'newPosition': index\r\n            });\r\n        }\r\n\r\n        this.items.valueHasMutated();\r\n\r\n        // delete oldChild;\r\n    },\r\n    getChild: function (index)\r\n    {\r\n        g.Assert(index < this.items().length);\r\n        return this.items()[index];\r\n    },\r\n    getFirstChild: function ()\r\n    {\r\n        return this.hasChildren() ? this.items()[0] : undefined;\r\n    },\r\n    isFirstChild: function ()\r\n    {\r\n        return this.parent() ? this.parent().getFirstChild() === this : false;\r\n    },\r\n    getLastChild: function ()\r\n    {\r\n        return this.hasChildren() ? this.items()[this.items().length - 1] : undefined;\r\n    },\r\n    isLastChild: function ()\r\n    {\r\n        return this.parent() ? this.parent().getLastChild() === this : false;\r\n    },\r\n    getChildIndex: function (child)\r\n    {\r\n        return this.getIndexOf(child.id, child.isArchived());\r\n    },\r\n    getIndexOf: function (id, isArchived)\r\n    {\r\n        // TODO: Re-enable assert about incoming object types\r\n        //g.Assert(typeof id == 'string', 'ID must be a valid ID string');\r\n\r\n        if (id.id) // If it's an item\r\n        {\r\n            id = id.id;\r\n        }\r\n\r\n        var index = -1;\r\n\r\n        var arr;\r\n        if (isArchived)\r\n        {\r\n            if (this.hasArchivedChildren())\r\n            {\r\n                arr = this.archivedItems(/*underlying*/true);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            arr = this.items();\r\n        }\r\n\r\n        if (arr)\r\n        {\r\n            for (var i = 0; i < arr.length; ++i)\r\n            {\r\n                if (arr[i].id === id)\r\n                {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    },\r\n    getRemoteIndexOf: function (item, isArchived)\r\n    {\r\n        // TODO: Re-enable assert about incoming object types\r\n        //g.Assert(typeof id == 'string', 'ID must be a valid ID string');\r\n\r\n        // if (id.id)\r\n        // {\r\n        //     id = id.id;\r\n        // }\r\n\r\n        var remoteList = gdata.getItemList(this.data, isArchived);\r\n\r\n        var index = -1;\r\n        if (remoteList)\r\n        {\r\n            // TODO: Change back to custom implementation?\r\n            index = remoteList.indexOf(item);\r\n            // for (var i = 0; i < remoteList.length; ++i)\r\n            // {\r\n            //     if (remoteList.get(i) === id)\r\n            //     {\r\n            //         index = i;\r\n            //         break;\r\n            //     }\r\n            // }\r\n        }\r\n\r\n        return index;\r\n    },\r\n    getIndex: function ()\r\n    {\r\n        return this.parent().getChildIndex(this);\r\n    },\r\n    hasChildren: function ()\r\n    {\r\n        return this.items().length > 0;\r\n    },\r\n    numChildren: function ()\r\n    {\r\n        return this.items().length;\r\n    },\r\n    canZoom: function ()\r\n    {\r\n        return this.numChildren() > 0 || this.getParsedText().length > 0;\r\n    },\r\n    // parentsUntil: function(targetParent)\r\n    // {\r\n    //     var arr = [];\r\n    //     var parent = this.parent();\r\n\r\n    //     while (parent && parent !== targetParent)\r\n    //     {\r\n    //         arr.push(parent);\r\n    //         parent = parent.parent();\r\n    //     }\r\n\r\n    //     return arr;\r\n    // },\r\n    parents: function()\r\n    {\r\n        var parents = [];\r\n        var parent = this;\r\n        while (parent)\r\n        {\r\n            parents.splice(0, 0, parent);\r\n            parent = parent.parent();\r\n        }\r\n        return parents;\r\n    },\r\n    getSiblings: function(startIndex)\r\n    {\r\n        startIndex = startIndex || 0;\r\n        var arr = [];\r\n\r\n        if (this.parent())\r\n        {\r\n            var items = this.parent().items();\r\n            for(var i = 0, _l = items.length; i < _l; i ++)\r\n            {\r\n                if(items[i] !== this)\r\n                {\r\n                    arr.push(items[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return arr;\r\n    },\r\n    outline: function(context)\r\n    {\r\n        if(context)\r\n        {\r\n            for(var i = context.$parents.length - 1; i > 0; i --)\r\n            {\r\n                if(context.$parents[i] instanceof g.VMOutline)\r\n                    return context.$parents[i];\r\n            }\r\n        }\r\n        return g.focusedPane.outline;\r\n    }\r\n//     notifyExternUpdated: function (data)\r\n//     {\r\n//         // TODO: Update this item based on extern data change\r\n//     }\r\n};\r\n\r\n// VMLI Extension classes\r\ng.extend(VMLI.prototype, VMLI_TapHandlers);\r\ng.extend(VMLI.prototype, VMLI_Text);\r\ng.extend(VMLI.prototype, VMLI_Drive(VMLI));\r\nreturn VMLI;\r\n});\r\n","asserts":[{"tag":1134,"offset":762},{"tag":1135,"offset":1031},{"tag":1136,"offset":1140},{"tag":1137,"offset":1213},{"tag":1138,"offset":4340},{"tag":1139,"offset":4824},{"tag":1140,"offset":7064},{"tag":1141,"offset":8832},{"tag":1142,"offset":9078},{"tag":1143,"offset":9269},{"tag":1144,"offset":9842},{"tag":1145,"offset":10239},{"tag":1146,"offset":10537},{"tag":1147,"offset":17692},{"tag":1148,"offset":21161},{"tag":1149,"offset":21599},{"tag":1150,"offset":22450},{"tag":1151,"offset":22906},{"tag":1152,"offset":27729},{"tag":1153,"offset":27903},{"tag":1154,"offset":28001},{"tag":1155,"offset":28519},{"tag":1156,"offset":30429},{"tag":1157,"offset":30562},{"tag":1158,"offset":31106},{"tag":1159,"offset":31434},{"tag":1160,"offset":31555},{"tag":1161,"offset":31888},{"tag":1162,"offset":32254},{"tag":1163,"offset":32622},{"tag":1164,"offset":34913},{"tag":1165,"offset":39064},{"tag":1166,"offset":39124},{"tag":1167,"offset":41484},{"tag":1168,"offset":44981},{"tag":1169,"offset":45489},{"tag":1170,"offset":45778},{"tag":1171,"offset":46026},{"tag":1172,"offset":46546},{"tag":1173,"offset":47070},{"tag":1174,"offset":48089},{"tag":1175,"offset":48175},{"tag":1176,"offset":48876},{"tag":1177,"offset":49503},{"tag":1178,"offset":50397},{"tag":1179,"offset":54345},{"tag":1180,"offset":55165},{"tag":1181,"offset":56043}]},"VMLI_TapHandlers":{"path":"F:/p/bce/Duchess/public/js/VMLI_TapHandlers.js","data":"define(['ko', 'globals', 'platform', 'android', 'tracker'],\nfunction (ko, g, platform, android, tracker)\n{\nvar gestureThreshold = 80;\nvar gestureSelectFirstThreshold = 40;\n\nvar SPThresholdLeft = 18;\nvar SPThresholdRight = 36;\n\nvar dataTransfer = undefined;\n\nvar VMLI_TapHandlers =\n{\n    dragStart: function (e)\n    {\n        g.Assert(!platform.mobile || !g.focusedPane.isTimeline(), 'Should not be able to drag/drop on timeline on mobile');\n        g.Assert(g.startDrag, 'Should always have a valid item to start dragging from');\n\n        // log('start drag');\n        g.clearSelection();\n\n        // When starting a new drag, ensure android input has been completed and hidden.\n        if (android.isEnabled())\n        {\n            android.finishInput();\n        }\n\n        // $(document.body).addClass('noSelect');\n\n        var target = g.startDrag.getElement();\n        g.startDrag = undefined;\n\n        g.Assert(g.dragging === undefined, 'Only one element may be dragged or dropped at a time');\n        g.Assert(g.draggingHidden === undefined, 'Only one element may be dragged or dropped at a time');\n\n        g.Assert(!g.tempUL.hasChildNodes(), 'TempUL should never have children when starting a drag');\n\n        g.draggingHidden = target;\n\n        // TODO: this clone is slow. Its purpose is to leave a white space when it moves.\n        // Could it be optimized by setting the height of the item above instead?\n        // Or is it ok to not leave a space?\n        g.dragging = target.cloneNode(true);\n        //g.$dragging = $target.clone();\n\n        g.tempUL.appendChild(g.dragging);\n\n        var scroll = document.getElementById('container').scrollTop;\n        var y = e.eventY + scroll - (platform.mobile ? g.phoneMainY : 0);\n        var width = g.width(target);\n\n        g.dragStartInfo = {x: e.eventX, y: e.eventY};\n\n        g.tempUL.style.display = 'block';\n        if(!platform.mobile)\n        {\n            g.tempUL.style.left = (e.eventX - e.xFromTopLeft) + 'px';\n        }\n        g.tempUL.style.top = (y - e.yFromTopLeft) + 'px';\n        g.tempUL.style.width = width + 'px';\n\n        g.addClass(g.draggingHidden, 'itemBeingDragged');\n\n        g.disableMouseMove = true;\n    },\n    dragMove: function (e)\n    {\n        // Prevent the default touchmove event, which is to pan with the finger\n        e.preventDefault();\n\n        var x = platform.mobile ? 0 : (e.eventX - g.dragStartInfo.x);\n        var y = e.eventY - g.dragStartInfo.y;\n\n        var translate = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n\n        g.tempUL.style[platform.transform.style] = translate;\n\n        var dragOver = document.elementFromPoint(e.eventX, e.eventY);\n\n        if (!dataTransfer) { dataTransfer = { dropEffect: 'move', item: this }; }\n\n        g.vmMain.handleDragOver({\n            srcElement: dragOver,\n            dataTransfer: dataTransfer,\n            diffY: e.diffY,\n            offsetY: e.eventY,\n            preventDefault: g.emptyFn,\n            stopPropagation: g.emptyFn,\n            stopImmediatePropagation: g.emptyFn\n        });\n    },\n    dragEnd: function (e)\n    {\n        // $(document.body).removeClass('noSelect');\n\n        if (platform.ios)\n        {\n            g.preventClick();\n        }\n\n        g.disableMouseMove = false;\n\n        var dragging = g.dragging;\n        var draggingHidden = g.draggingHidden;\n\n        g.dragging = undefined;\n        g.draggingHidden = undefined;\n\n        // TODO: This is revert:\n        // $dragging.css({\n        //     '-webkit-transition': '-webkit-transform ' + returnTime + 'ms',\n        //     '-webkit-transform': 'translate3d(0,0,0)'\n        // });\n        // setTimeout(function(){\n        g.removeClass(draggingHidden, 'itemBeingDragged');\n        dragging.parentNode.removeChild(dragging);\n        // }, 200);\n\n        g.tempUL.style.display = 'none';\n\n        if (!dataTransfer) { dataTransfer = { dropEffect: 'move', item: this }; }\n\n        g.vmMain.handleDrop({\n            srcElement: e.srcElement,\n            dataTransfer: dataTransfer,\n            preventDefault: g.emptyFn,\n            stopPropagation: g.emptyFn,\n            stopImmediatePropagation: g.emptyFn\n        });\n\n        dataTransfer = undefined;\n\n        // iOS workaround where preventDefault on touchMove makes touchUp think\n        // it's a click and then sets focus.\n        if (platform.ios)\n        {\n            g.preventClick();\n        }\n\n        g.disableMouseMove = false;\n    },\n    onStart: function(e)\n    {\n        if (g.dragStartTimeout)\n        {\n            clearTimeout(g.dragStartTimeout);\n            g.dragStartTimeout = undefined;\n        }\n\n        //g.touchPhase = g.TouchPhase.Start;\n        g.scrollAtTouchStart = g.focusedPane.getScrollOffset();\n        g.canRevealMenu = true;\n\n        //log('Begin DragTouch: ', g.scrollAtTouchStart);\n\n        if (g.isKeyboardOpen)\n        {\n            g.revealTimeout = setTimeout(function()\n            {\n                g.canRevealMenu = false;\n            }, 400);\n        }\n\n        if (platform.mobile && !platform.ie && e.srcElement.tagName !== 'UL' && !g.isKeyboardOpen && !g.focusedPane.isTimeline())\n        {\n            g.dragStartTimeout = setTimeout(function()\n            {\n                g.clearSelection();\n\n                g.startDrag = this;\n\n                this.dragStart(e);\n                this.dragMove(e);\n            }.bind(this), 500);\n        }\n        else if (e.srcElement.tagName === 'SPAN' && e.offsetX <= SPThresholdLeft) // Clicks on the left of item\n        {\n            g.clearSelection();\n            g.startDrag = this;\n\n            e.preventDefault();\n            e.stopImmediatePropagation();\n        }\n    },\n    onMove: function(e)\n    {\n        // if(this.ignoreThisTap)\n        //     return;\n\n                // log(document.body.scrollTop, window.innerHeight, document.body.scrollHeight);\n\n        if(g.revealTimeout)\n        {\n            clearTimeout(g.revealTimeout);\n            g.revealTimeout = undefined;\n        }\n\n        //g.touchPhase = g.TouchPhase.Move;\n\n        // if(g.isKeyboardOpen && platform.bodyscroll)\n        // {\n        //     if (g.phoneMenu.isSearchOut())\n        //     {\n        //         g.vmMain.elPhoneMenu.style.visibility = 'hidden';\n        //         document.getElementById('searchDivPhone').style.visibility = 'hidden';\n        //     }\n        //     else\n        //     {\n        //         g.keyboardToolbar.hide();\n        //     }\n        // }\n\n        if(this.isItemMenuOpen)\n        {\n            e.preventDefault();\n        }\n        else if (g.startDrag)\n        {\n            if(!platform.touch || Math.abs(e.distanceY) > g.ClickThreshold && Math.abs(e.distanceX) < g.ClickThreshold)\n            {\n                if (g.startDrag === this)\n                {\n                    this.dragStart(e);\n                }\n            }\n        }\n\n        if(g.dragging)\n        {\n            this.dragMove(e);\n        }\n        else\n        {\n            // TODO: Move this out of VMLI\n            if (platform.touch && g.canRevealMenu && !g.focusedPane.isTimeline())\n            {\n                if (g.revealingMenu || g.revealingRightMenu || (e.distanceY < g.ClickThreshold && Math.abs(e.diffX) > g.ClickThreshold))\n                {\n                    // if(!g.isKeyboardOpen)\n                    // {\n                        if (!g.revealingMenu)\n                        {\n                            g.menus.revealGestureMenu(this, e);\n                        }\n                        // if(!g.menus.startedInMultiSelectMode)\n                        // {\n                            g.menus.updateRevealGestureMenu(e);\n                        // }\n                    // }\n\n                    e.preventDefault();\n                }\n            }\n        }\n    },\n    onClick: function(e)\n    {\n        //log('Ele: ' + e.srcElement.tagName + '  Offset: ' + e.offsetX + '  ReqOffset: ' + (g.focusedPane.getWidth() - SPThresholdRight));\n        // if (this.ignoreThisTap)\n        // {\n        //     return;\n        // }\n\n        // if(g.vmMain.isOutlineOut())\n        // {\n        //     g.temp_closingOutline = true;\n        //     g.outline.close();\n        //     e.preventDefault();\n        //     e.stopImmediatePropagation();\n        // }\n        if (platform.mobile && g.phoneMenu.multiSelectMode())\n        {\n            g.menus.multiSelect(this);\n        }\n        else if (e.srcElement.tagName === 'SPAN' && e.offsetX <= SPThresholdLeft) // Clicks on the left of item\n        {\n            // if (e.srcElement.className.startsWith('spComplete'))\n            // {\n            //     this.isComplete(false);\n            // }\n\n            // this.applyPrefix(CompletePrefix);\n            // g.clearSelection();\n\n            // var $clicked = $(e.srcElement);\n            // var offset = $clicked.offset();\n            // g.menus.setGestureMenu('format');\n            // this.spanStart = g.offset(e.startSrc);\n            // var y = this.spanStart.top + 10;\n            // g.menus.openGestureMenu(this, this.spanStart.left, y);\n\n            if (!this.isComplete())\n            {\n                g.messageQueue.pushMessage({\n                    text: 'You completed an item, click again to undo',\n                    type: MessageType.Info,\n                    timeout: 3000\n                });\n            }\n\n            // g.menus.openFormatMenu(this);\n            this.isComplete(!this.isComplete());\n        }\n        else if (e.srcElement.tagName === 'LI' && this.isCollapsed() && e.offsetX >= (g.focusedPane.getWidth() - SPThresholdRight))\n        {\n            this.toggleCollapsed();\n        }\n        else if (g.hasClass(e.srcElement, 'tag') && !platform.mobile)\n        {\n            if (platform.mac && e.metaKey || !platform.mac && e.ctrlKey)\n            {\n                var text = e.srcElement.textContent;\n\n                if (e.shiftKey)\n                {\n                    g.focusedPane.vmSearch.setSearch(text);\n                }\n                else\n                {\n                    g.focusedPane.vmSearch.addToSearch(text);\n                }\n            }\n        }\n        else if (g.hasClass(e.srcElement, 'contact'))\n        {\n            var offset = g.getOffsetOfSubNode(this.getSpan(), e.srcElement);\n\n            g.autocomplete.update({item: this, start: offset + 1});\n            g.autocomplete.show(this, e.srcElement);\n\n            e.preventDefault();\n\n            if (platform.ios)\n            {\n                g.preventClick();\n            }\n        }\n        else if (e.startSrc.id === 'itemOptions')\n        {\n            // var $clicked = $(e.srcElement);\n            // var offset = $clicked.offset();\n            // g.menus.openItemMenu(this, offset.left, offset.top);\n            if (g.itemMenuOpenedOn == this)\n            {\n                g.itemMenuOpenedOn = undefined;\n            }\n            // log('menu');\n        }\n        // // Clicks on switch view mode\n        // else if(e.srcElement.tagName == 'LI' && e.yFromTopLeft < 0)\n        // {\n        //     this.togglePriorityView();\n        // }\n        else if (e.srcElement.tagName === 'A') // Link\n        {\n            if (platform.mac && e.metaKey || !platform.mac && e.ctrlKey)\n            {\n                var offset = g.offset(e.srcElement);\n\n                open(e.srcElement.href, 'link' + e.srcElement.href);\n            }\n            else\n            {\n                // g.menus.openLinkMenu(this, e.srcElement.href, offset.left, offset.top + 20);\n            }\n\n            // e.ignoreThisTap = true;\n            // e.handled = true;\n            // e.preventDefault();\n            // e.stopImmediatePropagation();\n        }\n        else\n        {\n            if (g.autocomplete)\n            {\n                g.autocomplete.hide();\n            }\n\n            if (platform.ios || platform.android || platform.mobileie)\n            {\n                var activeElement = document.activeElement;\n                var scrollTopClick = g.focusedPane.getScrollOffset();\n                var justCancelledInertialScroll = Math.abs(scrollTopClick - g.scrollAtTouchStart) > 0;\n\n                if((!g.isKeyboardOpen || !activeElement || activeElement.id == 'searchPhone') &&\n                    !justCancelledInertialScroll && !g.focusedPane.isTimeline())\n                {\n                    var performedScroll = false;\n\n                    var item = this;\n\n                    if (platform.mobile && this == g.focusedPane.item())\n                    {\n                        item = g.getLastVisibleItem(g.focusedPane.item());\n                    }\n\n                    g.Assert(item, 'Click on item should not happen');\n\n                    // if (item)\n                    // {\n                        if (platform.ios)\n                        {\n                            g.vmMain.setSelected( [ item ] );\n                        }\n                        g.openKeyboardOn(e, item.getSpan(), true, function()\n                        {\n                            g.selectChildren(item, item.getParsedText().length, 0);\n                        });\n\n                        // g.keyboardToolbar.preShow();\n\n                        // if (!g.isKeyboardOpen)\n                        // {\n                        //     // Scroll item into view first\n                        //     if(platform.app)\n                        //     {\n                        //         var callback = function()\n                        //         {\n                        //             setTimeout(function()\n                        //             {\n                        //                 g.keyboardToolbar.show();\n                        //                 g.selectChildren(item, item.getParsedText().length, 0);\n\n                        //                 if (!platform.bodyscroll)\n                        //                 {\n                        //                     g.enforceScroll();\n                        //                 }\n                        //                 g.removeClass(g.focusedPane.paneContent, 'padded');\n                        //             }, platform.keyboardOpenTime);\n                        //         };\n\n                        //         g.addClass(g.focusedPane.paneContent, 'padded');\n                        //         // Wait a frame to allow padding to take effect before scrolling\n                        //         performedScroll = g.scrollIntoView(item.getSpan(), platform.keyboardOpenTime, callback, /*useAnimationFrame*/true);\n                        //     }\n                        //     else\n                        //     {\n                        //         performedScroll = g.scrollIntoView(item.getSpan(), platform.keyboardOpenTime);\n                        //     }\n                        // }\n\n                        // if(!performedScroll || !platform.app)\n                        // {\n                        //     g.selectChildren(item, item.getParsedText().length, 0);\n                        // }\n                    // }\n\n                    // // Prevent native tap handler since setting selection will bring up\n                    // // the keyboard\n                    // if (platform.ios)\n                    // {\n                    //     g.preventClick();\n                    // }\n\n                    // e.preventDefault();\n                    // e.stopImmediatePropagation();\n                    // e.returnFalse = true;\n\n                    // if (!platform.bodyscroll)\n                    // {\n                    //     g.enforceScroll();\n                    // }\n                }\n                else if (platform.mobileie)\n                {\n                    if (android.isEnabled())\n                    {\n                        android.updateInput(this);\n                    }\n                }\n            }\n            else (!platform.mobile)\n            {\n                // On desktop, single clicking on a timeline element will jump other panes to highlight that particular item.\n                if (g.focusedPane.isTimeline() && g.hasClass(e.srcElement, 'text'))\n                {\n                    for (var i = 0; i < this.elements.length; ++i)\n                    {\n                        var spanEle = this.getSpan(i);\n\n                        var pane = g.vmMain.panes()[i];\n\n                        if (pane && pane.vmSearch.isVisible(this))\n                        {\n                            g.scrollIntoView(this.getSpan(i), 200);\n                        }\n                    }\n\n                    this.highlight();\n\n                    g.sendEvent('Menu', 'GoTo');\n                }\n            }\n        }\n    },\n    onDblClick: function(e)\n    {\n        if (g.hasClass(e.srcElement, 'text') && platform.mobile)\n        {\n            // On mobile double tap, switch back to the main pane and zoom to the item\n            // if (platform.mobile)\n            // {\n                g.Assert(g.phoneMenu, 'Phone menu should always be available on mobile');\n                g.phoneMenu.toggleMode();\n\n                e.preventDefault();\n            //}\n\n            for (var i = 0; i < this.elements.length; ++i)\n            {\n                g.scrollIntoView(this.getSpan(i), 200);\n            }\n\n            this.highlight();\n\n            g.sendEvent('PhoneMenu', 'GoTo');\n        }\n    },\n    // onMiddleClick: function(e)\n    // {\n    //     // if (this.ignoreThisTap)\n    //     // {\n    //     //     return;\n    //     // }\n    //     if (g.hasClass(e.srcElement, 'num'))\n    //     {\n    //         var target = ko.dataFor(e.srcElement);\n    //         if (target.hasChildren())\n    //         {\n    //             g.vmMain.addPane(target);\n\n    //             e.srcElement.blur();\n    //             e.ignoreThisTap = true;\n    //             e.handled = true;\n    //             e.preventDefault();\n    //             e.stopImmediatePropagation();\n    //         }\n    //     }\n    // },\n    onEnd: function(e)\n    {\n        //g.touchPhase = g.TouchPhase.End;\n        // if(this.ignoreThisTap)\n        //     return;\n\n        if (g.dragStartTimeout)\n        {\n            clearTimeout(g.dragStartTimeout);\n            g.dragStartTimeout = undefined;\n        }\n\n        g.startDrag = undefined;\n\n        // if(g.vmMain.isOutlineOut())\n        // {\n        //     if(g.vmMain.mainTransform < g.contextX() / 2)\n        //     {\n        //         g.outline.close();\n        //     }\n        //     else\n        //     {\n        //         g.vmMain.setTransform(g.contextX(), 150);\n        //     }\n\n        //     e.preventDefault();\n        //     return false;\n        // }\n        // else if(g.temp_closingOutline)\n        // {\n        //     g.temp_closingOutline = false;\n        //     e.preventDefault();\n        //     return false;\n        // }\n\n        // if(this.transforming)\n        // {\n        //     if(g.vmMain.mainTransform > -160 && g.vmMain.mainTransform !== 0)\n        //     {\n        //         g.vmMain.setTransform(0, 150);\n        //     }\n        //     else if(g.vmMain.mainTransform < -160 && g.vmMain.mainTransform != -320)\n        //     {\n        //         g.vmMain.setTransform(-320, 150);\n        //     }\n        //     this.transforming = false;\n        // }\n\n        if (g.itemMenuOpenedOn == this)\n        {\n            g.menus.menuItemSelected(e.srcElement);\n        }\n\n        if (g.revealingMenu || (g.phoneMenu && g.phoneMenu.multiSelectMode()))\n        {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.returnFalse = true;\n            // iOS workaround where preventDefault on touchMove makes touchUp think\n            // it's a click and then sets focus.\n            if (platform.ios)\n            {\n                g.preventClick();\n            }\n        }\n\n        if (g.revealingMenu)\n        {\n            g.menus.stopRevealGestureMenu(e);\n        }\n\n        var returnTime = 200;\n\n        if(g.dragging)\n        {\n            this.dragEnd(e);\n        }\n        // else if(!platform.touch)\n        // {\n        //     var target = g.getLIParent(e.srcElement);\n        //     log('end', target);\n        //     target.removeEventListener('dragstart', handleDragStart);\n        //     target.removeEventListener('dragend', handleDragEnd);\n        //     $(target).removeAttr('draggable');\n        // }\n\n        //g.events.emit('tapEnd', e);\n    },\n    // onCancel: function(e)\n    // {\n    //     if(touchTimeout)\n    //         clearTimeout(touchTimeout);\n    //     g.startDrag = undefined;\n    // },\n    onRightClick: function(e)\n    {\n        if (!e.stopPropagation || !e.preventDefault)\n        {\n            debugger;\n        }\n\n        g.menus.openItemMenu(this, e);\n        e.preventDefault();\n        e.stopPropagation();\n    },\n    onAutocompleteTapped: function(text, trackingTag)\n    {\n        var text = this.getParsedText().substr(0, trackingTag.index) + text + this.getParsedText().substr(trackingTag.index + trackingTag.length);\n\n        this.setText(text, /*immediateParse*/true);\n        g.selectChildren(this, trackingTag.index + text.length, 0);\n    }\n    // onTapTimeline: {\n    //     onClick: function(e)\n    //     {\n    //         var span = g.getLIParent(e.srcElement);\n    //         if(platform.touch || e.xFromTopLeft > span.clientWidth)\n    //         {\n    //             if(!g.smallMode)\n    //             {\n    //                 this.highlight();\n\n    //                 g.selectChildren(this, 0, this.getParsedText().length);\n    //             }\n    //             else\n    //             {\n    //                 g.phoneMenu.goHome();\n    //                 this.parent().zoomin({time: g.zoomTime});\n    //                 setTimeout(this.highlight, 600);\n    //                 e.preventDefault();\n    //             }\n    //         }\n    //     }\n    // }\n};\n\nreturn VMLI_TapHandlers;\n});\n","asserts":[{"tag":1068,"offset":325},{"tag":1069,"offset":449},{"tag":1070,"offset":908},{"tag":1071,"offset":1008},{"tag":1072,"offset":1115},{"tag":1073,"offset":12596},{"tag":1074,"offset":16903}]},"android":{"path":"F:/p/bce/Duchess/public/js/android.js","data":"define(['ko', 'globals', 'platform'],\nfunction (ko, g, platform) {\n    var self = { };\n\n    var paneRoot;\n    var paneScroller;\n    var paneContent;\n    var inputBox;\n    var currentVMLI;\n\n    var canSetInput = false;\n\n    var enabled = false;\n    self.isEnabled = function ()\n    {\n        return enabled;\n    };\n\n    self.getCurrentVMLI = function ()\n    {\n        return currentVMLI;\n    };\n\n    if (DEBUG)\n    {\n        window.__getCurrentVMLI = function ()\n        {\n            return currentVMLI;\n        };\n    }\n\n    self.getCurrentSpan = function ()\n    {\n        if (currentVMLI)\n        {\n            return currentVMLI.getSpan();\n        }\n\n        return undefined;\n    };\n\n    self.isTargetBox = function(e)\n    {\n        return inputBox === (e.target || e.srcElement);\n    };\n\n    self.getInputBox = function ()\n    {\n        return inputBox;\n    };\n\n    self.getSelectionStart = function ()\n    {\n        return inputBox.selectionStart;\n    };\n\n    self.getSelectionEnd = function ()\n    {\n        return inputBox.selectionEnd;\n    };\n\n    self.setPaneRoot = function(pane)\n    {\n        if (pane.rootElement !== undefined)\n        {\n            enabled = true;\n        }\n        else\n        {\n            enabled = false;\n\n            return;\n        }\n\n        if (pane.rootElement !== paneRoot)\n        {\n            // Grab DOM elements that need event listeners attached\n            paneRoot = pane.rootElement;\n            paneScroller = pane.scrollElement;\n            paneContent = pane.paneContent;\n\n            // paneRoot.addEventListener('textInput', function (e)\n            // {\n            //     log('TextInput: ', e.data.length, e);\n            // });\n\n            // paneRoot.addEventListener('compositionstart', function (e)\n            // {\n            //     log('CompositionStart: ', e);\n            // });\n\n            // paneRoot.addEventListener('compositionupdate', function (e)\n            // {\n            //     log('CompositionUpdate: ', e);\n            // });\n\n            // paneRoot.addEventListener('compositionend', function (e)\n            // {\n            //     log('CompositionEnd: ', e.data.length, e);\n            // });\n\n            // paneRoot.addEventListener('DOMCharacterDataModified', function (e)\n            // {\n            //     if (e.prevValue === TextSpace && e.newValue === \"\")\n            //     {\n            //         require(['edit', 'tracker'], function (edit, tracker)\n            //         {\n            //             var range = window.getSelection().getRangeAt(0);\n            //             var spanEl = range.startContainer\n\n            //             // If the selection container is a text node, grab the parent span\n            //             if (range.startContainer.nodeType === 3)\n            //             {\n            //                 spanEl = range.startContainer.parentNode;\n            //             }\n\n            //             tracker.beginAction(); // BEGIN TRACKER <----\n\n            //             edit.handleBackspace(e, range.startContainer, range);\n\n            //             tracker.endAction(); // END TRACKER <----\n            //         });\n            //     }\n            //     else\n            //     {\n            //         log(e);\n            //     }\n            // });\n\n            inputBox = document.createElement('textarea');\n\n            inputBox.id = 'androidInput';\n            inputBox.style.visibility = 'hidden';\n\n            paneRoot.appendChild(inputBox);\n\n            // if (DEBUG)\n            // {\n            //     var mutID = 0;\n            //     var observer = new MutationObserver(function (mutations)\n            //     {\n            //         mutations.forEach(function (mutation)\n            //         {\n            //             console.log(mutID + ' - Mutation: ', mutation.type + '  : ', mutation);\n            //         });\n\n            //         mutID++;\n            //     });\n\n            //     var config = { childList: true, characterData: true, characterDataOldValue: true, subtree: true };\n\n            //     observer.observe(inputBox, config);\n            // }\n\n            inputBox.onfocus = function (e)\n            {\n                if (DEBUG) log('InputBox Focus', e);\n\n                // If an element is being dragged, dont start editing\n                if (!g.dragging)\n                {\n                    //g.inputJustBlurred = false;\n\n                    if (!g.isKeyboardOpen)\n                    {\n                        g.keyboardToolbar.show();\n                    }\n                }\n            };\n\n            inputBox.onblur = function (e)\n            {\n                if (DEBUG) log('InputBox Blur: ', e);\n\n                if (!e.relatedTarget || e.relatedTarget.id === 'searchPhone')\n                {\n                    self.finishInput();\n\n                    //g.inputJustBlurred = true;\n\n                    g.keyboardToolbar.hide();\n                }\n            };\n\n            var edit;\n            var tracker;\n\n            inputBox.oninput = function (e)\n            {\n                g.Assert(currentVMLI, 'VMLI must be selected in order to get input events');\n\n                if (currentVMLI)\n                {\n                    var isBackspace = !self.getBoxHasTextSpace();\n\n                    if (isBackspace)\n                    {\n                        edit = edit || require('edit');\n                        tracker = tracker || require('tracker');\n\n                        g.Assert(edit && tracker, 'Should always be defined');\n\n                        tracker.beginAction(); // BEGIN TRACKER <----\n\n                        edit.handleBackspace(e, currentVMLI.getSpan(), /*range*/undefined);\n\n                        tracker.endAction(); // END TRACKER <----\n                    }\n                }\n            };\n\n            function enforceSelection()\n            {\n                g.Assert(currentVMLI, 'VMLI must be selected in order to enforce selection offset');\n                g.Assert(self.getBoxHasTextSpace(), 'Editor must always be prefixed with TextSpace');\n\n                // Move selection to after the TextSpace\n                if (inputBox.selectionStart === 0)\n                {\n                    inputBox.selectionStart = 1;\n                }\n            }\n\n            if (!platform.ie)\n            {\n                inputBox.ontouchend = function (e)\n                {\n                    setTimeout(enforceSelection, 30);\n                };\n            }\n\n            canSetInput = (inputBox.selectionStart !== null && inputBox.selectionStart !== undefined) && (inputBox.selectionEnd !== null && inputBox.selectionEnd !== undefined)\n\n\n\n            log('---- Android Editing Enabled ----');\n        }\n    };\n\n    var wasHeader = false;\n    var isInputVisible = false;\n    self.updateInput = function(vmli)\n    {\n        g.Assert(self.isEnabled(), 'Must be enabled to update input');\n\n        if (DEBUG) console.trace();\n\n        if (DEBUG) log('Android UpdateInput');\n\n        var sel = window.getSelection();\n        var selOffset = undefined;\n\n        if (sel.rangeCount > 0 && sel.getRangeAt(0).startContainer.nodeType === Node.TEXT_NODE)\n        {\n            var oldRange = sel.getRangeAt(0);\n\n            selOffset = g.getSelectOffsetsInSpan(vmli, vmli.getSpan(), oldRange, /*forceSelection*/true);\n\n            if (DEBUG) log('Sel Offset: ', selOffset, sel, sel.getRangeAt(0).startContainer);\n        }\n        else\n        {\n            if (DEBUG) log('No Selection Set - Android');\n        }\n\n        var openingInput = false;\n        if (!isInputVisible)\n        {\n            isInputVisible = true;\n\n            openingInput = true;\n\n            inputBox.style.visibility = 'visible';\n        }\n\n        if (!g.isKeyboardOpen)\n        {\n            g.keyboardToolbar.show();\n        }\n\n        var itemChanged = (vmli !== currentVMLI);\n\n        if (itemChanged || (vmli && vmli.isHeader() !== wasHeader))\n        {\n            // If there was an item being edited previously, ensure that its text is saved when switching to\n            // editing a new item.\n            if (currentVMLI && itemChanged)\n            {\n                self.finishInput(/*continueEditing*/true);\n            }\n\n            currentVMLI = vmli;\n\n            wasHeader = vmli.isHeader();\n\n            self.updateInputText(vmli);\n\n            self.updateInputBounds(vmli);\n        }\n\n        if (openingInput)\n        {\n            inputBox.focus();\n        }\n\n        if (selOffset !== undefined && canSetInput)\n        {\n            // +1 Comes from TextSpace that is guaranteed to be at the front of the textarea\n            inputBox.selectionStart = selOffset.start + 1;\n            inputBox.selectionEnd = selOffset.end + 1;\n\n            if (DEBUG) log('Set InputBox Selection: ' + (selOffset.start + 1), (selOffset.end + 1));\n        }\n    };\n\n    self.updateInputText = function(vmli)\n    {\n        if (!vmli || !currentVMLI || vmli.id !== currentVMLI.id)\n        {\n            return;\n        }\n\n        var displayText = currentVMLI.getParsedText();\n\n        if (DEBUG && DEBUG)  log('Update Input Text: ' + displayText);\n\n        self.setBoxValue(displayText);\n    };\n\n    self.insertText = function(offset, text)\n    {\n        var val = self.getBoxValue();\n\n        var newText = val.substr(0, offset) + text + val.substr(offset);\n\n        self.setBoxValue(newText);\n\n        if (canSetInput)\n        {\n            // +1 Comes from the TextSpace guaranteed to be at the beginning of the TextArea\n            inputBox.selectionStart = offset + text.length + 1;\n            inputBox.selectionEnd = offset + text.length + 1;\n        }\n    };\n\n    self.getInputText = function()\n    {\n        g.Assert(self.isEnabled(), 'Must be enabled to get input');\n        g.Assert(currentVMLI, 'Android input must be active to get input text');\n\n        if (!currentVMLI)\n        {\n            return '';\n        }\n\n        return self.getBoxValue();\n    };\n\n    var lastHeight = 0;\n    self.updateInputBounds = function(vmli)\n    {\n        if (!vmli || !currentVMLI || vmli.id !== currentVMLI.id)\n        {\n            return;\n        }\n\n        if (DEBUG) log('Android UpdateInputBounds');\n\n        var elem = vmli.getSpan();\n        var bRect = elem.getBoundingClientRect();\n\n        // The width of the left-hand colorized indicator\n        var leftOffset = 8;\n\n        // TODO: Remove magic number 41\n        var topOffset = 40;\n\n        var scrollTop = paneScroller.scrollTop;\n\n        g.copyStyles(elem, inputBox, ['paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'fontSize', 'lineHeight']);\n\n        inputBox.style.top = Math.ceil(bRect.top + scrollTop - topOffset) + \"px\";\n        inputBox.style.marginLeft = leftOffset + 'px';\n\n        inputBox.style.paddingLeft = (parseInt(inputBox.style.paddingLeft) - leftOffset) + 'px';\n\n        lastHeight = inputBox.scrollHeight;\n    };\n\n    self.checkAndroidBounds = function()\n    {\n        g.Assert(currentVMLI, 'When updating Android bounds we should always have a current VMLI');\n\n        var boxHeight = inputBox.scrollHeight;\n\n        if (boxHeight !== lastHeight)\n        {\n            var resultText = self.getBoxValue();\n\n            enabled = false;\n\n            if (currentVMLI)\n            {\n                if (currentVMLI.getRawText() !== resultText)\n                {\n                    currentVMLI.setText(resultText, /*immediateParse*/true, /*fromAndroidEditing*/true);\n                }\n\n                var cStyle = window.getComputedStyle(currentVMLI.getSpan());\n\n                inputBox.style.height = cStyle ? cStyle.height : '16px';\n            }\n\n            enabled = true;\n\n            lastHeight = boxHeight;\n        }\n    };\n\n    self.flushInput = function()\n    {\n        var resultText = self.getBoxValue();\n\n        if (DEBUG && DEBUG) log('Android Flush Input: ' + resultText);\n\n        // TODO: Only set text from android input when it has actually changed\n        if (currentVMLI.getRawText() !== resultText)\n        {\n            currentVMLI.setText(resultText, /*immediateParse*/true, /*fromAndroidEditing*/true);\n        }\n    };\n\n    self.finishInput = function(continueEditing)\n    {\n        g.Assert(self.isEnabled(), 'Must be enabled to finish input');\n\n        if (!currentVMLI)\n        {\n            return;\n        }\n\n        if (isInputVisible && !continueEditing)\n        {\n            isInputVisible = false;\n\n            inputBox.style.visibility = 'hidden';\n        }\n\n        self.flushInput();\n\n        if (DEBUG) log('Android Finished Input');\n\n        currentVMLI = undefined;\n    };\n\n    self.getBoxHasTextSpace = function()\n    {\n        var rawText = inputBox.value;\n\n        if (rawText.length === 0 || rawText[0] !== TextSpace)\n        {\n            g.Assert(rawText.indexOf(TextSpace) < 0, 'If TextSpace is not at the front of the editor, it shouldnt appear in the rest of the string');\n\n            return false;\n        }\n\n        return true;\n    };\n\n    self.getBoxValue = function()\n    {\n        var rawText = inputBox.value;\n\n        var outText = rawText.replace(TextSpace, '');\n\n        return outText;\n    };\n\n    self.setBoxValue = function(text)\n    {\n        if (!text || text.length === 0)\n        {\n            text = TextSpace;\n        }\n\n        var newText = text[0] === TextSpace ? text : (TextSpace + text);\n\n        inputBox.value = newText;\n    };\n\n    self.passKeypress = function(e)\n    {\n        //log('Keypress: ', e, currentVMLI);\n\n        if (!currentVMLI)\n        {\n            return false;\n        }\n\n        if (e.normCode === KeyCode.Enter || e.synthetic)\n        {\n            return true;\n        }\n\n        return false;\n    };\n\n    self.passKeydown = function(e)\n    {\n        //log('Keydown: ', e, currentVMLI);\n\n        if (!currentVMLI)\n        {\n            return false;\n        }\n\n        if (e.normCode === KeyCode.Tab || e.normCode === KeyCode.BackSpace || e.synthetic)\n        {\n            return true;\n        }\n\n        return false;\n    };\n\n    return self;\n});","asserts":[{"tag":1058,"offset":5085},{"tag":1059,"offset":5486},{"tag":1060,"offset":5898},{"tag":1061,"offset":5999},{"tag":1062,"offset":6858},{"tag":1063,"offset":9725},{"tag":1064,"offset":9793},{"tag":1065,"offset":10996},{"tag":1066,"offset":12237},{"tag":1067,"offset":12814}]},"VMLI_Text":{"path":"F:/p/bce/Duchess/public/js/VMLI_Text.js","data":"'use strict';\ndefine(['ko', 'data', 'gdata', 'globals', 'tracker', 'android', 'DuchessHelpers'],\nfunction (ko, d, gdata, g, tracker, android) {\nvar VMLI_Text = {\n    _runAndGetSaveData : function (text, immediateParse)\n    {\n        //log('Set Text: \\'' + text + '\\'' + '  P: ' + immediateParse);\n\n        var oldMetaData = this.getMetaTextSaveData();\n\n        this.setRawText(text);\n\n        this.parseText(immediateParse);\n\n        var newMetaData = this.getMetaTextSaveData();\n\n        // TODO: What if immediateParse is false - some of this info won't be available to save.\n\n\n        var saveData = { };\n        for (var key in newMetaData)\n        {\n            if (oldMetaData[key] !== newMetaData[key])\n            {\n                saveData[key] = newMetaData[key];\n            }\n        }\n\n        return saveData;\n    },\n    setText: function (text, immediateParse, fromAndroidEditing)\n    {\n        var saveData = this._runAndGetSaveData(text, immediateParse);\n\n        saveData['text'] = text;\n        gdata.saveChanges(this, saveData);\n\n        saveData['dateText'] = this.dateText;\n        this.save(saveData, SaveFlag.Text); // Modified text\n\n        if (immediateParse && !fromAndroidEditing && android.isEnabled())\n        {\n            android.updateInputText(this);\n        }\n    },\n    // insertText: function (index, addedText, fullText)\n    // {\n    //     var saveData = this._runAndGetSaveData(fullText, /*immediateParse*/true);\n\n    //     if (g.isEmpty(saveData))\n    //     {\n    //         gdata.insertText(this, index, addedText);\n\n    //         saveData['text'] = fullText;\n    //     }\n    //     else\n    //     {\n    //         saveData['text'] = fullText;\n\n    //         gdata.saveChanges(this, saveData, /*isText*/true);\n    //     }\n\n    //     saveData['dateText'] = this.dateText;\n    //     this.save(saveData, 'text'); // Modified text\n    // },\n    parseText: function(immediateParse)\n    {\n        var styleInfo = undefined;\n        if (immediateParse)\n        {\n            styleInfo = DuchessHelpers.parseText(\n                this.getRawText(),\n                this.getDateTime(),\n                this.isLoaded,\n                //this.formats,\n                d.getContacts()\n                );\n\n            if(styleInfo.numContacts > 0)\n            {\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.AddContact,\n                    data: [\n                    {\n                        itemID: this.id\n                    }]\n                });\n            }\n        }\n        else\n        {\n            // styleInfo = {\n            //     'lineStyle': DuchessHelpers.parseTextPrefixes(this.getRawText())\n            // };\n        }\n\n        this.styleText(styleInfo, /*parsedFull*/immediateParse);\n    },\n    styleText: function(styleInfo, parsedFull, changedStyles)\n    {\n        g.Assert(!(!styleInfo && parsedFull), 'In a full parse, styleInfo should always be defined');\n\n        var styleChanges = false;\n\n        var text;\n\n        if (styleInfo)\n        {\n            if (styleInfo.styledText !== undefined)\n            {\n                text = styleInfo.styledText;\n            }\n            else if (styleInfo.text !== undefined)\n            {\n                text = styleInfo.text;\n            }\n            else\n            {\n                text = this.getRawText();\n            }\n\n            // After a full parse for this item, set the parsed text (may be undefined)\n            if (parsedFull)\n            {\n                this.setParsedText(styleInfo.parsedText);\n            }\n\n            if (styleInfo.dates)\n            {\n                // TODO: Support multiple dates?\n                if (styleInfo.dates.length === 0 && this.date())\n                {\n                    if (this.date())\n                    {\n                        this.allDayDate = undefined;\n                        this.dateText = undefined;\n                        this.date(null);\n\n                        if (changedStyles)\n                        {\n                            styleChanges = true;\n                            changedStyles.date = undefined;\n                            changedStyles.dateText = undefined;\n                            changedStyles.allDayDate = undefined;\n                        }\n                    }\n                }\n\n                for (var i = 0; i < styleInfo.dates.length; i ++)\n                {\n                    var dt = styleInfo.dates[i];\n\n                    if (this.dateText !== dt.text)\n                    {\n                        this.dateText = dt.text;\n\n                        if (changedStyles)\n                        {\n                            styleChanges = true;\n                            changedStyles.dateText = dt.text;\n                        }\n                    }\n\n                    // If there is a change in whether this item has a date or not or the date has changed\n                    if (!dt.date || !this.date() || dt.date != this.date())\n                    {\n                        if (!!dt.date ^ !!this.date() || (this.date() && dt.date.getTime() !== this.date().getTime()))\n                        {\n                            if(dt.explicitTime)\n                            {\n                                dt.date._explicitTime = dt.explicitTime;\n                            }\n\n                            this.allDayDate = !dt.date._explicitTime;\n\n                            this.date(dt.date);\n\n                            if (changedStyles)\n                            {\n                                styleChanges = true;\n                                changedStyles.date = dt.date;\n                                changedStyles.allDayDate = dt.date._explicitTime;\n                            }\n                        }\n                    }\n                }\n            }\n            else if (this.date() && parsedFull)\n            {\n                // If there is no date string associated with the item, ensure that it is removed.\n                this.dateText = undefined;\n                this.allDayDate = undefined;\n                this.date(null);\n\n                if (changedStyles)\n                {\n                    styleChanges = true;\n                    changedStyles.date = undefined;\n                    changedStyles.dateText = undefined;\n                    changedStyles.allDayDate = undefined;\n                }\n            }\n\n            this.isStyled = styleInfo.hasStyle;\n        }\n        else\n        {\n            text = this.getRawText();\n        }\n\n        if (text.length === 0)\n        {\n            text = TextSpace;\n            parsedFull = true;\n        }\n\n        //if (parsedFull)\n        {\n            this.setStyledText(text);\n        }\n\n        return styleChanges;\n    },\n    checkFormats: function(i, format2, preventDisable)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        var format1 = this.formats[i];\n        // Equal to existing format so remove it\n        if(format2.start == format1.start && format2.end == format1.end)\n        {\n            if(!preventDisable)\n            {\n                this.formats.splice(i, 1);\n                return {neg: true, add: false};\n            }\n        }\n        // Format inside existing format\n        else if(format2.start > format1.start && format2.end < format1.end)\n        {\n            var oldEnd = format1.end;\n            format1.end = format2.start;\n            format2.start = format2.end;\n            format2.end = oldEnd;\n        }\n        // Format encapsulates existing format\n        else if(format2.start < format1.start && format2.end > format1.end)\n        {\n            this.formats.splice(i, 1);\n            return {neg: true};\n        }\n        // Format more before the start of formatted text\n        else if(format2.start < format1.start && format2.end >= format1.start)\n        {\n            format1.start = format2.start;\n            return {add: false};\n        }\n        // Format more after the end of formatted text\n        else if(format2.start <= format1.end && format2.end > format1.end)\n        {\n            format1.end = format2.end;\n            return {add: false};\n        }\n        // Unformat the end of formatted text\n        else if(format2.start > format1.start && format2.end == format1.end)\n        {\n            if(!preventDisable)\n            {\n                format1.end = format2.start;\n                return {add: false};\n            }\n        }\n        // Unformat the start of formatted text\n        else if(format2.start == format1.start && format2.end < format1.end)\n        {\n            if(!preventDisable)\n            {\n                this.formats[i].start = format2.end;\n                return {add: false};\n            }\n        }\n    },\n    toggleFormat: function(format, preventDisable)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        var add = true;\n        for(var i = 0; i < this.formats.length; i ++)\n        {\n            if(this.formats[i].tag == format.tag)\n            {\n                var ret = this.checkFormats(i, format, preventDisable);\n                if(ret && ret.add === false)\n                {\n                    add = false;\n                }\n                if(ret && ret.neg)\n                {\n                    i --;\n                }\n                if(i > 0 && this.formats[i - 1].tag == this.formats[i].tag)\n                {\n                    this.checkFormats(i - 1, this.formats[i], preventDisable);\n                }\n            }\n        }\n        if(add)\n        {\n            this.formats.push(format);\n        }\n        this.formats.sort(function (left, right)\n        {\n            return left.start - right.start;\n        });\n        this.saveFormats();\n    },\n    clearFormats: function()\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        if (this.formats.length !== 0)\n        {\n            this.formats.splice(0, this.formats.length);\n            this.saveFormats();\n        }\n    },\n    areFormatsEqual: function(formatsA, formatsB)\n    {\n        g.Assert(false, 'No formats');\n        return true;\n        // If only one formats is undefined they are different\n        if (!!formatsA ^ !!formatsB)\n        {\n            return false;\n        }\n\n        if (formatsA.length !== formatsB.length)\n        {\n            return false;\n        }\n\n        for (var i = 0; i < formatsA.length; ++i)\n        {\n            var entryA = formatsA[i];\n            var entryB = formatsB[i];\n\n            if (entryA.start !== entryB.start)\n            {\n                return false;\n            }\n\n            if (entryA.end !== entryB.end)\n            {\n                return false;\n            }\n\n            if (entryA.tag !== entryB.tag)\n            {\n                return false;\n            }\n        }\n\n        return true;\n    },\n    setFormats: function(format, isFromRemote)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n\n        if (!this.areFormatsEqual(this.formats, format))\n        {\n            this.formats = format;\n\n            this.parseText(/*immediateParse*/true);\n\n            this.saveFormats(isFromRemote);\n        }\n    },\n    appendFormats: function(newFormat, transform)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        transform = !isNaN(transform) ? transform : 0;\n        for(var i = 0; i < newFormat.length; i ++)\n        {\n            var fmt = newFormat[i];\n            if(transform)\n            {\n                this.formats.push({start: fmt.start + transform, end: fmt.end + transform, tag: fmt.tag});\n            }\n            else\n            {\n                this.formats.push(fmt);\n            }\n        }\n        this.formats.sort(function (left, right)\n        {\n            return left.start - right.start;\n        });\n        this.saveFormats();\n    },\n    getFormatsAfter: function(index)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        var ret = [];\n        for(var i = 0; i < this.formats.length; i ++)\n        {\n            var fmt = this.formats[i];\n            if(fmt.start >= index)\n            {\n                ret.push({start: fmt.start - index, end: fmt.end - index, tag: fmt.tag});\n            }\n            else if(fmt.end >= index)\n            {\n                ret.push({start: 0, end: fmt.end - index, tag: fmt.tag});\n            }\n        }\n        return ret;\n    },\n    removeFormatsAfter: function(index)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        for(var i = 0; i < this.formats.length; i ++)\n        {\n            var fmt = this.formats[i];\n            if(fmt.start > index)\n            {\n                this.formats.splice(i, 1);\n                i --;\n            }\n            else if(fmt.end > index)\n            {\n                fmt.end = index;\n            }\n        }\n        this.saveFormats();\n    },\n    transformFormats: function(index, transform)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        if (this.formats.length === 0)\n        {\n            return;\n        }\n\n        var wasModified = false;\n\n        for (var i = 0; i < this.formats.length; ++i)\n        {\n            var fmt = this.formats[i];\n\n            if(fmt.start >= index)\n            {\n                fmt.start = Math.max(fmt.start + transform, index);\n                wasModified = true;\n            }\n\n            if(fmt.end >= index)\n            {\n                // If the transform is larger than the space after the index, constrain it\n                fmt.end += Math.max(transform, index - fmt.end);\n                wasModified = true;\n            }\n\n            if(fmt.end <= 0 || fmt.start == fmt.end)\n            {\n                this.formats.splice(i, 1);\n                i --;\n                wasModified = true;\n            }\n\n            else\n            {\n                g.Assert(fmt.start >= 0);\n            }\n        }\n\n        if (wasModified)\n        {\n            this.saveFormats();\n        }\n    },\n    saveFormats: function(isFromRemote)\n    {\n        g.Assert(false, 'No formats');\n        return false;\n        g.Assert(false, 'PERF: Should not be modifying/saving formats as they are disabled');\n\n        if (!isFromRemote && this.data)\n        {\n            gdata.set(this.data, 'formats', this.formats);\n        }\n        this.save({formats: this.formats}, SaveFlag.Text);\n    }\n};\nreturn VMLI_Text;\n});\n","asserts":[{"tag":1075,"offset":2900},{"tag":1076,"offset":6906},{"tag":1077,"offset":8903},{"tag":1078,"offset":9875},{"tag":1079,"offset":10147},{"tag":1080,"offset":10988},{"tag":1081,"offset":11323},{"tag":1082,"offset":11986},{"tag":1083,"offset":12548},{"tag":1084,"offset":13037},{"tag":1085,"offset":13960},{"tag":1086,"offset":14149},{"tag":1087,"offset":14210}]},"DuchessHelpers":{"path":"F:/p/bce/Duchess/public/js/DuchessHelpers.js","data":"function DuchessHelpersWrapper(self)\n{\n\nthis.helperLibLoaded = true;\n\n// Each line may be set to any one of these. Starts of lines have the same\n// style names except they have a prefix of s (i.e. spImportant).\n\nvar VMLIFlag = {\n    LSNormal:    0x0000,\n    // LSComment:   0x0100,\n    // LSImportant: 0x0200,\n    // LSQuestion:  0x0400,\n    // LSStar:      0x0800,\n    LSComplete:  0x1000\n};\n\n// If the line style prefixes change we will need to update the @tag regex in parseText\n// var HeaderSuffix = ':';\n// var CompletePrefix = '^';\n//var ImportantPrefix = '!';\n//var StarPrefix = '*';\n//var QuestionPrefix = '?';\n//var CommentPrefix = \"/\";\nvar NumListPrefix = \"#.\";\nvar NumListPrefixOther = \"1.\";\nvar DatePrefix = '@';\nvar ContactPrefix = '+';\n\nvar cmdChar = ((navigator.userAgent.indexOf('Win') != -1) ? 'ctrl' : '');\n\nString.prototype.insertTag = function(sIndex, sTag, length, eTag)\n{\n    return (this.substr(0, sIndex) + sTag + this.substr(sIndex, length) + eTag + this.substr(sIndex + length));\n};\n\nif (typeof String.prototype.startsWith != 'function')\n{\n    String.prototype.startsWith = function (str)\n    {\n        return this.lastIndexOf(str, 0) === 0;\n    };\n}\n\nvar charMap = {\n    '&': \"&amp;\",\n    '\\\"': \"&quot;\",\n    '<': \"&lt;\",\n    '>': \"&gt;\"\n};\n\nvar softDates = [ 'YESTERDAY', 'TODAY', 'TOMORROW' ];\n\nvar tagRegexp = /(^#|[\\(\\s]#)([^\\s\\),]+)/g;\nvar dateRegexp = /(?:^@|[\\(\\s]@)([^\\s\\)]+)(\\s[^\\s\\)@]+)?(\\s[^\\s\\)@]+)?/g;\nvar linkRegexp = /\\b((?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?]))/g;\nvar minLinkRegexp = /(?:^|[\\s\\(\\[])([^\\(\\[@\\s]+\\.(?:com|org|net))/ig;\n\n// function transformFormats(formats, index, transform)\n// {\n//     for(var i = 0; i < formats.length; i ++)\n//     {\n//         var fmt = formats[i];\n//         if(fmt.start >= index)\n//         {\n//             fmt.start += transform;\n//         }\n//         if(fmt.end >= index)\n//         {\n//             fmt.end += transform;\n//         }\n//     }\n// }\n\nfunction escape (html, formats) {\n    // if(formats && formats.length > 0)\n    // {\n    //     var offset = 0;\n    //     for(var i = 0; i < html.length; i ++)\n    //     {\n    //         var mapped = charMap[html[i]];\n    //         if(mapped)\n    //         {\n    //             transformFormats(formats, i, mapped.length - 1);\n    //             offset += mapped.length;\n    //             html = html.substr(0, i) + mapped + html.substr(i + 1);\n    //             i += mapped.length;\n    //         }\n    //     }\n    //     return html;\n    // }\n    // else\n    {\n        return String(html).replace(/[&\\\"<>]/g, function (chr)\n            {\n                return charMap[chr];\n            }\n        );\n    }\n}\n\nfunction trimPunc(str)\n{\n    var outStr = str.replace(/[:,\\.\\'\\\"\\)\\]]$/g, '');\n\n    return outStr;\n};\n\n// function softToHard(date)\n// {\n//     switch(date.toLowerCase())\n//     {\n//         case 'next':\n//             return Date.today().add({hours: 12});\n//         case 'soon':\n//             return Date.today().add({days: 1, hours: 12});\n//         case 'later':\n//             return Date.today().add({days: 3, hours: 12});\n//     }\n//     return new Date(date);\n// }\n\n\nself.parseText = function (itemText, prevDate, isUpdate, contactsList)\n{\n    var hasDiffParse = false;\n    var parsedText = itemText;\n    var contacts = [ ];\n\n    if (itemText.length === 0)\n    {\n        return {\n            parsedText: undefined\n        };\n    }\n\n    var startText = itemText;\n\n    // keep track as to whether this items text has embedded style\n    var hasStyle = false;\n\n    // if (formats && formats.length > 0)\n    // {\n    //     // TODO: Replace with proper clone\n    //     formats = JSON.parse(JSON.stringify(formats));\n\n    //     hasStyle = true;\n    // }\n\n    var oldLength = itemText.length;\n    itemText = escape(itemText);\n\n    if (oldLength !== itemText.length)\n    {\n        hasStyle = true;\n    }\n\n    //\n    // Style Objects\n    //  - Start Index: sIndex\n    //  - Length: length\n    //  - Start Tag: sTag\n    //  - End Tag: eTag\n    //\n    var match,\n        startTag,\n        endTag;\n\n    var dates = [ ];\n\n    // Transform Formatting\n    {\n        // var transforms = [];\n        // function transform(index)\n        // {\n        //     var newIndex = index;\n        //     for (var i = 0; i < transforms.length; i ++)\n        //     {\n        //         if (transforms[i].index <= index)\n        //         {\n        //             newIndex += transforms[i].offset;\n        //         }\n        //     }\n\n        //     return newIndex;\n        // }\n\n        // if (formats)\n        // {\n        //     var prevStart = -1;\n        //     var offset = 0;\n        //     for (var i = 0; i < formats.length; i ++)\n        //     {\n        //         var fmt = formats[i];\n        //         var length = fmt.end - fmt.start;\n        //         var newStart = transform(fmt.start);\n        //         var newEnd = transform(fmt.end);\n        //         itemText = itemText.insertTag(newStart, '<' + fmt.tag + '>', newEnd - newStart, '</' + fmt.tag + '>');\n        //         transforms.push({index: fmt.start, offset: 3});\n        //         transforms.push({index: fmt.start + length, offset: 4});\n        //         prevStart = fmt.start;\n        //     }\n        // }\n    }\n\n    // Parse contacts\n    {\n        if (contactsList && contactsList['___info___'].count > 0 && itemText.indexOf(ContactPrefix) >= 0)\n        {\n            var words = itemText.split(' ');\n\n            var lineIndex = 0;\n            for (var i = 0; i < words.length; i ++)\n            {\n                if (words[i].indexOf(ContactPrefix) === 0)\n                {\n                    var matchedName = undefined;\n                    var combined = words[i].substring(1);\n                    for (var u = 1; u < 4; u ++)\n                    {\n                        var compStr = trimPunc(combined);\n\n                        // If we find a match, check to see if there is a longer match as well. We go\n                        // with the longest match that we can find.\n                        if (contactsList[compStr] === '')\n                        {\n                            matchedName = compStr;\n                        }\n\n                        if (i + u < words.length)\n                        {\n                            combined += ' ' + words[i + u];\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n\n                    if (matchedName)\n                    {\n                        contacts.push({name: matchedName, lineIndex: lineIndex});\n                    }\n                }\n\n                lineIndex += words[i].length + 1; // + 1 for space\n            }\n\n            if (contacts.length > 0)\n            {\n                for (var i = contacts.length - 1; i >= 0; i --)\n                {\n                    itemText = itemText.insertTag(contacts[i].lineIndex, '<p class=\"contact\">', contacts[i].name.length + 1, '</p>');\n\n                    hasStyle = true;\n                }\n            }\n        }\n    }\n\n    // Parse tags (#)\n    {\n        tagRegexp.lastIndex = 0;\n        while (match = tagRegexp.exec(itemText))\n        {\n            var matchIndex = match.index + match[1].length - 1;\n            var matchLength = match[2].length + 1;\n\n            if (match[2].charAt(match[2].length - 1) == \":\")\n            {\n                matchLength--;\n            }\n\n            itemText = itemText.insertTag(matchIndex, '<p class=\"tag\" title=\"' + cmdChar + '+click to search\">', matchLength, '</p>');\n\n            hasStyle = true;\n        }\n    }\n\n    // Parse Dates (@)\n    {\n        dateRegexp.lastIndex = 0;\n        while (match = dateRegexp.exec(itemText))\n        {\n            var prefixLength = match[0].indexOf(DatePrefix);\n\n            var dateString;\n\n            // Remove any trailing punctuation on each of the matched strings\n            var puncFound = false;\n            for (var i = 1; i < match.length && match[i]; ++i)\n            {\n                if (!puncFound)\n                {\n                    var lastChar = match[i][match[i].length - 1];\n                    if (lastChar === ':' || lastChar === ',' || lastChar === '.')\n                    {\n                        match[i] = match[i].slice(0, -1);\n\n                        puncFound = true;\n                    }\n                }\n                else\n                {\n                    match[i] = undefined;\n                }\n            }\n\n            // TODO: We can probably have a better strategy for determining the number of words in the date string\n            dateString = match[1] + (match[2] ? match[2] : '') + (match[3] ? match[3] : '');\n\n            var dt = Date.parse(dateString);\n            if (!dt && match[3])\n            {\n                dateString = match[1] + (match[2] ? match[2] : '');\n                dt = Date.parse(dateString);\n            }\n\n            if (!dt && match[2])\n            {\n                dateString = match[1];\n                dt = Date.parse(dateString);\n            }\n\n            if (dt)\n            {\n                // switch(dateString.toLowerCase())\n                // {\n                //     case 'next':\n                //     case 'soon':\n                //     case 'later':\n                //         date = softToHard(dateString);\n                //         break;\n                //     default:\n                //         date = dt;\n                // }\n\n                // log('------------------------------------');\n                // log('Text: ' + itemText + ':');\n\n                var newDateInfo = self.computeDateInfo(prevDate, isUpdate, dt, dateString);\n\n\n                if (newDateInfo.replacedDate)\n                {\n                    //log('>>>>Replaced Style Date');\n\n                    // + 2 to include the @ and space at the end\n                    dateLength = newDateInfo.text.length + 1;\n\n                    //\n                    // Replace text in the style string\n                    //\n                    {\n                        var dateTextOffset = match.index + prefixLength + 1;\n\n                        //log('      :', itemText);\n\n                        // TODO: Combine string ops\n                        itemText = itemText.substr(0, dateTextOffset) + newDateInfo.text + itemText.substr(dateTextOffset + dateString.length);\n                        //log('      :', itemText);\n\n                        itemText = itemText.insertTag(match.index + prefixLength, '<p class=\"date\">', dateLength, '</p>');\n                        //log('      :', itemText);\n                    }\n\n                    //\n                    // Replace text in the parsed string\n                    //\n                    {\n                        //log('>>>> Replaced Parsed Date');\n                        var parsedDateIndex = parsedText.indexOf(dateString);\n\n                        //log('      :', parsedText);\n\n                        parsedText = parsedText.substr(0, parsedDateIndex) + newDateInfo.text + parsedText.substr(parsedDateIndex + dateString.length);\n\n                        hasDiffParse = true;\n\n                        //log('      :', parsedText);\n                    }\n\n                    dates.push({\n                        date: newDateInfo.date,\n                        text: newDateInfo.text,\n                        explicitTime: dt._explicitTime\n                    });\n                }\n                else\n                {\n                    // + 1 to include the @\n                    dateLength = dateString.length + 1;\n\n                    itemText = itemText.insertTag(match.index + prefixLength, '<p class=\"date\">', dateLength, '</p>');\n\n                    dates.push({\n                        date: newDateInfo.date,\n                        text: dateString,\n                        explicitTime: dt._explicitTime\n                    });\n                }\n\n                //log('------------------------------------');\n\n                hasStyle = true;\n\n                // We currently only support a single date, break out early.\n                break;\n            }\n        }\n    }\n\n    // Parse hyperlinks\n    {\n        // function setHeightOnLoad(tempID, url)\n        // {\n        //     setTimeout(function() {\n        //         var $img = $(document.getElementById(tempID));\n        //         var image = new Image();\n        //         var text = '[' + url + ']';\n        //         var maxWidth = self.$element.width() - 10; // TODO: This -10 is a hack.\n        //         var sizeOfUrl = text.visualSize(maxWidth);\n        //         var heightOfUrl = sizeOfUrl.height + 5;\n        //         image.onload = function(){\n        //             var width = image.width;\n        //             var height = image.height;\n        //             var shrinkFactor = Math.min(Math.min(300 / width, 400 / height), 1);\n        //             width = width * shrinkFactor;\n        //             height = height * shrinkFactor;\n        //             $img.css({'height': height + heightOfUrl + 10 + 'px',\n        //                       'background-position': '0 ' + heightOfUrl + 'px',\n        //                       'background-size': (width) + 'px ' + (height) + 'px'});\n        //         };\n        //         image.src = url;\n        //     }, 0);\n        // }\n        linkRegexp.lastIndex = 0;\n        if (match = linkRegexp.exec(itemText))\n        {\n            // var foundImg = false;\n            // if(match.index > 0 && itemText.length > (match.index + match[0].length) &&\n            //    itemText[match.index - 1] == '[' && itemText[match.index + match[0].length] == ']')\n            // {\n            //     var regexImg = /([^\\s])+(\\.(?:jpg|png|gif|bmp))(?:\\?([^ ]*))?/g;\n            //     var match2;\n            //     while(match2 = regexImg.exec(match[0]))\n            //     {\n            //         foundImg = true;\n            //     }\n            // }\n            // if(foundImg)\n            // {\n            //     var tempID = g.generateTempID();\n            //     var url = match[0];\n\n            //     startTag = '<a id=\"' + tempID + '\" class=\"inlineImg\" style=\"background: url(' + match[0] + '); background-repeat: no-repeat;\">';\n            //     endTag = '</a>';\n            //     styleArray.push({ sIndex: match.index - 1, length: match[0].length + 2, sTag: startTag, eTag: endTag });\n\n            //     // setHeightOnLoad(tempID, url);\n            // }\n            // else\n            {\n                var linkHref = !match[0].startsWith('http') ? ('http://' + match[0]) : match[0];\n\n                startTag = \"<a target='_blank' href='\" + linkHref + \"' title='\" + cmdChar + \"+click to navigate'>\";\n                endTag = \"</a>\";\n                itemText = itemText.insertTag(match.index, startTag, match[0].length, endTag);\n                hasStyle = true;\n            }\n        }\n        else\n        {\n            minLinkRegexp.lastIndex = 0;\n            if (match = minLinkRegexp.exec(itemText))\n            {\n                var prefixLength = (match[0].length - match[1].length);\n\n                var linkHref = !match[1].startsWith('http') ? ('http://' + match[1]) : match[1];\n\n                startTag = \"<a target='_blank' href='\" + linkHref + \"' title='\" + cmdChar + \"+click to navigate'>\";\n                endTag = \"</a>\";\n                itemText = itemText.insertTag(match.index + prefixLength, startTag, match[1].length, endTag);\n                hasStyle = true;\n            }\n        }\n    }\n\n    // Parse emails\n    {\n\n    }\n\n    // Parse numbers\n    {\n\n    }\n\n    // var oldLength = itemText.length;\n    // itemText = itemText.replace(/@/g, '<span class=\"ha\">@</span>');\n                       //.replace(/#/g, '<span class=\"ht\">#</span>');\n\n    // if (oldLength !== itemText.length)\n    // {\n    //     hasStyle = true;\n    // }\n\n    // if (itemText.length > 1 && itemText[itemText.length - 1] == HeaderSuffix)\n    // {\n    //     itemText = itemText.insertTag(itemText.length - 1, '<span class=\"hc\">', 1, '</span>');\n    //     hasStyle = true;\n    // }\n\n    return {\n        text: startText,\n        styledText: itemText,\n        parsedText: (hasDiffParse ? parsedText : undefined),\n        dates: dates,\n        hasStyle: hasStyle,\n        numContacts: contacts.length\n    };\n};\n\nself.computeDateInfo = function(prevDate, isUpdate, dt, dateString)\n{\n    function getSoftText(date)\n    {\n        var DAY_LENGTH = 86400000;\n        var diff = new Date(date).clearTime() - (new Date()).clearTime();\n\n        // log('RawDiff: ', diff);\n        // log('DiffDays: ', diff / DAY_LENGTH);\n\n        if (diff < 0)\n        {\n            if (diff >= -DAY_LENGTH)\n            {\n                return 'yesterday';\n            }\n            else\n            {\n                // TODO: Check if is relative/soft date and replace with concrete date string\n                return date.toString('M/d');\n            }\n        }\n        else if (diff <= DAY_LENGTH && date.isToday())\n        {\n            return 'today';\n        }\n        else if (diff <= DAY_LENGTH * 2)\n        {\n            return 'tomorrow';\n        }\n\n        return undefined;\n    }\n\n    // log('IsUpdate: ', isUpdate);\n    // log('PrevDate: ', new Date(prevDate));\n    // log('DateText: ', dateText);\n    // log('');\n    // log('NewDateText: ', dateString);\n    // log('NewDate: ', dt);\n\n\n    var finalString = dateString;\n    var replacedDate = false;\n    var newDate;\n\n    // If this is on load, assume the prevDate is absolutely correct as we are not making\n    // local changes to the date text. Each client that modifies the text is responsible for\n    // pushing their correctly parsed version of text + timestamp.\n    if (!isUpdate)\n    {\n        newDate = new Date(prevDate)\n\n        // This is a load so the text will not be changing, however the date we are parsing\n        // may disagree with the date stored on the item. The display text may not match the\n        // stored text.\n        if (prevDate !== undefined && dt.getTime() !== prevDate)\n        {\n            if (softDates.indexOf(dateString.toUpperCase()) >= 0)\n            {\n                // TODO: Enable date loading from timestamp to correctly parse explicitTime and not cache value here\n                var explicitTime = dt._explicitTime;\n\n                newDate = new Date(prevDate);\n                //log('>>>> Dates do not match: ', newDate);\n\n                var transString = getSoftText(newDate);\n                if (transString)\n                {\n                    finalString = transString;\n\n                    if (explicitTime)\n                    {\n                        finalString += ' ' + newDate.toString('h:mmtt');\n                    }\n\n                    replacedDate = true;\n                }\n            }\n        }\n        else if (prevDate === undefined)\n        {\n            newDate = dt;\n        }\n    }\n    else\n    {\n        // This is a local or remote modification, the text may be changing relative to the\n        // previous text and timestamp. The display text should always match the stored text.\n        //log('>>>> Local Update: ', newDate);\n\n        newDate = dt;\n    }\n\n    //log('FinalString: ', finalString);\n\n    return {\n        text: finalString,\n        date: newDate,\n        replacedDate: replacedDate\n    };\n};\n\n}\n\nif (this.document)\n{\n    window.helperWrapper = DuchessHelpersWrapper;\n}\n\nif (!this.helperLibLoaded)\n{\n    DuchessHelpersWrapper(this.DuchessHelpers = this.DuchessHelpers || {});\n}\n","asserts":[]},"VMLI_Drive":{"path":"F:/p/bce/Duchess/public/js/VMLI_Drive.js","data":"'use strict';\r\ndefine(['globals', 'data', 'gdata', 'tracker'],\r\nfunction (g, d, gdata, tracker) {\r\n\r\nvar VMLI_Drive = function(VMLI)\r\n{\r\n    function iterateRemoteLink(remoteItem)\r\n    {\r\n        gdata.cacheItem(remoteItem);\r\n\r\n        iterateLink(gdata.get(remoteItem, 'items'));\r\n        iterateLink(gdata.get(remoteItem, 'archivedItems'));\r\n    }\r\n\r\n    function iterateLink(itemArray)\r\n    {\r\n        if (!itemArray)\r\n        {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < itemArray.length; ++i)\r\n        {\r\n            var item = itemArray.get(i);\r\n            g.Assert(item, 'Item must exist to get it from the array');\r\n\r\n            if (item)\r\n            {\r\n                var localItem = d.getModel(item.id);\r\n                if (localItem)\r\n                {\r\n                    localItem.linkToGDrive(item);\r\n                }\r\n                else\r\n                {\r\n                    iterateRemoteLink(item);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Remove undefined/nulls from remote list\r\n                itemArray.remove(i);\r\n\r\n                i--;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n    linkToGDrive: function(data, overwriteFromRemote)\r\n    {\r\n        g.Assert(data, 'Must be passing in valid data');\r\n\r\n        if (this.data)\r\n        {\r\n            if (DEBUG) log('Attempting to initialize an item twice with remote data', this.id);\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = data;\r\n        gdata.cacheItem(data);\r\n\r\n        this.setRemoteVersion(VersionType.Structure, gdata.getVersion(data, VersionType.Structure));\r\n        this.setRemoteVersion(VersionType.Text, gdata.getVersion(data, VersionType.Text));\r\n\r\n        if (DEBUG) log('Item: ', this.getParsedText() + ' - Local: ' + this.getVersion(VersionType.Text) + '  Remote: ' + this.getRemoteVersion(VersionType.Text));\r\n\r\n        if (overwriteFromRemote)\r\n        {\r\n            this.setVersion(VersionType.Structure, this.getRemoteVersion(VersionType.Structure));\r\n            this.setVersion(VersionType.Text, this.getRemoteVersion(VersionType.Text));\r\n        }\r\n\r\n        iterateLink(gdata.get(data, 'items'));\r\n        iterateLink(gdata.get(data, 'archivedItems'));\r\n    },\r\n    resetModified: function()\r\n    {\r\n        var i;\r\n        g.Assert(this.data, 'Can only reset modified if remote data exists');\r\n\r\n        var remoteChanged = false;\r\n\r\n        var versionChanges = { };\r\n\r\n        // If modified offline and the local version does not match the remote version then the remotee\r\n        // must have been changed. In this case, update the local version to match the remote and save it.\r\n\r\n        if (!this.modifiedOffline && this.isRemoteVersionNewer(VersionType.Structure))\r\n        {\r\n            var remoteVersion = this.getRemoteVersion(VersionType.Structure);\r\n            this.setVersion(VersionType.Structure, remoteVersion);\r\n\r\n            versionChanges.version = remoteVersion\r\n\r\n            remoteChanged = true;\r\n        }\r\n        else if (this.modifiedOffline)\r\n        {\r\n            //g.Assert(this.version >= this.versionRemote || this.version == this.versionRemote);\r\n\r\n            versionChanges.modifiedOffline = false;\r\n\r\n            remoteChanged = true;\r\n        }\r\n\r\n        if (!this.modifiedOfflineText && this.isRemoteVersionNewer(VersionType.Text))\r\n        {\r\n            var remoteVersionText = this.getRemoteVersion(VersionType.Text);\r\n            this.setVersion(VersionType.Text, remoteVersionText);\r\n\r\n            versionChanges.versionText = remoteVersionText;\r\n\r\n            remoteChanged = true;\r\n        }\r\n        else if (this.modifiedOfflineText)\r\n        {\r\n            //g.Assert(this.versionText >= this.versionRemoteText || this.versionText == this.versionRemoteText);\r\n\r\n            versionChanges.modifiedOfflineText = false;\r\n\r\n            remoteChanged = true;\r\n        }\r\n\r\n        if (remoteChanged)\r\n        {\r\n            this.save(versionChanges, SaveFlag.None);\r\n        }\r\n\r\n        // Only need remote versions while resolving conflicts\r\n        this.setRemoteVersion(VersionType.Structure, undefined);\r\n        this.setRemoteVersion(VersionType.Text, undefined);\r\n\r\n        var items = this.items();\r\n        for (i = 0; i < items.length; ++i)\r\n        {\r\n            items[i].resetModified();\r\n        }\r\n\r\n        if (this.hasArchivedChildren())\r\n        {\r\n            var archivedItems = this.archivedItems(/*underlying*/true);\r\n            for (i = 0; i < archivedItems.length; ++i)\r\n            {\r\n                archivedItems[i].resetModified();\r\n            }\r\n        }\r\n    },\r\n    initFromGDrive: function(data, parseChildren)\r\n    {\r\n        g.Assert(data, 'To initialize from gdrive a valid remote data object must be passed in');\r\n\r\n        if (!data)\r\n        {\r\n            g.reportError(new Error('FATAL ERROR - No remote data for item'));\r\n\r\n            return;\r\n        }\r\n\r\n        // log('init', this.text);\r\n\r\n        if (DEBUG && this.data)\r\n        {\r\n            g.Assert(this.data.id == data.id, 'If there is already valid data for this item, it shouldn\\'t change');\r\n            g.Assert(this.id == data.id || this.id == 'root', 'If there is already valid data for this item, it shouldn\\'t change');\r\n        }\r\n\r\n        this.data = data;\r\n        // Log color key: green = from remote, blue = to remote, pink = duplicating, orange = remove local, red = remove remote\r\n\r\n        var needsFullSave = ((this.id === undefined) || this.forceModifiedItems);\r\n\r\n        var remoteChanges = needsFullSave ? undefined : { };\r\n        var needsParsing = false;\r\n\r\n        this.id = data.id;\r\n\r\n        try\r\n        {\r\n            needsParsing = this.resolveText(remoteChanges) || needsParsing;\r\n            needsParsing = this.resolveMisc(remoteChanges) || needsParsing;\r\n\r\n            if (needsParsing)\r\n            {\r\n                g.vmMain.addParseItem(this, /*isRemoteLoad*/true);\r\n\r\n                g.vmMain.addModifiedItem(this);\r\n            }\r\n\r\n            this.resolveItems(remoteChanges, parseChildren);\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n\r\n            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.R, ResolveAction.Error, { msg: err.message, stacK: err.stack, item: this.getDebugData() }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n        }\r\n\r\n        if (needsFullSave)\r\n        {\r\n            g.Assert(remoteChanges === undefined, 'If doing a full save, remoteChanges should always be undefined');\r\n\r\n            //if (!d.hasLocalData)\r\n            {\r\n                this.setVersion(VersionType.Structure, this.getRemoteVersion(VersionType.Structure));\r\n                this.setVersion(VersionType.Text, this.getRemoteVersion(VersionType.Text));\r\n            }\r\n\r\n            this.save(null, SaveFlag.None);\r\n        }\r\n        else if (!g.isEmpty(remoteChanges))\r\n        {\r\n            if (remoteChanges.isDeleted !== true)\r\n            {\r\n                remoteChanges.isDeleted = undefined;\r\n            }\r\n\r\n            this.save(remoteChanges, SaveFlag.None);\r\n        }\r\n\r\n        gdata.attachEventsToItem(this);\r\n    },\r\n    resolveText: function(remoteChanges)\r\n    {\r\n        // Keep track of whether or not the text has changed and needs to be re-parsed\r\n        var needsParsing = false;\r\n\r\n        //\r\n        // Conflict resolution for text change\r\n        //\r\n\r\n        {\r\n            if (this.modifiedOfflineText && !this.forceModifiedItems)\r\n            {\r\n                 // If local version is newer, set it on remote otherwise if remote is newer create a conflicted item.\r\n                if (this.isLocalVersionNewer(VersionType.Text))\r\n                {\r\n                    if (DEBUG) log('%cSet text on remote', 'color: blue', this.getVersion(VersionType.Structure), this.getParsedText(), gdata.get(this.data, 'text'));\r\n\r\n                    if (REPORT_ACTIONS) { try { g.reportAction(RATAG.A, ResolveAction.SetRemoteText, { text: this.getParsedText(), item: this.getDebugData() }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                    // var localText = this.getParsedText();\r\n                    // var remoteText = gdata.get(this.data, 'text');\r\n\r\n                    gdata.saveChanges(this, { text: this.getParsedText() });\r\n                }\r\n                else\r\n                {\r\n                    var remoteText = gdata.get(this.data, 'text');\r\n                    g.Assert(remoteText !== undefined, 'Every item should have text associated with it from gdrive');\r\n\r\n                    var localText = this.getRawText();\r\n\r\n                    if (DEBUG) log('%cModified offline but out of date. Creating a duplicate item.', 'color: pink', this.getVersion(VersionType.Structure), this.getParsedText(), gdata.get(this.data, 'text'));\r\n\r\n                    var needDupe = false;\r\n\r\n                    // Only dupe the text item if the remote text and local text have changed\r\n                    // in a significant way.\r\n                    //\r\n                    // Ideally this will be replaced with a text diffing algorithm where we rarely\r\n                    // need to dupe the text entries.\r\n                    if (localText !== remoteText)\r\n                    {\r\n                        needDupe = true;\r\n                    }\r\n\r\n                    if (needDupe)\r\n                    {\r\n                        // Add a duplicated item after this one\r\n                        var thisIndex = this.getIndex();\r\n\r\n                        var newItem = new VMLI({text: this.getParsedText()}, {parent: this.parent(), forceSave: true});\r\n\r\n                        this.parent().insertItem(newItem, thisIndex + 1);\r\n\r\n                        // Set this to be the one from remote\r\n                        this.setText(remoteText, /*immediateParse*/true);\r\n\r\n                        if (REPORT_ACTIONS) { try { g.reportAction(RATAG.B, ResolveAction.DupeItem, { remoteText: remoteText, localText: this.getParsedText(), prevItem: this.getDebugData(), newItem: newItem.getDebugData() }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                        if (remoteChanges)\r\n                        {\r\n                            remoteChanges['text'] = this.getParsedText();\r\n                        }\r\n\r\n                        // TODO: Is this really necessary, we parse right above here\r\n                        needsParsing = true;\r\n                    }\r\n                    else if (remoteChanges)\r\n                    {\r\n                        remoteChanges['modifiedOfflineText'] = false;\r\n                    }\r\n\r\n                    if (remoteChanges)\r\n                    {\r\n                        // Update local text version to match remote\r\n                        remoteChanges['versionText'] = this.getRemoteVersion(VersionType.Text);\r\n                    }\r\n                }\r\n            }\r\n            else if (this.isRemoteVersionNewer(VersionType.Text))\r\n            {\r\n                var remoteText = gdata.get(this.data, 'text');\r\n                g.Assert(remoteText !== undefined, 'Every item should have text associated with it from gdrive');\r\n\r\n                if (DEBUG) log('Text: [' + this.getVersion(VersionType.Text) + '] [' + this.getRemoteVersion(VersionType.Text) + ']: ' +  remoteText);\r\n\r\n                if (this.getRawText() != remoteText)\r\n                {\r\n                    if (DEBUG) log('%cSet text from remote', 'color: green', this.getVersion(VersionType.Text), this.getParsedText(), gdata.get(this.data, 'text'));\r\n\r\n                    if (REPORT_ACTIONS) { try { g.reportAction(RATAG.C, ResolveAction.SetLocalText, { oldText: this.getRawText(), newText: remoteText, item: this.getDebugData() }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                    this.setRawText(remoteText);\r\n\r\n                    if (remoteChanges)\r\n                    {\r\n                        remoteChanges['text'] = this.getRawText();\r\n                    }\r\n\r\n                    needsParsing = true;\r\n                }\r\n\r\n                if (remoteChanges && this.getVersion(VersionType.Text) !== this.getRemoteVersion(VersionType.Text))\r\n                {\r\n                    // Update local text version to match remote\r\n                    remoteChanges['versionText'] = this.getRemoteVersion(VersionType.Text);\r\n                }\r\n            }\r\n        }\r\n\r\n        return needsParsing;\r\n    },\r\n    resolveMisc: function(remoteChanges)\r\n    {\r\n        var useLocal = this.modifiedOfflineText && this.isLocalVersionNewer(VersionType.Text);\r\n\r\n        //log('Size[' + this.data.size + ']: ' + this.data.keys());\r\n        //inspectRemote(this.data.id);\r\n\r\n        var needsParsing = false;\r\n\r\n        var modLocal = false;\r\n\r\n        // Only perform comparison on local vs remote data when one of the versions for the item is out of date.\r\n        if (useLocal || this.isRemoteVersionNewer(VersionType.Structure) || this.isRemoteVersionNewer(VersionType.Text))\r\n        {\r\n            var localChanges = { };\r\n\r\n            //\r\n            // Check remote and local properties to see if they have changed.\r\n            //\r\n\r\n            // var formats = gdata.get(this.data, 'formats');\r\n            // if (formats && formats.length > 0)\r\n            // {\r\n            //     // TODO: Conflict resolution for formats\r\n            //     var incomingFormats = JSON.parse(JSON.stringify(formats));\r\n\r\n            //     if (!this.areFormatsEqual(incomingFormats, this.formats))\r\n            //     {\r\n            //         if (useLocal)\r\n            //         {\r\n            //             localChanges['formats'] = this.formats;\r\n\r\n            //             modLocal = true;\r\n            //         }\r\n            //         else\r\n            //         {\r\n            //             this.setFormats(incomingFormats, /*isFromRemote*/true);\r\n\r\n            //             if (remoteChanges)\r\n            //             {\r\n            //                 remoteChanges['formats'] = incomingFormats;\r\n            //             }\r\n\r\n            //             needsParsing = true;\r\n            //         }\r\n            //     }\r\n            // }\r\n\r\n            // TODO: If an items is modified locally here, should it be pushing its date change at this point or wait?\r\n            var remoteDate = gdata.get(this.data, 'date');\r\n            if (remoteDate || this.date())\r\n            {\r\n                if (!this.date() || (this.date().getTime() !== remoteDate))\r\n                {\r\n                    if (useLocal && this.date())\r\n                    {\r\n                        localChanges['date'] = this.date().getTime();\r\n\r\n                        modLocal = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        // TODO: Conflict resolution for dates\r\n                        this.date(new Date(remoteDate), /*fromRemote*/true);\r\n                        this.date()._explicitTime = !!this.allDayDate;\r\n\r\n                        if (remoteChanges)\r\n                        {\r\n                            remoteChanges['date'] = this.date().getTime();\r\n                        }\r\n\r\n                        needsParsing = true;\r\n                    }\r\n                }\r\n\r\n                // AllDayDate should only be set if the date is also set\r\n                var remoteAllDayDate = gdata.get(this.data, 'allDayDate');\r\n                if (remoteAllDayDate)\r\n                {\r\n                    if (this.allDayDate !== remoteAllDayDate)\r\n                    {\r\n                        if (useLocal)\r\n                        {\r\n                            localChanges['allDayDate'] = this.allDayDate;\r\n\r\n                            modLocal = true;\r\n                        }\r\n                        else\r\n                        {\r\n                            this.allDayDate = remoteAllDayDate;\r\n\r\n                            if (remoteChanges)\r\n                            {\r\n                                remoteChanges['allDayDate'] = remoteAllDayDate;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            g.Assert(this.allDayDate === undefined || this.date() !== undefined, 'Cannot have an alldaydate with no date specified');\r\n\r\n\r\n            var remoteDateCreated = gdata.get(this.data, 'dateCreated');\r\n            if (!this.dateCreated || !remoteDateCreated || this.dateCreated.getTime() !== remoteDateCreated)\r\n            {\r\n                if (useLocal)\r\n                {\r\n                    localChanges['dateCreated'] = this.dateCreated ? this.dateCreated.getTime() : undefined;\r\n\r\n                    modLocal = true;\r\n                }\r\n                else\r\n                {\r\n                    var rDate = remoteDateCreated;\r\n                    g.Assert(typeof remoteDateCreated !== 'string', 'Invalid date format stored');\r\n\r\n                    // if (typeof remoteDateCreated == 'string')\r\n                    // {\r\n                    //     rDate = (new Date(remoteDateCreated)).getTime();\r\n\r\n                    //     gdata.saveChanges(this, { 'dateCreated': rDate });\r\n                    // }\r\n\r\n                    this.dateCreated = new Date(rDate);\r\n\r\n                    if (remoteChanges)\r\n                    {\r\n                        remoteChanges['dateCreated'] = rDate;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var remoteDateCompleted = gdata.get(this.data, 'dateCompleted');\r\n            if (remoteDateCompleted || this.dateCompleted)\r\n            {\r\n                if (!this.dateCompleted || !remoteDateCompleted || this.dateCompleted.getTime() !== remoteDateCompleted)\r\n                {\r\n                    if (useLocal)\r\n                    {\r\n                        localChanges['dateCompleted'] = this.dateCompleted ? this.dateCompleted.getTime() : undefined;\r\n\r\n                        modLocal = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        var rDate = remoteDateCompleted;\r\n                        g.Assert(typeof remoteDateCompleted !== 'string', 'Invalid date format stored');\r\n\r\n                        // if (typeof remoteDateCompleted == 'string')\r\n                        // {\r\n                        //     rDate = (new Date(remoteDateCompleted)).getTime();\r\n\r\n                        //     gdata.saveChanges(this, { 'dateCompleted': rDate });\r\n                        // }\r\n\r\n                        this.dateCompleted = new Date(rDate);\r\n\r\n                        if (remoteChanges)\r\n                        {\r\n                            remoteChanges['dateCompleted'] = rDate;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var remotePriority = gdata.get(this.data, 'priority');\r\n            if (remotePriority || this.priority())\r\n            {\r\n                if (this.priority() !== remotePriority)\r\n                {\r\n                    if (useLocal)\r\n                    {\r\n                        localChanges['priority'] = this.priority();\r\n\r\n                        modLocal = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        if (remotePriority === null)\r\n                        {\r\n                            remotePriority = VMLIFlag.None;\r\n                        }\r\n\r\n                        this.priority(remotePriority, /*fromRemote*/true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            var remoteFlagged = gdata.get(this.data, 'isFlagged');\r\n            if (remoteFlagged || this.isFlagged())\r\n            {\r\n                if (this.isFlagged() !== remoteFlagged)\r\n                {\r\n                    if (useLocal)\r\n                    {\r\n                        localChanges['isFlagged'] = this.isFlagged();\r\n\r\n                        modLocal = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        if (remoteFlagged === null)\r\n                        {\r\n                            remoteFlagged = false;\r\n                        }\r\n\r\n                        this.isFlagged(remoteFlagged, /*fromRemote*/true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            var remoteComplete = gdata.get(this.data, 'isComplete');\r\n            if (remoteComplete || this.isComplete())\r\n            {\r\n                if (this.isComplete() !== remoteComplete)\r\n                {\r\n                    if (useLocal)\r\n                    {\r\n                        localChanges['isComplete'] = this.isComplete();\r\n\r\n                        modLocal = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        if (remoteComplete === null)\r\n                        {\r\n                            remoteComplete = false;\r\n                        }\r\n\r\n                        this.isComplete(remoteComplete, /*fromRemote*/true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // TODO: We do not currently send isCollapsed state to the remote doc\r\n            // var isCollapsed = (gdata.get(this.data, 'isCollapsed') === true);\r\n            // if (isCollapsed !== !!this.isCollapsed())\r\n            // {\r\n            //     this.isCollapsed(isCollapsed);\r\n\r\n            //     remoteChanges['isCollapsed'] = isCollapsed;\r\n            // }\r\n\r\n            if (useLocal)\r\n            {\r\n                g.Assert(modLocal === !g.isEmpty(localChanges), 'Verify modLocal is computed properly. It should track any changes to localChanges');\r\n\r\n                if (modLocal === true)\r\n                {\r\n                    gdata.saveChanges(this, localChanges);\r\n                }\r\n            }\r\n        }\r\n\r\n        return needsParsing;\r\n    },\r\n    resolveItemsHelper: function(resolveArchived, remoteChanges, parseChildren)\r\n    {\r\n        if (DEBUG) log('Resolving [', resolveArchived, ']: ',  this.getParsedText());\r\n\r\n        var i,\r\n            remoteItem,\r\n            localIndex,\r\n            localItem,\r\n            localModel,\r\n            saveItemLists;\r\n\r\n        // Log color key:\r\n        //   green = from remote\r\n        //   blue = to remote\r\n        //   brown: revert local change\r\n        //   pink = duplicating\r\n        //   orange = remove local\r\n        //   red = remove remote\r\n\r\n        var collabItemList = gdata.getItemList(this.data, resolveArchived);\r\n\r\n        var itemArray;\r\n        if (resolveArchived)\r\n        {\r\n            if (this.hasArchivedChildren())\r\n            {\r\n                itemArray = this.archivedItems(/*underlying*/true);\r\n            }\r\n            else\r\n            {\r\n                itemArray = [ ];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            itemArray = this.items();\r\n        }\r\n\r\n        g.Assert(itemArray, 'Item arrays must exist');\r\n\r\n        // Check remote items\r\n        //\r\n        // Cases:\r\n        // 1. Normal = Exists in both places\r\n        // 2. Added remotely = !localItem\r\n        // 3. Deleted locally = modifiedOffline && localItem.isDeleted\r\n        // 4. Moved remotely = !modifiedOffline\r\n        // 5. Moved locally = modifiedOffline && !localItem.isDeleted\r\n        for (i = 0; collabItemList && i < collabItemList.length; i++)\r\n        {\r\n            remoteItem = collabItemList.get(i);\r\n\r\n            // In the past there have been instances of undefined/null items being improperly inserted into the\r\n            // remote arrays. In this case, simply skip the item as it is invalid. It will be removed when checking\r\n            // the remote integrity of the items array.\r\n            if (!remoteItem)\r\n            {\r\n                g.Assert(remoteItem, 'Item in remote list does not exist');\r\n                continue;\r\n            }\r\n\r\n            g.Assert(gdata.loadSeen[remoteItem.id] === undefined || gdata.loadSeen[remoteItem.id] === false, 'Items can only be seen once on the remote.');\r\n\r\n            // Mark item as being seen on remote\r\n            gdata.loadSeen[remoteItem.id] = this.id;\r\n\r\n            var localIndex = this.getIndexOf(remoteItem.id, /*isArchived*/resolveArchived);\r\n\r\n            if (localIndex >= 0)\r\n            {\r\n                // The normal case - the item has the same local and remote parent and archive status.\r\n                localModel = itemArray[localIndex];\r\n                localModel.initFromGDrive(remoteItem);\r\n            }\r\n            else\r\n            {\r\n                // If the item is not found as a child of the local parent, check to see if it is located elsewhere or\r\n                // if it was added remotely.\r\n                localItem = d.getItem(remoteItem.id);\r\n                localModel = d.getModel(remoteItem.id);\r\n\r\n                if (!localItem)\r\n                {\r\n                    // If there is no corresponding local item for the remote item, it must be a newly added remote item,\r\n                    // it needs to be added locally.\r\n                    if (DEBUG) log('%cAdding from remote', 'color: green', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                    localModel = new VMLI(\r\n                    {\r\n                        data: remoteItem,\r\n                        isArchived: resolveArchived\r\n                    },\r\n                    {\r\n                        parent: this,\r\n                        parse: parseChildren\r\n                    });\r\n\r\n                    itemArray.splice(i, 0, localModel);\r\n                    saveItemLists = true;\r\n\r\n                    if (REPORT_ACTIONS) { try { g.reportAction(RATAG.D, ResolveAction.AddLocalItem, { item: localModel.getDebugData(), parent: this.getDebugData(), index: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                    g.vmMain.addModifiedItem(localModel);\r\n                }\r\n                else\r\n                {\r\n                    // There is a corresponding local item for the remote item, however it has a different parent than the\r\n                    // remote item and may have been deleted. Based on versioning determine where to move them item.\r\n                    if (localItem.isDeleted)\r\n                    {\r\n                        g.Assert(!localModel, 'The local model should never exist when an item has been marked as deleted locally');\r\n\r\n                        // The local item has been deleted, but the item still exists in the remote, it must have been deleted locally.\r\n                        g.Assert(localItem.modifiedOffline, 'How did it get deleted if it wasn\\'t modified offline?');\r\n\r\n                        // Note: Have to specifically check versions instead of using isLocalVersionNewer because\r\n                        // the model doesn't exist due to the item being marked as isDeleted.\r\n                        if (gdata.getVersion(remoteItem, VersionType.Structure) == localItem.version)\r\n                        {\r\n                            // Not modified remotely\r\n                            if (DEBUG) log('%cDeleting from remote', 'color: red', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                            // Delete remotely\r\n                            gdata.itemRemoved({\r\n                                item: this,\r\n                                index: i,\r\n                                numToRemove: 1,\r\n                                isArchived: resolveArchived\r\n                            });\r\n\r\n                            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.E, ResolveAction.RemoveRemoteItem, { item: this.getChild(i).getDebugData(), parent: this.getDebugData(), index: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                            i--;\r\n                        }\r\n                        else\r\n                        {\r\n                            g.Assert(!localModel, 'The local model should never exist when an item has been marked as deleted locally');\r\n\r\n                            if (DEBUG) log('%cAdding deleted item back from remote', 'color: brown', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                            // Modified remotely so add it back locally. Always err on the side of keeping data instead of removing it.\r\n                            d.undeleteItem(localItem);\r\n\r\n                            localModel = new VMLI(\r\n                            {\r\n                                data: remoteItem,\r\n                                isArchived: resolveArchived\r\n                            },\r\n                            {\r\n                                parent: this,\r\n                                parse: parseChildren,\r\n                                forceSave: true\r\n                            });\r\n\r\n                            itemArray.splice(i, 0, localModel);\r\n                            saveItemLists = true;\r\n\r\n                            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.F, ResolveAction.AddBackDeletedItem, { item: localModel.getDebugData(), parent: this.getDebugData(), index: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                            g.vmMain.addModifiedItem(localModel);\r\n                        }\r\n                    }\r\n                    else if (localModel && localModel.modifiedOffline)\r\n                    {\r\n                        // If the localItem was not marked as isDeleted the localModel must exist. Additionally the localModel will have\r\n                        // a different parent than the remote item.\r\n\r\n                        // Not modified remotely, so local changes will be applied.\r\n                        if (localModel.isLocalVersionNewer(VersionType.Structure))\r\n                        {\r\n                            // It needs to be moved remotely but let the case where items are moved locally handle it when\r\n                            // traversing the local items lists.\r\n                            if (DEBUG) log('%cMoved from here locally. 0x90.', 'color: gray', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.G, ResolveAction.LocalMoveCandidate, { item: localModel.getDebugData(), parent: this.getDebugData(), index: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                            // If the item is being left alone, don't mark as seen so that it will be handled later.\r\n                            g.Assert(gdata.loadSeen[remoteItem.id] === this.id);\r\n                            gdata.loadSeen[remoteItem.id] = false;\r\n                        }\r\n                        else\r\n                        {\r\n                            // Modified remotely as well as locally, remote changes will be applied.\r\n                            if (DEBUG) log('%cMoved from here locally but overridden by remote', 'color: brown', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.H, ResolveAction.MoveLocalItem, { item: localModel.getDebugData(), oldParent: localModel.parent(), oldIndex: localModel.getIndex(), newParent: this.getDebugData(), newIndex: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                            // Move it back here\r\n                            localModel.moveTo({\r\n                                parent: this,\r\n                                index: i,\r\n                                isRemoteChange: true,\r\n                                shouldBeArchived: resolveArchived\r\n                            });\r\n\r\n                            localModel.initFromGDrive(remoteItem);\r\n                            saveItemLists = true;\r\n\r\n                            g.vmMain.addModifiedItem(localModel);\r\n                        }\r\n                    }\r\n                    // Moved remotely to here\r\n                    else if (localModel)\r\n                    {\r\n                        // The local item was neither deleted nor modified so the item was moved remotely. Update the\r\n                        // local model to reflect the remote move.\r\n                        if (DEBUG) log('%cMoved to here by remote', 'color: green', this.getRawText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                        if (REPORT_ACTIONS) { try { g.reportAction(RATAG.I, ResolveAction.MoveLocalItem, { item: localModel.getDebugData(), oldParent: localModel.parent().getDebugData(), oldIndex: localModel.getIndex(), newParent: this.getDebugData(), newIndex: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                        localModel.moveTo({\r\n                            parent: this,\r\n                            index: i,\r\n                            isRemoteChange: true,\r\n                            shouldBeArchived: resolveArchived\r\n                        });\r\n\r\n                        localModel.initFromGDrive(remoteItem);\r\n                        saveItemLists = true;\r\n\r\n                        g.vmMain.addModifiedItem(localModel);\r\n                    }\r\n                    else\r\n                    {\r\n                        if (REPORT_ACTIONS) { try { g.reportAction(RATAG.Q, ResolveAction.Error, { msg: 'Local model does not exist for local item that was not deleted', item: localModel.getDebugData(), localIndex: i, data: localItem }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                        g.reportError(new Error('Local model does not exist for local item that was not deleted.'));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (d.hasLocalData)\r\n        {\r\n            // Check local items\r\n            // Cases:\r\n            // 1. Added locally = !gdata.item() && modifiedOffline\r\n            // 2. Deleted remotely = !gdata.item() && !modifiedOffline\r\n            // 3. Moved locally = gdata.item() && modifiedOffline\r\n            // 4. Moved remotely = gdata.item() && !modifiedOffline\r\n            for (i = 0; i < itemArray.length; i++)\r\n            {\r\n                localModel = itemArray[i];\r\n\r\n                // Already processed this item in the remote check\r\n                if (gdata.loadSeen[localModel.id] === this.id)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // Item exists locally but not remotely\r\n                remoteItem = localModel.data; //gdata.item(localModel.id);\r\n                //g.Assert(remoteItem == gdata.item(localModel.id), 'Local model should always be up to date at this point');\r\n\r\n                // Doesn't exist on remote\r\n                if (!remoteItem)\r\n                {\r\n                    // Added locally\r\n                    if (localModel.modifiedOfflineText)\r\n                    {\r\n                        // Add to remote\r\n                        if (DEBUG) log('%cAdding from local', 'color: blue', this.getParsedText(), i, localModel.id, localModel.getParsedText());\r\n\r\n                        var childrenToRemove = [ ];\r\n\r\n                        var localChildren;\r\n                        if (resolveArchived)\r\n                        {\r\n                            if (localModel.hasArchivedChildren())\r\n                            {\r\n                                localChildren = localModel.archivedItems(/*underlying*/true);\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            localChildren = localModel.items();\r\n                        }\r\n\r\n                        if (localChildren)\r\n                        {\r\n                            for (var j = 0; j < localChildren.length; ++j)\r\n                            {\r\n                                // If the local child has valid remote data, it needs to be moved from its previous location\r\n                                // to this item. Additionally the child should not have been moved remotely otherwise the\r\n                                // remote move should be applied instead.\r\n                                if (localChildren[j].data && localChildren[j].isLocalVersionNewer(VersionType.Structure))\r\n                                {\r\n                                    var inTree = gdata.findInTree(localChildren[j].data);\r\n                                    g.Assert(inTree, 'Item should be found in tree');\r\n\r\n                                    if (inTree)\r\n                                    {\r\n                                        childrenToRemove.push({\r\n                                            parent: inTree.parent,\r\n                                            child: localChildren[j]\r\n                                        });\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Initialize the local item and create it remotely.\r\n                        d.initializeItem(localModel);\r\n\r\n                        gdata.itemAdded({\r\n                            item: this,\r\n                            addedItem: localModel,\r\n                            index: i,\r\n                            isArchived: resolveArchived\r\n                        });\r\n\r\n                        if (REPORT_ACTIONS) { try { g.reportAction(RATAG.J, ResolveAction.AddRemoteItem, { item: localModel.getDebugData(), parent: this.getDebugData(), index: i, isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                        if (DEBUG) log('Moving Children: ', childrenToRemove);\r\n\r\n                        // Any children that need to be moved into the newly created remote item need to be removed\r\n                        // from their current parents.\r\n                        for (var j = 0; j < childrenToRemove.length; ++j)\r\n                        {\r\n                            var removeData = childrenToRemove[j];\r\n                            g.Assert(removeData, 'Must have valid data to remove');\r\n\r\n                            var isArchived = removeData.child.isArchived();\r\n\r\n                            var remoteList = gdata.getItemList(removeData.parent, isArchived);\r\n                            g.Assert(remoteList, 'The item has children, it must have a list');\r\n\r\n                            var index = remoteList.indexOf(removeData.child.data);\r\n                            g.Assert(index >= 0, 'Remote item must be in the parents list');\r\n\r\n                            gdata.itemRemoved({\r\n                                item: removeData.parent,\r\n                                index: index,\r\n                                numToRemove: 1,\r\n                                isArchived: isArchived\r\n                            });\r\n\r\n                            if (REPORT_ACTIONS) { try { g.reportAction(RATAG.K, ResolveAction.RemoveRemoteItem, { item: removeData.child.getDebugData(), parent: d.getModel(removeData.parent.id).getDebugData(), index: index, isArchived: isArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n                        }\r\n\r\n                        // After removing remote items from their current parents, initialize the new remote item which\r\n                        // will add the items that were removed to its own items list.\r\n                        localModel.initFromGDrive(localModel.data);\r\n                    }\r\n                    else\r\n                    {\r\n                        // Item was deleted remotely, delete from local db.\r\n                        if (DEBUG) log('%cDeleted on remote', 'color: orange', this.getParsedText(), localModel.id, localModel.getParsedText(), this.getVersion(VersionType.Structure));\r\n\r\n                        if (REPORT_ACTIONS) { try { g.reportAction(RATAG.L, ResolveAction.DeleteLocalItem, { item: localModel.getDebugData(), parent: this.getDebugData(), index: localModel.getIndex(), isArchived: resolveArchived }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                        g.Assert(d.getItem(localModel.id), \"Trying to delete an item locally that doesn't exist locally\");\r\n\r\n                        this.deleteChild(localModel);\r\n                        i--;\r\n\r\n                        saveItemLists = true;\r\n\r\n                        g.vmMain.addModifiedItem(localModel);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Item exists on remote and moved locally to here\r\n                    if (localModel.modifiedOffline)\r\n                    {\r\n                        // Modified more recently than remote\r\n                        if (localModel.isLocalVersionNewer(VersionType.Structure))\r\n                        {\r\n                            if (DEBUG) log('%cMoved to here locally', 'color: blue', this.getParsedText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n\r\n                            var inTree = gdata.findInTree(remoteItem);\r\n                            g.Assert(inTree, 'Item should be found in tree');\r\n\r\n                            if (inTree)\r\n                            {\r\n                                if (REPORT_ACTIONS)\r\n                                {\r\n                                    try\r\n                                    {\r\n                                        var oldParentModel = d.getModel(inTree.parent.id);\r\n\r\n                                        g.reportAction(RATAG.M, ResolveAction.MoveRemoteItem, { item: localModel.getDebugData(), oldParent: oldParentModel ? oldParentModel.getDebugData() : undefined, oldIndex: inTree.index, newParent: localModel.parent().getDebugData(), newIndex: i, isArchived: resolveArchived });\r\n                                    }\r\n                                    catch(sErr)\r\n                                    {\r\n                                        g.reportActionCrash(sErr);\r\n                                    }\r\n                                }\r\n\r\n                                // Move the item before initializing it to avoid a recursive hierarchy\r\n                                gdata.itemMoved({\r\n                                    item: localModel,\r\n                                    newInfo: { 'index': i, 'isArchived': resolveArchived },\r\n                                    oldParent: inTree.parent,\r\n                                    oldInfo: inTree\r\n                                });\r\n                            }\r\n                            else\r\n                            {\r\n                                if (REPORT_ACTIONS) { try { g.reportAction(RATAG.N, ResolveAction.Error, { msg: 'Item not found in local tree', item: localModel.getDebugData(), localIndex: i, data: localItem }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n                            }\r\n\r\n                            localModel.initFromGDrive(remoteItem);\r\n                        }\r\n                        else\r\n                        {\r\n                            // Modified more recently on remote, do nothing.\r\n                            if (DEBUG) log('%cMoved to here locally but overridden by remote. 0x90.', 'color: gray', this.getParsedText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        // It needs to be moved locally but let the case to where it is moved handle it\r\n                        if (DEBUG) log('%cMoved from here by remote. 0x90.', 'color: gray', this.getParsedText(), i, remoteItem.id, gdata.get(remoteItem, 'text'));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!resolveArchived && collabItemList && (collabItemList.length > 0 || itemArray.length > 0))\r\n            {\r\n                // To merge two arrays of items in a sensible way without knowing the state of the array that\r\n                // they diverged from the following steps are performed:\r\n                //  1) Take the item list from the remote and create a temporary list with items whose local\r\n                //     version is newer are removed. Items that are not in both lists should be removed as well.\r\n                //  2) Reinsert the locally modified items into the temporary list at their local index.\r\n                //  3) Compute moves needed to go from the local list to the current temporary list.\r\n                //  4) Perform computed moves on the local list.\r\n                //  5) Compute moves needed to go from the remote list to the current temporary list.\r\n                //  6) Perform computed moves on the remote list.\r\n                //  7) Items that were not in both local and remote lists can be readded to the end of the list\r\n                //     or left in whatever place they were in before as they will be moved at a later step.\r\n\r\n                var localModArray = [ ];\r\n                var nonSharedArray = undefined;\r\n                var tempArray = [ ];\r\n\r\n                var remoteArray = collabItemList.asArray();\r\n\r\n                var reorderFound = false;\r\n\r\n                // Iterate over the remote array to base the destination list on. Any items that were not modified\r\n                // locally should be copied over into an array which will then have the locally modified items merged\r\n                // into them. Any items that aren't seen should be added to nonSharedArray as they are expected to remain\r\n                // at the end of the array and moved later in the conflict resolution process.\r\n                for (i = 0; i < remoteArray.length; ++i)\r\n                {\r\n                    var tempID = remoteArray[i].id;\r\n\r\n                    var tempModel = d.getModel(tempID);\r\n                    g.Assert(tempModel, 'If the remote ID exists the local item should have been created.');\r\n\r\n                    // If an item only exists remotely or was not modified locally, move it into the destination array.\r\n                    var localIndex = this.getIndexOf(tempID);\r\n                    if (!tempModel || !tempModel.modifiedOffline || !tempModel.isLocalVersionNewer(VersionType.Structure))\r\n                    {\r\n                        if (localIndex >= 0)\r\n                        {\r\n                            tempArray.push(tempID);\r\n\r\n                            if (localIndex !== i)\r\n                            {\r\n                                reorderFound = true;\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            if (!nonSharedArray)\r\n                            {\r\n                                nonSharedArray = [ ];\r\n                            }\r\n\r\n                            log(this.id + ': Item in remote array not found in local array: ', tempID);\r\n                            nonSharedArray.push(tempID);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if (localIndex >= 0)\r\n                        {\r\n                            localModArray.push(localIndex);\r\n                        }\r\n                        else\r\n                        {\r\n                            if (!nonSharedArray)\r\n                            {\r\n                                nonSharedArray = [ ];\r\n                            }\r\n\r\n                            log(this.id + ': Item in remote array not found in local array: ', tempID);\r\n                            nonSharedArray.push(tempID);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // In the case that no local items were modified skip trying to match the local remote and destination arrays as\r\n                // they are guarenteed to be equal at this point.\r\n                if (reorderFound || localModArray.length > 0)\r\n                {\r\n                    if (DEBUG && DEBUG)\r\n                    {\r\n                        var tempArrayText = [ ];\r\n                        tempArray.forEach(function (item) { tempArrayText.push(d.getModel(item)._rawText); });\r\n                        log('Orig Remote Array: ', tempArrayText.join());\r\n                    }\r\n\r\n                    // In order to guarentee correct insertion order, make sure the insert indices are sorted in ascending order.\r\n                    // The indices stored here are the expected final index of an item. Inserting in ascending order ensures that\r\n                    // the index is correct relative to the final list.\r\n                    localModArray.sort();\r\n\r\n                    // Insert the locally modified items into the destination array.\r\n                    for (i = 0; i < localModArray.length; i++)\r\n                    {\r\n                        var localItem = itemArray[localModArray[i]];\r\n\r\n                        if (localItem)\r\n                        {\r\n                            tempArray.splice(localModArray[i], 0, localItem.id)\r\n                        }\r\n\r\n                        if (DEBUG && DEBUG)\r\n                        {\r\n                            var tempArrayText = [ ];\r\n                            tempArray.forEach(function (item) { tempArrayText.push(d.getModel(item)._rawText); });\r\n                            log('Add Local - Remote Array: ', tempArrayText.join());\r\n                        }\r\n                    }\r\n\r\n                    // If there are any remote-only items, ensure that they end up at the end of the array as they should\r\n                    // be moved by a later node in the tree.\r\n                    if (nonSharedArray && nonSharedArray.length > 0)\r\n                    {\r\n                        tempArray = tempArray.concat(nonSharedArray);\r\n                    }\r\n\r\n                    if (DEBUG && DEBUG)\r\n                    {\r\n                        var remoteArrayText = [ ];\r\n                        remoteArray.forEach(function(item) { remoteArrayText.push(d.getModel(item.id)._rawText); });\r\n\r\n                        var localArrayText = [ ];\r\n                        itemArray.forEach(function (item) { localArrayText.push(d.getModel(item.id)._rawText); });\r\n\r\n                        var tempArrayText = [ ];\r\n                        tempArray.forEach(function (item) { tempArrayText.push(d.getModel(item)._rawText); });\r\n\r\n                        log('Remote Array: ', remoteArrayText.join());\r\n                        log('Local Array: ', localArrayText.join());\r\n                        log('Temp Array: ', tempArrayText.join());\r\n\r\n                        var remoteArrayText = [ ];\r\n                        collabItemList.asArray().forEach(function(item) { remoteArrayText.push(d.getModel(item.id)._rawText); });\r\n                        log('  ROrig: ', remoteArrayText.join());\r\n                    }\r\n\r\n                    // Given a temp array, find any differences between the temp array and the remote array and remove them. This is\r\n                    // done by insertion sort. Each move operation modifies the underlying remote data.\r\n                    for (i = 0; i < tempArray.length; ++i)\r\n                    {\r\n                        var searchItem = tempArray[i];\r\n\r\n                        // Only search the unsorted portion of the remote item list.\r\n                        for (var j = i; j < collabItemList.length; ++j)\r\n                        {\r\n                            var findItem = collabItemList.get(j);\r\n\r\n                            if (searchItem === findItem.id)\r\n                            {\r\n                                if (i !== j)\r\n                                {\r\n                                    var lModel = d.getModel(findItem.id);\r\n\r\n                                    if (REPORT_ACTIONS) { try { g.reportAction(RATAG.O, ResolveAction.MoveRemoteItem, { item: lModel.getDebugData(), oldParent: this.getDebugData(), oldIndex: j, newParent: lModel.parent().getDebugData(), newIndex: i, isArchived: false }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                                    var oldInfo = { 'index': j, 'isArchived': false };\r\n                                    var newInfo = { 'index': i, 'isArchived': false };\r\n\r\n                                    gdata.itemMoved({\r\n                                        item: lModel,\r\n                                        newInfo: newInfo,\r\n                                        oldParent: this,\r\n                                        oldInfo: oldInfo\r\n                                    });\r\n\r\n                                    saveItemLists = true;\r\n\r\n                                    g.vmMain.addModifiedItem(lModel);\r\n\r\n                                    if (DEBUG && DEBUG)\r\n                                    {\r\n                                        var remoteArrayText = [ ];\r\n                                        collabItemList.asArray().forEach(function(item) { remoteArrayText.push(d.getModel(item.id)._rawText); });\r\n                                        log('   Sort: ', remoteArrayText.join());\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (DEBUG && DEBUG)\r\n                    {\r\n                        var localArrayText = [ ];\r\n                        itemArray.forEach(function (item) { localArrayText.push(d.getModel(item.id)._rawText); });\r\n                        log('  LOrig: ', localArrayText.join());\r\n                    }\r\n\r\n                    // Given a temp array, find any differences between the temp array and the local array and remove them. This is also\r\n                    // done by insertion sort.\r\n                    for (i = 0; i < tempArray.length; ++i)\r\n                    {\r\n                        var searchItem = tempArray[i];\r\n\r\n                        for (var j = i; j < itemArray.length; ++j)\r\n                        {\r\n                            var findItem = itemArray[j];\r\n\r\n                            if (searchItem === findItem.id)\r\n                            {\r\n                                if (i !== j)\r\n                                {\r\n                                    if (REPORT_ACTIONS) { try { g.reportAction(RATAG.P, ResolveAction.MoveLocalItem, { item: findItem.getDebugData(), oldParent: findItem.parent().getDebugData(), oldIndex: findItem.getIndex(), newParent: this.getDebugData(), newIndex: i, isArchived: false }); } catch(sErr) { g.reportActionCrash(sErr); } }\r\n\r\n                                    findItem.moveTo({\r\n                                        parent: this,\r\n                                        index: i,\r\n                                        isRemoteChange: true,\r\n                                        shouldBeArchived: false\r\n                                    });\r\n\r\n                                    saveItemLists = true;\r\n\r\n                                    g.vmMain.addModifiedItem(findItem);\r\n\r\n                                    if (DEBUG && DEBUG)\r\n                                    {\r\n                                        var localArrayText = [ ];\r\n                                        itemArray.forEach(function (item) { localArrayText.push(d.getModel(item.id)._rawText); });\r\n                                        log('   Sort: ', localArrayText.join());\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // After ensuring items have been moved to the correct parents and any local-only items were created remotely, check\r\n            // to see if any items that were moved locally within the same parent need to be moved remotely.\r\n            // for (i = 0; i < itemArray.length; i++)\r\n            // {\r\n            //     localModel = itemArray[i];\r\n\r\n            //     // Modified locally\r\n            //     if (localModel.modifiedOffline && localModel.isLocalVersionNewer(VersionType.Structure))\r\n            //     {\r\n            //         g.Assert(localModel.data, 'Must have valid remote item');\r\n            //         var remoteIndex = this.getRemoteIndexOf(localModel.data, /*isArchived*/resolveArchived);\r\n\r\n            //         // Item is in a different place\r\n            //         if (remoteIndex >= 0 && remoteIndex !== i)\r\n            //         {\r\n            //             g.Assert(localModel.data === gdata.item(localModel.id), 'Local item should always have up to date remote at this point');\r\n\r\n            //             // Moved locally to here\r\n            //             if (DEBUG) log('%cMoved locally to', 'color:ack green', this.getParsedText(), remoteIndex, i, localModel.id, localModel.getParsedText());\r\n\r\n            //             var oldInfo = { 'index': remoteIndex, 'isArchived': resolveArchived };\r\n            //             var newInfo = { 'index': i, 'isArchived': resolveArchived };\r\n\r\n            //             gdata.itemMoved({\r\n            //                 item: localModel,\r\n            //                 newInfo: newInfo,\r\n            //                 oldParent: this,\r\n            //                 oldInfo: oldInfo\r\n            //             });\r\n\r\n            //             saveItemLists = true;\r\n\r\n            //             g.vmMain.addModifiedItem(localModel);\r\n            //         }\r\n            //     }\r\n            // }\r\n\r\n            // // Now check for any items that were moved remotely to determine if they need to be reordered as well.\r\n            // for (i = 0; i < itemArray.length; i++)\r\n            // {\r\n            //     localModel = itemArray[i];\r\n\r\n            //     if (localModel.isRemoteVersionNewer(VersionType.Structure))\r\n            //     {\r\n            //         g.Assert(localModel.data, 'Must have valid remote item');\r\n            //         var remoteIndex = this.getRemoteIndexOf(localModel.data, /*isArchived*/resolveArchived);\r\n\r\n            //         // Item is in a different place\r\n            //         if (remoteIndex >= 0 && remoteIndex !== i)\r\n            //         {\r\n            //             g.Assert(localModel.data === gdata.item(localModel.id), 'Local item should always have up to date remote at this point');\r\n\r\n            //             // Moved remotely to here\r\n            //             if (DEBUG) log('%cMoved by remote to', 'color: green', this.getParsedText(), remoteIndex, i, localModel.id, localModel.getParsedText);\r\n\r\n            //             localModel.moveTo({\r\n            //                 parent: this,\r\n            //                 index: remoteIndex,\r\n            //                 isRemoteChange: true,\r\n            //                 shouldBeArchived: resolveArchived\r\n            //             });\r\n\r\n            //             saveItemLists = true;\r\n\r\n            //             g.vmMain.addModifiedItem(localModel);\r\n            //         }\r\n            //     }\r\n            // }\r\n        }\r\n\r\n        if (saveItemLists)\r\n        {\r\n            if (d.hasLocalData)\r\n            {\r\n                if (resolveArchived)\r\n                {\r\n                    if (this.hasArchivedChildren())\r\n                    {\r\n                        this.archivedItems().valueHasMutated();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.items.valueHasMutated();\r\n                }\r\n            }\r\n\r\n            if (resolveArchived && !this.hasArchivedChildren())\r\n            {\r\n                g.Assert(itemArray.length > 0, 'If saving an archive array it should have data in it');\r\n\r\n                this.archivedItems()(itemArray);\r\n            }\r\n\r\n            if (remoteChanges)\r\n            {\r\n                remoteChanges['items'] = this.getItemsArrayForSave();\r\n            }\r\n        }\r\n    },\r\n    resolveItems: function(remoteChanges, parseChildren)\r\n    {\r\n        this.resolveItemsHelper(/*resolveArchived*/false, remoteChanges, parseChildren);\r\n        this.resolveItemsHelper(/*resolveArchived*/true, remoteChanges, parseChildren);\r\n    },\r\n    onValueChanged: function(event)\r\n    {\r\n        if (event.isLocal && !tracker.undoRedoActive)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var mappedProperty = g.translateFieldOut(event.property);\r\n\r\n        //log('Value Changed: ' + this.id + ' || ' + event.target.id);\r\n        //g.Assert(this.id === event.target.id, 'When changing values the correct item should always be handling itself');\r\n\r\n        // When creating new items, properties may be set on the realtime object before the object has been inserted into the\r\n        // tree. Due to the way that the realtime API handles these changes we will still receive the object changed event which\r\n        // should be ignored.\r\n        if (this.id !== event.target.id)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (DEBUG) log(this.id, ': Changing remote property [', mappedProperty, ']: ', event.oldValue, ' -> ', event.newValue);\r\n\r\n        switch (mappedProperty)\r\n        {\r\n            case 'version':\r\n            case 'versionText':\r\n                var remoteVersion = gdata.get(this.data, mappedProperty);\r\n\r\n                // TODO: We get a nasty ping-pong effect here if you undo/redo the same action a bunch of times.\r\n                //       How bad is it for the version to revert when undoing a change? Is there something else\r\n                //       we can do here instead that doesn't cause this?\r\n                if (remoteVersion > this[mappedProperty] || this[mappedProperty] === undefined)\r\n                {\r\n                    var changes = {\r\n                        modifiedOffline: false\r\n                    };\r\n\r\n                    changes[mappedProperty] = this[mappedProperty] = remoteVersion;\r\n\r\n                    this.save(changes, SaveFlag.None);\r\n                }\r\n                else\r\n                {\r\n                    // TODO: How terrible is not doing this?\r\n\r\n                    // if (event.isLocal && tracker.undoRedoActive)\r\n                    // {\r\n                    //     if (this[mappedProperty] !== remoteVersion)\r\n                    //     {\r\n                    //         this[mappedProperty] = (this[mappedProperty] ? this[mappedProperty] + 1 : 1);\r\n\r\n                    //         if (DEBUG) log('Setting Version During Undo:', this[mappedProperty]);\r\n\r\n                    //         gdata.set(this.data, mappedProperty, this[mappedProperty]);\r\n                    //         this.save({version: this[mappedProperty]}, /*toModify*/false);\r\n                    //     }\r\n                    // }\r\n                }\r\n\r\n                break;\r\n            case 'formats':\r\n                var formats = JSON.parse(JSON.stringify(gdata.get(this.data, 'formats')));\r\n\r\n                if (!formats)\r\n                {\r\n                    formats = [ ];\r\n                }\r\n\r\n                this.setFormats(formats, /*isFromRemote*/true);\r\n\r\n                break;\r\n            case 'priority':\r\n                this.priority(event.newValue, /*fromRemote*/true);\r\n\r\n                break;\r\n            case 'isComplete':\r\n                this.isComplete(event.newValue, /*fromRemote*/true);\r\n\r\n                break;\r\n\r\n            case 'isFlagged':\r\n                this.isFlagged(event.newValue, /*fromRemote*/true);\r\n\r\n                break;\r\n            case 'dateCompleted':\r\n                this.dateCompleted = new Date(event.newValue);\r\n                this.save({'dateCompleted': event.newValue}, SaveFlag.None);\r\n\r\n                break;\r\n            case 'isArchived':\r\n                this.isArchived(event.newValue);\r\n                this.save({'isArchived': event.newValue}, SaveFlag.None);\r\n\r\n                break;\r\n            case 'date':\r\n                this.date(new Date(event.newValue));\r\n                this.save({'date': event.newValue}, SaveFlag.None);\r\n\r\n                break;\r\n            case 'allDayDate':\r\n                this.allDayDate = event.newValue;\r\n                this.save({'allDayDate': event.newValue}, SaveFlag.None);\r\n\r\n                break;\r\n            case 'items':\r\n            case 'archivedItems':\r\n                var isArchived = !(mappedProperty === 'items');\r\n\r\n                if (event.newValue)\r\n                {\r\n                    for (var i = 0; i < event.newValue.length; ++i)\r\n                    {\r\n                        this.addRemoteItem(event.newValue.get(i), i, isArchived);\r\n                    }\r\n\r\n                    gdata.attachEventsToItem(this);\r\n                }\r\n                else\r\n                {\r\n                    g.Assert(event.oldValue.length === 0, 'Expected no items in list');\r\n\r\n                    this.removeAllRemoteItems(isArchived);\r\n\r\n                    // for (var i = 0; i < event.oldValue.length; ++i)\r\n                    // {\r\n                    //     this.removeRemoteItem(event.oldValue.get(i), i, isArchived);\r\n                    // }\r\n                }\r\n\r\n                this.save({ 'items': this.getItemsArrayForSave() }, SaveFlag.None);\r\n\r\n                break;\r\n            case 'dateCreated':\r\n                // Do Nothing\r\n                break;\r\n            case 'text':\r\n                this.onTextChanged(event);\r\n\r\n                break;\r\n            default:\r\n                if (ShouldLog(LogLevels.Error)) log('Unhandled value changed remotely: ', mappedProperty, event);\r\n                break;\r\n        }\r\n    },\r\n    onTextChanged: function(event)\r\n    {\r\n        if (event.isLocal && !tracker.undoRedoActive)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var remoteText = gdata.get(this.data, 'text');\r\n\r\n        // TODO: Avoid doing full string compare\r\n        if (remoteText != this.getRawText())\r\n        {\r\n            if (DEBUG) log('Text modified remotely', remoteText);\r\n\r\n            this.setRawText(remoteText);\r\n            this.parseText(/*immediateParse*/true);\r\n\r\n            this.save({text: this.getRawText()}, SaveFlag.None);\r\n\r\n            if (tracker.undoRedoActive)\r\n            {\r\n                //var evType = (event.type === \"text_deleted\" ? TrackerType.Remove : TrackerType.Insert);\r\n                var evType = TrackerType.SetText;\r\n                tracker.notifyStateChangedFromUndoRedo(evType,\r\n                {\r\n                    'itemID': this.id,\r\n                    'position': g.findFirstDiff(event.newValue, event.oldValue),\r\n                    'text': event.newValue\r\n                });\r\n            }\r\n        }\r\n    },\r\n    addRemoteItem: function (remoteItem, index, isArchived)\r\n    {\r\n        var remoteID = remoteItem.id;\r\n        gdata.cacheItem(remoteItem);\r\n\r\n        var localList = (isArchived ? this.archivedItems() : this.items);\r\n\r\n        if (index < localList().length && localList()[index].id === remoteID)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (DEBUG) log('Remote List Add [', index, ']: ', remoteID, gdata.get(remoteItem, 'text'));\r\n\r\n        var vmli = d.getModel(remoteID);\r\n        if (vmli)\r\n        {\r\n            //log('%cClear delete timeout', 'color: green', remoteID, d.models[remoteID].text);\r\n            clearTimeout(vmli.deleteTimeout);\r\n            vmli.deleteTimeout = undefined;\r\n        }\r\n        else\r\n        {\r\n            vmli = new VMLI({data: remoteItem}, {parent: this, parse: true});\r\n        }\r\n\r\n        // TODO: We have the potential to do two saves below for isDeleted and isArchived\r\n\r\n        // Adding a deleted item to a list, ensure that we undelete it and properly re-add it to the local cache.\r\n        if (vmli.isDeleted)\r\n        {\r\n            vmli.isDeleted = false;\r\n            vmli.save(null, SaveFlag.None);\r\n        }\r\n\r\n        if (vmli.isArchived() !== isArchived)\r\n        {\r\n            vmli.isArchived(isArchived);\r\n            vmli.save({ 'isArchived': isArchived }, SaveFlag.None);\r\n        }\r\n\r\n        vmli.parent(this);\r\n\r\n        localList.splice(index, 0, vmli);\r\n\r\n        //g.events.emit('itemAdded', vmli, /*force*/true);\r\n        g.fireCustomEvent('itemAdded', { item: vmli, force: true });\r\n\r\n        g.timeline.notifyStateChanged(vmli);\r\n\r\n        if (tracker.undoRedoActive)\r\n        {\r\n            tracker.notifyStateChangedFromUndoRedo(TrackerType.Create,\r\n            {\r\n                'itemID': vmli.id,\r\n                'parent': this.id,\r\n                'position': index,\r\n                'text': gdata.get(remoteItem, 'text')\r\n            });\r\n        }\r\n\r\n        //this.parseText(/*immediateParse*/true);\r\n        // TODO: Put this back if parsing incoming items is slow. It was taken out because\r\n        // of race conditions where onTextChanged would come in after onListAdded and set new text\r\n        // before the parse worker completed and set it back to ''\r\n        // g.vmMain.runParseWorker(vmli);\r\n    },\r\n    removeAllRemoteItems : function(isArchived)\r\n    {\r\n        if (isArchived)\r\n        {\r\n            if (this.hasArchivedChildren())\r\n            {\r\n                (this.archivedItems())([]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.items([]);\r\n        }\r\n    },\r\n    removeRemoteItem: function(remoteItem, index, isArchived, deleteLocal)\r\n    {\r\n        var localList;\r\n        if (isArchived)\r\n        {\r\n            g.Assert(this.hasArchivedChildren(), 'Must have a valid item list to remove from');\r\n            \r\n            localList = this.archivedItems();\r\n        }\r\n        else\r\n        {\r\n            localList = this.items;\r\n        }\r\n\r\n        var localItem = localList()[index];\r\n\r\n        if (!localItem || localItem.id !== remoteItem.id)\r\n        {\r\n            return;\r\n        }\r\n\r\n        g.Assert(localItem, 'Expect a valid local item to remove');\r\n        g.Assert(remoteItem.id == localItem.id, 'Remote item should match local items');\r\n\r\n        if (tracker.undoRedoActive)\r\n        {\r\n            tracker.notifyStateChangedFromUndoRedo(TrackerType.Delete,\r\n            {\r\n                'itemID': localItem.id,\r\n                'parent': this.id,\r\n                'position': index,\r\n                'previous': g.getPreviousItem(localItem).id\r\n            });\r\n        }\r\n\r\n        localList.splice(index, 1);\r\n\r\n        if (deleteLocal)\r\n        {\r\n            localItem.deleteTimeout = setTimeout(localItem.deleteFromServer.bind(localItem), 2000);\r\n        }\r\n        else\r\n        {\r\n            localItem.deleteTimeout = setTimeout(localItem.markDeleted.bind(localItem), 2000);\r\n        }\r\n    },\r\n    onListAdded: function(event)\r\n    {\r\n        if (event.isLocal && !tracker.undoRedoActive)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var areItemsArchived = false;\r\n\r\n        var remoteItemList = gdata.get(this.data, 'items');\r\n        if (!remoteItemList || event.target.id !== remoteItemList.id)\r\n        {\r\n            var remoteArchivedList = gdata.get(this.data, 'archivedItems');\r\n            if (remoteArchivedList && event.target.id === remoteArchivedList.id || !remoteItemList)\r\n            {\r\n                areItemsArchived = true;\r\n            }\r\n        }\r\n\r\n        // When creating a new item list, the values will be empty however the list will contain entries.\r\n\r\n        var getRemoteFn;\r\n        var startIndex;\r\n        var endIndex;\r\n        if (event.values.length > 0)\r\n        {\r\n            startIndex = event.index;\r\n            endIndex = startIndex + event.values.length;\r\n\r\n            getRemoteFn = function(index)\r\n            {\r\n                return event.values[index];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            startIndex = 0;\r\n            endIndex = event.target.length;\r\n\r\n            getRemoteFn = function(index)\r\n            {\r\n                return event.target.get(index);\r\n            }\r\n        }\r\n\r\n        for (var i = startIndex; i < endIndex; ++i)\r\n        {\r\n            var eventIndex = i - startIndex;\r\n            var remoteItem = getRemoteFn(eventIndex);\r\n\r\n            g.Assert(remoteItem, 'Always expect a valid item at each index');\r\n\r\n            this.addRemoteItem(remoteItem, i, areItemsArchived);\r\n        }\r\n\r\n        this.save({ 'items': this.getItemsArrayForSave() }, SaveFlag.None);\r\n    },\r\n    onListRemoved: function(event)\r\n    {\r\n        var localItem;\r\n        if (event.isLocal && !tracker.undoRedoActive)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (DEBUG)\r\n        {\r\n            log('%cOn removed:', 'color: red', this.id, d.getModel(this.id).getParsedText());\r\n\r\n            for (var idx = 0; idx < event.values.length; ++idx)\r\n            {\r\n                var remoteItem = event.values[idx];\r\n\r\n                var debugLocalItem = this.items()[event.index + idx];\r\n\r\n                if (debugLocalItem)\r\n                {\r\n                    var localText = debugLocalItem.getParsedText();\r\n\r\n                    log('Remote List Remove [', event.index, ']: ', remoteItem.id, localText);\r\n                }\r\n                else\r\n                {\r\n                    g.Assert(false, 'Should always have a valid item to be removing');\r\n                }\r\n            }\r\n        }\r\n\r\n        var areItemsArchived = false;\r\n\r\n        var remoteItemList = gdata.get(this.data, 'items');\r\n        if (!remoteItemList || event.target.id !== remoteItemList.id)\r\n        {\r\n            var remoteArchivedList = gdata.get(this.data, 'archivedItems');\r\n            if (remoteArchivedList && event.target.id === remoteArchivedList.id)\r\n            {\r\n                areItemsArchived = true;\r\n            }\r\n        }\r\n\r\n        var startIndex = event.index;\r\n        var endIndex = startIndex + event.values.length;\r\n\r\n        for (var i = endIndex - 1; i >= startIndex; i--)\r\n        {\r\n            var eventIndex = i - startIndex;\r\n\r\n            g.Assert(!!event.values[eventIndex], 'Always expect a valid item at each index');\r\n\r\n            var remoteItem = event.values[eventIndex];\r\n\r\n            // Until there is a better solution for determining when a remove is actually a deletion,\r\n            // and not a move, only mark items as deleted when removing them remotely. When doing a local\r\n            // undo action, don't mark the item deleted.\r\n            var deleteLocal = event.isLocal && tracker.undoRedoActive;\r\n            this.removeRemoteItem(remoteItem, i, areItemsArchived, deleteLocal);\r\n        }\r\n\r\n        this.save({ 'items': this.getItemsArrayForSave() }, SaveFlag.None);\r\n    },\r\n    onListSet: function(event)\r\n    {\r\n        g.Assert(false, 'What? This shouldn\\'t happen!', event);\r\n    },\r\n    onObjectChanged: function(event)\r\n    {\r\n        if (event.ocHandled)\r\n        {\r\n            //log('Event Already Handled: ', event.ocHandled, '-', this.id, event.events[0].type);\r\n\r\n            return false;\r\n        }\r\n\r\n        event.ocHandled = this.id;\r\n\r\n        event.stopPropagation();\r\n\r\n        // var pre = (event.isLocal ? 'L' : '');\r\n        // log(pre + this.id + ': ', event.events[0]);\r\n\r\n        // if (event.events[0].type == 'values_added')\r\n        // {\r\n        //     if (g.isString(event.events[0].values[0]))\r\n        //     {\r\n        //         debugger;\r\n        //     }\r\n        // }\r\n\r\n        if (event.isLocal && !tracker.undoRedoActive)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //log('[' + this.id + '] Object Changed Event: ', event);\r\n\r\n        for (var i = 0; i < event.events.length; ++i)\r\n        {\r\n            //console.log(' Type: '  + event.events[i].type);\r\n\r\n            switch (event.events[i].type)\r\n            {\r\n                case gapi.drive.realtime.EventType.TEXT_DELETED:\r\n                    this.onTextChanged(event.events[i]);\r\n                    break;\r\n                case gapi.drive.realtime.EventType.TEXT_INSERTED:\r\n                    this.onTextChanged(event.events[i]);\r\n                    break;\r\n                case gapi.drive.realtime.EventType.VALUES_ADDED:\r\n                    this.onListAdded(event.events[i]);\r\n                    break;\r\n                case gapi.drive.realtime.EventType.VALUES_REMOVED:\r\n                    this.onListRemoved(event.events[i]);\r\n                    break;\r\n                case gapi.drive.realtime.EventType.VALUE_CHANGED:\r\n                    this.onValueChanged(event.events[i]);\r\n                    break;\r\n                case gapi.drive.realtime.EventType.VALUES_SET:\r\n                    g.Assert(false, 'VALUES_SET should never be triggered');\r\n                    break;\r\n                default:\r\n                    g.Assert(false, 'Unexpected event type');\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    deleteFromServer: function()\r\n    {\r\n        if (DEBUG) log('%cDB delete item', 'color: red', this.id, this.getParsedText());\r\n\r\n        d.dbDeleteItem(this.id);\r\n        // TODO: Remove this VMLI\r\n    },\r\n    markDeleted: function()\r\n    {\r\n        d.deleteItem(this);\r\n\r\n        g.timeline.notifyStateChanged(this);\r\n    }\r\n};\r\n};\r\nreturn VMLI_Drive;\r\n});","asserts":[{"tag":1088,"offset":584},{"tag":1089,"offset":1255},{"tag":1090,"offset":2319},{"tag":1091,"offset":3095},{"tag":1092,"offset":3708},{"tag":1093,"offset":4707},{"tag":1094,"offset":5041},{"tag":1095,"offset":5159},{"tag":1096,"offset":6433},{"tag":1097,"offset":8461},{"tag":1098,"offset":11080},{"tag":1099,"offset":16207},{"tag":1100,"offset":16865},{"tag":1101,"offset":18139},{"tag":1102,"offset":21530},{"tag":1103,"offset":22897},{"tag":1104,"offset":23771},{"tag":1105,"offset":23888},{"tag":1106,"offset":26336},{"tag":1107,"offset":26609},{"tag":1108,"offset":28006},{"tag":1109,"offset":30707},{"tag":1110,"offset":34758},{"tag":1111,"offset":36636},{"tag":1112,"offset":38269},{"tag":1113,"offset":38531},{"tag":1114,"offset":38714},{"tag":1115,"offset":40326},{"tag":1116,"offset":41292},{"tag":1117,"offset":46062},{"tag":1118,"offset":56527},{"tag":1119,"offset":56877},{"tag":1120,"offset":58243},{"tag":1121,"offset":58593},{"tag":1122,"offset":59985},{"tag":1123,"offset":60842},{"tag":1124,"offset":65107},{"tag":1125,"offset":69770},{"tag":1126,"offset":70161},{"tag":1127,"offset":70230},{"tag":1128,"offset":72444},{"tag":1129,"offset":73483},{"tag":1130,"offset":74254},{"tag":1131,"offset":74964},{"tag":1132,"offset":76862},{"tag":1133,"offset":76994}]},"sounds":{"path":"F:/p/bce/Duchess/public/js/sounds.js","data":"define(['globals', 'platform'],\r\nfunction (g, platform) {\r\n    var self = {};\r\n    var bank = {};\r\n\r\n    function addSource( sound, src )\r\n    {\r\n        var source = document.createElement( 'source' );\r\n        source.src = src;\r\n        sound.appendChild( source );\r\n    }\r\n\r\n    self.add = function(name)\r\n    {\r\n        self[name] = name;\r\n        if(!bank[name])\r\n        {\r\n            var sound = document.createElement('audio');\r\n            addSource(sound, 'sounds/' + name + '.mp3');\r\n            //addSource(sound, '/sounds/' + name + '.ogg');\r\n            sound.preload = 'auto';\r\n            bank[name] = sound;\r\n        }\r\n    };\r\n\r\n    self.play = function(name)\r\n    {\r\n        if (g.settings.get(Settings.noSounds))\r\n            return;\r\n\r\n        if (!bank[name])\r\n        {\r\n            log('Tried to play a sound that has not been loaded:', name);\r\n            console.trace();\r\n            return;\r\n        }\r\n\r\n        try\r\n        {\r\n            bank[name].play();\r\n        }\r\n        catch (err)\r\n        {\r\n            log('Failed to play audio', err);\r\n        }\r\n    };\r\n\r\n    // TODO: Enable sounds\r\n    // if (!platform.demo)\r\n    // {\r\n    //     self.add('complete');\r\n    // }\r\n\r\n    return self;\r\n});","asserts":[]},"edit":{"path":"F:/p/bce/Duchess/public/js/edit.js","data":"define(['ko', 'globals', 'platform', 'android', 'VMLI', 'tracker'],\nfunction (ko, g, platform, android, VMLI, tracker) {\n    var self = { };\n\n    var selection,\n        range,\n        rangeStartContainer,\n        rangeEndContainer,\n        rangeStart,\n        rangeEnd;\n\n    var keyCodesDown = [KeyCode.Tab, KeyCode.BackSpace, KeyCode.Delete, KeyCode.Period];\n    var keyCodesArrows = [KeyCode.UpArrow, KeyCode.DownArrow, KeyCode.LeftArrow, KeyCode.RightArrow,\n                          KeyCode.Home, KeyCode.End];\n\n    var textSaveInfo = {};\n    var tempInput;\n    var lastKeypress;\n\n    var lastEditSelect = 0;\n\n    var StringNewLine = String.fromCharCode(10);\n\n    function updateSelection()\n    {\n        if (!android.isEnabled())\n        {\n            selection = g.getSelectionInfo();\n\n            if (!selection || selection.rangeCount === 0)\n            {\n                return true;\n            }\n\n            range = selection.selection.getRangeAt(0);\n            rangeStartContainer = range.startContainer;\n            rangeEndContainer = range.endContainer;\n            rangeStart = range.startOffset;\n            rangeEnd = range.endOffset;\n        }\n        else\n        {\n            if (!android.getCurrentVMLI())\n            {\n                return true;\n            }\n\n            selection = { };\n\n            range = undefined;\n            rangeStartContainer = rangeEndContainer = android.getCurrentSpan();\n            rangeStart = android.getSelectionStart();\n            rangeEnd = android.getSelectionEnd();\n        }\n    }\n\n    self.updateAutocomplete = function(e)\n    {\n       var fromArrows = e.normCode && keyCodesArrows.indexOf(e.normCode) >= 0;\n\n        // Autocomplete\n        if (g.autocomplete)\n        {\n            var selection = g.getSelectionInfo();\n\n            if (selection && selection.selection.rangeCount > 0)\n            {\n                var range = selection.selection.getRangeAt(0);\n\n                var startLI = g.getLIParent(range.startContainer);\n                var endLI = g.getLIParent(range.endContainer);\n                if (startLI && startLI === endLI && range.startOffset === range.endOffset)\n                {\n                    if (range.startContainer.tagName !== 'UL')\n                    {\n                        var item = ko.dataFor(startLI);\n                        var span = item.getSpan();\n\n                        g.Assert(span, 'Items should always have a valid span if we are performing updates in a VMPane');\n\n                        if (span)\n                        {\n                            var offset = g.getSelectOffsetsInSpan(item, span, range);\n\n                            if (offset.start === offset.end)\n                            {\n                                g.autocomplete.update({ item: item, start: offset.start, fromArrows: fromArrows });\n                            }\n                        }\n                        else\n                        {\n                            g.autocomplete.hide();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    self.onTextInput = function(e)\n    {\n        // If the last character was space and text input is not space, this was an autocorrect\n        // so replace the highlighted word with the data from the event.\n        if(textSaveInfo.item && textSaveInfo.waitAutocorrect && e.data != ' ' && e.data != StringNewLine)\n        {\n            var item = textSaveInfo.item;\n            // If autocorrect came from hitting enter, the tempInput has the text\n            var span = textSaveInfo.waitAutocorrect == 'enter' ? tempInput : item.getSpan();\n            var s = item.getParsedText();\n\n            updateSelection();\n            var offsets = g.getSelectOffsetsInSpan(item, span, range);\n\n            var oldLength = offsets.endText - offsets.startText;\n            var insertText = textSaveInfo.waitAutocorrect == 'space' ? ' ' : '';\n\n            textSaveInfo.text = s.substr(0, offsets.startText) + e.data + insertText + s.substr(offsets.endText);\n            textSaveInfo.start += e.data.length - oldLength;\n            textSaveInfo.waitAutocorrect = undefined;\n        }\n    };\n\n    self.keyup = function (element, e)\n    {\n        if(textSaveInfo.item)\n        {\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            if(textSaveInfo.text != undefined)\n            {\n                textSaveInfo.item.setText(textSaveInfo.text, true);\n            }\n\n            if(textSaveInfo.nextItem)\n            {\n                g.selectChildren(textSaveInfo.nextItem, 0, 0);\n            }\n            else\n            {\n                g.selectChildren(textSaveInfo.item, textSaveInfo.start, 0);\n            }\n\n            self.updateAutocomplete(e);\n\n            tracker.endAction(); // END TRACKER <----\n        }\n\n        textSaveInfo.item = undefined;\n        textSaveInfo.nextItem = undefined;\n        textSaveInfo.text = undefined;\n        textSaveInfo.start = undefined;\n        textSaveInfo.waitAutocorrect = undefined;\n\n        // On mobile we want to scroll to the item after it's been created\n        // so it's called here instead of in keydown\n        if (e.normCode === KeyCode.Enter || e.normCode === KeyCode.PageUp || e.normCode === KeyCode.PageDown)\n        {\n            self.scrollTextIntoView();\n        }\n\n        g.Assert(e.stopImmediatePropagation, 'Should always be defined');\n        if (e.stopImmediatePropagation)\n        {\n            e.stopImmediatePropagation();\n        }\n\n        g.Assert(e.preventDefault, 'Should always be defined');\n        if (e.preventDefault)\n        {\n            e.preventDefault();\n        }\n\n        if (e.handled)\n        {\n            return true;\n        }\n    };\n\n    self.scrollTextIntoView = function(direction, time)\n    {\n        g.Assert(direction !== 0, 'Cannot have a null scroll direction');\n\n        if (isNaN(time))\n        {\n            time = 200;\n        }\n\n        // TODO: Optimize number of times that we call this - can be somewhat expensive\n        if (!g.isScrolling)\n        {\n            updateSelection();\n\n            if (rangeEndContainer && rangeEndContainer.tagName !== 'UL' && rangeEndContainer.tagName !== 'LI')\n            {\n                //g.Assert(rangeStartContainer.nodeName == '#text', 'Expected SPAN, Actual: ' + rangeStartContainer.tagName);\n                var scrollSpan = g.getSpanParent(rangeEndContainer);\n\n                // Grab either the previous or next item to scroll into view so the current item doesnt end up at the very bottom\n                // or very top of the screen. If this is the first or last item we dont have a choice.\n                var currentItem = ko.dataFor(scrollSpan);\n\n                if (currentItem)\n                {\n                    var item;\n\n                    if (direction < 0)\n                    {\n                        item = g.getPreviousItem(currentItem, g.focusedPane) || currentItem;\n                    }\n                    else if (direction > 0)\n                    {\n                        item = g.getNextItem(currentItem, g.focusedPane) || currentItem;\n                    }\n\n                    var targetSpan = item ? item.getSpan() : scrollSpan;\n\n                    g.scrollIntoView(targetSpan, time);\n                }\n            }\n        }\n    };\n\n    self.handleSelectAll = function(pane, e)\n    {\n        updateSelection();\n\n        var firstItem = g.getFirstPaneItem(pane);\n        var lastItem = g.getLastPaneItem(pane);\n\n        g.selectMultiline(firstItem.getSpan(), 0, lastItem.getSpan(), lastItem.getParsedText().length);\n\n        //lastEditSelect = g.getItemCount(firstItem, lastItem, pane);\n\n        return false;\n    };\n\n    self.handleArrows = function(element, e)\n    {\n        g.restrictSelectionToText();\n        updateSelection();\n\n        // Up arrow\n        if ((platform.mac && e.metaKey && e.normCode === KeyCode.UpArrow) ||\n            (!platform.mac && e.ctrlKey && e.normCode === KeyCode.Home))\n        {\n            var firstItem = g.getFirstPaneItem(g.focusedPane);\n            if(e.shiftKey) // Highlight from top of box to here\n            {\n                g.selectMultiline(firstItem.getSpan(), 0, rangeEndContainer, rangeEnd);\n            }\n            else // Select top of box\n            {\n                g.selectChildren(firstItem, 0, 0);\n            }\n            g.scrollIntoView(firstItem.getSpan());\n            return false;\n        }\n        // Down arrow\n        else if ((platform.mac && e.metaKey && e.normCode === KeyCode.DownArrow) ||\n                 (!platform.mac && e.ctrlKey && e.normCode === KeyCode.End))\n        {\n            var lastItem = g.getLastPaneItem(g.focusedPane);\n\n            if (e.shiftKey) // Highlight from here to bottom of box\n            {\n                g.selectMultiline(rangeStartContainer, rangeStart, lastItem.getSpan(), lastItem.getParsedText().length);\n            }\n            else // Select bottom of box\n            {\n                g.selectChildren(lastItem, lastItem.getParsedText().length, 0);\n            }\n\n            g.scrollIntoView(lastItem.getSpan());\n\n            return false;\n        }\n        else if (!platform.mac && e.ctrlKey && e.normCode === KeyCode.UpArrow && rangeStartContainer)\n        {\n            var item = ko.dataFor(g.getSpanParent(rangeStartContainer));\n\n            var focusItem;\n            if (item.parent() === g.focusedItem)\n            {\n                if (!item.isFirstChild())\n                {\n                    g.Assert(item.getIndex() > 0, 'Should never hit this with the first item in the list');\n\n                    focusItem = item.parent().getChild(item.getIndex() - 1);\n                }\n            }\n            else\n            {\n                while (item.parent() !== g.focusedItem) { item = item.parent(); }\n\n                focusItem = item;\n            }\n\n            if (focusItem !== undefined)\n            {\n                g.selectChildren(focusItem, focusItem.getParsedText().length, 0);\n\n                g.scrollIntoView(focusItem.getSpan());\n            }\n\n            return false;\n        }\n        else if (!platform.mac && e.ctrlKey && e.normCode === KeyCode.DownArrow && rangeEndContainer)\n        {\n            var item = ko.dataFor(g.getSpanParent(rangeEndContainer));\n\n            var focusItem;\n            if (item.parent() === g.focusedItem)\n            {\n                if (!item.isLastChild())\n                {\n                    focusItem = item.parent().getChild(item.getIndex() + 1);\n                }\n            }\n            else\n            {\n                while (item.parent() !== g.focusedItem) { item = item.parent(); }\n\n                if (!item.isLastChild())\n                {\n                    focusItem = item.parent().getChild(item.getIndex() + 1);\n                }\n            }\n\n            if (focusItem !== undefined)\n            {\n                g.selectChildren(focusItem, focusItem.getParsedText().length, 0);\n\n                g.scrollIntoView(focusItem.getSpan());\n            }\n\n            return false;\n        }\n\n        if (rangeStartContainer === undefined || rangeEndContainer === undefined)\n        {\n            // If there is no selection present bail out early\n            return true;\n        }\n\n        if (e.normCode === KeyCode.LeftArrow || e.normCode === KeyCode.RightArrow)\n        {\n            updateSelection();\n\n            var li = g.getLIParent(rangeStartContainer);\n            var li2 = g.getLIParent(rangeEndContainer);\n            if (li == li2)\n            {\n                var item = ko.dataFor(li);\n                if (item.getParsedText().length === 0)\n                {\n                    if (e.normCode === KeyCode.LeftArrow)\n                    {\n                        var prev = g.getPreviousItem(item, g.focusedPane);\n                        if (prev)\n                        {\n                            g.selectChildren(prev, prev.getParsedText().length, 0);\n                        }\n                    }\n                    else if (e.normCode === KeyCode.RightArrow)\n                    {\n                        var next = g.getNextItem(item, g.focusedPane);\n                        if (next)\n                        {\n                            g.selectChildren(next, 0, 0);\n                        }\n                    }\n\n                    return false;\n                }\n            }\n        }\n        else if (platform.ie && (e.normCode === KeyCode.UpArrow || e.normCode === KeyCode.DownArrow))\n        {\n            updateSelection();\n\n            if (e.normCode === KeyCode.UpArrow)\n            {\n                var oldItem = ko.dataFor(g.getLIParent(rangeStartContainer));\n\n                var newItem = g.getPreviousItem(oldItem, g.focusedPane);\n            }\n            else if (e.normCode === KeyCode.DownArrow)\n            {\n                var oldItem = ko.dataFor(g.getLIParent(rangeEndContainer));\n\n                var newItem = g.getNextItem(oldItem, g.focusedPane);\n            }\n\n            if (newItem)\n            {\n                if (rangeStartContainer === rangeEndContainer)\n                {\n                    var selOffset = g.getSelectOffsetsInSpan(undefined, rangeEndContainer, range);\n                    var offset = Math.min(selOffset.start, newItem.getParsedText().length);\n                }\n                else\n                {\n                    var offset = newItem.getParsedText().length;\n                }\n\n                g.selectChildren(newItem, offset, 0);\n\n                return false;\n            }\n        }\n\n        self.updateAutocomplete(e);\n\n        return true;\n    };\n\n    self.keydown = function (element, e)\n    {\n        // log('down', e);\n        var ret = true;\n        if (keyCodesDown.indexOf(e.normCode) >= 0)\n        {\n            ret = self.keypress(element, e, /*fromKeydown*/true);\n        }\n        else if (keyCodesArrows.indexOf(e.normCode) >= 0)\n        {\n            ret = self.handleArrows(element, e);\n        }\n        else if (platform.mac && e.metaKey || !platform.mac && e.ctrlKey)\n        {\n            if (e.normCode === KeyCode.A)\n            {\n                return self.handleSelectAll(element, e);\n            }\n            else if (e.normCode === KeyCode.Y || e.normCode === KeyCode.Z)\n            {\n                return self.keypress(element, e, /*fromKeydown*/true);\n            }\n        }\n\n        // if (self.nextKeypressFormat)\n        // {\n        //     var keyCodeUnformat = [KeyCode.LeftArrow, KeyCode.UpArrow, KeyCode.RightArrow, KeyCode.DownArrow];\n        //     if (keyCodeUnformat.indexOf(e.normCode) >= 0)\n        //     {\n        //         self.nextKeypressFormat = undefined;\n        //     }\n        // }\n\n        switch (e.normCode)\n        {\n            case KeyCode.Enter:\n                // On mobile scrollTextIntoView on Enter is called by keyUp. On Android the keyUp event\n                // may not be processed so call it here.\n                if (!platform.mobile || android.isEnabled())\n                {\n                    self.scrollTextIntoView();\n                }\n\n                break;\n            case KeyCode.UpArrow:\n                if(platform.mac && !e.metaKey)\n                {\n                    self.scrollTextIntoView(-1, 10);\n                }\n                break;\n            case KeyCode.DownArrow:\n                if(platform.mac && !e.metaKey)\n                {\n                    self.scrollTextIntoView(1, 10);\n                }\n                break;\n            default:\n                // TODO: Make this smarter?\n                var validCharacter = (e.normCode >= 32 && e.normCode <= 90 && e.normCode !== KeyCode.Period) || e.normCode === KeyCode.Enter;\n                // If it's a character and not a hotkey press, scroll into view\n                if(validCharacter && !(platform.mac && e.metaKey) && !(!platform.mac && e.ctrlKey))\n                {\n                    self.scrollTextIntoView();\n                }\n\n                break;\n        }\n\n        return ret;\n    };\n\n    //\n    //\n    // <ul>\n    //   <li>                         Case A\n    //     <span>#text</span>\n    //   </li>\n    //   <li>                         Case B\n    //     <span>#text</span>\n    //     <!-- Comment -->\n    //     <ul>\n    //       <li>\n    //         <span>#text</span>\n    //       </li>\n    //     </ul>\n    //     <!-- Comment -->\n    //   </li>\n    // </ul>\n    //\n    self.keypress = function (element, e, fromKeydown)\n    {\n        // log('press', e);\n        var keyCodes = [KeyCode.Enter];\n\n        //console.log('Pressed: [' + String.fromCharCode(e.which) + ']  ' + 'Code: ' + e.normCode);\n        g.Assert(e.stopPropagation, 'Should always be defined');\n        if(e.stopPropagation)\n            e.stopPropagation();\n\n        var returnValue = true;\n\n        var validCharacter = (e.normCode >= 32 && e.normCode !== KeyCode.Period) || keyCodes.indexOf(e.normCode) >= 0;\n\n        var skipCharacter = (platform.mobile && e.normCode === KeyCode.Delete) || (e.which === 0);\n\n        //log('KeyPress: (fromKeydown: ' + fromKeydown + ') (validCharacter: ' + validCharacter + ') (normCode: ' + e.normCode + ')');\n\n        // TODO: Optimize perf for updates/saving!\n        if (!skipCharacter && (fromKeydown || validCharacter))\n        {\n            updateSelection();\n\n            if (!selection && !android.isEnabled())\n            {\n                return true;\n            }\n\n            if (platform.mac && e.metaKey || !platform.mac && e.ctrlKey)\n            {\n                if (e.normCode === KeyCode.Y || e.normCode === KeyCode.Z)\n                {\n                    if (e.normCode === KeyCode.Z && !e.shiftKey)\n                    {\n                        tracker.undoAction();\n                        g.sendEvent('Hotkey', 'Undo');\n                    }\n                    else\n                    {\n                        tracker.redoAction();\n                        g.sendEvent('Hotkey', 'Redo');\n                    }\n\n                    e.handled = true;\n\n                    g.Assert(e.preventDefault, 'Should always be defined');\n                    if(e.preventDefault)\n                        e.preventDefault();\n\n                    return true;\n                }\n                else\n                {\n                    var keyChar = String.fromCharCode(e.normCode);\n                    //console.log(e.normCode, keyChar);\n                    switch(keyChar)\n                    {\n                        case 'c':\n                        case 'C':\n                            e.handled = true;\n                            return true;\n                        case 'v':\n                        case 'V':\n                            e.handled = true;\n                            return true;\n                        case 'r':\n                        case 'R':\n                        case 'a':\n                        case 'A':\n                            e.handled = true;\n                            return true;\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            var item;\n\n            // If selection is in the content UL and there are no items, this UL is empty or has no matching search results.\n            // So add an item here and continue as normal.\n            if (rangeStartContainer.nodeName == 'UL')\n            {\n                var pane = ko.dataFor(rangeStartContainer);\n                if(!(pane instanceof VMLI))\n                {\n                    // item is the VMPane\n                    item = pane.addItemToPane('', 0);\n                    span = item.getSpan();\n                    g.selectChildren(item, 0, 0);\n                }\n            }\n\n            // Ensure that our selection range is valid and fully inside the <span> elements\n            g.restrictSelectionToText();\n            updateSelection();\n\n            g.Assert(android.isEnabled() || rangeStartContainer.nodeName == '#text' || rangeStartContainer.nodeName == 'SPAN', 'Expected SPAN, Actual: ' + rangeStartContainer.tagName);\n            var startSpan = g.getSpanParent(rangeStartContainer);\n\n            g.Assert(android.isEnabled() || rangeEndContainer.nodeName == '#text' || rangeEndContainer.nodeName == 'SPAN', 'Expected SPAN, Actual: ' + rangeEndContainer.tagName);\n            var endSpan = g.getSpanParent(rangeEndContainer);\n\n            // console.log(rangeStart, range.startContainer, ' -- ', rangeEnd, range.endContainer);\n\n            if (!startSpan || !endSpan)\n            {\n                e.stopPropagation();\n                e.preventDefault();\n\n                return false;\n            }\n\n\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n\n            // Multiselect\n            if (startSpan != endSpan && e.normCode !== KeyCode.Tab)\n            {\n                returnValue = returnValue && self.handleMultiselect(e, startSpan, endSpan, range);\n            }\n\n            var specialKeys = [KeyCode.Tab, KeyCode.Enter, KeyCode.BackSpace, KeyCode.Delete];\n            if (returnValue && specialKeys.indexOf(e.normCode) >= 0)\n            {\n                // TODO: Unduplicate work from spans above\n                var span = g.getSpanParent(selection.node);\n                g.Assert(android.isEnabled() || (span && span.tagName === 'SPAN'), 'Expected SPAN, Actual: ' + span.tagName);\n\n                if (span)\n                {\n                    // If we're holding shift and hitting backspace, unindent\n                    var treatBackspaceLikeTab = false;\n                    if (e.shiftKey && e.normCode === KeyCode.BackSpace)\n                    {\n                        var startOffset = g.getSelectOffsetsInSpan(undefined, span, range);\n\n                        if (startOffset.start === 0)\n                        {\n                            treatBackspaceLikeTab = true;\n                        }\n                    }\n\n                    if (e.normCode === KeyCode.Tab || treatBackspaceLikeTab)\n                    {\n                        returnValue = returnValue && self.handleTab(e, range);\n                    }\n                    else if (e.normCode === KeyCode.Enter)\n                    {\n                        returnValue = returnValue && self.handleEnter(e, span, range);\n                    }\n                    else if (e.normCode === KeyCode.BackSpace)\n                    {\n                        returnValue = returnValue && self.handleBackspace(e, span, range);\n\n                        if (!textSaveInfo.item)\n                        {\n                            self.updateAutocomplete(e);\n                        }\n                    }\n                    else if (e.normCode === KeyCode.Delete)\n                    {\n                        returnValue = returnValue && self.handleDelete(e, span, range);\n                    }\n                }\n            }\n\n            var keyCode = e.normCode; // TODO: Why are we using which for this particular case?\n            if (e.normCode === KeyCode.Period)\n            {\n                keyCode = (e.shiftKey ? KeyCode.RAngle : KeyCode.Delete);\n            }\n\n            var character = String.fromCharCode(keyCode);\n\n            if (returnValue && character && e.normCode !== KeyCode.BackSpace && e.normCode !== KeyCode.Enter && !e.ctrlKey)\n            {\n                updateSelection();\n\n                g.Assert(g.getSpanParent(rangeStartContainer) == g.getSpanParent(rangeEndContainer));\n\n                var span = g.getSpanParent(selection.node);\n                g.Assert(android.isEnabled() || span.tagName === 'SPAN', 'Expected SPAN, Actual: ' + span.tagName);\n\n                if (!item)\n                {\n                    item = g.getItemForElement(span);\n                }\n\n                g.Assert(item, 'Must be able to get a valid item from the selected span');\n\n                var offsets = g.getSelectOffsetsInSpan(item, span, range);\n\n                var s;\n                if (android.isEnabled())\n                {\n                    s = android.getInputText();\n                }\n                else\n                {\n                    s = item.getParsedText();\n                }\n\n                var onlyInsert = true;\n                var newText = s.substr(0, offsets.startText) + character + s.substr(offsets.endText);\n\n                if (offsets.startText !== offsets.endText)\n                {\n                    onlyInsert = false;\n\n                    tracker.performAction(TrackerType.Remove, {\n                        'itemID': item.id,\n                        'position': offsets.startText,\n                        'text': s.slice(offsets.startText, offsets.endText)\n                    });\n                }\n\n                // item.transformFormats(offsets.start, 1);\n                // if (self.nextKeypressFormat)\n                // {\n                //     item.toggleFormat({start: offsets.start, end: offsets.start + 1, tag: self.nextKeypressFormat});\n                //     self.nextKeypressFormat = undefined;\n                // }\n\n                tracker.performAction(TrackerType.Insert, {\n                    'itemID': item.id,\n                    'position': offsets.startText,\n                    'text': character\n                });\n\n                if (platform.ios)\n                {\n                    textSaveInfo.text = newText;\n                    textSaveInfo.start = offsets.start + 1;\n                    textSaveInfo.waitAutocorrect = (character == ' ') ? 'space' : undefined;\n                    textSaveInfo.item = item;\n                    returnValue = true;\n                }\n                else\n                {\n                    g.clearSelection();\n                    item.setText(newText, /*setImmediate*/true);\n\n                    g.selectChildren(item, offsets.start + 1, 0);\n                    returnValue = false;\n\n                    g.Assert(e.preventDefault, 'Should always be defined');\n                    if(e.preventDefault)\n                        e.preventDefault();\n\n                    self.updateAutocomplete(e);\n                }\n            }\n\n            tracker.endAction(); // END TRACKER <----\n        }\n\n        lastKeypress = e.normCode;\n\n        return returnValue;\n    };\n\n    self.handleMultiselect = function(e, startSpan, endSpan, range)\n    {\n        var arrToDelete = [ ];\n\n        var levelsDeep = 0;\n        var returnValue = true;\n\n        var startLI = startSpan.parentNode;\n        var endLI = endSpan.parentNode;\n\n        g.Assert(startLI.tagName == 'LI', 'Expected LI, Actual: ', startLI);\n        g.Assert(endLI.tagName == 'LI', 'Expected LI, Actual: ', endLI);\n\n        // Ensure that this actually is a multi-select scenario, we can do the same actions cheaper\n        // through the non-multiselect functions.\n        g.Assert(startLI != endLI);\n\n\n        var startItem = ko.dataFor(startLI);\n        var endItem = ko.dataFor(endLI);\n        var nextItem = startItem;\n\n        var startOffset = g.getSelectOffsetsInSpan(startItem, startSpan, range);\n        var endOffset = g.getSelectOffsetsInSpan(endItem, endSpan, range);\n\n        // Track the number of fullscreen child headers that are affected\n        var fscount = 0;\n\n        // Add all lines in the selection to arrToDelete\n        do\n        {\n            var nextItemOptions = { numLevels: 0 };\n            nextItem = g.getNextItem(nextItem, g.focusedPane, nextItemOptions);\n\n            if (nextItem.parent() === g.focusedPane.item() && nextItem.isHeader())\n            {\n                fscount++;\n            }\n\n            levelsDeep += nextItemOptions.numLevels;\n\n            if (nextItem !== endItem || endOffset.end === endOffset.total)\n            {\n                arrToDelete.push(nextItem);\n            }\n        } while (nextItem !== endItem);\n\n        // Check the total number of items as well as the total number of fullscreen child headers to determine if\n        // the user should be prompted to confirm their action.\n        var doAction = true;\n        if (arrToDelete.length >= 16 && fscount >= 2)\n        {\n            if (!platform.packagedApp)\n            {\n                doAction = confirm('You have selected a large number of items to delete, please confirm you want to perform this action.');\n            }\n        }\n\n        if (doAction)\n        {\n            var newStartText;\n\n            // If starting or ending mid-text combine the items\n            if (startOffset.start > 0 || endOffset.end < endOffset.total)\n            {\n                var startText = startItem.getParsedText();\n                var textAdded = endItem.getParsedText().substring(endOffset.endText);\n\n                // Set text to be the combination of the unselected regions of the first and last items\n                newStartText = startText.substring(0, startOffset.startText) + textAdded;\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': startItem.id,\n                    'position': startOffset.startText,\n                    'text': startText.slice(startOffset.startText)\n                });\n\n                tracker.performAction(TrackerType.Insert, {\n                    'itemID': startItem.id,\n                    'position': startOffset.startText,\n                    'text': textAdded\n                });\n\n                if (arrToDelete.indexOf(endItem) < 0)\n                {\n                    arrToDelete.push(endItem);\n                }\n\n                // If wholly replacing the text of the start object, reset the properties of the object to match the end.\n                if (startOffset.start === 0)\n                {\n                    startItem.copyProperties(endItem);\n                }\n            }\n            else\n            {\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': startItem.id,\n                    'position': 0,\n                    'text': startItem.getParsedText()\n                });\n\n                // console.log('else', range.startOffset, range.endOffset, range.startContainer);\n                newStartText = \"\";\n            }\n\n            // This performs the delete action, so if that was the key pressed, return false\n            if (e.normCode === KeyCode.BackSpace || e.normCode === KeyCode.Delete || e.normCode === KeyCode.Enter)\n            {\n                returnValue = false;\n            }\n\n            // Move all children from the endItem to the startItem\n            endItem.moveChildren(startItem, 0);\n\n            // If the last LI is a sub-item, all subsequent sub-items need to be moved\n            if (levelsDeep > 0)\n            {\n                var arrToMove = [ ];\n                var next;\n\n                if (endLI.children.length > 1)\n                {\n                    // TODO: Will need to change this from hardcoded children to finding them.\n                    next = endLI.children[1].children[0];\n                }\n                else\n                {\n                    next = endLI.nextElementSibling;\n                }\n\n                var nextChild = next;\n                while (levelsDeep > 0 && nextChild)\n                {\n                    levelsDeep--;\n\n                    while (nextChild !== undefined && nextChild !== null)\n                    {\n                        arrToMove.push(nextChild);\n                        nextChild = nextChild.nextElementSibling;\n                    }\n\n                    next = next.parentElement.parentElement;\n                    nextChild = next.nextElementSibling;\n                }\n\n                // TODO: Can we optimize the moves of the children to avoid recomputing the templates each time?\n                if (arrToMove.length > 0)\n                {\n                    var firstDelete = startItem;//ko.dataFor(arrToDelete[0]);\n                    var parentToMoveTo = firstDelete.parent();// levelsDeep > 0 ? firstDelete.parent() : firstDelete;\n                    var index = firstDelete.getIndex() + 1;\n\n                    for (var i = 0; i < arrToMove.length; i++)\n                    {\n                        var item = ko.dataFor(arrToMove[i]);\n                        var oldParent = item.parent();\n\n                        item.moveTo({parent: parentToMoveTo, index: index});\n\n                        var oldIndex = item.parent().getIndexOf(item);\n\n                        tracker.performAction(TrackerType.Move, {\n                            'itemID': item.id,\n                            'oldParent': oldParent.id,\n                            'oldPosition': oldIndex,\n                            'newParent': parentToMoveTo.id,\n                            'newPosition': index\n                        });\n\n                        index++;\n                    }\n                }\n            }\n\n            // TODO: Can we optimize the deletion of the children to avoid recomputing the templates each time?\n            for (var i = 0; i < arrToDelete.length; i++)\n            {\n                var item = arrToDelete[i];\n                g.Assert(item, 'Item must exist');\n\n                if (!item.isDeleted)\n                {\n                    item.parent().deleteChild(item);\n                }\n            }\n\n            startItem.setText(newStartText, /*setImmediate*/true);\n\n            // Set selection to the start of the selection\n            g.selectChildren(startItem, startOffset.start, 0);\n        }\n        else\n        {\n            returnValue = false;\n        }\n\n        return returnValue;\n    };\n\n    self.handleTab = function(e, range)\n    {\n        if (android.isEnabled())\n        {\n            // Android will always be a single item selection\n            var startItem = android.getCurrentVMLI();\n            var endItem = android.getCurrentVMLI();\n        }\n        else\n        {\n            var startSpan = g.getSpanParent(range.startContainer);\n            var endSpan = g.getSpanParent(range.endContainer);\n\n            var startOffset = g.getSelectOffsetsInSpan(undefined, startSpan, range);\n            var endOffset = g.getSelectOffsetsInSpan(undefined, endSpan, range);\n\n            g.Assert(startSpan.parentNode.tagName == 'LI', 'Expected LI, Actual: ', startSpan.parentNode);\n            g.Assert(endSpan.parentNode.tagName == 'LI', 'Expected LI, Actual: ', endSpan.parentNode);\n\n            var startItem = ko.dataFor(startSpan.parentNode);\n            var endItem = ko.dataFor(endSpan.parentNode);\n        }\n\n        var nextItem = startItem;\n\n        var needUpdate = { };\n\n        var itemsToTab = [ startItem ];\n        var siblingsToMove = [ ];\n\n        var parent;\n        var newParent;\n\n        var moved = { };\n        var itemsHighlighted = { };\n\n        itemsHighlighted[startItem.id] = true;\n\n        if (startItem !== endItem)\n        {\n            // Add all lines in the selection to itemsToTab\n            do\n            {\n                // TODO: Should this ignore items not in search?\n                var nextItemOptions = { numLevels: 0, ignoreSearch: true };\n                nextItem = g.getNextItem(nextItem, undefined, nextItemOptions);\n\n                parent = nextItem.parent();\n                itemsToTab.push(nextItem);\n                itemsHighlighted[nextItem.id] = true;\n            } while (nextItem !== endItem);\n        }\n\n        // Note: These variables need to be declared at this scope to support the for loop before\n        var i, condition, increment;\n        if (e.shiftKey)\n        {\n            var initial = function(){i = itemsToTab.length - 1;};\n            var condition = function(){return i >= 0;};\n            var increment = function(){i --;};\n        }\n        else\n        {\n            var initial = function(){i = 0;};\n            var condition = function(){return i < itemsToTab.length;};\n            var increment = function(){i ++;};\n        }\n\n        for (initial(); condition(); increment())\n        {\n            var item = itemsToTab[i];\n\n            var parent = item.parent();\n\n            var index = parent.items().indexOf(item);\n            var ok;\n            var u;\n\n            if (e.shiftKey) // Unindent\n            {\n                ok = item.parent() != g.focusedItem;\n                if(ok)\n                {\n                    newParent = item.parent().parent();\n\n                    var parentItems = parent.items();\n                    var numSiblings = parentItems.length - index - 1;\n\n                    // Move this item's siblings that aren't selected or hidden to be its child\n                    u = index + 1;\n                    while(parentItems[index + 1])\n                    {\n                        var siblingItem = parentItems[index + 1];\n                        // Note: Don't want to move hidden items to be its child as they should stay in their current list\n                        if(!itemsHighlighted[siblingItem.id] && !g.hasClass(siblingItem.getElement(), 'hidden'))\n                        {\n                            needUpdate[siblingItem.parent().id] = siblingItem.parent();\n                            needUpdate[item.id] = item;\n\n                            siblingItem.moveTo({parent: item, underlying: true});\n                            moved[siblingItem.id] = true;\n\n                            tracker.performAction(TrackerType.Move, {\n                                'itemID': siblingItem.id,\n                                'oldParent': parent.id,\n                                'oldPosition': u,\n                                'newParent': item.id,\n                                'newPosition': item.items().length - 1\n                            });\n                        }\n                        else\n                        {\n                            index ++;\n                        }\n\n                        u ++;\n                    }\n\n                    // Item's parent is going to be tabbed so don't need to move this one\n                    if(itemsHighlighted[parent.id] >= 0 && !(parent.parent() && parent.parent() == g.focusedItem))\n                    {\n                        continue;\n                    }\n\n                    // It should be added as the next item after the current parent\n                    var parentIndex = newParent.items().indexOf(parent);\n\n                    needUpdate[item.parent().id] = item.parent();\n                    needUpdate[newParent.id] = newParent;\n\n                    //log('move', item.text, parent.text, parentIndex);\n                    item.moveTo({parent: newParent, index: parentIndex + 1, underlying: true});\n                    moved[item.id] = true;\n\n                    tracker.performAction(TrackerType.Move, {\n                        'itemID': item.id,\n                        'oldParent': parent.id,\n                        'oldPosition': index,\n                        'newParent': newParent.id,\n                        'newPosition': parentIndex + 1\n                    });\n                }\n            }\n            else // Indent\n            {\n                ok = index > 0;\n                if (ok)\n                {\n                    // New parent is the item above this one\n                    newParent = parent.items()[index - 1];\n                    // Keep going up while the item does not match search\n                    while(g.hasClass(newParent.getElement(), 'hidden'))\n                    {\n                        index --;\n                        if(index <= 0)\n                        {\n                            // No previous items matching search, so can't indent\n                            return false;\n                        }\n                        newParent = parent.items()[index - 1];\n                    };\n\n                    // If the parent has already been tabbed, this will be undefined. Just move on.\n                    if(!moved[parent.id])\n                    {\n                        needUpdate[item.parent().id] = item.parent();\n                        needUpdate[newParent.id] = newParent;\n\n                        item.moveTo({parent: newParent, underlying: true});\n                        //log('move A', item.text);\n                    }\n                    moved[item.id] = true;\n\n                    tracker.performAction(TrackerType.Move, {\n                        'itemID': item.id,\n                        'oldParent': parent.id,\n                        'oldPosition': index,\n                        'newParent': newParent.id,\n                        'newPosition': newParent.items().length - 1\n                    });\n                }\n                else\n                {\n                    newParent = parent;\n                    moved[item.id] = moved[parent.id];\n                }\n\n                var moveSiblings = false;\n                var parentMoved = item;\n                while(parentMoved)\n                {\n                    if(moved[parentMoved.id])\n                    {\n                        moveSiblings = true;\n                        break;\n                    }\n                    parentMoved = parentMoved.parent();\n                }\n                var siblingStartIndex = item.getIndex() + 1;\n                if(moveSiblings)\n                {\n                    // Make all children siblings\n                    var items = item.items();\n                    var numMoved = 0;\n                    for(u = 0; u < items.length; u ++)\n                    {\n                        var child = items[u];\n                        // Only move siblings not within the selection\n                        if(!itemsHighlighted[child.id])\n                        {\n                            // Leave hidden children where they are\n                            if(g.hasClass(child.getElement(), 'hidden'))\n                            {\n                                continue;\n                            }\n                            needUpdate[child.parent().id] = child.parent();\n                            needUpdate[item.parent().id] = item.parent();\n\n                            var moveIndex = siblingStartIndex + numMoved;\n                            child.moveTo({parent: item.parent(), index: moveIndex, underlying: true});\n\n                            //log('move C', child.text, siblingStartIndex, moveIndex);\n                            moved[child.id] = true;\n                            tracker.performAction(TrackerType.Move, {\n                                'itemID': child.id,\n                                'oldParent': item.id,\n                                'oldPosition': u,\n                                'newParent': item.parent().id,\n                                'newPosition': moveIndex\n                            });\n                            numMoved ++;\n                            u --;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (var itemId in needUpdate)\n        {\n            //log('Mutated: ', needUpdate[itemId]);\n            needUpdate[itemId].items.valueHasMutated();\n        }\n\n\n        //log('-----');\n\n        // Enumerate the modified DOM to find the selected elements\n        // at the saved indices\n        // for (i = 0; i < itemsToTab.length; i ++)\n        // {\n        //     if (i == toSelectStartIndex)\n        //     {\n        //         toSelectStart = itemsToTab[i].focusedSpan();\n        //     }\n\n        //     if (i == toSelectEndIndex)\n        //     {\n        //         toSelectEnd = itemsToTab[i].focusedSpan();\n        //     }\n        // }\n\n        // Select the #text element off of the span\n        if (!android.isEnabled())\n        {\n            if (startItem || endItem)\n            {\n                g.Assert(startItem && endItem);\n\n                g.selectMultiline(startItem.getSpan(), startOffset.start, endItem.getSpan(), endOffset.end);\n            }\n        }\n        else\n        {\n            android.updateInputBounds(startItem);\n        }\n\n        e.handled = true;\n\n        g.Assert(e.preventDefault, 'Should always be defined');\n        if (e.preventDefault)\n        {\n            e.preventDefault();\n        }\n\n        return false;\n    };\n\n    self.handleEnter = function(e, span, range)\n    {\n        //g.Assert(span.parentNode.tagName == 'LI', 'Expected LI, Actual: ' + span.parentNode.tagName);\n\n        var item = g.getItemForElement(span);\n        var parent = item.parent();\n        var index = parent.items().indexOf(item);\n\n        var offsets = g.getSelectOffsetsInSpan(item, span, range);\n\n        // When pressing enter, ensure that the previous editing values are saved before continuing. This\n        // should happen after the selection offsets are grabbed and the current VMLI is used and before the\n        // text of the currently edited item is cached locally.\n        if (android.isEnabled())\n        {\n            android.finishInput(/*continueEditing*/true);\n        }\n\n        var text = item.getParsedText();\n\n        var createText = '';\n\n        var item2;\n\n        var addToChild = false;\n        var newParent = parent;\n\n        var useNextItem = true;\n        if (offsets.end === 0) // Start\n        {\n            // Since we are at the beginning of the line, insert the new item before this one\n            if (item.isNumList())\n            {\n                item2 = new VMLI({ text: NumListPrefix}, {parent: newParent, forceSave: true });\n            }\n            else\n            {\n                item2 = new VMLI({ text: ''}, {parent: newParent, forceSave: true });\n            }\n\n            index--;\n            useNextItem = false;\n        }\n        else if (offsets.start >= offsets.total) // End\n        {\n            // Add to child if this item has children or if it's an empty child of fullscreen header\n            addToChild = !e.shiftKey && !item.isCollapsed() && (item.items().length > 0 || item.isHeader());\n\n            if (addToChild)\n            {\n                newParent = item;\n            }\n\n            var newText = '';\n            if (item.isNumList())\n            {\n                newText = NumListPrefix;\n            }\n\n            item2 = new VMLI({ text: newText}, {parent: newParent, forceSave: true });\n        }\n        else if (offsets.start === 0 && offsets.end === offsets.total) // All\n        {\n            item2 = new VMLI({ text: ''}, {parent: newParent, forceSave: true });\n            item.setText('', /*setImmediate*/true);\n\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': 0,\n                'text': text\n            });\n        }\n        else // Somewhere in the middle\n        {\n            var firstText = offsets.start > 0 ? text.substring(0, offsets.startText) : '';\n            secondText = offsets.endText < text.length ? text.substring(offsets.endText) : '';\n\n            if (item.isNumList())\n            {\n                secondText = NumListPrefix + secondText;\n            }\n\n            item2 = new VMLI({ text: firstText }, { parent: newParent, forceSave: true });\n\n            // var formatsClone = JSON.parse(JSON.stringify(item.formats));\n            // item2.setFormats(formatsClone);\n            // item2.removeFormatsAfter(offsets.start);\n\n            // var newFormats = item.getFormatsAfter(offsets.end);\n            item.setText(secondText, /*setImmediate*/true);\n            // item.setFormats(newFormats);\n\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': offsets.startText,\n                'text': text.substring(offsets.startText)\n            });\n\n            item2.copyProperties(item);\n\n            index --;\n            useNextItem = false;\n        }\n\n        item2.parseText(/*immediateParse*/true);\n        //item.setHeaderFromTemp();\n\n        if (addToChild)\n        {\n            item.insertItem(item2, 0);\n\n            tracker.performAction(TrackerType.Create, {\n                'itemID': item2.id,\n                'parent': item.id,\n                'position': 0,\n                'text': item2.getParsedText()\n            });\n        }\n        else\n        {\n            newParent.insertItem(item2, index + 1);\n\n            // // If item had children, move children to item2 unless it's collapsed\n            // if (!item.isCollapsed() && item.items().length > 0 && useNextItem)\n            // {\n            //     item.moveChildren(item2);\n            // }\n\n            // // parent.items.splice(index + 1, 0, item2);\n\n            tracker.performAction(TrackerType.Create, {\n                'itemID': item2.id,\n                'parent': newParent.id,\n                'position': (index + 1),\n                'text': item2.getParsedText()\n            });\n        }\n\n        var selectItem = useNextItem ? item2 : item;\n\n        g.Assert(selectItem, 'Expected another item to exist');\n\n        if (platform.ios)\n        {\n            textSaveInfo.start = offsets.start;\n            textSaveInfo.waitAutocorrect = 'enter';\n            textSaveInfo.item = useNextItem ? item : item2;\n            textSaveInfo.nextItem = useNextItem ? item2 : item;\n\n            if (!tempInput)\n            {\n                tempInput = g.element('tempInput');\n            }\n\n            tempInput.innerHTML = textSaveInfo.item.getStyledText();\n\n            g.selectMultiline(tempInput, offsets.start, tempInput, offsets.start);\n\n            // setTimeout(function(){\n            // var sel = window.getSelection();\n            // var range = document.createRange();\n\n            // log(offsets.start, tempInput.innerHTML);\n            // range.setStart(tempInput, offsets.start);\n            // range.setEnd(tempInput, offsets.start);\n\n            // sel.removeAllRanges();\n            // sel.addRange(range);\n        // }, 0);\n\n\n            return true;\n        }\n        else if (android.isEnabled())\n        {\n            android.updateInput(selectItem);\n\n            g.Assert(e.preventDefault, 'Should always be defined');\n            if (e.preventDefault)\n            {\n                e.preventDefault();\n            }\n\n            return false;\n        }\n        else\n        {\n            g.selectChildren(selectItem, 0, 0);\n\n            g.Assert(e.preventDefault, 'Should always be defined');\n            if (e.preventDefault)\n            {\n                e.preventDefault();\n            }\n\n            return false;\n        }\n    };\n\n    self.handleBackspace = function(e, span, range)\n    {\n        //g.Assert(span.parentNode.tagName == 'LI', 'Expected LI, Actual: ' + span.parentNode.tagName);\n\n        //var item = ko.dataFor(span.parentNode);\n        var item = g.getItemForElement(span);\n\n        var parent = item.parent();\n\n        // var index = parent.items().indexOf(item);\n        // g.Assert(index >= 0);\n\n        var offsets = g.getSelectOffsetsInSpan(item, span, range);\n\n        // When pressing backspace, ensure that the previous editing values are saved before continuing. This\n        // should happen after the selection offsets are grabbed and the current VMLI is used and before the\n        // text of the currently edited item is cached locally.\n        if (android.isEnabled())\n        {\n            android.finishInput(/*continueEditing*/true);\n        }\n\n        if (platform.ie)\n        {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n        }\n\n        var text = item.getParsedText();\n\n        var itemSelSpan = item.getSpan();\n        var newText = '';\n        var newTextOffset = 0;\n\n        // Beginning of line\n        if ((offsets.startText === 0 && offsets.endText === 0) || text === '')\n        {\n            // Cursor was at the start. Move this text to the end of the previous\n            // item and delete it.\n            var prev = g.getPreviousItem(item, g.focusedPane);\n            var next = g.getNextItem(item, g.focusedPane);\n\n            // Should not delete if prev is fullscreen\n            if (prev && (!prev.isFullscreen() || (text === '' && next)))\n            {\n                //var numChildren = item.items().length;\n                var prevTextLength = prev.getParsedText().length;\n\n                //if (numChildren === 0)\n                {\n                    // If the item being deleted does not have children, just move the item text\n                    // and remove the item. If however it does have children, the children need to\n                    // be moved into the previous item starting at the index of the item being removed.\n                    //\n                    // This logic is handled within deleteChild which will automatically move any children\n                    // of item to be children of prev at the index of the deleted item.\n                    parent.deleteChild(item, prev, 0);\n\n                    // Set text of above to line above + this text\n                    if (text.length > 0 && text !== '')\n                    {\n                        if (prev.getParsedText().length === 0)\n                        {\n                            prev.copyProperties(item);\n                        }\n                        // TODO: Put formats back\n                        // prev.appendFormats(item.formats, prevTextLength);\n                        prev.setText(prev.getParsedText() + text, /*setImmediate*/true);\n\n                        tracker.performAction(TrackerType.Insert, {\n                            'itemID': prev.id,\n                            'position': prevTextLength,\n                            'text': text\n                        });\n                    }\n\n                    // isFullscreen check is handling the case where the first item is being deleted\n                    var selectItem = prev.isFullscreen() ? prev.getFirstChild() : prev;\n                    var selectOffset = prev.isFullscreen() ? 0 : prevTextLength;\n\n                    g.selectChildren(selectItem, selectOffset, 0);\n\n                    return false;\n                }\n                // else\n                // {\n\n                //     var prevParent = prev.parent();\n                //     var prevIndex = prevParent.getIndexOf(prev);\n                //     var siblings = item.getSiblings();\n\n                //     item.moveTo({parent: prevParent, index: prevIndex});\n\n                //     if(prev.items().length > 0)\n                //     {\n                //         var moveSiblingsTo = item;\n                //         var siblingIndex = 0;\n                //         for(var i = 0; i < siblings.length; i ++)\n                //         {\n                //             siblings[i].moveTo({parent: moveSiblingsTo, index: siblingIndex + i});\n                //         }\n                //     }\n\n                //     prev.deleteSelf();\n\n                //     // Set text of this to line above + this text\n                //     if (prev.getParsedText().length > 0 && prev.getParsedText() != '')\n                //     {\n                //         item.transformFormats(0, prev.getParsedText().length);\n                //         item.appendFormats(prev.formats);\n                //         item.setText(prev.getParsedText() + text, /*setImmediate*/true);\n                //     }\n\n                //     //item.setHeaderFromTemp();\n\n                //     g.selectChildren(item, prevTextLength, 0);\n                //     return false;\n                // }\n\n                // if (!prev.isFullscreen())\n                // {\n                //     g.scrollIntoView(g.getLIParent(prev.getSpan()));\n                // }\n                // else\n                // {\n                //     g.scrollIntoView(g.getLIParent(prev.items()[0].getSpan()));\n                // }\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if ((e.metaKey && offsets.startText === text.length)  || // Cmd key\n          (offsets.startText === 0 && offsets.endText === text.length)) // All selected\n        {\n            // Cursor is at end and cmd + bksp or all text is selected.\n\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': 0,\n                'text': item.getParsedText()\n            });\n\n            //item.clearFormats();\n            newText = '';\n            newTextOffset = 0;\n        }\n        else if (e.metaKey)\n        {\n            // Delete everything from the currently selected location on the line to the start of the line\n            newText = text.substring(offsets.startText);\n\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': 0,\n                'text': text.slice(0, offsets.startText)\n            });\n\n            //item.clearFormats();\n            newTextOffset = 0;\n        }\n        else if ((platform.mac && e.altKey || !platform.mac && e.ctrlKey) && offsets.start === offsets.end)\n        {\n            // option + bksp while not selecting multiple characters should delete\n            // the word. If it's the only word, set the text to empty.\n            var endOfText = text.substring(offsets.startText);\n            var seenALetter = false;\n            var isHandled = false;\n            for (var i = offsets.startText - 1; i >= 0 && !isHandled; i--)\n            {\n                // Delete the word after the space or special characters.\n                // seenALetter is for trimming the spaces off the end.\n                seenALetter = seenALetter || text[i] !== ' ';\n                if(text[i] == ' ')\n                {\n                    if(text[i - 1] == ' ')\n                        continue;\n                }\n                if (i === 0 || text[i] === ' ' || text[i] === '@')\n                {\n                    // If the special character is right before the cursor, delete it.\n                    // Otherwise, delete up to it.\n                    var subIndex = (i === 0 || i === offsets.startText - 1) ? i : i + 1;\n                    if (seenALetter || text[i] !== ' ')\n                    {\n                        //item.transformFormats(subIndex, -(offsets.startText - subIndex));\n\n                        tracker.performAction(TrackerType.Remove, {\n                            'itemID': item.id,\n                            'position': subIndex,\n                            'text': text.slice(subIndex, offsets.startText)\n                        });\n\n                        newText = text.substring(0, subIndex) + endOfText;\n                        newTextOffset = subIndex;\n\n                        isHandled = true;\n                    }\n                }\n            }\n\n            if (!isHandled)\n            {\n                if (offsets.startText === text.length)\n                {\n                    if (offsets.start === 0)\n                    {\n                        //item.clearFormats();\n                        newText = '';\n\n                        tracker.performAction(TrackerType.Remove, {\n                            'itemID': item.id,\n                            'position': 0,\n                            'text': text\n                        });\n                    }\n                }\n                else\n                {\n                    //item.transformFormats(offsets.startText, -offsets.startText);\n                    tracker.performAction(TrackerType.Remove, {\n                        'itemID': item.id,\n                        'position': 0,\n                        'text': text.slice(0, offsets.startText)\n                    });\n\n                    newText = endOfText;\n                }\n\n                newTextOffset = 0;\n            }\n        }\n        // If backspacing the last character, put a TextSpace there\n        // TODO: startText?\n        // TODO: Does this even need to be here now that we have no TextSpace?\n        else if (offsets.start === 1 && offsets.end === 1 && text.length === 1 && text[0] != '')\n        {\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': 0,\n                'text': item.getParsedText()\n            });\n            newText = '';\n            newTextOffset = 0;\n        }\n        else\n        {\n            g.Assert(offsets.start >= 0);\n\n            // If there is some text selected, delete that text\n            if (offsets.start != offsets.end)\n            {\n                //item.transformFormats(offsets.startText, -(offsets.end - offsets.start));\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': item.id,\n                    'position': offsets.startText,\n                    'text': text.slice(offsets.startText, offsets.endText)\n                });\n\n                newText = text.substr(0, offsets.startText) + text.substr(offsets.endText);\n                newTextOffset = offsets.start;\n            }\n            else\n            {\n                var sub = 1;\n                if (text.length > 1 && text[offsets.startText - 1] == '')\n                {\n                    sub++;\n                }\n\n                // Otherwise there is no text selected, delete the previous character\n                newText = text.substr(0, offsets.startText - sub) + text.substr(offsets.startText);\n\n                //item.transformFormats(offsets.end - 1, -1);\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': item.id,\n                    'position': offsets.startText - sub,\n                    'text': text.slice(offsets.startText - sub, offsets.startText)\n                });\n\n                newTextOffset = offsets.startText - sub ;\n            }\n        }\n\n        // Don't do this if the last keypress was backspace because that means it's repeating\n        // and we don't want to to delete words\n        // TODO: It'd be nice to stop doing this once backspace is no longer being repeated.\n        // The only way I can think of is a timeout and that's scary.\n        if(platform.phone && lastKeypress !== KeyCode.BackSpace)\n        {\n            textSaveInfo.text = newText;\n            textSaveInfo.start = newTextOffset;\n            textSaveInfo.item = item;\n            if(newText.length === 0)\n            {\n                // If the text will be empty, temporarily put a TextSpace in the style text\n                // so the default action of deleting it won't break the html.\n                item.setStyledText(TextSpace + ' ', true);\n                g.selectChildren(item, 1, 0);\n            }\n            return true;\n        }\n        else\n        {\n            item.setText(newText, /*setImmediate*/true);\n            g.selectChildren(item, newTextOffset, 0);\n        }\n\n        return false;\n    };\n\n    self.handleDelete = function (e, span, range)\n    {\n        var item = ko.dataFor(span.parentNode);\n\n        var offsets = g.getSelectOffsetsInSpan(item, span, range);\n\n        g.Assert(item);\n\n        var parent = item.parent();\n        var index = item.getIndex();\n        var text = item.getParsedText();\n\n        var itemSelSpan = item.getSpan();\n\n        // If the text is completely equal to the placeholder space\n        if (text === '')\n        {\n            var refocusItem = g.getNextItem(item, g.focusedPane);\n            var refocusIndex = 0;\n\n            if (!refocusItem)\n            {\n                refocusItem = g.getPreviousItem(item, g.focusedPane);\n                refocusIndex = refocusItem.getParsedText().length;\n            }\n\n            if (refocusItem && !refocusItem.isFullscreen())\n            {\n                if (item.hasChildren())\n                {\n                    parent.replaceChild(item, item.getFirstChild());\n                }\n                else\n                {\n                    // Delete self and focus the next item\n                    parent.deleteChild(item, parent, index);\n                }\n\n                g.selectChildren(refocusItem, refocusIndex, refocusIndex);\n                // g.scrollIntoViewIfNeeded(refocusItem);\n            }\n        }\n        else if ((offsets.start === offsets.total && offsets.end === offsets.total) ||\n            (offsets.start === offsets.total - 1 && offsets.end === offsets.total - 1 && span.textContent[offsets.endText] === ''))\n        {\n            // If the delete key is pressed while the caret is at the end of the line,\n            // delete the next item and set this items text to be the union\n            var next = g.getNextItem(item, g.focusedPane);\n\n            if (next)\n            {\n                // Set text of above to line above + this text\n                // TODO: Move around the formatting\n                //item.appendFormats(next.formats, text.length);\n                item.setText(text + next.getParsedText(), /*setImmediate*/true);\n\n                tracker.performAction(TrackerType.Insert, {\n                    'itemID': item.id,\n                    'position': text.length,\n                    'text': next.getParsedText()\n                });\n\n                next.parent().deleteChild(next, item, 0);\n                g.selectChildren(item, offsets.total, 0);\n            }\n        }\n        else if (offsets.start === 0 && offsets.end === 0 && text.length === 1 && text[0] != '')\n        {\n            // If there is a single character left being deleted, it needs to be replaced\n            // with a palceholder space\n            item.setText('', /*setImmediate*/true);\n\n            tracker.performAction(TrackerType.Remove, {\n                'itemID': item.id,\n                'position': 0,\n                'text': text\n            });\n        }\n        else if ((platform.mac && e.altKey || !platform.mac && e.ctrlKey) && offsets.start === offsets.end)\n        {\n            // option + delete while not selecting multiple characters should delete\n            // the word. If it's the only word, set the text to empty.\n            var startOfText = text.substring(0, offsets.startText);\n            var seenALetter = false;\n            var isHandled = false;\n            for (var i = offsets.startText; i < text.length && !isHandled; i ++)\n            {\n                // Delete the word after the space or special characters.\n                // seenALetter is for trimming the spaces off the end.\n                seenALetter = seenALetter || text[i] !== ' ';\n                if (i === (text.length - 1) || text[i] === ' ')\n                {\n                    // If the special character is right before the cursor, delete it.\n                    // Otherwise, delete up to it.\n                    var subIndex = (text[i] === ' ' && text[offsets.startText] == ' ') ? i : i + 1;\n                    if (seenALetter || text[i] !== ' ')\n                    {\n                        //item.transformFormats(offsets.startText + 1, -(subIndex - offsets.startText));\n                        var newText = startOfText + text.substring(subIndex);\n                        item.setText(newText, /*setImmediate*/true);\n\n                        tracker.performAction(TrackerType.Remove, {\n                            'itemID': item.id,\n                            'position': subIndex,\n                            'text': newText\n                        });\n\n                        g.selectChildren(item, offsets.start, 0);\n\n                        isHandled = true;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Either delete the selected text, or delete the character folliwng the caret\n            if (offsets.start != offsets.end)\n            {\n                //item.transformFormats(offsets.start, -(offsets.end - offsets.start));\n                var newText = text.substr(0, offsets.startText) + text.substr(offsets.endText);\n                item.setText(newText, /*setImmediate*/true);\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': item.id,\n                    'position': offsets.startText,\n                    'text': text.slice(offsets.startText, offsets.endText)\n                });\n\n                g.selectChildren(item, offsets.start, 0);\n            }\n            else\n            {\n                // Otherwise there is no text selected, delete the previous character\n                //item.transformFormats(offsets.start, -1);\n                var newText = text.substr(0, offsets.startText) + text.substr(offsets.startText + 1);\n                item.setText(newText, /*setImmediate*/true);\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': item.id,\n                    'position': offsets.startText,\n                    'text': text.slice(offsets.startText, offsets.startText + 1)\n                });\n\n                g.selectChildren(item, offsets.start, 0);\n            }\n        }\n\n        return false;\n    };\n\n    return self;\n});","asserts":[{"tag":1235,"offset":2391},{"tag":1236,"offset":5350},{"tag":1237,"offset":5527},{"tag":1238,"offset":5812},{"tag":1239,"offset":6250},{"tag":1240,"offset":9528},{"tag":1241,"offset":16699},{"tag":1242,"offset":18094},{"tag":1243,"offset":19960},{"tag":1244,"offset":20212},{"tag":1245,"offset":21313},{"tag":1246,"offset":23439},{"tag":1247,"offset":23602},{"tag":1248,"offset":23837},{"tag":1249,"offset":25953},{"tag":1250,"offset":26573},{"tag":1251,"offset":26650},{"tag":1252,"offset":26874},{"tag":1253,"offset":33109},{"tag":1254,"offset":34189},{"tag":1255,"offset":34296},{"tag":1256,"offset":43736},{"tag":1257,"offset":44021},{"tag":1258,"offset":44254},{"tag":1259,"offset":48831},{"tag":1260,"offset":49954},{"tag":1261,"offset":50229},{"tag":1262,"offset":50496},{"tag":1263,"offset":50789},{"tag":1264,"offset":60211},{"tag":1265,"offset":62887}]},"kos":{"path":"F:/p/bce/Duchess/public/js/kos.js","data":"define([], function() {\n    return null;\n});","asserts":[]},"VMMain":{"path":"F:/p/bce/Duchess/public/js/VMMain.js","data":"define(['ko', 'globals', 'util', 'android', 'data', 'gdata', 'goog', 'edit', 'copypaste', 'VMMain_DragDrop', 'VMLI', 'VMTitle', 'tracker', 'platform', 'VMSearch', 'VMPane', 'VMMenus', 'VMSettings', 'VMPicker', 'VMPhoneMenu', 'VMKeyboardToolbar', 'VMHelp', 'parseWorker', 'VMIntro'],\r\nfunction (ko, g, util, android, d, gdata, goog, edit, copypaste, VMMain_DragDrop, VMLI, VMTitle, tracker, platform, VMSearch, VMPane, VMMenus, VMSettings, VMPicker, VMPhoneMenu, VMKeyboardToolbar, VMHelp, parseWorker, VMIntro) {\r\nvar VMMain = function()\r\n{\r\n    var self = {\r\n        root: ko.observable(undefined),\r\n        panes: ko.observableArray(),\r\n        height: ko.observable(0),\r\n        isHelpShowing: ko.observable(false),\r\n        isLoaded: false,\r\n        numCols: ko.observable(),\r\n        hasResized: ko.observable(false),\r\n        isSidebarOpen: false,\r\n        //menuState: ko.observable(MenuState.Main),\r\n        helpButtonHidden: ko.observable(false),\r\n\r\n        // vmSearch: new VMSearch(),\r\n        gdriveStatus: ko.observable(-1),\r\n        main: undefined,\r\n        mainTransform: 0,\r\n        isPhone: platform.phone,\r\n        outline: undefined,\r\n        vmSettings: new VMSettings(this),\r\n        supportWebWorker: true,\r\n        swipingScreens: false,\r\n        swipeDirection: 0,\r\n        lastSwipeMove: 0,\r\n        lastSwipeMoveTime: 0,\r\n        vmPicker: new VMPicker(),\r\n        vmHelp: new VMHelp(),\r\n        selected: ko.observableArray(),\r\n        help: undefined\r\n    };\r\n\r\n    if (platform.mobile)\r\n    {\r\n        self.elPhoneMenu = g.element('phoneMenu');\r\n    }\r\n\r\n    g.vmSettings = self.vmSettings;\r\n\r\n    // self.gDriveIcon = ko.computed({\r\n    //     read: function()\r\n    //     {\r\n    //         switch(self.gdriveStatus())\r\n    //         {\r\n    //             case 'offline':\r\n    //                 return 'iconCloud_x';\r\n    //             case 'connecting':\r\n    //                 return 'iconCloud_sync';\r\n    //             case 'saving':\r\n    //                 return 'iconCloud_up';\r\n    //             case 'saved':\r\n    //                 return 'iconCloud_done';\r\n    //         }\r\n    //     },\r\n    //     deferEvaluation: true\r\n    // });\r\n\r\n    if (DEBUG)\r\n    {\r\n        window.getPanes = function()\r\n        {\r\n            return self.panes();\r\n        };\r\n    }\r\n\r\n    self.isOnline = function()\r\n    {\r\n        return self.gdriveStatus() !== DriveStatus.Offline;\r\n    };\r\n\r\n    self.isLocal = function()\r\n    {\r\n        return window.location.hostname == 'localhost';\r\n    };\r\n\r\n    self.onlineText = function()\r\n    {\r\n        if (self.isDemoMode())\r\n        {\r\n            return 'DEMO';\r\n        }\r\n\r\n        switch(self.gdriveStatus())\r\n        {\r\n            case DriveStatus.Offline:\r\n                return 'OFFLINE';\r\n            case DriveStatus.Saving:\r\n            case DriveStatus.Saved:\r\n                return 'ONLINE';\r\n        }\r\n    };\r\n\r\n    // VMMain Extension classes\r\n    VMMain_DragDrop(self);\r\n\r\n    var worker;\r\n\r\n    var nextPaneId = 0;\r\n\r\n    // TODO: Can be a normal function.\r\n    self.maxWidth = ko.computed({\r\n        read: function() {\r\n            if (self.isPhone)\r\n            {\r\n                return platform.windowWidth() + 'px';\r\n            }\r\n            else\r\n            {\r\n                var width = (self.panes().length * 800) +\r\n                                (self.isHelpShowing() ? 400 : 0);\r\n                return width + 'px';\r\n            }\r\n        },\r\n        deferEvaluation: true\r\n    });\r\n\r\n    // TODO: Can be a normal function.\r\n    self.needsPadTop = ko.computed({\r\n        read: function() {\r\n            if(!self.isPhone)\r\n            {\r\n                return (self.panes().length * 800) +\r\n                        (self.isHelpShowing() ? 400 : 0) + 170 > platform.windowWidth();\r\n            }\r\n        }\r\n    });\r\n\r\n    // TODO: Can be a normal function.\r\n    self.pinButtons = ko.computed({\r\n        read: function() {\r\n            return platform.windowWidth() > self.panes().length * 800;\r\n        },\r\n        deferEvaluation: true\r\n    });\r\n\r\n    self.getUserName = ko.computed({\r\n        read: function ()\r\n        {\r\n            var user = gdata.authenticatedUser();\r\n            if (user)\r\n            {\r\n                return user.displayName;\r\n            }\r\n\r\n            if (self.gdriveStatus() === DriveStatus.Saved)\r\n            {\r\n                return 'Connected';\r\n            }\r\n\r\n            /*if (g.vmSetup.loginState() == LoginState.OFFLINE)\r\n            {\r\n                return 'Offline';\r\n            }\r\n            else */if (g.vmSetup.loginState() == LoginState.LOGGED_IN)\r\n            {\r\n                return 'Connecting';\r\n            }\r\n            else\r\n            {\r\n                return 'Demo';\r\n            }\r\n        },\r\n        deferEvaluation: true\r\n    });\r\n\r\n    self.getUserImage = function()\r\n    {\r\n        var user = gdata.authenticatedUser();\r\n        if (user)\r\n        {\r\n            return user.photoUrl;\r\n        }\r\n    };\r\n\r\n    // TODO: This didn't seem to ever get called. Only the one in VMMenus gets called?\r\n    // self.hotkeyText =function(key)\r\n    // {\r\n    //     return + cmdChar + '+' + key;\r\n    // };\r\n\r\n    // self.getDocTitle = function ()\r\n    // {\r\n    //     var currentTitle = goog.docTitle();\r\n\r\n    //     var displayText;\r\n\r\n    //     if (self.isDemoMode())\r\n    //     {\r\n    //         displayText = \"Leave Introduction\";\r\n    //     }\r\n    //     else if (goog.LEGACY_DefaultDriveDocTitle !== currentTitle)\r\n    //     {\r\n    //         displayText = currentTitle;\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         displayText = \"Default Document\";\r\n    //     }\r\n\r\n    //     return displayText;\r\n    // };\r\n\r\n    // self.runPicker = function ()\r\n    // {\r\n    //     if (!self.isDemoMode())\r\n    //     {\r\n    //         if (self.isOnline() || DEBUG)\r\n    //         {\r\n    //             VMPicker.init();\r\n    //         }\r\n    //         else\r\n    //         {\r\n    //             g.messageQueue.pushMessage({\r\n    //                 text: 'You can only access your other documents while online.',\r\n    //                 type: MessageType.Warning,\r\n    //                 action: MessageAction.Reload,\r\n    //                 timeout: 2000\r\n    //             });\r\n    //         }\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         util.removeURLParam('demo');\r\n    //     }\r\n\r\n    //     self.hideMenu();\r\n    // };\r\n\r\n    self.isDemoMode = function ()\r\n    {\r\n        return g.isDemoMode();\r\n    };\r\n\r\n    window.addEventListener('scriptLoadError', function (e)\r\n    {\r\n        self.handleScriptLoadError(e);\r\n    });\r\n\r\n    self.handleScriptLoadError = function (e)\r\n    {\r\n        if (e.data.id === 'gapiScript')\r\n        {\r\n            log('Failed to load GAPI!');\r\n\r\n            self.setGDriveStatus(DriveStatus.Offline);\r\n\r\n            self.failedGapiLoad = true;\r\n\r\n            // Try and reload gapi after 30 seconds\r\n            setTimeout(goog.goOnline, 30000);\r\n        }\r\n    };\r\n\r\n    self.setGDriveStatus = function (status)\r\n    {\r\n        var prevStatus = self.gdriveStatus();\r\n\r\n        // Ignore changes to/from DriveStatus.Saving\r\n        if (status !== prevStatus && status !== DriveStatus.Saving)\r\n        {\r\n            // platform.sendToApp('onlineStatus', status);\r\n\r\n            self.gdriveStatus(status);\r\n\r\n            if (status === DriveStatus.Offline)\r\n            {\r\n                g.goOffline();\r\n\r\n                if(platform.mobile)\r\n                {\r\n                    g.messageQueue.pushMessage(MessageID.MobileOffline);\r\n                }\r\n            }\r\n            else if (prevStatus === DriveStatus.Offline)\r\n            {\r\n                g.goOnline();\r\n\r\n                if(platform.mobile)\r\n                {\r\n                    g.messageQueue.clearMessage(MessageID.MobileOffline);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    self.init = function()\r\n    {\r\n        copypaste.init();\r\n    };\r\n\r\n    // {\r\n        // if(false)//window.webkitNotifications)\r\n        // {\r\n        //     var permissionState = window.webkitNotifications.checkPermission();\r\n        //     if(permissionState === 0)\r\n        //     {\r\n        //         var now = new Date();\r\n        //         var timeout = 60 - now.getSeconds();\r\n        //         // Check for notifications now\r\n        //         doNotifications();\r\n        //         // Check for notifications on the next minute\r\n        //         setTimeout(function(){\r\n        //             doNotifications();\r\n        //             // Check for notifications every following minute\r\n        //             setInterval(doNotifications, 60000);\r\n        //         }, timeout * 1000);\r\n        //     }\r\n        // }\r\n\r\n        // TODO: Uncomment and update to add themes back in\r\n        // var theme = g.settings.get(Settings.theme);\r\n        // if (!theme)\r\n        // {\r\n        //     theme = 'theme-light';\r\n        // }\r\n        // else\r\n        // {\r\n        //     theme = 'theme-' + theme;\r\n\r\n        //     $(document.documentElement).addClass(theme);\r\n        // }\r\n\r\n        // if (g.settings.get(Settings.syncGoogle) == true)\r\n        // {\r\n        //     $(document.getElementById('syncButton')).removeClass('none');\r\n        // }\r\n    // };\r\n\r\n    self.onLoad = function (element)\r\n    {\r\n        if (platform.isTouchDevice && !platform.app)\r\n        {\r\n            var outlines = document.getElementsByClassName('paneOutline');\r\n\r\n            for (var i = 0; i < outlines.length; ++i)\r\n            {\r\n                outlines[i].addEventListener(platform.touchStartEvent, function (e)\r\n                {\r\n                    if (!g.preventScrollPropagation(ele))\r\n                    {\r\n                        e.preventDefault();\r\n\r\n                        return false;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Grant: Does this need to be here? This is the only place\r\n        if (platform.touch)\r\n        {\r\n            setTimeout(function ()\r\n            {\r\n                g.ScreenManager.computeSnapPoints();\r\n                // g.ScreenManager.snapToScreen(window.Screens.List);\r\n            }.bind(this), 0);\r\n        }\r\n    };\r\n\r\n    //var modifiedItems = { };\r\n    self.addModifiedItem = function(item)\r\n    {\r\n        //modifiedItems[item.id] = item;\r\n    };\r\n\r\n    self.flushModifiedItems = function(callback)\r\n    {\r\n        // g.Assert(callback, 'Callback required');\r\n\r\n        // callback(modifiedItems);\r\n\r\n        // modifiedItems = { };\r\n    };\r\n\r\n    var parseItems = [ ];\r\n    self.addParseItem = function (item, isRemoteLoad)\r\n    {\r\n        self.addItemToArrayForWorker(item, isRemoteLoad, parseItems);\r\n    };\r\n\r\n    self.flushParseItems = function (callback)\r\n    {\r\n        g.Assert(callback, 'Callback required');\r\n\r\n        if (parseItems.length > 0 && !goog.loadingContacts)\r\n        {\r\n            self.runParseWorker(parseItems, callback);\r\n        }\r\n\r\n        parseItems = [ ];\r\n    };\r\n\r\n    self.runParseWorkerNewContacts = function()\r\n    {\r\n        if (self.root())\r\n        {\r\n            var contactParseItems = [ ];\r\n\r\n            self.parseWorkerNewContactsHelper(self.root(), contactParseItems);\r\n\r\n            if (contactParseItems.length > 0)\r\n            {\r\n                self.runParseWorker(contactParseItems);\r\n            }\r\n        }\r\n    };\r\n\r\n    self.parseWorkerNewContactsHelper = function(item, array)\r\n    {\r\n        g.Assert(item, 'Must supply a valid item to parse');\r\n\r\n        var rawText = item.getRawText();\r\n\r\n        if (rawText.indexOf(ContactPrefix) >= 0)\r\n        {\r\n            array.push({\r\n                'id': item.id,\r\n                'text': item.getRawText(),\r\n                //'formats': item.formats,\r\n                'isUpdate': false,\r\n                'prevDate': item.getDateTime()\r\n            });\r\n        }\r\n\r\n        var items = item.items();\r\n        for (var i = 0; i < items.length; i++)\r\n        {\r\n            self.parseWorkerNewContactsHelper(items[i], array);\r\n        }\r\n    };\r\n\r\n    // Add a single item to the given array.\r\n    self.addItemToArrayForWorker = function(item, isRemoteLoad, array)\r\n    {\r\n        //log('Add Item: ', item);\r\n\r\n        array.push({\r\n            'id': item.id,\r\n            'text': item.getRawText(),\r\n            //'formats': item.formats,\r\n            'isUpdate': !isRemoteLoad && item.isLoaded,\r\n            'prevDate': item.getDateTime()\r\n        });\r\n    };\r\n\r\n    // Recursively add items starting from the given item to the given array.\r\n    self.addChildrenToArrayForWorker = function(item, isRemoteLoad, array)\r\n    {\r\n        g.Assert(item, 'Must supply a valid item to parse');\r\n\r\n        //log(item.formats);\r\n        array.push({\r\n            'id': item.id,\r\n            'text': item.getRawText(),\r\n            //'formats': item.formats,\r\n            'isUpdate': !isRemoteLoad && item.isLoaded,\r\n            'prevDate': item.getDateTime()\r\n        });\r\n\r\n        var items = item.items();\r\n        for (var i = 0; i < items.length; i++)\r\n        {\r\n            self.addChildrenToArrayForWorker(items[i], isRemoteLoad, array);\r\n        }\r\n    };\r\n\r\n    function createWorkerSource(callback)\r\n    {\r\n        g.Assert(window.helperWrapper, 'helperWrapper must be defined for worker to be created');\r\n        g.Assert(window.dateWrapper, 'dateWrapper must be defined for worker to be created');\r\n        g.Assert(window.parseWorkerWrapper, 'parseWorkerWrapper must be defined for worker to be created');\r\n\r\n        var workerSource;\r\n\r\n        if (!platform.ie)\r\n        {\r\n            try\r\n            {\r\n                var helperString = window.helperWrapper.toString();\r\n                var dateString = window.dateWrapper.toString();\r\n                var workerString = window.parseWorkerWrapper.toString();\r\n                var execString = 'parseWorkerWrapper();';\r\n\r\n                window.URL = window.URL || window.webkitURL;\r\n                workerSource = window.URL.createObjectURL(new Blob([helperString, dateString, workerString, execString], { type: \"text/javascript\" }));\r\n            }\r\n            catch (err)\r\n            {\r\n                if (ShouldLog(LogLevels.Warning)) log('---- WARNING: Blob URLs not supported, falling back to default web worker support! ----');\r\n                if (ShouldLog(LogLevels.Warning)) log(JSON.stringify(err));\r\n\r\n                workerSource = 'js/parseWorker.js';\r\n            }\r\n            finally\r\n            {\r\n                window.helperWrapper = undefined;\r\n                window.dateWrapper = undefined;\r\n                window.parseWorkerWrapper = undefined;\r\n\r\n                delete window.helperWrapper;\r\n                delete window.dateWrapper;\r\n                delete window.parseWorkerWrapper;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            workerSource = 'js/parseWorker.js';\r\n\r\n            window.helperWrapper = undefined;\r\n            window.dateWrapper = undefined;\r\n            window.parseWorkerWrapper = undefined;\r\n\r\n            delete window.helperWrapper;\r\n            delete window.dateWrapper;\r\n            delete window.parseWorkerWrapper;\r\n        }\r\n\r\n        return workerSource;\r\n    }\r\n\r\n    var messageID = 0;\r\n    var pendingRequests = [ ];\r\n    function setupWorker()\r\n    {\r\n        // Only create the worker once, otherwise pass messages to it\r\n        if (!self.worker)\r\n        {\r\n            if (!window.Worker || (DEBUG && DEBUG) || (DEBUG && window.location.pathname === '/cover/'))\r\n            {\r\n                if (ShouldLog(LogLevels.Warning)) log('---- WARNING: Running without WebWorker support! ----');\r\n\r\n                self.supportWebWorker = false;\r\n                self.worker = undefined;\r\n\r\n                return;\r\n            }\r\n\r\n            var workerSource = createWorkerSource();\r\n\r\n            if (DEBUG) log('Worker Source: ', workerSource);\r\n\r\n            try\r\n            {\r\n                self.worker = new Worker(workerSource);\r\n            }\r\n            catch (err)\r\n            {\r\n                if (err.code === 18)\r\n                {\r\n                    try\r\n                    {\r\n                        self.worker = new Worker('js/parseWorker.js');\r\n                    }\r\n                    catch (err2)\r\n                    {\r\n                        g.reportError(err2);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    g.reportError(err);\r\n                }\r\n            }\r\n\r\n            if (!self.worker)\r\n            {\r\n                self.supportWebWorker = false;\r\n            }\r\n            else\r\n            {\r\n                self.worker.onmessage = function(e)\r\n                {\r\n                    if (g.isString(e.data))\r\n                    {\r\n                        log('Message from worker: ', e.data);\r\n\r\n                        return;\r\n                    }\r\n                    // log('%cMessage from worker:', 'color: green', e.data);\r\n                    log('Worker Finished: ', (e.data.end - e.data.start), 'ms');\r\n\r\n                    var handlerIndex = -1;\r\n                    var resHandler;\r\n                    for (var i = 0; i < pendingRequests.length; ++i)\r\n                    {\r\n                        if (pendingRequests[i].id === e.data.id)\r\n                        {\r\n                            resHandler = pendingRequests[i];\r\n                            handlerIndex = i;\r\n                        }\r\n                    }\r\n\r\n                    g.Assert(resHandler, 'Must have a valid response handler');\r\n                    g.Assert(resHandler.id === e.data.id, 'Respose handler should match request');\r\n\r\n                    pendingRequests.splice(handlerIndex, 1);\r\n\r\n                    if (e.data.styles)\r\n                    {\r\n                        for (var i = 0; i < e.data.styles.length; ++i)\r\n                        {\r\n                            var styles = e.data.styles[i];\r\n\r\n                            var model = d.getModel(resHandler.items[i].id);\r\n                            if (model)\r\n                            {\r\n                                var changedStyles = { };\r\n\r\n                                if (model.styleText(styles, /*parsedFull*/true, changedStyles))\r\n                                {\r\n                                    //log('Property Changed From Worker: ', changedStyles);\r\n                                    model.save(changedStyles, SaveFlag.None);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (e.data.done && resHandler.cb)\r\n                    {\r\n                        resHandler.cb();\r\n                    }\r\n\r\n                    if (!e.data.styles && !e.data.done)\r\n                    {\r\n                        log('Error in parse worker: ', e);\r\n                    }\r\n                };\r\n\r\n                self.worker.onerror = function (e)\r\n                {\r\n                    log('Error in ParseWorker: ', e, e.message);\r\n\r\n                    g.reportError(new Error('Worker reported error'));\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    var sentContacts = false;\r\n    self.notifyContactsUpdated = function()\r\n    {\r\n        sentContacts = false;\r\n    };\r\n\r\n    function workerRun(arr, callback)\r\n    {\r\n        g.Assert(self.worker, 'Worker must exist');\r\n\r\n        if (self.supportWebWorker)\r\n        {\r\n            var requestID = messageID++;\r\n            pendingRequests.push({ 'id': requestID, 'cb': callback, 'items': arr });\r\n\r\n            var msgData = {\r\n                'id': requestID,\r\n                'items': arr\r\n            };\r\n\r\n            if (!sentContacts)\r\n            {\r\n                msgData['contacts'] = d.getContacts();\r\n\r\n                sentContacts = true;\r\n            }\r\n\r\n            self.worker.postMessage(msgData);\r\n        }\r\n    }\r\n\r\n    self.runParseWorker = function(input, callback)\r\n    {\r\n        var parseStart = performance.now();\r\n\r\n        var arr;\r\n        if (!input || !(input instanceof Array))\r\n        {\r\n            arr = [ ];\r\n\r\n            // If no item is given or if a single non-array item is given, assume that we recursively\r\n            // want to parse the tree at either the root or the input item.\r\n            var item = input;\r\n            if (!input)\r\n            {\r\n                item = self.root();\r\n\r\n                log('Running Parse Worker for Root.');\r\n            }\r\n            else\r\n            {\r\n                log('Running Parse Worker for Item: ', input.id);\r\n            }\r\n\r\n            // If there is no item specified and there is no root item loaded yet, skip running parse.\r\n            if (item)\r\n            {\r\n                self.addChildrenToArrayForWorker(item, /*isRemoteLoad*/false, arr);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            g.Assert(input instanceof Array, 'Inputs to runParseWorker must either be: undefined, single item or an array');\r\n            g.Assert(input.length > 0, 'Shouldnt run the parse worker with no items in the input array');\r\n\r\n            log('Running Parse Worker for Array: ', input.length);\r\n\r\n            arr = input;\r\n        }\r\n\r\n        setupWorker();\r\n\r\n        if (self.supportWebWorker)\r\n        {\r\n            log('Parsing Items Async: ', arr.length);\r\n            // for (var i = 0; i < arr.length; ++i)\r\n            // {\r\n            //     log(' :', arr[i].id);\r\n            // }\r\n\r\n            workerRun(arr, callback);\r\n\r\n            if (DEBUG) log('Worker Setup Time: ', (performance.now() - parseStart));\r\n        }\r\n        else\r\n        {\r\n            setTimeout(function ()\r\n            {\r\n                log('Parsing Items Sync: ', arr.length);\r\n\r\n                var contacts = d.getContacts();\r\n\r\n                for (var i = 0; i < arr.length; ++i)\r\n                {\r\n                    var entry = arr[i];\r\n\r\n                    var styles = DuchessHelpers.parseText(entry.text, entry.prevDate, entry.isUpdate, contacts);\r\n\r\n                    var model = d.getModel(entry.id);\r\n                    if (model)\r\n                    {\r\n                        var changedStyles = { };\r\n\r\n                        if (model.styleText(styles, /*parsedFull*/true, changedStyles))\r\n                        {\r\n                            //log('Property Changed From Worker: ', changedStyles);\r\n                            model.save(changedStyles, SaveFlag.None);\r\n                        }\r\n                    }\r\n                }\r\n            }, 0);\r\n        }\r\n    };\r\n\r\n    self.createPane = function(index, mode)\r\n    {\r\n        if (isNaN(index))\r\n        {\r\n            index = self.panes().length;\r\n        }\r\n\r\n        var newPane = new VMPane({\r\n            id: nextPaneId++,\r\n            item: self.root(),\r\n            mode: mode\r\n        });\r\n\r\n        self.addPane(newPane, index);\r\n\r\n        self.setFocusedPane(newPane);\r\n\r\n        return newPane;\r\n    };\r\n\r\n    self.removePane = function(pane)\r\n    {\r\n        var paneArr = self.panes();\r\n\r\n        for (var i = 0; i < paneArr.length; i ++)\r\n        {\r\n            if (pane == paneArr[i])\r\n            {\r\n                self.removePaneAtIndex(i);\r\n\r\n                self.setFocusedPane(paneArr[0]);\r\n\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    };\r\n\r\n    self.paneCount = function()\r\n    {\r\n        return self.panes().length;\r\n    };\r\n\r\n    var lastDateRollover = 0;\r\n    self.setupDateRollover = function()\r\n    {\r\n        var currentTime = new Date();\r\n\r\n        var nextRolloverTime = currentTime.clone().addDays(1).clearTime();\r\n        g.Assert(nextRolloverTime > currentTime, 'Rollover time must be in the future');\r\n        g.Assert(nextRolloverTime > lastDateRollover, 'Rollover time must be after the last rollover');\r\n\r\n        log('Next Rollover Time: ', nextRolloverTime);\r\n\r\n        setTimeout(function ()\r\n        {\r\n            g.Assert(self.isLoaded, 'Expect that we have fully loaded the page before performing rollover');\r\n\r\n            log('---- Running Date Rollover ----');\r\n\r\n            lastDateRollver = new Date();\r\n\r\n            var nextTime = self.setupDateRollover();\r\n\r\n            function runRolloverWork()\r\n            {\r\n                self.runParseWorker();\r\n\r\n                g.timeline.reloadTimelines();\r\n\r\n                log('-------------------------------');\r\n            }\r\n\r\n            // Reload contacts as well to keep up to date.\r\n            if (g.settings.get(Settings.syncContacts))\r\n            {\r\n                goog.loadedContacts = false;\r\n                goog.loadContacts(runRolloverWork);\r\n            }\r\n            else\r\n            {\r\n                runRolloverWork();\r\n            }\r\n        }, (nextRolloverTime - currentTime));\r\n\r\n        return nextRolloverTime;\r\n    };\r\n\r\n    function runRemoteLoad(rootItem)\r\n    {\r\n        g.isLoadingRemote = true;\r\n\r\n        try\r\n        {\r\n            d.beginTransaction();\r\n\r\n            if (DEBUG) console.profile('Load Remote Data');\r\n\r\n            g.timeline.startLoading();\r\n\r\n            var lastServerVersion = g.settings.get(Settings.lastServerVersion);\r\n            var currentServerVersion = gdata.getServerVersion();\r\n\r\n            if (lastServerVersion === currentServerVersion)\r\n            {\r\n                log('Client and Server Versions Match!');\r\n            }\r\n\r\n            g.startTimeEvent('PageLoad', 'RemoteData', 'Load Remote Data');\r\n            tracker.beginAction();\r\n\r\n            var previousLocalIntegrity = g.settings.get(Settings.localIntegrity);\r\n\r\n            if (previousLocalIntegrity === false)\r\n            {\r\n                if (ShouldLog(LogLevels.Warning)) log('Previous remote sync had an issue!');\r\n\r\n                g.reportError(new Error('Previous remote sync had an issue!'));\r\n            }\r\n\r\n            gdata.loadSeen = { };\r\n\r\n            if (REPORT_ACTIONS) { d.reportData(DataSnapshot.Before); }\r\n\r\n            g.settings.set(Settings.localIntegrity, false);\r\n\r\n            self.root().initFromGDrive(rootItem);\r\n\r\n            g.settings.set(Settings.localIntegrity, true);\r\n\r\n            if (REPORT_ACTIONS) { d.reportData(DataSnapshot.After); }\r\n\r\n            gdata.loadSeen = { };\r\n\r\n            tracker.endAction();\r\n\r\n            if (DEBUG)\r\n            {\r\n                gdata.verifyLocalRemoteIntegrity();\r\n            }\r\n\r\n            if (DEBUG) log('Drive done init', log.now());\r\n\r\n            self.flushParseItems(function ()\r\n            {\r\n                for (var i = 0; i < self.panes().length; i ++)\r\n                {\r\n                    self.panes()[i].vmSearch.updateSearch(true);\r\n                }\r\n            });\r\n\r\n            self.flushModifiedItems(function (items)\r\n            {\r\n                log('Flushing Modified: ', Object.keys(items).length);\r\n\r\n                // for (var id in items)\r\n                // {\r\n                //     log('Modified Item: ', items[id]);\r\n                // }\r\n            });\r\n\r\n            g.timeline.endLoading();\r\n\r\n            if (d.hasLocalData)\r\n            {\r\n                self.root().resetModified();\r\n            }\r\n\r\n            // Any updates that were queued before the remote data was loaded should be flushed\r\n            // as they were taken into account during conflict resolution and applied.\r\n            d.clearPendingUpdates();\r\n\r\n            g.endTimeEvent();\r\n\r\n            g.fireCustomEvent('remoteDataLoaded');\r\n\r\n            /////////////////////////////////////////\r\n            /////////////////////////////////////////\r\n            /////////////////////////////////////////\r\n            if (DEBUG) console.profileEnd();\r\n            /////////////////////////////////////////\r\n            /////////////////////////////////////////\r\n            /////////////////////////////////////////\r\n\r\n            if (DEBUG) console.profileEnd();\r\n\r\n            if (DEBUG)\r\n            {\r\n                setTimeout(function()\r\n                {\r\n                    d.printIndexedDB('id', 'text', 'version', 'versionText', 'modifiedOffline', 'isArchived');\r\n                    gdata.print();\r\n                }, 200);\r\n            }\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n\r\n            g.messageQueue.pushMessage({\r\n                text: 'There was an error loading your data from the server, consider reloading the app.',\r\n                type: MessageType.Error,\r\n                action: MessageAction.Reload\r\n            });\r\n        }\r\n        finally\r\n        {\r\n            d.endTransaction();\r\n\r\n            g.isLoadingRemote = false;\r\n\r\n            g.vmMain.isLoadingDoc(false);\r\n\r\n            g.StopSpinner();\r\n        }\r\n    }\r\n\r\n    function restoreLoadSelection()\r\n    {\r\n        if (!platform.mobile)\r\n        {\r\n            var setSelection = g.restoreSavedSelection('loadData');\r\n            if (!setSelection)\r\n            {\r\n                if (g.focusedPane && !g.focusedPane.isTimeline())\r\n                {\r\n                    var firstItem = g.getFirstPaneItem(g.focusedPane);\r\n\r\n                    if (firstItem)\r\n                    {\r\n                        g.setSelection(firstItem.getSpan(), 0, 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    var hasLoadedRemoteData = false;\r\n    self.loadGDriveData = function()\r\n    {\r\n        if (hasLoadedRemoteData)\r\n        {\r\n            return;\r\n        }\r\n\r\n        hasLoadedRemoteData = true;\r\n\r\n        if (!platform.mobile)\r\n        {\r\n            g.saveSelection('loadData');\r\n        }\r\n\r\n        if (DEBUG) log('Begin Remote Load:', log.now());\r\n\r\n        // var syncMessage = g.messageQueue.pushMessage({\r\n        //     text: 'Syncing with remote server, do not close your browser.',\r\n        //     type: MessageType.Info,\r\n        //     action: MessageAction.Default\r\n        // });\r\n\r\n        var rootItem = gdata.rootItem;\r\n        self.root().linkToGDrive(rootItem);\r\n\r\n        gdata.itemsLoaded = true;\r\n\r\n        try\r\n        {\r\n            gdata.checkRemoteIntegrity();\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n\r\n        var localRoot = d.getRootItem();\r\n        if (localRoot.id !== rootItem.id)\r\n        {\r\n            d.modifyItemId(localRoot.id, rootItem.id, function()\r\n            {\r\n                var item = d.getModel(rootItem.id);\r\n                g.Assert(localRoot.id === rootItem.id, 'IDs should have been modified in modifyItemId');\r\n                localRoot.id = rootItem.id;\r\n\r\n                d.setRoot(rootItem.id);\r\n                item.forceModifiedItems = true;\r\n\r\n                if (DEBUG) log('Got Drive data', log.now());\r\n\r\n                runRemoteLoad(rootItem);\r\n\r\n                if (!d.hasLocalData)\r\n                {\r\n                    item.items.valueHasMutated();\r\n                }\r\n\r\n                //g.messageQueue.clearMessage(syncMessage);\r\n\r\n                restoreLoadSelection();\r\n\r\n                if (DEBUG) log('Remote Document Loaded', log.now());\r\n            });\r\n        }\r\n        else\r\n        {\r\n            runRemoteLoad(rootItem);\r\n\r\n            //g.messageQueue.clearMessage(syncMessage);\r\n\r\n            restoreLoadSelection();\r\n\r\n            if (DEBUG) log('Remote Document Loaded', log.now());\r\n        }\r\n\r\n        self.vmPicker.refreshFiles();\r\n        if (DEBUG) log('Loading documents', log.now());\r\n    };\r\n\r\n    var hasLoadedData = false;\r\n    self.loadData = function()\r\n    {\r\n        if (hasLoadedData || !d.localDataLoaded())\r\n        {\r\n            return;\r\n        }\r\n\r\n        hasLoadedData = true;\r\n\r\n        // var start = window.performance.now();\r\n\r\n        // var docRoot = gdata.docRoot;\r\n        // docRoot.isRoot = true;\r\n        // log(docRoot.get('text'));\r\n\r\n        if (DEBUG) console.profile('Load Local Data');\r\n\r\n        if (DEBUG)\r\n        {\r\n            d.printIndexedDB('id', 'text', 'version', 'versionText', 'modifiedOffline', 'isArchived');\r\n        }\r\n\r\n        g.startTimeEvent('PageLoad', 'LocalData', 'Load Local Data');\r\n\r\n        //console.timeStamp('Loading Local Data');\r\n\r\n        self.root(new VMLI(d.getRootItem()));\r\n        //g.root = self.root();\r\n\r\n        if (DEBUG) log('Local Document Loaded', log.now());\r\n        g.checkpoint(Checkpoint.LocalDocLoad);\r\n\r\n        g.endTimeEvent();\r\n\r\n        if (DEBUG) console.profileEnd();\r\n\r\n        if (g.requireGDriveDataCallback)\r\n        {\r\n            self.loadGDriveData();\r\n        }\r\n\r\n        // var end = window.performance.now();\r\n\r\n        //log('init took ', (end - start), start, end);\r\n\r\n        // var end2 = window.performance.now();\r\n        //log('apply took', (end2 - end));\r\n\r\n        if (self.isDemoMode())\r\n        {\r\n            var contacts = [ ];\r\n            var contactId = 0;\r\n\r\n            function addContact(name)\r\n            {\r\n                var email = 'fake_' + name.replace(' ', '');\r\n\r\n                contacts.push({\r\n                    id: 'contact_' + contactId ++,\r\n                    name: name,\r\n                    isDemo: true,\r\n                    emails: [\r\n                        {address: email + '@moo.do', primary: true}\r\n                    ],\r\n                    phoneNumbers: [\r\n                        {number: \"(555) 123-4567\", type: \"mobile\"}\r\n                    ]\r\n                });\r\n            }\r\n\r\n            addContact('Ramada');\r\n            addContact('Canyon Ranch');\r\n            addContact('Jim Joseph');\r\n            addContact('Miller Harris');\r\n            addContact('Bob Johnson');\r\n            addContact('Bill Wilson');\r\n            addContact('Emily Edwards');\r\n            addContact('Jane Johnson');\r\n            addContact('Mike Thomas');\r\n            addContact('Joe Lewis');\r\n            addContact('Grant');\r\n            addContact('Jay');\r\n            addContact('Honey Bear');\r\n\r\n            d.loadContacts(contacts, /*isDemo*/true);\r\n        }\r\n\r\n        if (DEBUG) log('Run loading/parseWorker', log.now());\r\n\r\n        self.runParseWorker(undefined, function ()\r\n        {\r\n            var testData = util.getURLParam('data');\r\n\r\n            // if (self.isDemoMode() && (!testData || testData === \"\"))\r\n            // {\r\n            //     g.vmSetup.startIntroduction();\r\n            // }\r\n\r\n            if (self.isDemoMode())\r\n            {\r\n                if (platform.script)\r\n                {\r\n                    g.vmSetup.runScript(util.getURLParam('script'));\r\n                }\r\n\r\n                if (DEBUG && typeof window.callPhantom === 'function')\r\n                {\r\n                    setTimeout(function ()\r\n                    {\r\n                        window.callPhantom('takeShot');\r\n                    });\r\n                }\r\n\r\n                window.parent.postMessage('loaded', '*');\r\n            }\r\n        });\r\n\r\n        self.afterLoaded();\r\n\r\n\r\n        if (DEBUG) console.profile('Apply Bindings');\r\n\r\n        //console.timeStamp('Start Apply Bindings');\r\n\r\n        g.startTimeEvent('PageLoad', 'ApplyBindings', 'Apply Bindings');\r\n\r\n        g.applyBindings(self, 'container');\r\n\r\n        for (var i = 0; i < self.panes().length; i ++)\r\n        {\r\n            self.panes()[i].vmSearch.onUpdated.valueHasMutated();\r\n        }\r\n\r\n        // if (!g.settings.get(Settings.shownTutorial))\r\n        // {\r\n        //     ko.applyBindings(self, document.getElementById('introBox'));\r\n\r\n        //     StopSpinner();\r\n        // }\r\n\r\n        // var desktopMenuEle = document.getElementById('desktopMenu');\r\n        // if (desktopMenuEle)\r\n        // {\r\n        //     ko.applyBindings(self, desktopMenuEle);\r\n        // }\r\n\r\n        // var gdStatusEle = document.getElementById('gdriveStatus');\r\n        // if (gdStatusEle)\r\n        // {\r\n        //     ko.applyBindings(self, gdStatusEle);\r\n        // }\r\n\r\n        // var docTitleEle = document.getElementById('docTitle');\r\n        // if (docTitleEle)\r\n        // {\r\n        //     ko.applyBindings(self, docTitleEle);\r\n        // }\r\n\r\n        // g.removeClass(document.getElementById('container'), 'none');\r\n\r\n        //console.timeStamp('End Apply Bindings');\r\n\r\n        if (DEBUG) console.profileEnd();\r\n\r\n        self.isLoaded = true;\r\n\r\n        document.getElementById('container').style.display = 'block';\r\n\r\n        if (DEBUG && DEBUG)\r\n        {\r\n            window.__AUTO_TEST_DONE_LOADING = true;\r\n        }\r\n\r\n        g.endTimeEvent();\r\n    };\r\n\r\n    self.changeRoot = function(rootId)\r\n    {\r\n        g.Assert(rootId, 'Cannot use to reset root to undefined');\r\n\r\n        var needsParse = false;\r\n        var newRoot = d.getModel(rootId);\r\n        if (!newRoot)\r\n        {\r\n            newRoot = new VMLI(d.getItem(rootId));\r\n            needsParse = true;\r\n        }\r\n\r\n        g.Assert(newRoot, 'Must have a new root VMLI at this point, otherwise failed creation');\r\n\r\n        if (newRoot)\r\n        {\r\n            self.root(newRoot);\r\n\r\n            for (var i = 0; i < self.panes().length; i ++)\r\n            {\r\n                self.panes()[i].item(newRoot);\r\n                self.panes()[i].notifyOfZoom();\r\n            }\r\n\r\n            if (needsParse)\r\n            {\r\n                self.runParseWorker(undefined);\r\n            }\r\n        }\r\n    };\r\n\r\n    self.resetScrollOffsets = function()\r\n    {\r\n        for(var i = 0; i < self.panes().length; i ++)\r\n        {\r\n            var pane = self.panes()[i];\r\n\r\n            pane.setScrollOffset(pane.defaultOffset);\r\n        }\r\n    };\r\n\r\n    // var dismissedHelp = ko.observable(false);\r\n\r\n    // self.showHelp = function()\r\n    // {\r\n    //     //var rootItems = self.root().items();\r\n\r\n    //     //var fewItems = !((rootItems.length > 1) || (rootItems.length > 0 && rootItems[0].items().length > 0));\r\n\r\n    //     var hasShownTutorial = g.settings.get(Settings.shownTutorial);\r\n\r\n    //     var defaultDoc = goog.isDefaultDoc();\r\n\r\n    //     //return (fewItems && defaultDoc) && !dismissedHelp();\r\n    //     //return defaultDoc && !hasShownTutorial && !dismissedHelp() && !self.isDemoMode();\r\n    //     return false;\r\n    // };\r\n\r\n    self.helpMessage = function()\r\n    {\r\n        if (platform.mobile)\r\n        {\r\n            return \"Welcome to Moo.do! If this is your first time here take a minute to orient yourself, otherwise your data will be here shortly.\";\r\n        }\r\n        else\r\n        {\r\n            return \"Welcome to Moo.do! If this is your first time here take a minute to orient yourself and import your data, otherwise your data will be here shortly. You can access the introduction at a later time through the top-right menu.\";\r\n        }\r\n    };\r\n\r\n    self.onTapMain = {\r\n        onClick: function(e)\r\n        {\r\n            if (self.isDemoMode() && platform.script)\r\n            {\r\n                window.parent.postMessage('click', '*');\r\n            }\r\n        }\r\n    };\r\n\r\n    // self.onTapRunIntroduction = function(e)\r\n    // {\r\n    //     dismissedHelp(true);\r\n\r\n    //     util.insertURLParam('demo', 'true');\r\n\r\n    //     e.preventDefault();\r\n    //     e.stopImmediatePropagation();\r\n\r\n    //     return false;\r\n    // };\r\n\r\n    // self.onTapImportData = function(e)\r\n    // {\r\n    //     g.vmDebug.onTapImport();\r\n\r\n    //     e.preventDefault();\r\n    //     e.stopImmediatePropagation();\r\n\r\n    //     return false;\r\n    // };\r\n\r\n    // self.onTapCancelIntroduction = function(e)\r\n    // {\r\n    //     g.settings.set(Settings.shownTutorial, true);\r\n\r\n    //     dismissedHelp(true);\r\n\r\n    //     e.preventDefault();\r\n    //     e.stopImmediatePropagation();\r\n\r\n    //     return false;\r\n    // };\r\n\r\n    //\r\n    // Per Pane State:\r\n    // id, focus, mode, showarch, search, offset\r\n    //\r\n    self.addPane = function(pane, index)\r\n    {\r\n        g.Assert(pane, 'Must pass in a valid pane to update');\r\n\r\n        var paneState = g.settings.get(Settings.paneState);\r\n        if (!paneState)\r\n        {\r\n            paneState = [ ];\r\n        }\r\n\r\n        g.Assert(paneState.length === self.panes().length, 'Pane state does not match currently loaded pane set');\r\n\r\n        if (index === undefined)\r\n        {\r\n            self.panes.push(pane);\r\n        }\r\n        else\r\n        {\r\n            self.panes.splice(index, 0, pane);\r\n        }\r\n\r\n        paneState.push({\r\n            id: pane.id,\r\n            focus: pane.item().id,\r\n            mode: pane.mode(),\r\n            showarch: pane.showArchived(),\r\n            search: pane.vmSearch.search(),\r\n            offset: 0\r\n        });\r\n\r\n        g.settings.set(Settings.paneState, paneState);\r\n    };\r\n\r\n    self.removePaneAtIndex = function(index)\r\n    {\r\n        g.Assert(index !== undefined, 'Must pass in a valid index to remove');\r\n\r\n        var paneState = g.settings.get(Settings.paneState);\r\n        g.Assert(paneState, 'Pane state should always be valid when removing panes');\r\n\r\n        g.Assert(paneState.length === self.panes().length, 'Pane state does not match currently loaded pane set');\r\n\r\n        self.panes.splice(index, 1);\r\n\r\n        paneState.splice(index, 1);\r\n\r\n        g.settings.set(Settings.paneState, paneState);\r\n    }\r\n\r\n    self.afterLoaded = function()\r\n    {\r\n        var paneState;\r\n        if (self.isDemoMode())\r\n        {\r\n            self.clearPaneState();\r\n        }\r\n        else\r\n        {\r\n            paneState = g.settings.get(Settings.paneState);\r\n        }\r\n\r\n        if (paneState)\r\n        {\r\n            for (var i = 0; i < paneState.length; ++i)\r\n            {\r\n                if(platform.mobile && i > 0)\r\n                {\r\n                    break;\r\n                }\r\n                var paneInfo = paneState[i];\r\n\r\n                // Update stored ID for the pane, this will change per load\r\n                paneInfo.id = nextPaneId;\r\n\r\n                var item = d.getModel(paneInfo.focus);\r\n\r\n                // When resetting the client it is possible that the hash will contain items that dont\r\n                // exist. Handle this by switching them back to the root. This will also reset the scroll\r\n                // position and search.\r\n                if (!item)\r\n                {\r\n                    item = self.root();\r\n\r\n                    paneInfo.focus = item.id;\r\n                    paneInfo.offset = 0;\r\n                    paneInfo.search = '';\r\n                }\r\n\r\n                g.Assert(item, 'Should always have a valid item at this point');\r\n\r\n                var pane = new VMPane({\r\n                    id: nextPaneId++,\r\n                    item: item,\r\n                    mode: paneInfo.mode,\r\n                    search: paneInfo.search,\r\n                    offset: paneInfo.offset\r\n                });\r\n\r\n                if (paneInfo.showarch)\r\n                {\r\n                    pane.showArchived(true);\r\n                }\r\n\r\n                // TODO: Fix potential perf problems with this approach, replace with something\r\n                //       that wont recreate DOM nodes while updating knockout\r\n\r\n                // When loading panes from the current pane state do not call addPane as it would double add\r\n                // the pane to the state.\r\n                self.panes.push(pane);\r\n                self.setFocusedPane(pane, /*forLoad*/true);\r\n                self.zoomin(item, true);\r\n            }\r\n\r\n            if (self.panes().length !== 1)\r\n            {\r\n                self.setFocusedPane(self.panes()[0], /*forLoad*/true);\r\n            }\r\n        }\r\n\r\n        if (self.isDemoMode() && g.demoPanes)\r\n        {\r\n            for(var i = 0; i < g.demoPanes.length; i ++)\r\n            {\r\n                self.addPane(new VMPane({\r\n                    id: nextPaneId ++,\r\n                    item: self.root(),\r\n                    mode: +g.demoPanes[i]\r\n                }));\r\n            }\r\n\r\n            var pane = self.panes()[0];\r\n            g.focusedPaneID = pane.id;\r\n            g.focusedPane = pane;\r\n            g.focusedItem = pane.item();\r\n\r\n            self.zoomin(pane.item(), true);\r\n        }\r\n        else if (self.panes().length === 0)\r\n        {\r\n            var pane = new VMPane({\r\n                id: nextPaneId++,\r\n                item: self.root()\r\n            });\r\n\r\n            self.addPane(pane);\r\n\r\n            if (!platform.mobile && g.activeDisplayMode & DisplayMode.ForceTwoPane)\r\n            {\r\n                var pane2 = new VMPane({\r\n                    id: nextPaneId++,\r\n                    item: self.root(),\r\n                    mode: PaneMode.Timeline\r\n                });\r\n\r\n                self.addPane(pane2);\r\n            }\r\n\r\n            // self.setFocusedPane('pane' + 0);\r\n            // self.zoomin(self.root(), true);\r\n\r\n            g.focusedPaneID = pane.id;\r\n            g.focusedPane = pane;\r\n            g.focusedItem = self.root();\r\n\r\n            self.zoomin(self.root(), true);\r\n        }\r\n\r\n        if (platform.mobile)\r\n        {\r\n            // setTimeout(function ()\r\n            // {\r\n            g.phoneMenu = new VMPhoneMenu();\r\n            g.keyboardToolbar = new VMKeyboardToolbar();\r\n            // }, 0);\r\n        }\r\n\r\n        // self.root().zoomin({time: 0});\r\n\r\n        // self.root(new VMLI({data: docRoot}));\r\n\r\n\r\n        // if (fullscreen)\r\n        // {\r\n        //     if(fullscreen != self.root().id)\r\n        //     {\r\n        //         var newFullscreen = d.getModel(fullscreen);\r\n\r\n        //         if (!newFullscreen)\r\n        //         {\r\n        //             newFullscreen = self.root();\r\n        //             g.Assert(newFullscreen);\r\n        //         }\r\n        //         // newFullscreen.zoomin({time: 0});\r\n        //         self.zoomin(newFullscreen);\r\n        //     }\r\n        //     elsepS\r\n        //     {\r\n        //         // Hash is root so just clear it off\r\n        //         location.hash = '';\r\n        //     }\r\n        // }\r\n        // else\r\n        // {\r\n        //     self.zoomin(self.root());\r\n        // }\r\n\r\n        g.timeline.updateNotifications();\r\n\r\n        //self.sendAnalytics();\r\n    };\r\n\r\n    // self.sendAnalytics = function ()\r\n    // {\r\n    //     g.sendEvent('LoadInfo', 'Items', window.__TOTAL_ITEMS);\r\n    //     g.sendEvent('LoadInfo', 'ArchivedItems', window.__TOTAL_ARCHIVED_ITEMS);\r\n    // };\r\n\r\n    // self.runAssertValid = function ()\r\n    // {\r\n    //     var state =\r\n    //     {\r\n    //         seenFullscreen: false,\r\n    //         errors: []\r\n    //     };\r\n\r\n    //     self.root().assertValid(state);\r\n    // };\r\n\r\n    self.clearPaneState = function()\r\n    {\r\n        g.settings.reset(Settings.paneState);\r\n    };\r\n\r\n    self.updatePaneState = function(pane)\r\n    {\r\n        if (g.isRunningScript() || platform.mobile)\r\n        {\r\n            return;\r\n        }\r\n\r\n        g.Assert(pane, 'Must pass in a valid pane to update');\r\n\r\n        var paneState = g.settings.get(Settings.paneState);\r\n        g.Assert(paneState, 'Pane state should always be valid when updating state');\r\n\r\n        g.Assert(paneState.length === self.panes().length, 'Pane state does not match currently loaded pane set');\r\n\r\n        var paneStateFound = false;\r\n        for (var i = 0; i < paneState.length; ++i)\r\n        {\r\n            var info = paneState[i];\r\n\r\n            if (info.id === pane.id)\r\n            {\r\n                info.focus = pane.item().id;\r\n                info.mode = pane.mode();\r\n                info.showarch = pane.showArchived();\r\n                info.search = pane.vmSearch.search();\r\n                //info.offset = pane.getScrollOffset();\r\n\r\n                g.settings.set(Settings.paneState, paneState);\r\n\r\n                paneStateFound = true;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        g.Assert(paneStateFound, 'Pane state should always be found');\r\n    };\r\n\r\n    self.updatePaneScrollState = function()\r\n    {\r\n        if (g.isRunningScript() || platform.mobile)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var paneState = g.settings.get(Settings.paneState);\r\n\r\n        // Pane length could be 0 if at the login screen\r\n        if (paneState && self.panes().length > 0)\r\n        {\r\n            g.Assert(paneState.length === self.panes().length, 'Pane state does not match currently loaded pane set');\r\n\r\n            for (var i = 0; i < paneState.length; ++i)\r\n            {\r\n                var info = paneState[i];\r\n                var pane = self.panes()[i];\r\n\r\n                info.offset = pane ? pane.getScrollOffset() : 0;\r\n            }\r\n\r\n            g.settings.set(Settings.paneState, paneState);\r\n        }\r\n    };\r\n\r\n    // self.updateHash = function()\r\n    // {\r\n    //     return;\r\n\r\n    //     var hash = '#';\r\n\r\n    //     for(var i = 0; i < self.panes().length; i ++)\r\n    //     {\r\n    //         var pane = self.panes()[i];\r\n\r\n    //         if (i > 0)\r\n    //         {\r\n    //             hash += ',';\r\n    //         }\r\n\r\n    //         if (pane.item() != self.root())\r\n    //         {\r\n    //             hash += pane.item().id;\r\n    //         }\r\n\r\n    //         if (pane.mode() === PaneMode.Timeline)\r\n    //         {\r\n    //             hash += ':t';\r\n\r\n    //             if (pane.showArchived())\r\n    //             {\r\n    //                 hash += 'a';\r\n    //             }\r\n    //         }\r\n\r\n    //         var search = pane.vmSearch.search();\r\n    //         if (search && search !== TextSpace)\r\n    //         {\r\n    //             hash += ':?' + search;\r\n    //         }\r\n    //     }\r\n\r\n    //     if(hash != location.hash)\r\n    //     {\r\n    //         location.hash = hash;\r\n    //     }\r\n    // }\r\n\r\n    // self.handleExternInsert = function (id, data)\r\n    // {\r\n    //     g.Assert(id && data);\r\n\r\n    //     var createdCalendarList = false;\r\n\r\n    //     var itemAlreadyExists = false;\r\n\r\n    //     var eDuchessID = undefined;\r\n    //     if (data.extendedProperties && data.extendedProperties.private)\r\n    //     {\r\n    //         eDuchessID = data.extendedProperties.private.DuchessID;\r\n    //         if (eDuchessID)\r\n    //         {\r\n    //             var internalItem = d.getItem(eDuchessID, /*noAlert*/true);\r\n    //             if (internalItem)\r\n    //             {\r\n    //                 d.updateItemWithExtern(eDuchessID, id);\r\n    //                 itemAlreadyExists = true;\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     if (!itemAlreadyExists)\r\n    //     {\r\n    //         if (!g.root.calendarList)\r\n    //         {\r\n    //             g.root.calendarList = new VMLI({ 'text': 'Calendar Import:'}, {'parent': g.root, 'forceSave': true });\r\n    //             g.root.addChild(g.root.calendarList);\r\n\r\n    //             createdCalendarList = true;\r\n    //         }\r\n\r\n    //         var startDate;\r\n    //         if(data.start.dateTime) // Has a date and time\r\n    //             startDate = new Date(data.start.dateTime);\r\n    //         else if(data.start.date) // Has only a date\r\n    //         {\r\n    //             startDate = new Date(data.start.date);\r\n    //             startDate.setHours(0); // This is a temp workaround for timezone issues\r\n    //         }\r\n    //         else // Has no date\r\n    //             return;\r\n\r\n    //         var dateString = \"\";\r\n    //         if (!eDuchessID)\r\n    //         {\r\n    //             if(!startDate.getHours()) // Only a date, no time\r\n    //                 dateString = startDate.toString('M/d');\r\n    //             else if(!startDate.getMinutes()) // A time with 0 minutes\r\n    //                 dateString = startDate.toString('M/d htt');\r\n    //             else // A time with minutes\r\n    //                 dateString = startDate.toString('M/d h:mmtt');\r\n\r\n    //             dateString = ' @' + dateString;\r\n    //         }\r\n\r\n    //         // If there is an empty summary, use a placeholder\r\n    //         if (!data.summary)\r\n    //         {\r\n    //             data.summary = '(No Title)';\r\n    //         }\r\n\r\n    //         var itemText = data.summary + dateString;\r\n    //         var newItem = new VMLI({ 'text': itemText, 'extern': id}, {'parent': g.root.calendarList, 'forceSave': true });\r\n    //         g.root.calendarList.items.push(newItem);\r\n\r\n    //         self.runParseWorker(newItem.parent());\r\n    //     }\r\n    // };\r\n\r\n    // self.handleExternUpdate = function (id, data)\r\n    // {\r\n    //     var externItem = d.getItemForExternEntry(id);\r\n\r\n    //     if (externItem)\r\n    //     {\r\n    //         externItem.notifyExternUpdated(data);\r\n    //     }\r\n    // };\r\n\r\n    // var lastItemNoSelect;\r\n    // var didMouseUp = false;\r\n\r\n    // function mousedown(e)\r\n    // {\r\n    //     // TODO: Do we want to do this?\r\n    //     return;\r\n\r\n    //     if (!didMouseUp) // Cover the case where the mouse leaves the window so mouseup never fired\r\n    //     {\r\n    //         mouseup(e);\r\n    //         didMouseUp = true;\r\n    //     }\r\n\r\n    //     var el = e.srcElement;\r\n    //     var li = g.getLIParent(el);\r\n    //     if(!li)\r\n    //         return;\r\n    //     var fullscreenChild = ko.dataFor(li);\r\n    //     if (!fullscreenChild || fullscreenChild.isFullscreen())\r\n    //     {\r\n    //         return;\r\n    //     }\r\n\r\n    //     while (!fullscreenChild.parent().isFullscreen())\r\n    //     {\r\n    //         fullscreenChild = fullscreenChild.parent();\r\n    //     }\r\n\r\n    //     if (fullscreenChild.isHeader())\r\n    //     {\r\n    //         // If it's a header, just make this box autoSelect\r\n    //         fullscreenChild.$element.addClass('autoSelect');\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         // Otherwise, find all non-header items in this box and make them autoSelect\r\n    //         var itemIndex = fullscreenChild.getIndex();\r\n    //         var parent = fullscreenChild.parent();\r\n    //         for(var i = itemIndex; i >= 0; i --)\r\n    //         {\r\n    //             var prevItem = parent.items()[i];\r\n    //             if(prevItem.isHeader()) // A header is a new box\r\n    //                 break;\r\n    //             prevItem.$element.addClass('autoSelect');\r\n    //         }\r\n\r\n    //         for(i = itemIndex + 1; i < parent.items().length; i ++)\r\n    //         {\r\n    //             var nextItem = parent.items()[i];\r\n    //             if(nextItem.isHeader()) // A header is a new box\r\n    //                 break;\r\n    //             nextItem.$element.addClass('autoSelect');\r\n    //         }\r\n    //     }\r\n\r\n    //     g.focusedItem.$element.addClass('noSelect');\r\n    //     lastItemNoSelect = fullscreenChild;\r\n    //     didMouseUp = false;\r\n    // }\r\n\r\n    // function mouseup(e)\r\n    // {\r\n    //     // Remove the selection modification\r\n    //     didMouseUp = true;\r\n    //     if(lastItemNoSelect)\r\n    //     {\r\n    //         g.focusedItem.$element.removeClass('noSelect');\r\n    //         var parentItems = lastItemNoSelect.parent().items();\r\n    //         for(var i = 0; i < parentItems.length; i ++)\r\n    //         {\r\n    //             parentItems[i].$element.removeClass('autoSelect');\r\n    //         }\r\n    //         lastItemNoSelect = undefined;\r\n    //     }\r\n    // }\r\n    // container.addEventListener('mousedown', mousedown);\r\n    // container.addEventListener('mouseup', mouseup);\r\n\r\n    // Set isSelected on items in the user's selection\r\n    // var prevSelected = {};\r\n    var prevRange;\r\n\r\n    // self.isKeyboardOpen.subscribe(function(newValue)\r\n    // {\r\n    //     if (DEBUG) log('Keyboard Open: ' + newValue);\r\n\r\n    //     if (newValue)\r\n    //     {\r\n    //         g.addClass(document.documentElement, 'keyboardOpen');\r\n\r\n    //         // Only hide the topbar if we are not focusing on the search box.\r\n    //         g.element('phoneMenuFloating').style.visibility = 'hidden';\r\n\r\n    //         // if (g.shouldShowKeyboardMenu())\r\n    //         // {\r\n    //         //     self.elPhoneMenu.style.visibility = 'hidden';\r\n    //         // }\r\n    //                     // requestAnimationFrame(function(){\r\n    //         // self.elPhoneMenu.style.position = 'absolute';\r\n    //         // g.vmMain.elPhoneMenu.style.top = document.body.scrollTop + 'px';\r\n\r\n    //         // });\r\n    //         // g.addClass(document.documentElement, 'keyboardOpen');\r\n    //         // g.addClass(self.elContainer, 'keyboardOpen');\r\n    //         // requestAnimationFrame(function(){\r\n    //         //     g.keyboardToolbar.element.style.visibility = 'visible';\r\n    //         // });\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         g.removeClass(document.documentElement, 'keyboardOpen');\r\n\r\n    //         // self.elPhoneMenu.style.position = 'fixed';\r\n    //         // g.removeClass(document.documentElement, 'keyboardOpen');\r\n    //         requestAnimationFrame(function()\r\n    //         {\r\n    //             self.elPhoneMenu.style.visibility = 'visible';\r\n\r\n    //             if (platform.bodyscroll)\r\n    //             {\r\n    //                 self.elPhoneMenu.style.position = 'fixed';\r\n    //             }\r\n    //             else\r\n    //             {\r\n    //                 self.elPhoneMenu.style.top = '0';\r\n    //             }\r\n\r\n    //             g.element('phoneMenuFloating').style.visibility = 'visible';\r\n    //             g.keyboardToolbar.hide();\r\n    //         });\r\n    //         // g.keyboardToolbar.element.style.visibility = 'hidden';\r\n    //         // g.removeClass(g.keyboardToolbar.element, 'keyboardOpen');\r\n    //         // g.removeClass(self.elContainer, 'keyboardOpen');\r\n    //     }\r\n    // });\r\n\r\n    self.getFirstSelectedItem = function()\r\n    {\r\n        g.Assert(platform.mobile, 'Selection tracking only available from mobile');\r\n\r\n        if(self.selected().length > 0)\r\n            return self.selected()[0];\r\n\r\n        return undefined;\r\n    };\r\n\r\n    // selection must be an array\r\n    self.setSelected = function(selection)\r\n    {\r\n        g.Assert(platform.mobile, 'Selection tracking only available from mobile');\r\n\r\n        selection = selection || [];\r\n        self._clearIsSelected(selection);\r\n        for(var i = 0; i < selection.length; i ++)\r\n        {\r\n            selection[i].isSelected(true);\r\n        }\r\n        self.selected(selection);\r\n    };\r\n\r\n    // newSelection must be an array\r\n    self._clearIsSelected = function(newSelected)\r\n    {\r\n        g.Assert(platform.mobile, 'Selection tracking only available from mobile');\r\n\r\n        newSelected = newSelected || [];\r\n        // Remove selection from old items that aren't in new items\r\n        for(var i = 0; i < self.selected().length; i ++)\r\n        {\r\n            // If item is in the new selection, don't remove selection from it\r\n            var selectedItem = self.selected()[i];\r\n            if(newSelected.indexOf(selectedItem) < 0)\r\n            {\r\n                selectedItem.isSelected(false);\r\n            }\r\n        }\r\n    };\r\n\r\n    self.clearSelected = function(newSelected)\r\n    {\r\n        g.Assert(platform.mobile, 'Selection tracking only available from mobile');\r\n\r\n        self._clearIsSelected(newSelected);\r\n        self.selected([]);\r\n    };\r\n\r\n    // Selection is only used on mobile platforms, desktop does not use this.\r\n    if (platform.mobile)\r\n    {\r\n        document.onselectionchange = function(e)\r\n        {\r\n            var selection = g.getSelectionInfo();\r\n            var itemsChanged = true;\r\n            var arrToSelect;\r\n\r\n            // This gets set by g.blurActiveElement\r\n            if(g.ignoreSelectionChange)\r\n            {\r\n                g.ignoreSelectionChange = false;\r\n                prevRange = undefined;\r\n                return;\r\n            }\r\n\r\n            if (selection)\r\n            {\r\n                // On android, if a drag has started, ensure that no text is selected\r\n                if (platform.android && g.dragging)\r\n                {\r\n                    g.clearSelection();\r\n\r\n                    return;\r\n                }\r\n\r\n                var range = selection.selection.getRangeAt(0);\r\n                itemsChanged = !prevRange || range.startContainer !== prevRange.startContainer || range.endContainer !== prevRange.endContainer;\r\n\r\n                if (prevRange && !itemsChanged &&\r\n                    range.startOffset == prevRange.startOffset &&\r\n                    range.endOffset == prevRange.endOffset)\r\n                {\r\n                    return; // Nothing's changed so return out\r\n                }\r\n\r\n                if (range.startContainer.id === 'itemOptions' || range.startContainer.id === 'fullscreenClickGrabber')\r\n                {\r\n                    return;\r\n                }\r\n\r\n                prevRange = range;\r\n                // var docRoot = $(range.startContainer).parents('.pane')[0];\r\n                // var paneContent = $(range.startContainer).parents('.paneContent')[0];\r\n\r\n                if (g.focusedPane && g.focusedPane.mode() === PaneMode.Normal)\r\n                {\r\n                    var origLIParent = g.getLIParent(range.startContainer);\r\n                    var origStart = origLIParent ? ko.dataFor(origLIParent) : undefined;\r\n\r\n                    var skipUpdates = !origStart || (!origStart instanceof VMPane && !origStart instanceof VMLI);\r\n                    if (skipUpdates)\r\n                    {\r\n                        // Don't do anything because this isn't an item\r\n                    }\r\n                    else\r\n                    {\r\n                        g.restrictSelectionToText();\r\n\r\n                        selection = g.getSelectionInfo();\r\n                        range = selection.selection.getRangeAt(0);\r\n\r\n                        var startLI = g.getLIParent(range.startContainer);\r\n                        var endLI = g.getLIParent(range.endContainer);\r\n\r\n                        if (startLI && endLI && !g.hasClass(startLI, 'emptyPaneItem') && !g.hasClass(endLI, 'emptyPaneItem'))\r\n                        {\r\n                            var item = ko.dataFor(startLI);\r\n\r\n                            if (itemsChanged)\r\n                            {\r\n                                if (startLI !== endLI)\r\n                                {\r\n                                    var endItem = ko.dataFor(endLI);\r\n\r\n                                    // Add all lines in the selection to arrToSelect\r\n                                    arrToSelect = g.getItemsBetween(item, endItem, g.focusedPane);\r\n                                }\r\n                                else\r\n                                {\r\n                                    arrToSelect = [ item ];\r\n\r\n                                    if (android.isEnabled())\r\n                                    {\r\n                                        android.updateInput(item);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (platform.android || platform.mobileie || (platform.ios && (!platform.app || platform.ipad)))\r\n            {\r\n                g.fireCustomEvent('closeKeyboard');\r\n            }\r\n\r\n            if(!selection)\r\n            {\r\n                prevRange = undefined;\r\n            }\r\n\r\n            // If there are items which have changed their selection state and the selection state matters.\r\n            if (itemsChanged && !(platform.android || platform.mobileie))\r\n            {\r\n                // Set selection to new items\r\n                self.setSelected(arrToSelect);\r\n            }\r\n        };\r\n    }\r\n\r\n    self.setFocusedPaneFromElement = function(element)\r\n    {\r\n        if (element)\r\n        {\r\n            var paneEl = g.hasClass(element, 'paneRoot') ? element : g.getPaneForElement(element).rootElement;\r\n\r\n            var pane = ko.dataFor(paneEl);\r\n            g.Assert(pane, 'Could not find matching pane');\r\n\r\n            self.setFocusedPane(pane);\r\n        }\r\n    };\r\n\r\n    var hasCalledNonLoad = false;\r\n    self.setFocusedPane = function(pane, forLoad)\r\n    {\r\n        if (g.focusedPaneID !== pane.id)\r\n        {\r\n            hasCalledNonLoad = !forLoad;\r\n\r\n            g.focusedPaneID = pane.id;\r\n            // var paneIndex = parseInt(id.replace(/\\D/g, ''), 10);\r\n            g.focusedPane = pane;//self.panes()[paneIndex];\r\n            g.focusedItem = g.focusedPane.item();\r\n        }\r\n\r\n        // if (!forLoad && !platform.phone)\r\n        // {\r\n        //     g.menus.openHoverMenu(g.focusedItem);\r\n        // }\r\n    };\r\n\r\n    self.zoomin = function(item, forLoad)\r\n    {\r\n        g.Assert(item, 'Must supply a valid item to zoom to');\r\n\r\n        var oldItem = g.focusedItem;\r\n        self._zoom(item, forLoad);\r\n\r\n        var pane = g.focusedPane;\r\n\r\n        if(!forLoad)\r\n        {\r\n            g.sendEvent('Menu', 'ZoomIn');\r\n        }\r\n\r\n        if (!platform.mobile && pane.paneContent)\r\n        {\r\n            g.setSelection(pane.paneContent, 0, 0);\r\n        }\r\n\r\n        if (pane.rootElement)\r\n        {\r\n            pane.setScrollOffset();\r\n        }\r\n        else\r\n        {\r\n            setTimeout(function ()\r\n            {\r\n                pane.setScrollOffset();\r\n            }, 0);\r\n        }\r\n\r\n        if (item.isCollapsed())\r\n        {\r\n            item.toggleCollapsed();\r\n        }\r\n\r\n        if (!forLoad)\r\n        {\r\n            tracker.performAction(TrackerType.Zoom, {\r\n                itemID: item.id,\r\n                oldItemID: oldItem.id,\r\n                zoomOut: false,\r\n                time: g.zoomTime\r\n            });\r\n        }\r\n    };\r\n\r\n    self.zoomout = function(item, zoomedOutFrom)\r\n    {\r\n        g.Assert(item, 'Must supply a valid item to zoom to');\r\n        var oldItem = g.focusedItem;\r\n\r\n        self._zoom(item, false);\r\n\r\n        g.sendEvent('Menu', 'ZoomOut');\r\n\r\n        g.selectChildren(zoomedOutFrom, zoomedOutFrom.getParsedText().length, 0);\r\n\r\n        g.scrollToTop(zoomedOutFrom.getSpan(), 0);\r\n\r\n        tracker.performAction(TrackerType.Zoom, {\r\n            itemID: item.id,\r\n            oldItemID: oldItem.id,\r\n            zoomOut: true,\r\n            time: g.zoomTime\r\n        });\r\n    };\r\n\r\n    self._zoom = function(item, forLoad)\r\n    {\r\n        g.Assert(item, 'Must supply a valid item to zoom to');\r\n\r\n        var oldItem = g.focusedItem;\r\n\r\n        if (oldItem && oldItem.id === item.id)\r\n        {\r\n            // Already zoomed at this item, so do nothing\r\n            return;\r\n        }\r\n\r\n        g.focusedPane.item(item);\r\n        g.focusedPane.notifyOfZoom();\r\n\r\n        g.focusedItem = item;\r\n\r\n        if (!forLoad)\r\n        {\r\n            self.updatePaneState(g.focusedPane);\r\n        }\r\n    };\r\n\r\n    // function doNotifications()\r\n    // {\r\n    //     return; // Disabled for now\r\n    //     var timeNow = new Date();\r\n    //     timeNow.setSeconds(0);\r\n    //     timeNow.setMilliseconds(0);\r\n    //     // TODO: This doesn't handle time zones correctly\r\n    //     // TODO: Notify for items that have already happened but haven't notified\r\n    //     // and something nicer for items that happen on a date but not a specific time\r\n    //     // Get all items that happen this minute\r\n    //     var items = [];// a query for all items that happen this minute\r\n    //     if(items.length > 0)\r\n    //     {\r\n    //         for(var i = 0; i < items.length; i ++)\r\n    //         {\r\n    //             var notification = window.webkitNotifications.createNotification(\r\n    //                 null,\r\n    //                 'Basketcase',\r\n    //                 items[i].getParsedText()\r\n    //             );\r\n    //             // TODO: Highlight this item on click\r\n    //             notification.onclick = function(x) { window.focus(); this.cancel(); };\r\n    //             notification.show();\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    // self.setHideCompleted = function(value)\r\n    // {\r\n    //     g.hideCompleted = value;\r\n    //     if(value)\r\n    //         g.addClass(document.body, 'hideChecked');\r\n    //     else\r\n    //         g.removeClass(document.body, 'hideChecked');\r\n    // };\r\n\r\n    // self.openMenu = function(item, e)\r\n    // {\r\n    //     // TODO: Logic for which menu to open\r\n    //     g.clearSelection();\r\n\r\n    //     var offset = $(e.srcElement).offset();\r\n\r\n    //     self.menuHeader = $(document.getElementById('contextMenuHeader'));\r\n    //     self.menuHeader.css({left: offset.left + 'px', top: offset.top + 'px', opacity: 1});\r\n    //     self.menuOpenOn = item;\r\n\r\n    //     self.handleFullscreenClick(self.closeMenu);\r\n    // };\r\n\r\n    // self.closeMenu = function()\r\n    // {\r\n    //     self.menuHeader.css({opacity: 0});\r\n    //     self.menuHeader = undefined;\r\n    //     self.menuOpenOn = undefined;\r\n    // };\r\n\r\n    // g.setupClick(document.getElementById('contextMenus'), {\r\n    //     onEnd: function(e)\r\n    //     {\r\n    //         if(self.menuOpenOn)\r\n    //         {\r\n    //             log(e.target.className);\r\n    //             if (e.target.className.startsWith('menuOptionZoom'))\r\n    //             {\r\n    //                 if (self.menuOpenOn.hasChildren())\r\n    //                 {\r\n    //                     var oldZoomItem = g.focusedItem;\r\n\r\n    //                     self.menuOpenOn.zoomin({time: g.zoomTime});\r\n\r\n    //                     tracker.performAction(TrackerType.Zoom, {\r\n    //                         'itemID': self.menuOpenOn.id,\r\n    //                         'oldItemID': oldZoomItem.id,\r\n    //                         'zoomIn': true,\r\n    //                         'time': g.zoomTime\r\n    //                     });\r\n    //                 }\r\n    //             }\r\n\r\n    //             self.closeMenu();\r\n    //             self.cancelFullscreenClick();\r\n    //         }\r\n    //     }\r\n    // });\r\n\r\n    //var isMenuVisible = false;\r\n\r\n    // self.hideMenu = function()\r\n    // {\r\n    //     if(document.getElementById('menu'))\r\n    //     {\r\n    //         document.getElementById('menu').style.visibility = 'hidden';\r\n    //     }\r\n    //     isMenuVisible = false;\r\n    // };\r\n\r\n    // self.onMenuClicked = function()\r\n    // {\r\n    //     isMenuVisible = !isMenuVisible;\r\n    //     if (isMenuVisible)\r\n    //     {\r\n    //         document.getElementById('menu').style.visibility = 'visible';\r\n\r\n    //         setTimeout(function ()\r\n    //         {\r\n    //             self.handleFullscreenClick(function()\r\n    //             {\r\n    //                 self.hideMenu();\r\n    //             });\r\n    //         }, 100);\r\n    //     }\r\n    //     else\r\n    //     {\r\n    //         document.getElementById('menu').style.visibility = 'hidden';\r\n    //     }\r\n    // };\r\n\r\n    self.onMenuButtonClick = function (e)\r\n    {\r\n        if (!self.isSidebarOpen)\r\n        {\r\n            self.openSidebar();\r\n\r\n            g.sendEvent('Menu', 'OpenSidebar');\r\n        }\r\n        else\r\n        {\r\n            self.closeSidebar();\r\n\r\n            g.sendEvent('Menu', 'CloseSidebar');\r\n        }\r\n    };\r\n\r\n    self.onHelpButtonClick = function(e)\r\n    {\r\n        // g.menus.openModal('help');\r\n        this.showHelp(HelpMode.Normal);\r\n\r\n        g.sendEvent('Menu', 'HelpMain');\r\n    };\r\n\r\n    self.onHelpMouseOver = function(e)\r\n    {\r\n        // self.openCheatSheet();\r\n    };\r\n\r\n    self.onHelpMouseOut = function(e)\r\n    {\r\n        // self.closeCheatSheet();\r\n    };\r\n\r\n    var cheatSheet = document.getElementById('cheatSheetContainer');\r\n    self.openCheatSheet = function()\r\n    {\r\n        var helpEle = document.getElementById('desktopHelpButton').getBoundingClientRect();\r\n\r\n        cheatSheet.style.top = (helpEle.bottom +5) + 'px';\r\n\r\n        g.removeClass(cheatSheet, 'none');\r\n    };\r\n\r\n    self.closeCheatSheet = function()\r\n    {\r\n        g.addClass(cheatSheet, 'none');\r\n    };\r\n\r\n    self.closeSidebarEvent = function(e)\r\n    {\r\n        if (self.isSidebarOpen)\r\n        {\r\n            self.closeSidebar();\r\n            e.preventDefault();\r\n\r\n            return false;\r\n        }\r\n    };\r\n\r\n    g.addCustomEventListener('keyEscape', self.closeSidebarEvent, 200);\r\n\r\n    self.openSidebar = function()\r\n    {\r\n        self.isSidebarOpen = true;\r\n\r\n        if (g.autocomplete)\r\n        {\r\n            g.autocomplete.hide();\r\n        }\r\n\r\n        g.tooltip.hideTip();\r\n\r\n        // g.addClass(g.element('container'), 'sidebarOpen');\r\n        // g.addClass(g.element('overlayArea'), 'sidebarOpen');\r\n\r\n        g.setTransform(g.element('container'), 250, 0);\r\n\r\n        setTimeout(function()\r\n        {\r\n            g.element('main').addEventListener('mouseup', self.closeSidebarEvent);\r\n        }, 0);\r\n\r\n        tracker.miscAction({\r\n            type: TrackerType.Misc,\r\n            misc: TrackerMisc.ToggleSidebar,\r\n            data: [\r\n            {\r\n                value: true\r\n            }]\r\n        });\r\n    };\r\n\r\n    self.closeSidebar = function()\r\n    {\r\n        self.isSidebarOpen = false;\r\n\r\n        g.setTransform(g.element('container'), 0, 0);\r\n        // g.removeClass(g.element('container'), 'sidebarOpen');\r\n        // g.removeClass(g.element('overlayArea'), 'sidebarOpen');\r\n\r\n        g.element('main').removeEventListener('mouseup', self.closeSidebarEvent);\r\n\r\n        g.hideHighlightElement();\r\n\r\n        tracker.miscAction({\r\n            type: TrackerType.Misc,\r\n            misc: TrackerMisc.ToggleSidebar,\r\n            data: [\r\n            {\r\n                value: false\r\n            }]\r\n        });\r\n    };\r\n\r\n    // self.onHelpButtonClick = function (e)\r\n    // {\r\n    //     g.clearSelection();\r\n\r\n    //     if (!g.vmHelp)\r\n    //     {\r\n    //         g.vmHelp = new VMHelp();\r\n    //     }\r\n\r\n    //     g.removeClass(document.getElementById('help'), 'none');\r\n\r\n    //     g.sendEvent('Menu', 'Help');\r\n    // };\r\n\r\n    var grabber = document.getElementById('fullscreenClickGrabber');\r\n\r\n    var fullscreenClickHandled = false;\r\n\r\n    self.handleFullscreenClick = function(callback)\r\n    {\r\n        if (!fullscreenClickHandled)\r\n        {\r\n            g.setupClick(grabber, undefined,\r\n            {\r\n                onRightClick: function(e)\r\n                {\r\n                    grabber.style.display = 'none';\r\n\r\n                    var realElem = document.elementFromPoint(e.clientX, e.clientY);\r\n\r\n                    var pane = g.getPaneForElement(realElem);\r\n\r\n                    if (pane)\r\n                    {\r\n                        pane.onTap.onRightClick({\r\n                            srcElement: realElem,\r\n                            pageX: e.x,\r\n                            pageY: e.y,\r\n                            preventDefault: function () { e.preventDefault(); },\r\n                            stopPropagation: function () { e.stopPropagation(); },\r\n                            stopImmediatePropagation: function() { e.stopImmediatePropagation(); }\r\n                        });\r\n                    }\r\n\r\n                    grabber.style.display = '';\r\n                },\r\n                onEnd: function(e)\r\n                {\r\n                    self.cancelFullscreenClick();\r\n                    callback();\r\n                }\r\n            });\r\n\r\n            g.removeClass(grabber, 'none');\r\n\r\n            fullscreenClickHandled = true;\r\n        }\r\n    };\r\n    self.cancelFullscreenClick = function()\r\n    {\r\n        if (fullscreenClickHandled)\r\n        {\r\n            g.addClass(grabber, 'none');\r\n            //g.removeClick(grabber);\r\n\r\n            g.menus.closeAllMenus();\r\n\r\n            fullscreenClickHandled = false;\r\n        }\r\n    };\r\n\r\n    // self.applyFormatToSelection = function(format)\r\n    // {\r\n    //     g.restrictSelectionToText();\r\n\r\n    //     var selection = g.getSelectionInfo();\r\n    //     if (!selection || selection.rangeCount === 0)\r\n    //     {\r\n    //         log(selection);\r\n    //         return true;\r\n    //     }\r\n\r\n    //     tracker.beginAction();\r\n\r\n    //     var range = selection.selection.getRangeAt(0);\r\n\r\n    //     rangeStartContainer = range.startContainer;\r\n    //     rangeEndContainer = range.endContainer;\r\n\r\n    //     var nextLI = g.getLIParent(range.startContainer);\r\n    //     var startItem = ko.dataFor(nextLI);\r\n    //     var endItem = ko.dataFor(g.getLIParent(rangeEndContainer));\r\n    //     var item = startItem;\r\n\r\n    //     if (startItem == endItem) // One line\r\n    //     {\r\n    //         var span = g.getSpanParent(rangeStartContainer);\r\n    //         var offsets = g.getSelectOffsetsInSpan(item, span, range);\r\n\r\n    //         if (offsets.start != offsets.end)\r\n    //         {\r\n    //             var remEnd = false;\r\n\r\n    //             item.toggleFormat({start: offsets.start, end: offsets.end, tag: format});\r\n    //             item.parseText(/*immediateParse*/true);\r\n\r\n    //             g.selectChildren(item, offsets.start, offsets.end - offsets.start);\r\n    //         }\r\n    //         else\r\n    //         {\r\n    //             edit.nextKeypressFormat = format;\r\n    //         }\r\n    //     }\r\n    //     else // Multiline\r\n    //     {\r\n    //         var span = g.getSpanParent(rangeStartContainer);\r\n    //         var offsets = g.getSelectOffsetsInSpan(item, span, range);\r\n\r\n    //         span = endItem.getSpan();\r\n    //         var endOffsets = g.getSelectOffsetsInSpan(endItem, span, range);\r\n\r\n    //         item.toggleFormat({start: offsets.start, end: item.getParsedText().length, tag: format}, true);\r\n    //         item.parseText(/*immediateParse*/true);\r\n\r\n    //         do\r\n    //         {\r\n    //             // nextLI = g.getMext(nextLI);\r\n    //             // item = ko.dataFor(nextLI);\r\n    //             item = g.getNextItem(item);\r\n\r\n    //             if (item == endItem)\r\n    //             {\r\n    //                 item.toggleFormat({start: 0, end: endOffsets.end, tag: format}, true);\r\n    //             }\r\n    //             else\r\n    //             {\r\n    //                 item.toggleFormat({start: 0, end: item.getParsedText().length, tag: format}, true);\r\n    //             }\r\n\r\n    //             item.parseText(/*immediateParse*/true);\r\n    //         } while (item != endItem);\r\n\r\n    //         g.selectMultiline(startItem.getSpan(), offsets.start, endItem.getSpan(), endOffsets.end);\r\n    //     }\r\n\r\n    //     tracker.endAction();\r\n    // };\r\n\r\n    self.applyFnToSelection = function(fn, params)\r\n    {\r\n        // If toggling, if any item in the selection does not match the\r\n        // target value, all items should be set to the target value.\r\n        // If all items already match the target value, they should be\r\n        // toggled off.\r\n\r\n        // If params == true, this is a boolean operation\r\n        var toggle = params && params.toggle || (params === true);\r\n\r\n        // If no specified value, value is true\r\n        var value = (params && params.value !== undefined) ? params.value : true;\r\n\r\n        self.applyToSelection(function(item)\r\n        {\r\n            if (toggle)\r\n            {\r\n                if(item[fn]() !== value)\r\n                {\r\n                    toggle = false;\r\n                }\r\n            }\r\n            if (!toggle)\r\n            {\r\n                item[fn](value);\r\n            }\r\n        });\r\n\r\n        if (toggle)\r\n        {\r\n            // If no specified empty value, value is false\r\n            var emptyValue = (params && params.emptyValue !== undefined) ? emptyValue = params.emptyValue : emptyValue = false;\r\n\r\n            self.applyToSelection(function(item)\r\n            {\r\n                item[fn](emptyValue);\r\n            });\r\n        }\r\n    };\r\n\r\n    self.applyPriorityToSelection = function(pri, toggle)\r\n    {\r\n        if(toggle)\r\n        {\r\n            self.applyFnToSelection('priority',\r\n            {\r\n                toggle: true,\r\n                value: pri,\r\n                emptyValue: VMLIFlag.None\r\n            });\r\n        }\r\n        else\r\n        {\r\n            self.applyFnToSelection('priority', {value: pri});\r\n        }\r\n        // self.applyToSelection(function(item)\r\n        // {\r\n        //     if(toggle)\r\n        //     {\r\n        //         pri = item.priority() !== pri ? pri : VMLIFlag.None;\r\n        //         toggle = false;\r\n        //     }\r\n\r\n        //     item.priority(pri);\r\n        // });\r\n    };\r\n\r\n    self.insertCharacter = function(character, withSpace)\r\n    {\r\n        var text;\r\n        if (android.isEnabled())\r\n        {\r\n            text = android.getInputText();\r\n\r\n            var prevChar = text[android.getSelectionStart() - 1];\r\n\r\n            if (withSpace && prevChar !== ' ')\r\n            {\r\n                android.insertText(android.getSelectionStart(), ' ' + character);\r\n            }\r\n            else\r\n            {\r\n                android.insertText(android.getSelectionStart(), character);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var range = g.getSelectionRange();\r\n\r\n            if (range)\r\n            {\r\n                var item = g.getItemForElement(range.startContainer);\r\n\r\n                if (item)\r\n                {\r\n                    text = item.getRawText();\r\n\r\n                    var prevChar = text[range.startOffset - 1];\r\n\r\n                    // Insert a space before the character if not already led by a space\r\n                    if (withSpace && prevChar !== ' ')\r\n                    {\r\n                        g.fireKeyEvent(undefined, { normCode: KeyCode.Space });\r\n                    }\r\n\r\n                    g.fireKeyEvent(undefined, { normCode: character.charCodeAt(0) });\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    self.applyToSelection = function(action, options)\r\n    {\r\n        //var restoreSelection = options && options.restoreSelection;\r\n        var passExtraInfo = options && options.passExtraInfo;\r\n\r\n        var selection = g.getSelectionInfo();\r\n\r\n        // If nothing is selected, skip running the algorithm.\r\n        if (!selection || selection.rangeCount === 0)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // If search is selected, skip running the algorithm.\r\n        if (selection.node && g.hasClass(selection.node, 'search'))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // If selected is not in a pane, skip running the algorithm.\r\n        var pane = g.getPaneForElement(selection.node);\r\n        if(!pane)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        g.restrictSelectionToText();\r\n\r\n        selection = g.getSelectionInfo();\r\n\r\n        // If nothing is selected, skip running the algorithm.\r\n        if (!selection || selection.rangeCount === 0)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        var range = selection.selection.getRangeAt(0);\r\n\r\n        // If there is no item found, skip running the algorithm.\r\n        if (g.hasClass(range.startContainer.parentNode, 'timelineItemTime'))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // var selectionInfo;\r\n        // if (restoreSelection)\r\n        // {\r\n        //     selectionInfo = g.saveSelectionItem(range);\r\n        // }\r\n\r\n        var nextItem = g.getItemForElement(range.startContainer);\r\n        var endItem = g.getItemForElement(range.endContainer);\r\n\r\n        if (nextItem === undefined || endItem === undefined)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        tracker.beginAction(); // BEGIN TRACKER <----\r\n\r\n        // If at the beginning of a line (generally through shift + up arrow) ignore the item that does not\r\n        // have text selected unless this is a single-select case.\r\n        if (range.endOffset === 0 && nextItem !== endItem)\r\n        {\r\n            endItem = g.getPreviousItem(endItem, g.focusedPane);\r\n        }\r\n\r\n        var items = g.getItemsBetween(nextItem, endItem, g.focusedPane);\r\n\r\n        var tempPanes = self.panes();\r\n        var tempNumPanes = tempPanes.length;\r\n\r\n        for (var i = 0; i < items.length; ++i)\r\n        {\r\n            var actionRetVal = passExtraInfo ? action(items[i], i, items.length) : action(items[i]);\r\n\r\n            // Functions that get run can require that we stop iteration over the selected items.\r\n            if (actionRetVal === false)\r\n            {\r\n                break;\r\n            }\r\n\r\n            // TODO: Is this necessary? We should be notifying panes of search updates as we change properties\r\n            //       on items.\r\n            for (var u = 0; u < tempNumPanes; u ++)\r\n            {\r\n                if (tempPanes[u] == g.focusedPane)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                tempPanes[u].vmSearch.checkItem(items[i]);\r\n            }\r\n        }\r\n\r\n        tracker.endAction(); // END TRACKER <----\r\n\r\n        // if (restoreSelection)\r\n        // {\r\n        //     g.restoreSelectionItem(selectionInfo);\r\n        // }\r\n\r\n        return items.length;\r\n    };\r\n\r\n    var prevMove = { over: undefined, wasPointer: false };\r\n\r\n    self.updateCursor = function (ctrlPressed)\r\n    {\r\n        if (prevMove && prevMove.over)\r\n        {\r\n            if (ctrlPressed && (prevMove.over.tagName === 'A' || g.hasClass(prevMove.over, 'tag')))\r\n            {\r\n                prevMove.wasPointer = true;\r\n                prevMove.over.style.cursor = 'pointer';\r\n            }\r\n            else if (!ctrlPressed && prevMove.wasPointer)\r\n            {\r\n                prevMove.wasPointer = false;\r\n                prevMove.over.style.cursor = 'text';\r\n            }\r\n        }\r\n    };\r\n\r\n    if (!platform.touch)\r\n    {\r\n        self.mousemove = function mousemove(e)\r\n        {\r\n            if (g.disableMouseMove)\r\n            {\r\n                return;\r\n            }\r\n\r\n            if (e.pageX === prevMove.pageX && e.pageY === prevMove.pageY)\r\n            {\r\n                return;\r\n            }\r\n            else\r\n            {\r\n                prevMove.pageX = e.pageX;\r\n                prevMove.pageY = e.pageY;\r\n            }\r\n\r\n            var to = e.srcElement || e.target;\r\n\r\n            // TODO: Replace with fix pos ele over left half of the panes to do cursor work\r\n            if (e.offsetX >= 0 && e.offsetX <= 18)\r\n            {\r\n                var prevLI = g.getLIParent(prevMove.over);\r\n                var newLI = g.getLIParent(to);\r\n\r\n                if (newLI)\r\n                {\r\n                    g.addClass(newLI, 'hoveredFormatter');\r\n                }\r\n\r\n                if (prevLI && prevLI !== newLI)\r\n                {\r\n                    g.removeClass(prevLI, 'hoveredFormatter');\r\n                }\r\n            }\r\n            else\r\n            {\r\n                var prevLI = g.getLIParent(prevMove.over);\r\n\r\n                if (prevLI)\r\n                {\r\n                    g.removeClass(prevLI, 'hoveredFormatter');\r\n                }\r\n            }\r\n\r\n            // Hyperlinks should only receive a pointer cursor when ctrl is being held down. This needs to be\r\n            // handled manually as browsers have a default cursor style for <a> tags.\r\n            if (e.ctrlKey && (to.tagName === 'A' || g.hasClass(to, 'tag')))\r\n            {\r\n                if (prevMove.wasPointer)\r\n                {\r\n                    prevMove.over.style.cursor = 'text';\r\n                }\r\n\r\n                prevMove.wasPointer = true;\r\n                to.style.cursor = 'pointer';\r\n            }\r\n            else if (prevMove.wasPointer)\r\n            {\r\n                prevMove.wasPointer = false;\r\n                prevMove.over.style.cursor = 'text';\r\n            }\r\n\r\n            prevMove.over = to;\r\n        };\r\n\r\n        g.element('container').addEventListener('mousemove', self.mousemove);\r\n    }\r\n\r\n    self.addPaneToRight = function(mode)\r\n    {\r\n        var index = self.panes().length;\r\n\r\n        var pane = self.createPane(index, mode);\r\n\r\n        self.cancelFullscreenClick();\r\n\r\n        if (mode === PaneMode.Normal)\r\n        {\r\n            pane.vmSearch.focusBox();\r\n        }\r\n\r\n        tracker.performAction(TrackerType.UIAction, {\r\n                type: TrackerUIAction.AddPane,\r\n                data: index\r\n            });\r\n    };\r\n\r\n    self.onTapAddNormal = function()\r\n    {\r\n        self.addPaneToRight(PaneMode.Normal);\r\n\r\n        g.sendEvent('Menu', 'AddPaneNormal');\r\n    };\r\n\r\n    self.onTapAddTimeline = function()\r\n    {\r\n        self.addPaneToRight(PaneMode.Timeline);\r\n\r\n        g.sendEvent('Menu', 'AddPaneTimeline');\r\n    };\r\n\r\n    self.showSearchSeparator = function()\r\n    {\r\n        return !platform.mobile || g.phoneMenu.showSearchSeparator();\r\n    };\r\n\r\n    self.onTapSettingsPhone =\r\n    {\r\n        onStart: function(e)\r\n        {\r\n            g.ScreenManager.checkSwipeStart(e);\r\n        },\r\n        onMove: function(e)\r\n        {\r\n            g.ScreenManager.checkSwipeMove(e);\r\n        },\r\n        onEnd: function(e)\r\n        {\r\n            g.ScreenManager.checkSwipeEnd(e);\r\n        }\r\n    };\r\n\r\n    self.isLoadingDoc = function(value)\r\n    {\r\n        for (var i = 0; i < self.panes().length; i ++)\r\n        {\r\n            if(value)\r\n            {\r\n                g.addClass(self.panes()[i].paneContent, 'loading');\r\n            }\r\n            else\r\n            {\r\n                g.removeClass(self.panes()[i].paneContent, 'loading');\r\n            }\r\n        }\r\n    };\r\n\r\n    self.showHelp = function(helpState)\r\n    {\r\n        // No help on mobile yet\r\n        if(platform.mobile)\r\n            return;\r\n\r\n        var openState = helpState || HelpMode.Intro;\r\n\r\n        if (!this.help)\r\n        {\r\n            this.help = new VMIntro(openState);\r\n            this.helpButtonHidden(openState === HelpMode.Intro);\r\n        }\r\n\r\n        this.isHelpShowing(true);\r\n\r\n        g.settings.set(Settings.helpPaneState, openState);\r\n    };\r\n\r\n    self.closeHelp = function()\r\n    {\r\n        self.isHelpShowing(false);\r\n        self.helpButtonHidden(false);\r\n\r\n        g.settings.set(Settings.helpPaneState, HelpMode.None);\r\n    };\r\n\r\n    // This is here for testing the sidebar\r\n    // self.openSidebar();\r\n\r\n    var helpPaneState = g.settings.get(Settings.helpPaneState) || HelpMode.None;\r\n    if (helpPaneState !== HelpMode.None && !g.isDemoMode())\r\n    {\r\n        self.showHelp(helpPaneState);\r\n    }\r\n\r\n    self.init();\r\n\r\n    return self;\r\n};\r\n\r\nreturn VMMain;\r\n});\r\n","asserts":[{"tag":1356,"offset":10434},{"tag":1357,"offset":10793},{"tag":1358,"offset":11467},{"tag":1359,"offset":12655},{"tag":1360,"offset":13238},{"tag":1361,"offset":13337},{"tag":1362,"offset":13432},{"tag":1363,"offset":17542},{"tag":1364,"offset":17623},{"tag":1365,"offset":19397},{"tag":1366,"offset":20939},{"tag":1367,"offset":21065},{"tag":1368,"offset":23705},{"tag":1369,"offset":23795},{"tag":1370,"offset":24007},{"tag":1371,"offset":30486},{"tag":1372,"offset":36560},{"tag":1373,"offset":36837},{"tag":1374,"offset":39799},{"tag":1375,"offset":40005},{"tag":1376,"offset":40667},{"tag":1377,"offset":40810},{"tag":1378,"offset":40899},{"tag":1379,"offset":42365},{"tag":1380,"offset":45517},{"tag":1381,"offset":46739},{"tag":1382,"offset":46866},{"tag":1383,"offset":46955},{"tag":1384,"offset":47682},{"tag":1385,"offset":48101},{"tag":1386,"offset":49626},{"tag":1387,"offset":57495},{"tag":1388,"offset":57787},{"tag":1389,"offset":58214},{"tag":1390,"offset":58823},{"tag":1391,"offset":63699},{"tag":1392,"offset":64430},{"tag":1393,"offset":65486},{"tag":1394,"offset":66055}]},"copypaste":{"path":"F:/p/bce/Duchess/public/js/copypaste.js","data":"define(['ko', 'globals', 'platform', 'edit', 'VMLI', 'tracker', 'parse'],\nfunction (ko, g, platform, edit, VMLI, tracker, parse) {\n    var self = { };\n\n    self.init = function ()\n    {\n        g.Assert(document.readyState === 'complete' || document.readyState === 'interactive', 'Setting up copy/paste too early');\n\n        document.body.addEventListener(\"paste\", handlepaste, false);\n        document.body.addEventListener(\"cut\", handlecut, false);\n        document.body.addEventListener(\"copy\", handlecopy, false);\n    }\n\n    function insertDummyItem(parentItem, e, text)\n    {\n        if (!text)\n        {\n            text = '';\n        }\n\n        var item = new VMLI({text: text}, {parent: parentItem, parse: true, forceSave: true});\n        parentItem.items.unshift(item);\n\n        tracker.performAction(TrackerType.Create, {\n            'itemID': item.id,\n            'parent': parentItem.id,\n            'position': 0,\n            'text': text\n        });\n\n        g.selectChildren(item, 0, 0);\n        var selection = g.getSelectionInfo();\n        var range = selection.selection.getRangeAt(0);\n\n        return range;\n    }\n\n    function killEvent(e)\n    {\n        g.Assert(e.preventDefault, 'Should always be defined');\n        g.Assert(e.stopPropagation, 'Should always be defined');\n\n        if (e.preventDefault)\n        {\n            e.preventDefault();\n        }\n\n        if (e.stopPropagation)\n        {\n            e.stopPropagation();\n        }\n    }\n\n    function handlepaste(e)\n    {\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var clipData = (e && e.clipboardData) ? e.clipboardData : window.clipboardData;\n        var dataType = platform.ie ? 'Text' : 'text/plain';\n\n        var clipboardBuffer = '';\n\n        var selection = g.getSelectionInfo();\n        if(!selection || !selection.selection)\n            return;\n\n        var range = selection.selection.getRangeAt(0);\n\n        var pane = g.getPaneForElement(e.srcElement);\n\n        if (g.hasClass(e.srcElement, 'search'))\n        {\n            if (/text\\/plain/.test(clipData.types) || platform.ie)\n            {\n                e.srcElement.textContent = clipData.getData(dataType).replace(/[\\r\\n\\t]/g, '');\n                g.selectElement(e.srcElement, /*selectEnd*/true);\n            }\n\n            e.preventDefault();\n\n            return false;\n        }\n        else if (!pane)\n        {\n            return;\n        }\n\n        if (pane.mode() !== PaneMode.Normal)\n        {\n            return false;\n        }\n\n        // Check for invalid paste targets\n        var startSpan = g.getSpanParent(range.startContainer);\n\n        var endSpan = g.getSpanParent(range.endContainer);\n        if (!startSpan || !endSpan) // Nothing valid to paste into\n        {\n            // If pasting into an empty paneContent\n            if (range.startContainer == pane.paneContent || range.endContainer == pane.paneContent)\n            {\n                if (DEBUG) log('Pasting into empty pane content');\n                var item = pane.addItemToPane('', 0);\n\n                startSpan = endSpan = item.getSpan();\n                g.selectChildren(item, 0, 0);\n            }\n            else\n            {\n                g.Assert(false, 'There should always be something to paste into');\n                // TODO: Should there be an error report here? Or is this ok to happen?\n                return;\n            }\n        }\n\n        if (clipData && clipData.getData)\n        {\n            tracker.miscAction({\n                type: TrackerType.Misc,\n                misc: TrackerMisc.Paste,\n                data: [\n                {\n                    value: true\n                }]\n            });\n            killEvent(e);\n\n            // Parse the incoming text\n            var traversed;\n            if (/text\\/html/.test(clipData.types))\n            {\n                if (DEBUG) log(clipData.getData('text/html'));\n                clipboardBuffer = clipData.getData('text/html');\n\n                if (!clipboardBuffer)\n                {\n                    if (DEBUG) log('Paste buffer is empty');\n                    return;\n                }\n\n                var node = document.createElement('div');\n                var replacedText = clipboardBuffer.replace(/[\\n\\t]/g, ' ')\n                                                  .replace(/[\\r]|<head(.|\\s)*?\\/head>|<script(.|\\s)*?\\/script>|<style(.|\\s)*?\\/style>/g, '')\n                                                  .replace(/\\s+/g, ' ')\n                                                  .replace(/onload/gi, 'never');\n\n                var bodyRegex = /<body(.|\\s)*?\\/body>/g;\n                var bodyMatch;\n                if (bodyMatch = bodyRegex.exec(replacedText))\n                {\n                    replacedText = bodyMatch[0];\n                }\n\n                node.innerHTML = replacedText;\n\n                traversed = parse.traverseDOM({root: node, shouldPrint: DEBUG, stripParents: true});\n                if (traversed.items.length === 1 && traversed.items[0].text === '')\n                {\n                    traversed = traversed.items[0];\n                }\n            }\n            else if (/text\\/plain/.test(clipData.types) || platform.ie)\n            {\n                if (DEBUG) log(clipData.getData(dataType));\n                clipboardBuffer = clipData.getData(dataType).trim();\n\n                var isXML = clipboardBuffer.startsWith('<?xml ');\n                var isOPML = clipboardBuffer.startsWith('<?opml ');\n                var xml;\n                if (isXML || isOPML)\n                {\n                    xml = g.loadXML(clipboardBuffer);\n                }\n\n                // If pasting XML/OPML content, be smarter about the data that we paste into the doc. If it\n                // really is just plain text, do the simple thing.\n                if (xml)\n                {\n                    if (isXML)\n                    {\n                        g.messageQueue.pushMessage({\n                            text: 'We currently do not support pasting generic XML documents, try convering to OPML. If you need to import XML send us a message and we will work through your scenario with you.',\n                            type: MessageType.Error\n                        });\n\n                        return false;\n                    }\n                    else if (isOPML)\n                    {\n                        parse.parseOPML(xml, 'OPML Import');\n\n                        return false;\n                    }\n                }\n                else\n                {\n                    var isJSON = false;\n\n                    // If we might be pasting JSON, try parsing\n                    if (clipboardBuffer.startsWith('{') && clipboardBuffer.endsWith('}'))\n                    {\n                        try\n                        {\n                            var jsonData = JSON.parse(clipboardBuffer);\n\n                            var root = ko.dataFor(startSpan.parentElement);\n\n                            var res = parse.parseJSON(jsonData, root);\n\n                            // If we successfully parsed the JSON, return out, otherwise continue on\n                            if (res)\n                            {\n                                return false;\n                            }\n                        }\n                        catch (err)\n                        {\n                            // Do nothing, assume invalid JSON and paste normal text\n                        }\n                    }\n\n                    var replacedText = clipboardBuffer.replace(/[\\t]/g, ' ');\n\n                    var traversedText = replacedText.split('\\n');\n\n                    traversed = { items: [ ] };\n                    for (var i = 0; i < traversedText.length; i++)\n                    {\n                        if (traversedText[i].length === 0)\n                        {\n                            continue;\n                        }\n\n                        traversed.items.push({text: g.trimString(traversedText[i]), parent: traversed});\n                    }\n                }\n            }\n\n            if (!traversed || traversed.items.length === 0)\n            {\n                return false;\n            }\n\n            g.Assert(startSpan !== undefined && endSpan !== undefined, 'Must have a valid selection to perform paste');\n\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            var itemStart = ko.dataFor(startSpan.parentElement);\n            var itemEnd = ko.dataFor(endSpan.parentElement);\n\n            var sOffset = g.getSelectOffsetsInSpan(itemStart, startSpan, range);\n            var eOffset = g.getSelectOffsetsInSpan(itemEnd, endSpan, range);\n\n            var itemParent = itemStart.parent();\n\n            var itemIndex = itemStart.getIndex();\n            var sText = itemStart.getParsedText();\n            var eText = itemEnd.getParsedText();\n\n            var selItemSpan;\n            var selOffset;\n\n            // Iterate through each item between the start and end, removing them.\n            if (itemStart != itemEnd)\n            {\n                edit.handleMultiselect({}, startSpan, endSpan, range);\n            }\n\n            var lastItem = itemStart;\n\n            if (traversed && traversed.items.length === 1 && !traversed.items[0].items)\n            {\n                var iText = traversed.items[0].text.trim();\n\n                // Just one item so insert it into the middle of the current line\n                var str = sText.substring(0, sOffset.startText) + iText + eText.substring(eOffset.endText);\n                selItemSpan = itemStart.getSpan();\n\n                tracker.performAction(TrackerType.Remove, {\n                    'itemID': itemStart.id,\n                    'position': 0,\n                    'text': itemStart.getParsedText()\n                });\n\n                //itemStart.transformFormats(sOffset.start, iText.length);\n                itemStart.setText(str, true);\n\n                tracker.performAction(TrackerType.Insert, {\n                    'itemID': itemStart.id,\n                    'position': 0,\n                    'text': str\n                });\n                selOffset = sOffset.start + iText.length;\n                g.selectChildren(itemStart, selOffset, 0);\n            }\n            else\n            {\n                if(DEBUG) console.time('paste');\n                var parentItems = itemParent.items();\n                //var newFormats;\n                var mutations = [];\n\n                for (var i = 0; traversed && i < traversed.items.length; ++i)\n                {\n                    // Add each item\n                    var itemInfo = traversed.items[i];\n\n                    itemInfo.text = itemInfo.text.trim();\n\n                    if (itemInfo.text === '' && !itemInfo.items)\n                    {\n                        continue;\n                    }\n\n                    if (i === 0)\n                    {\n                        // If the first item == incoming text's formatter, don't include it twice\n                        if (itemInfo.text[0] == sText)\n                        {\n                            itemInfo.text = itemInfo.text.substr(1);\n                        }\n\n                        // First item's text = text + incoming first item\n                        itemInfo.text = sText.substring(0, sOffset.startText) + itemInfo.text;\n\n                        // newFormats = itemStart.getFormatsAfter(sOffset.start);\n                        // itemStart.removeFormatsAfter(sOffset.start);\n\n                        itemStart.setText(itemInfo.text, true);\n\n                        tracker.performAction(TrackerType.Insert, {\n                            'itemID': itemStart.id,\n                            'position': 0,\n                            'text': itemInfo.text\n                        });\n\n                        itemIndex ++;\n\n                        if(itemInfo.items)\n                        {\n                            for(var u = 0; u < itemInfo.items.length; u ++)\n                            {\n                                var child = itemInfo.items[u];\n\n                                if (child.text === '' && !child.items)\n                                {\n                                    continue;\n                                }\n\n                                itemStart.insertItem(new VMLI(child, {parent: itemStart, parse: true, forceSave: true}));\n                            }\n                            if(mutations.indexOf(itemStart) == -1)\n                                mutations.push(itemStart);\n                        }\n                    }\n                    else\n                    {\n                        var newItem = new VMLI(itemInfo, {parent: itemParent, parse: true, forceSave: true});\n\n                        // TODO: what if UL?\n\n                        itemParent.insertItem(newItem, itemIndex++, true);\n                        if(mutations.indexOf(itemParent) == -1)\n                            mutations.push(itemParent);\n\n                        tracker.performAction(TrackerType.Create, {\n                            'itemID':  newItem.id,\n                            'parent': itemParent.id,\n                            'position': itemIndex - 1,\n                            'text': newItem.getParsedText()\n                        });\n                    }\n                }\n\n                for(i = 0; i < mutations.length; i ++)\n                {\n                    mutations[i].items.valueHasMutated();\n                }\n\n                // Find the last item so it can be selected\n                lastItem = itemParent.getChild(itemIndex - 1);\n                while (lastItem.hasChildren())\n                {\n                    lastItem = lastItem.getLastChild();\n                }\n\n                // Select the end of the last item\n                selOffset = lastItem.getParsedText().length;\n\n                lastItem.setRawText(lastItem.getParsedText() + eText.substring(eOffset.endText));\n\n                g.vmMain.runParseWorker(itemParent, function()\n                {\n                    setTimeout(function(){\n                        g.selectChildren(lastItem, selOffset, 0);\n                    }, 0);\n                });\n            }\n            if(DEBUG) console.timeEnd('paste');\n        }\n\n        // console.log('Types', clipData.types);\n\n        // console.log(clipboardBuffer);\n        // waitForPasteData(clipboardBuffer);\n\n        tracker.endAction(); // END TRACKER <----\n\n        g.scrollIntoView(lastItem.getSpan(), 200);\n\n        return false;\n    }\n\n    function handlecut (e)\n    {\n        var copySuccess = !handlecopy(e);\n        if (copySuccess)\n        {\n            edit.keydown(undefined, {normCode: KeyCode.BackSpace});\n\n            killEvent(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    function handlecopy (e)\n    {\n        var clipData = (e && e.clipboardData) ? e.clipboardData : window.clipboardData;\n\n        if (clipData)\n        {\n            if (!e.srcElement)\n            {\n                e.srcElement = e.target;\n            }\n\n            var selection = g.getSelectionInfo();\n\n            if (!selection)\n            {\n                return true;\n            }\n\n            var currentItem = selection.selection.getRangeAt(0).startContainer;\n            if (currentItem.nodeName == '#text')\n            {\n                currentItem = currentItem.parentNode;\n            }\n\n            // Short-circuit logic for export data\n            if (e.srcElement.id === 'exportedArea' || e.srcElement.id === 'exportedContent')\n            {\n                var dataType = platform.ie ? 'Text' : 'text/plain';\n                clipData.setData(dataType, e.srcElement.textContent);\n            }\n            else\n            {\n                var inPane = g.elementInPane(currentItem);\n\n                if (!inPane || selection.node.id === 'searchDiv' || g.hasClass(selection.node, 'search'))\n                {\n                    return true;\n                }\n\n                g.restrictSelectionToText();\n\n                selection = g.getSelectionInfo();\n                var range = selection.selection.getRangeAt(0);\n\n                g.Assert(range.startContainer.nodeName == '#text', 'Expected #text, Actual: ' + range.startContainer.tagName);\n                var startSpan = g.getSpanParent(range.startContainer);\n\n                g.Assert(range.endContainer.nodeName == '#text' || range.endContainer.nodeName == 'SPAN', 'Expected #text or SPAN, Actual: ' + range.endContainer.tagName);\n                var endSpan = g.getSpanParent(range.endContainer);\n\n                // #text -> span -> li\n                var startLI = startSpan.parentElement;\n                g.Assert(startLI.tagName == 'LI', 'Expected LI, Actual: ', startLI);\n\n                var endLI = endSpan.parentElement;\n                g.Assert(endLI.tagName == 'LI', 'Expected LI, Actual: ', endLI);\n\n                var item = ko.dataFor(startLI);\n                var endItem = ko.dataFor(endLI);\n                var offsets = g.getSelectOffsetsInSpan(item, startSpan, range);\n\n                var nextLI = startLI;\n\n                g.Assert(item);\n\n                var createHTML = !platform.ie;\n\n                var html;\n                var plain;\n                var text = item.getParsedText().substring(offsets.startText);\n                if (startLI == endLI)\n                {\n                    if (offsets.start == offsets.end)\n                    {\n                        text = item.getParsedText();\n                    }\n                    else\n                    {\n                        text = item.getParsedText().substr(offsets.startText, offsets.endText - offsets.startText);\n                    }\n\n                    if (createHTML) { html = text; }\n                    plain = text;\n                }\n                else\n                {\n                    var deep = 0;\n\n                    // if (item.parent().isFullscreen())\n                    // {\n                    //     debugger;\n                    //     html = text;\n                    //     plain = text;\n                    // }\n                    // else\n                    {\n                        deep++;\n\n                        if (createHTML) { html = '<ul><li>' + text + '</li>'; }\n                        plain = text;\n                    }\n\n                    do\n                    {\n                        var nextOptions = {numLevels: 0};\n\n                        item = g.getNextItem(item, g.focusedPane, nextOptions);\n\n                        if (nextOptions.numLevels > 0) // Next item is a child\n                        {\n                            if (createHTML) { html += '<ul>'; }\n                            deep++;\n                        }\n\n                        while (nextOptions.numLevels < 0 && deep >= 0) // Next item is in an ancestor\n                        {\n                            if (createHTML) { html += '</ul>'; }\n                            deep--;\n\n                            nextOptions.numLevels++;\n                        }\n\n                        // Handle the case where the first node selected is at a higher indentation level that other nodes\n                        // in the selection. In this case, we need to insert extra lists to ensure that the less indented\n                        // nodes get inserted in the proper order.\n                        if (deep <= 0)\n                        {\n                            if (createHTML) { html += '<ul>'; }\n                            deep++;\n                        }\n\n                        if (item !== endItem) // Middle item\n                        {\n                            text = item.getParsedText();\n                            if (createHTML) { html += '<li>' + text + '</li>'; }\n                        }\n                        else // End item\n                        {\n                            var endOffset = g.getSelectOffsetsInSpan(item, item.getSpan(), range);\n\n                            text = item.getParsedText().substring(0, endOffset.endText);\n\n                            if (createHTML) { html += '<li>' + text + '</li></ul>'; }\n                            deep--;\n                        }\n\n                        plain += '\\r\\n' + text;\n                    } while (item !== endItem);\n\n                    while (deep > 0)\n                    {\n                        if (createHTML) { html += '</ul>'; }\n                        deep--;\n                    }\n                }\n\n                //log(html);\n                //log(plain);\n\n                if (createHTML && html)\n                {\n                    clipData.setData(\"text/html\", html);\n                }\n\n                var dataType = platform.ie ? 'Text' : 'text/plain';\n                clipData.setData(dataType, plain);\n            }\n        }\n\n        killEvent(e);\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.Copy,\n            data: [\n            {\n                value: true\n            }]\n        });\n\n        return false;\n    }\n\n    return self;\n});","asserts":[{"tag":1290,"offset":194},{"tag":1291,"offset":1174},{"tag":1292,"offset":1238},{"tag":1293,"offset":3232},{"tag":1294,"offset":8262},{"tag":1295,"offset":16235},{"tag":1296,"offset":16434},{"tag":1297,"offset":16768},{"tag":1298,"offset":16905},{"tag":1299,"offset":17204}]},"parse":{"path":"F:/p/bce/Duchess/public/js/parse.js","data":"define(['globals', 'VMLI', 'tracker', 'data'],\nfunction (g, VMLI, tracker, d) {\nvar self = { };\n\nfunction parseHead(node)\n{\n    var props = { };\n\n    for (var i = 0; i < node.childElementCount; ++i)\n    {\n        var prop = node.children[i];\n\n        var propName = prop.nodeName;\n\n        if (prop.firstChild)\n        {\n            var propValue = prop.firstChild.textContent;\n\n            props[propName] = propValue;\n        }\n    }\n\n    return props;\n}\n\nself.parseOPML = function(data, filename)\n{\n    var rootModel;\n    function visit(node, parentModel)\n    {\n        var visitChildren = true;\n\n        var nodeModel = undefined;\n        switch (node.nodeName)\n        {\n            case '#document':\n            case \"body\":\n            case 'opml':\n                break;\n            case 'head':\n                visitChildren = false;\n\n                var ret = parseHead(node);\n\n                if (ret && ret.title && !rootModel)\n                {\n                    rootModel = new VMLI({ text: ret.title }, { parent: d.getRootModel(), parse: true, forceSave: true });\n                    d.getRootModel().insertItem(rootModel);\n                }\n\n                break;\n            case 'outline':\n                if (!parentModel)\n                {\n                    if (rootModel)\n                    {\n                        parentModel = rootModel;\n                    }\n                    else\n                    {\n                        parentModel = rootModel = new VMLI({ text: filename }, { parent: d.getRootModel(), parse: true, forceSave: true });\n                        d.getRootModel().insertItem(rootModel);\n                    }\n                }\n\n                nodeModel = new VMLI({ text: node.attributes['text'].value }, { parent: parentModel, parse: true, forceSave: true });\n                parentModel.insertItem(nodeModel);\n\n                break;\n            default:\n                log('Unknown OPML Node: ', node);\n                break;\n        }\n\n        if (visitChildren)\n        {\n            for (var i = 0; i < node.childElementCount; ++i)\n            {\n                visit(node.children[i], nodeModel);\n            }\n        }\n\n        return nodeModel;\n    }\n\n    tracker.beginAction(); // BEGIN TRACKER <----\n\n    visit(data);\n\n    tracker.endAction(); // END TRACKER <----\n\n    return true;\n};\n\nself.parseJSON = function(data, root)\n{\n    var dataVersion;\n\n    function visit(node, parentModel)\n    {\n        var nodeParent = parentModel || root || d.getRootModel();\n\n        var nodeData =\n        {\n            text: node.text,\n            dateCompleted: node.dateCompleted,\n            priority: node.priority,\n            isComplete: node.isComplete,\n            isFlagged: node.isFlagged,\n        };\n\n        var nodeModel = new VMLI(nodeData, { parent: nodeParent, parse: true, forceSave: true });\n        nodeParent.insertItem(nodeModel);\n\n        if (node.items)\n        {\n            for (var i = 0; i < node.items.length; ++i)\n            {\n                visit(node.items[i], nodeModel);\n            }\n        }\n    }\n\n    // Validate basic properties on the root\n    if (data.moodoVer !== undefined && data.moodoRoot !== undefined)\n    {\n        try\n        {\n            dataVersion = parseInt(data.moodoVer);\n\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            visit(data.moodoRoot);\n\n            tracker.endAction(); // END TRACKER <----\n\n            return true;\n        }\n        catch (err)\n        {\n            // Do Nothing\n        }\n    }\n    else if (data.text !== undefined && data.items !== undefined)\n    {\n        try\n        {\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            visit(data);\n\n            tracker.endAction(); // END TRACKER <----\n\n            return true;\n        }\n        catch (err)\n        {\n            // Do Nothing\n        }\n    }\n\n    return false;\n};\n\n// self.parseXML = function(data, filename)\n// {\n//     function visit(node, parentModel)\n//     {\n//         var visitChildren = true;\n\n//         var nodeModel = undefined;\n//         switch (node.nodeName)\n//         {\n//             default:\n//                 break;\n//         }\n\n//         if (visitChildren)\n//         {\n//             for (var i = 0; i < node.childElementCount; ++i)\n//             {\n//                 visit(node.children[i], nodeModel);\n//             }\n//         }\n\n//         return nodeModel;\n//     }\n\n//     tracker.beginAction(); // BEGIN TRACKER <----\n\n//     visit(data);\n\n//     tracker.endAction(); // END TRACKER <----\n// };\n\nfunction stripParents(item)\n{\n    item.parent = undefined;\n\n    if (item.items)\n    {\n        for(var i = 0; i < item.items.length; i ++)\n        {\n            stripParents(item.items[i]);\n        }\n    }\n}\n\nself.traverseDOM = function(options)\n{\n    var root = options.root;\n    var doStripParents = options.stripParents;\n    var shouldPrint = options.shouldPrint;\n\n    var n = root.firstChild;\n    var rootNode = {items: []};\n    var currentLine = {text: '', parent: rootNode};\n    rootNode.items.push(currentLine);\n\n    var newItem;\n    var needsNewItem = false;\n    var reallyNeedsNewItem = false;\n\n    // Process the DOM node\n    function visit(node)\n    {\n        if (node.nodeType === Node.TEXT_NODE) // Text\n        {\n            //log('Visit: ', node.nodeValue);\n            if (reallyNeedsNewItem || needsNewItem)\n            {\n                currentLine.text = currentLine.text.trim();\n\n                if (currentLine.text !== '')\n                {\n                    newItem = {text: '', parent: currentLine.parent};\n                    currentLine.parent.items.push(newItem);\n\n                    currentLine = newItem;\n                }\n            }\n\n            reallyNeedsNewItem = false;\n            needsNewItem = false;\n\n            var addText = node.nodeValue;\n            if (currentLine.text === '')\n            {\n                addText = node.nodeValue.replace(/^\\s+/g, '');\n            }\n\n            currentLine.text += addText;\n        }\n        else if (node.nodeType === Node.COMMENT_NODE) // Comment\n        {\n            // Do Nothing\n        }\n        else\n        {\n            // This node demands a new line\n            if(node.tagName == 'BR' || node.tagName == 'P' || node.tagName == 'LI' || node.tagName == 'DIV')\n            {\n                needsNewItem = true;\n            }\n            // This node defines a list\n            else if(node.tagName == 'UL' || node.tagName == 'OL')\n            {\n                needsNewItem = false;\n\n                currentLine.text = currentLine.text.trim();\n\n                newItem = {text: '', parent: currentLine};\n\n                if (currentLine.items)\n                {\n                    currentLine.items.push(newItem);\n                }\n                else\n                {\n                    currentLine.items = [newItem];\n                }\n\n                currentLine = newItem;\n            }\n        }\n    }\n    // Process the closing of a DOM node\n    function end(node)\n    {\n        if(node.nodeType !== Node.TEXT_NODE)\n        {\n            // If this is the end of a list, set current to parent\n            if(node.tagName == 'UL' || node.tagName == 'OL')\n            {\n                currentLine = currentLine.parent;\n                reallyNeedsNewItem = true;\n            }\n            // The end of this node demand a new line\n            else if(node.tagName == 'DIV' || node.tagName == 'P')\n            {\n                needsNewItem = true;\n            }\n        }\n    }\n    // Debug printer\n    function print(r, levelsDeep)\n    {\n        if(isNaN(levelsDeep))\n        {\n            levelsDeep = 0;\n        }\n\n        var text = '';\n        for (var i = 0; i < levelsDeep; i ++)\n        {\n            text += '--';\n        }\n\n        if (levelsDeep)\n        {\n            console.log(text, r.text);\n        }\n\n        if (r.items)\n        {\n            for(var i = 0; i < r.items.length; i ++)\n            {\n                print(r.items[i], levelsDeep + 1);\n            }\n        }\n    }\n\n\n    do\n    {\n        visit(n); // Process this node\n        c = n.firstChild;\n        if(c) // If this has a child, visit it next\n        {\n            n = c;\n        }\n        else\n        {\n            c = n.nextSibling;\n            if(c) // If this has a sibling, visit it next\n            {\n                n = c;\n            }\n            else // No siblings so go up through parents\n            {\n                do\n                {\n                    c = n.parentNode.nextSibling;\n                    if(c) // Parent has a next sibling\n                    {\n                        end(n.parentNode);\n                        n = c; // c != null so loop will break out here\n                    }\n                    else // Parent has no siblings, so move to next parent\n                    {\n                        n = n.parentNode;\n                        end(n);\n                    }\n                } while(!c && n && n.parentNode);\n\n                if (!c)\n                {\n                    break;\n                }\n            }\n        }\n    } while(n);\n\n    if (doStripParents)\n    {\n        stripParents(rootNode);\n    }\n\n    if(shouldPrint)\n    {\n        print(rootNode);\n    }\n\n    return rootNode;\n};\n\nreturn self;\n});","asserts":[]},"VMMain_DragDrop":{"path":"F:/p/bce/Duchess/public/js/VMMain_DragDrop.js","data":"define(['ko', 'globals', 'platform', 'tracker', 'VMPane', 'VMLI'],\nfunction (ko, g, platform, tracker, VMPane, VMLI)\n{\nvar VMMain_DragDrop = function(self)\n{\n    // var prevDragOver;\n    // var prevDragHighlight;\n    // //var prevDragIndex = 0;\n    // var prevDragClass;\n    // var prevWasPane = false;\n\n    // function removePrevDragEffect()\n    // {\n    //     if (prevDragHighlight && (prevDragHighlight.tagName == 'LI' || prevDragHighlight.tagName == 'UL'))\n    //     {\n    //         g.removeClass(prevDragHighlight, 'itemDraggingAbove');\n    //         g.removeClass(prevDragHighlight, 'itemDraggingBelow');\n    //     }\n    // }\n\n    ////\n    ////\n    ////\n\n    var activePane = undefined;\n\n    var previousEventTarget = undefined;\n    var previousDropTarget = undefined;\n\n    var previousHighlightElement = undefined;\n    var previousDragClass = undefined;\n\n    var previousWasPane = false;\n\n    function removePreviousDragEffect()\n    {\n        if (previousHighlightElement)\n        {\n            g.removeClass(previousHighlightElement, 'itemDraggingAbove');\n            g.removeClass(previousHighlightElement, 'itemDraggingBelow');\n        }\n    }\n\n    self.handleDragOver = function (e)\n    {\n        // Only update the drop target once when the element that is being dragged over changes.\n        if (previousEventTarget !== e.srcElement)\n        {\n            if (e.srcElement)\n            {\n                activePane = g.getPaneForElement(e.srcElement);\n            }\n\n            var eventTarget = e.srcElement;\n\n            // Only update the drop target for certain element types.\n            if (!eventTarget || !activePane || eventTarget.tagName !== 'SPAN' && eventTarget.tagName !== 'P' && eventTarget.tagName !== 'LI' && eventTarget.tagName !== 'UL')\n            {\n                // Skip Updating Drag Target\n            }\n            else\n            {\n                removePreviousDragEffect();\n\n                var pane = g.getPaneForElement(eventTarget);\n                g.Assert(pane, 'Must have a valid pane to update our drag target on');\n\n                var currentDropTarget = ko.dataFor(eventTarget);\n                g.Assert(currentDropTarget, 'Should always have a valid drop target');\n\n                var highlightAbove = undefined;\n\n                var isPane = false;\n                if (currentDropTarget instanceof VMPane)\n                {\n                    isPane = true;\n\n                    if (previousDropTarget)\n                    {\n                        currentDropTarget = previousDropTarget;\n                    }\n                    else\n                    {\n                        currentDropTarget = g.getLastPaneItem(currentDropTarget);\n                    }\n\n                    highLightAbove = (e.diffY < 0 ? true : false);\n                }\n                else if (currentDropTarget instanceof VMLI)\n                {\n                    if (!pane.isTimeline() && (currentDropTarget.isFullscreen() || eventTarget.tagName === 'LI'))\n                    {\n                        if (previousDropTarget)\n                        {\n                            currentDropTarget = previousDropTarget;\n                            highlightAbove = (e.diffY < 0 || previousWasPane ? true : false);\n                        }\n                    }\n                    else\n                    {\n                        highlightAbove = true;\n                    }\n                }\n                else\n                {\n                    // Default to the original position of the item\n                    currentDropTarget = self.getDropItem(e);\n                }\n\n                g.Assert(currentDropTarget, 'Should always have a valid drop target');\n\n                previousHighlightElement = pane.isTimeline() ? undefined : currentDropTarget.getSpan(pane.id);\n                previousDragClass = (highlightAbove ? 'itemDraggingAbove' : 'itemDraggingBelow');\n\n                // We don't support drop onto timeline right now\n                if (!pane.isTimeline())\n                {\n                    g.addClass(previousHighlightElement, previousDragClass);\n                }\n\n                //log(previousDragClass, previousHighlightElement);\n\n                g.Assert(!(currentDropTarget instanceof VMPane), 'Drop target shouldnt be a pane');\n\n                previousDropTarget = currentDropTarget;\n                previousEventTarget = eventTarget;\n                previousWasPane = isPane;\n            }\n        }\n\n        if (activePane)\n        {\n            var topMin = 70;\n            var topMax = 110;\n\n            var bottomMin = platform.windowHeight() - 40;\n            var bottomMax = platform.windowHeight() + 40;\n\n            // Top drag-target for scrolling pane\n            if (e.offsetY < topMax)\n            {\n                var speed = -(1 - g.computeScrollSpeed(topMin, topMax, e.offsetY));\n\n                g.repeatScroll(speed, activePane);\n            }\n            else if (e.offsetY > bottomMin && e.offsetY < bottomMax)\n            {\n                var speed = g.computeScrollSpeed(bottomMin, bottomMax, e.offsetY);\n\n                g.repeatScroll(speed, activePane);\n            }\n            else\n            {\n                g.cancelRepeatScroll();\n            }\n        }\n        else\n        {\n            g.cancelRepeatScroll();\n        }\n\n        return false;\n    };\n\n    self.handleDropItem = function (movingItem, e)\n    {\n        //log('DROP: ', movingItem);\n\n        g.cancelRepeatScroll();\n\n        if (movingItem !== previousDropTarget)\n        {\n            // First check to see if we are dropping an item into its own subtree\n            var parent = previousDropTarget.parent();\n            while (parent)\n            {\n                if (parent === movingItem)\n                {\n                    return;\n                }\n\n                parent = parent.parent();\n            }\n\n            // Second check if this item is being dropped at the same location it started at.\n            if (g.getNextItem(movingItem, g.focusedPane) === previousDropTarget && previousDragClass === 'itemDraggingAbove')\n            {\n                return;\n            }\n\n            var pane = g.getPaneForElement(previousEventTarget);\n\n            // We don't support drag/drop into timelines, ignore if it happens.\n            if (!pane.isTimeline())\n            {\n                var previousParent = movingItem.parent();\n                var previousIndex = movingItem.getIndex();\n\n                var target = undefined;\n                var targetIndex = -1;\n\n                // Compute target information\n                if (previousDropTarget.isFullscreen())\n                {\n                    target = previousDropTarget;\n                    targetIndex = target.numChildren();\n                }\n                else\n                {\n                    target = previousDropTarget.parent();\n\n                    if (previousDragClass === 'itemDraggingAbove')\n                    {\n                        targetIndex = previousDropTarget.getIndex();\n                    }\n                    else\n                    {\n                        targetIndex = previousDropTarget.getIndex() + 1;\n                    }\n                }\n\n                // Perform drop/move action\n\n                tracker.beginAction(); // BEGIN TRACKER <----\n\n                //log('Dropping: ', targetIndex, target);\n\n                g.Assert(target, 'Trying to move without a target');\n                g.Assert(!isNaN(targetIndex), 'Trying to move without a target index');\n\n                movingItem.moveTo({parent: target, index: targetIndex});\n\n                tracker.performAction(TrackerType.Move, {\n                    'itemID': movingItem.id,\n                    'oldParent': previousParent.id,\n                    'oldPosition': previousIndex,\n                    'newParent': target.id,\n                    'newPosition': targetIndex\n                });\n\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.DropItem,\n                    data: [\n                    {\n                        'itemID': movingItem.id\n                    }]\n                });\n\n                tracker.endAction(); // END TRACKER <----\n\n                g.timeline.reloadTimelines();\n            }\n        }\n    };\n\n    ////\n    ////\n    ////\n\n    // self.handleDragOver = function(e)\n    // {\n    //     log('Drag: ', e);\n\n    //     // Special case for dragging over empty parent UL\n    //     if (e.srcElement !== prevDragOver || e.srcElement.tagName == 'UL')\n    //     {\n    //         var to = e.srcElement;\n\n    //         if (!to || to.tagName !== 'SPAN' && to.tagName !== 'P' && to.tagName !== 'LI' && to.tagName !== 'UL')\n    //         {\n    //             return;\n    //         }\n\n    //         removePrevDragEffect();\n\n    //         var highlightAbove = true;\n    //         var isPane = false;\n\n    //         //\n    //         // Get the item that is currently being dragged over\n    //         //\n\n    //         if (to.tagName == 'SPAN' || to.tagName == 'P')\n    //         {\n    //             to = g.getLIParent(to);\n    //         }\n\n    //         var pane = g.getPaneForElement(to);\n\n    //         if (to && (to.tagName == 'LI' || to.tagName == 'UL'))\n    //         {\n    //             var item;\n\n    //             if (to.tagName == 'LI')\n    //             {\n    //                 log('LI: ', prevDragHighlight);\n\n    //                 item = ko.dataFor(to);\n\n    //                 //if (e.diffY < 0 && prevWasPane)\n    //                 {\n    //                     highlightAbove = false;\n    //                 }\n    //                 log('Item: ', item);\n    //             }\n    //             else if(to.tagName == 'UL')\n    //             {\n    //                 if (g.hasClass(to, 'itemList'))\n    //                 {\n    //                     isPane = true;\n\n    //                     log('itemList: ', prevDragHighlight);\n\n    //                     item = ko.dataFor(prevDragHighlight);\n    //                     to = item.getElement(pane.id);\n\n    //                     //log('Index: ' + item.getIndex() + '   |    Children: ' + item.parent().numChildren());\n\n    //                     // TODO: Fix this logic, doesnt work correctly when going back and forth\n    //                     if (e.diffY > 0)\n    //                     {\n    //                         highlightAbove = false;\n    //                     }\n    //                 }\n    //                 else if (!g.hasClass(to, 'paneContent'))\n    //                 {\n    //                     //log('paneContent: ', prevDragOver, prevDragHighlight, e.srcElement);\n\n    //                     item = ko.dataFor(to.parentElement);\n    //                 }\n    //                 else\n    //                 {\n    //                     //log('UL: ', prevDragOver, prevDragHighlight, e.srcElement);\n\n    //                     item = pane.item().getLastChild();\n    //                     to = item.getElement(pane.id);\n\n    //                     highlightAbove = false;\n    //                 }\n    //             }\n\n    //             //log('Drag: ', to, e.srcElement);\n\n    //             //\n    //             // If there is a valid item being dragged over, update its styles to reflect that it is the drop target.\n    //             //\n    //             if (item && !pane.isTimeline())\n    //             {\n    //                 prevDragHighlight = item.getSpan(pane.id);\n    //                 prevDragClass = (highlightAbove ? 'itemDraggingAbove' : 'itemDraggingBelow');\n\n    //                 g.addClass(prevDragHighlight, prevDragClass);\n    //             }\n    //             else\n    //             {\n    //                 prevDragHighlight = undefined;\n    //             }\n    //         }\n    //         else\n    //         {\n    //             prevDragHighlight = undefined;\n    //         }\n\n    //         prevWasPane = isPane;\n    //     }\n\n    //     e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.\n    //     prevDragOver = e.srcElement;\n\n    //     //log('Drag Over [' + prevDragClass + ']: ' + e.srcElement.textContent)\n\n    //     return false;\n    // };\n\n    // function handleDropItem(from, e)\n    // {\n    //     var to = ko.dataFor(prevDragHighlight);\n\n    //     log('DROP: ', prevDragClass, to, from);\n\n    //     // TODO: If dropping off the end of the list, we should be smarter about where we place the item\n    //     if (!to || !to.parent)\n    //     {\n    //         to = g.focusedItem;\n    //     }\n\n    //     // if (prevDragHighlight.id == \"main\" || prevDragHighlight.id == \"container\" || prevDragHighlight.id == \"subcontainer\" || prevDragHighlight.id == \"addItemText\")\n    //     // {\n    //     //     to = g.focusedItem;\n    //     // }\n    //     // else\n    //     // {\n    //     //     to = ko.dataFor(prevDragHighlight);\n    //     // }\n\n    //     if (to.id !== from.id)\n    //     {\n    //         //\n    //         // Perform checks to ensure that we are actually moving this item to a valid location\n    //         //\n\n    //         // First check to see if we are dropping an item into its own subtree\n    //         var parent = to.parent();\n    //         while (parent)\n    //         {\n    //             if (parent.id == from.id)\n    //             {\n    //                 return;\n    //             }\n\n    //             parent = parent.parent();\n    //         }\n\n    //         // Second check if this item is being dropped at the same lcoation it started at.\n    //         if (g.getNextItem(from) === to && prevDragClass == 'itemDraggingAbove')\n    //         {\n    //             log('Dropping Next');\n    //             return;\n    //         }\n\n\n    //         var fromOldParent = from.parent();\n    //         var oldIndex = fromOldParent.getIndexOf(from); //from.parent().removeChild(from);\n\n    //         if (prevDragHighlight.id == 'container')\n    //         {\n    //             to = g.focusedItem;\n    //             //prevDragIndex = 0;\n    //         }\n\n    //         var target;\n    //         var targetIndex = 0;\n\n    //         if (to.isFullscreen())\n    //         {\n    //             target = to;\n    //             //targetIndex = prevDragIndex;\n    //         }\n    //         else\n    //         {\n    //             if (prevDragClass == 'itemDraggingAbove')\n    //             {\n    //                 if (prevDragHighlight.tagName == 'UL')\n    //                 {\n    //                     target = to;\n    //                     targetIndex = to.items().length;\n    //                 }\n    //                 else\n    //                 {\n    //                     target = to.parent();\n    //                     targetIndex = to.getIndex();\n    //                 }\n    //             }\n    //             else\n    //             {\n    //                 target = to.parent();\n    //                 targetIndex = to.getIndex() + 1;\n    //             }\n    //         }\n\n    //         var pane = g.getPaneForElement(prevDragHighlight);\n\n    //         if (!pane.isTimeline())\n    //         {\n    //             tracker.beginAction(); // BEGIN TRACKER <----\n    //             log('Dropping: ', targetIndex, target);\n\n    //             g.Assert(target, 'Trying to move without a target');\n    //             g.Assert(!isNaN(targetIndex), 'Trying to move without a target index');\n\n    //             from.moveTo({parent: target, index: targetIndex});\n\n    //             tracker.performAction(TrackerType.Move, {\n    //                 'itemID': from.id,\n    //                 'oldParent': fromOldParent.id,\n    //                 'oldPosition': oldIndex,\n    //                 'newParent': target,\n    //                 'newPosition': targetIndex\n    //             });\n\n    //             tracker.endAction(); // END TRACKER <----\n    //         }\n\n    //         // TODO: Should this set selection to the end of the dropped content?\n    //         g.timeline.reloadTimelines();\n    //     }\n    // }\n\n    function handleReaderLoad(evt) {\n        log(evt.target.result);\n    }\n\n    function handleDropFiles(e)\n    {\n        var file = e.dataTransfer.files[0];\n\n        var reader = new FileReader();\n\n        // init the reader event handlers\n        reader.onload = handleReaderLoad;\n\n        // begin the read operation\n        reader.readAsDataURL(file);\n    }\n\n    self.getDropItem = function(e)\n    {\n        g.Assert(e.dataTransfer.item, 'We do not support HTML5 drag/drop');\n\n        return e.dataTransfer.item;\n    };\n\n    self.handleDrop = function(e)\n    {\n        e.stopPropagation();\n\n        if (!previousEventTarget)\n        {\n            return;\n        }\n\n        removePreviousDragEffect();\n\n        var item = self.getDropItem(e);\n        if (item)\n        {\n            self.handleDropItem(item, e);\n        }\n        else\n        {\n            //TODO: This was to support html5 dragdrop. Take it out if we don't use that.\n            var id = e.dataTransfer.getData('itemid');\n            if (id)\n            {\n                var from = ko.dataFor(document.getElementById(id));\n\n                self.handleDropItem(from, e);\n            }\n            else if (e.dataTransfer.files && e.dataTransfer.files.length > 0)\n            {\n                handleDropFiles(e);\n                e.stopPropagation();\n                e.preventDefault();\n            }\n        }\n    };\n};\nreturn VMMain_DragDrop;\n});","asserts":[{"tag":1329,"offset":2000},{"tag":1330,"offset":2153},{"tag":1331,"offset":3645},{"tag":1332,"offset":4231},{"tag":1333,"offset":7435},{"tag":1334,"offset":7504},{"tag":1335,"offset":15352},{"tag":1336,"offset":15424},{"tag":1337,"offset":16535}]},"VMPane":{"path":"F:/p/bce/Duchess/public/js/VMPane.js","data":"define(['ko', 'globals', 'android', 'data', 'gdata', 'VMSearch', 'VMTitle', 'edit', 'VMLI', 'tracker', 'VMPane_Timeline', 'VMOutline', 'platform'],\nfunction (ko, g, android, d, gdata, VMSearch, VMTitle, edit, VMLI, tracker, VMPane_Timeline, VMOutline, platform) {\nfunction VMPane(p)\n{\n    this.id = p.id;\n    this.item = ko.observable(p.item);\n    this.mode = ko.observable(p.mode || PaneMode.Normal);\n    this.rootElement = undefined;\n    this.scrollElement = undefined;\n    this.element = undefined;\n    this.paneContent = undefined;\n    this.titleMenu = undefined;\n    this.vmSearch = undefined;\n    this.titles = ko.observableArray();\n    this.showArchived = ko.observable(false);\n    this.reloading = false;\n\n    this.width = -1;\n\n    //this.touchPhase = g.TouchPhase.None;\n\n    this.initialOffset = p.offset;\n\n    if (platform.mobile)\n    {\n        this.defaultOffset = 50;\n    }\n    else\n    {\n        this.defaultOffset = 0;\n    }\n\n    //log('initial offset', p.offset);\n\n    // Used to track whether a click is a real click or if it is the result of a scroll in touch IE\n    //paneClickTimeout = undefined;\n\n    if (platform.mobile)\n    {\n        g.vmSearchPhone = this.vmSearch = new VMSearch(this, p.search);\n        this.outline = g.vmMain.outline = new VMOutline(this);\n    }\n    else\n    {\n        this.vmSearch = new VMSearch(this, p.search);\n\n        this.outline = new VMOutline(this);\n    }\n\n    this.initTimeline();\n    this.init(p);\n}\n\nVMPane.prototype = {\n    init: function(p)\n    {\n        this.vmSearch.init();\n\n        // this.item.subscribe(this.notifyOfZoom, this);\n        this.mode.subscribe(this.onModeChanged, this);\n\n        if (platform.mobile)\n        {\n            g.ScreenManager.addScreen(this, Screens.List);\n        }\n\n        this.updateContents();\n    },\n    getScroller: function ()\n    {\n        if (platform.bodyscroll)\n        {\n            return document.body;\n        }\n        else\n        {\n            return this.scrollElement;\n        }\n    },\n    getScrollOffset: function ()\n    {\n        var sOffset = 0;\n\n        if (platform.bodyscroll)\n        {\n            sOffset = document.body.scrollTop;\n        }\n        else\n        {\n            if (this.scrollElement)\n            {\n                sOffset = this.scrollElement.scrollTop;\n            }\n        }\n\n        return sOffset;\n    },\n    setScrollOffset: function(offset)\n    {\n        g.Assert(this.scrollElement, 'Pane must have loaded a scrollable element');\n\n        if (offset === undefined)\n        {\n            offset = this.defaultOffset;\n        }\n\n        g.scrollTo(offset, 0, this.scrollElement);\n\n        // TODO: Does this work properly for body scrolling?\n        //this.scrollElement.scrollTop = offset;\n    },\n    setMode: function(mode)\n    {\n        this.mode(mode);\n        g.sendEvent('Menu', 'PaneModeSwitchTo', mode);\n        modeChanged = true;\n        g.vmMain.updatePaneState(this);\n        this.vmSearch.updateSearch(true);\n    },\n    getTopElement: function()\n    {\n        return this.element;\n    },\n    trackDOM: function()\n    {\n        // Used in OnLoad to determine if this VMLI root needs to track its DOM elements\n        return true;\n    },\n    templateName: function(pane, b)\n    {\n        if(pane.mode() === PaneMode.Normal)\n            return 'template-pane-normal';\n\n        if(pane.mode() === PaneMode.Timeline)\n            return 'template-pane-timeline';\n    },\n    itemHasChildren: function()\n    {\n        return this.item().items().length > 0;\n    },\n    isTimeline: function()\n    {\n        return this.mode() == PaneMode.Timeline;\n    },\n    onModeChanged: function(newValue)\n    {\n        if (newValue === PaneMode.Timeline)\n        {\n            this.loadTimeline();\n        }\n        else\n        {\n            this.unloadTimeline();\n        }\n\n        if (platform.ios || platform.ie)\n        {\n            this.setupFocusEvents();\n        }\n    },\n    setupFocusEvents: function()\n    {\n        if (platform.phone)\n        {\n            log('setting up focus');\n\n            if (platform.ios)\n            {\n                g.Assert(!android.isEnabled(), 'Android sets up its own focus/blur events in android.js');\n                g.Assert(!platform.ie, 'IE does not rely on focus/blur events to be fired');\n\n                // this.paneContent.onfocus = g.vmMain.onfocus;\n                // this.paneContent.onblur = g.vmMain.onblur;\n\n                this.paneContent.addEventListener(\"textInput\", edit.onTextInput, false);\n            }\n        }\n    },\n    onLoad: function(e)\n    {\n        if (g.hasClass(e, 'pane'))\n        {\n            this.element = e;\n\n            if (platform.mobile)\n            {\n                this.itemMenuPhone = g.element('itemMenuPhone');\n                this.rightMenuPhone = g.element('rightMenuPhone');\n            }\n\n            // if (platform.ios && platform.bodyscroll)\n            // {\n            //     window.onscroll = (function(e)\n            //     {\n            //         if (!platform.bodyscroll)\n            //         {\n            //             g.Assert(document.body.scrollTop === 0, 'Scroll top has been set to a non-zero value', document.body.scrollTop);\n            //         }\n\n            //         if (g.isKeyboardOpen)\n            //         {\n            //             var top = document.body.scrollTop;\n            //             log('onscroll', top);\n\n            //             // Put either the phone menu or keyboard toolbar back at the top of the screen\n            //             var element = g.phoneMenu.isSearchOut() ? g.element('phoneMenu') : g.keyboardToolbar.element;\n            //             if(g.phoneMenu.isSearchOut())\n            //             {\n            //                 element.style.visibility = 'visible';\n            //             }\n            //             else\n            //             {\n            //                 g.keyboardToolbar.show();\n            //             }\n\n            //             // element.style.position = 'absolute';\n            //             // element.style.top = top + 'px';\n\n            //             // If we're searching, need to show the search box again\n            //             if(g.phoneMenu.isSearchOut())\n            //             {\n            //                 g.element('searchDivPhone').style.visibility = 'visible';\n            //             }\n            //         }\n\n            //         if (g.touchPhase == g.TouchPhase.Start)\n            //         {\n            //             log('canceled scroll');\n            //             g.justCancelledInertialScroll = true;\n            //         }\n            //     }).bind(this);\n            // }\n        }\n        else\n        {\n            this.paneContent = e;\n            this.rootElement = e.parentElement;\n            this.scrollElement = this.rootElement.parentElement;\n            this.outlineElement = this.scrollElement.previousElementSibling;\n\n            // this.scrollElement.onscroll = function (e)\n            // {\n            //     if (this.paneClickTimeout)\n            //     {\n            //         log('Clear Click Timeout: ', e);\n\n            //         clearTimeout(this.paneClickTimeout);\n            //         this.paneClickTimeout = undefined;\n            //     }\n            // }.bind(this);\n\n            g.Assert(g.hasClass(this.rootElement, 'paneRoot'));\n            g.Assert(g.hasClass(this.paneContent, 'paneContent'));\n\n            if ((platform.android || platform.mobileie) && !platform.script)\n            {\n                android.setPaneRoot(this);\n            }\n\n            window.addEventListener('windowResize', function (e)\n            {\n                this.width = g.width(this.element);\n            }.bind(this));\n\n            setTimeout(function ()\n            {\n                this.width = g.width(this.element);\n\n                // this.paneContent = g.findChild(this.rootElement, 'paneContent');\n                // this.paneContent.style.minHeight = (platform.windowHeight() + 10) + 'px';\n\n                if (platform.ios || platform.ie)\n                {\n                    // if (platform.mobile && !this.isTimeline())\n                    // {\n                    //     g.element('panePull', true);\n                    //     g.element('panePullBox', true);\n                    //     g.element('panePullMessageA', true);\n                    //     g.element('panePullMessageB', true);\n                    // }\n\n                    this.setupFocusEvents();\n                }\n\n                if (this.mode() === PaneMode.Normal && isNaN(this.initialOffset))\n                {\n                    this.initialOffset = this.defaultOffset;\n                }\n                else if (this.mode() === PaneMode.Timeline)\n                {\n                    var block = this.findNextBlock();\n                    if (block && block.element)\n                    {\n                        if(platform.mobile)\n                        {\n                            this.initialOffset = block.element.getBoundingClientRect().top;\n                        }\n                        else\n                        {\n                            this.initialOffset = block.element.getBoundingClientRect().top - this.scrollElement.getBoundingClientRect().top - 25;\n                        }\n                    }\n                    else\n                    {\n                        this.initialOffset = 0;\n                    }\n                }\n\n                if (this.initialOffset !== 0)\n                {\n                    this.setScrollOffset(this.initialOffset);\n                }\n            }.bind(this), 0);\n\n            // On iOS listen for scroll events for each pane to determine when intertial scrolling is beginning\n            // and ending. This shouldn't cause performance problems (pending further testing) as iOS will not\n            // fire scroll events during scroll. On other platforms scroll events are fired during intertial scroll\n            // which will force the scroll to be synchronous.\n            if (platform.ios)\n            {\n                this.scrollElement.onscroll = function(e)\n                {\n                    if (Math.abs(this.scrollElement.scrollTop - g.scrollAtTouchStart) > 100)\n                    {\n                        if (g.dragStartTimeout)\n                        {\n                            clearTimeout(g.dragStartTimeout);\n                            g.dragStartTimeout = undefined;\n                        }\n\n                        g.startDrag = undefined;\n                    }\n\n                    if (this.scrollElement.scrollTop === 0)\n                    {\n                        e.preventDefault();\n                        e.stopImmediatePropagation();\n\n                        return false;\n                    }\n\n                    return true;\n                }.bind(this);\n            }\n\n            this.setNoItems(!!this.vmSearch.numMatches());\n        }\n\n        //this.$titleWrapper = $(e).find('#titleWrapper');\n\n\n        // var scrollTimeout;\n\n        // function reEnableOptions()\n        // {\n        //     g.vmMain.setIsScrolling(false);\n        // }\n\n        // {\n        //     if (g.autocomplete)\n        //     {\n        //         g.autocomplete.hide();\n        //     }\n\n        //     g.vmMain.setIsScrolling(true);\n        //     clearTimeout(scrollTimeout);\n        //     scrollTimeout = setTimeout(reEnableOptions, 100);\n        // };\n    },\n    setNoItems: function(turnOff)\n    {\n        if (turnOff)\n        {\n            g.removeClass(this.paneContent, 'noItems');\n        }\n        else\n        {\n            g.addClass(this.paneContent, 'noItems');\n        }\n    },\n    getWidth: function()\n    {\n        return this.width;\n    },\n    toggleOutlineVisibility: function()\n    {\n        g.Assert(this.outline, 'Outline must exist');\n\n        g.Assert(this.outlineElement, 'Outline element must be valid');\n\n        this.outline.toggleDesktop();\n    },\n    updateContents: function()\n    {\n        if (this.mode() == PaneMode.Normal)\n        {\n\n        }\n        else if (this.mode() === PaneMode.Timeline)\n        {\n            this.reloadTimeline();\n        }\n\n        this.updateTitles();\n        // if(this.scrollElement)\n        //     this.setScrollOffset(this.initialOffset);\n    },\n    notifyOfZoom: function()\n    {\n        this.updateContents();\n        this.vmSearch.updateSearch(true);\n    },\n    updateTitles: function()\n    {\n        var parents = this.item().parents();\n        this.titles.removeAll();\n        for(var i = 0; i < parents.length; i ++)\n        {\n            var title = new VMTitle({\n                item: parents[i],\n                pane: this\n            })\n            this.titles.push(title);\n        }\n    },\n    //\n    // Forward keyhandling events to editing code\n    //\n    keydown: function(element, e)\n    {\n        if (android.isEnabled() && !android.passKeydown(e))\n        {\n            return true;\n        }\n\n        if (g.autocomplete && !g.autocomplete.onkeydown(e))\n        {\n            return false;\n        }\n\n        try\n        {\n            return edit.keydown(element, e);\n        }\n        catch(err)\n        {\n            g.reportError(err, e);\n        }\n    },\n    keypress: function(element, e)\n    {\n        if (android.isEnabled() && !android.passKeypress(e))\n        {\n            return true;\n        }\n\n        try\n        {\n            return edit.keypress(element, e);\n        }\n        catch(err)\n        {\n            g.reportError(err, e);\n        }\n    },\n    keyup: function(element, e)\n    {\n        if (android.isEnabled())\n        {\n            android.checkAndroidBounds();\n\n            return true;\n        }\n\n        try\n        {\n            return edit.keyup(element, e);\n        }\n        catch(err)\n        {\n            g.reportError(err, e);\n        }\n    },\n    // contextmenu: function(element, e)\n    // {\n    //     var targetModel = ko.dataFor(e.target);\n    //     if (targetModel && targetModel.onContextMenu)\n    //     {\n    //         return targetModel.onContextMenu(e);\n    //     }\n    //     return true;\n    // },\n    addItemToPane: function(text, index)\n    {\n        var target = this.item();\n\n        if (!text)\n        {\n            text = \"\";\n        }\n\n        tracker.beginAction();\n\n        var item = new VMLI({text: text}, {parent: target, forceSave: true});\n        target.insertItem(item, index);\n\n        tracker.performAction(TrackerType.Create, {\n            'itemID': item.id,\n            'parent': target.id,\n            'position': (isNaN(index) ? target.items().length - 1 : index),\n            'text': text\n        });\n\n        tracker.endAction();\n\n        return item;\n    },\n     // This is forwarded to here by VMTitle\n    onTapTitle: {\n        onClick: function(e, item)\n        {\n            var oldItem = g.focusedItem;\n\n            if (!platform.ios)\n            {\n                // If the currently fullscreen item, reset search\n                if (item == this.item())\n                {\n                    this.vmSearch.resetSearch();\n                }\n            }\n\n            if (this.titles().length <= 1)\n            {\n                if (this.outline.isVisible())\n                {\n                    this.toggleOutlineVisibility();\n                }\n\n                return;\n            }\n\n            g.vmMain.zoomout(item, oldItem);\n\n            g.sendEvent('Menu', 'Title');\n\n            // this.titlesExpanded(false);\n        }\n        // }\n    },\n    // pullPaneStart: function (e)\n    // {\n    //     if(platform.bodyscroll)\n    //     {\n    //         g.pullMax = 50;\n    //     }\n    //     else\n    //     {\n    //         g.pullMax = 150;\n    //     }\n    // },\n    // pullPaneMove: function (e)\n    // {\n    //     // Pull-to-add is disabled on android and ie\n    //     if (g.revealingMenu || g.dragging)\n    //     {\n    //         return;\n    //     }\n\n    //     g.Assert(!platform.android && !platform.ie);\n\n    //     // log(e.clientY, e.startClientY);\n\n    //     var scrollTop = this.getScrollOffset();\n    //     g.pullY = Math.min(e.clientY - (g.pullingStartY || e.startClientY), g.pullMax);\n    //     if(g.pulling === 0 && scrollTop <= 0 && g.pullY > 0)\n    //     {\n    //         g.pulling = 1;\n    //         g.pullingStartY = e.clientY;\n    //         //log('start pulling at ', g.pullingStartY);\n    //     }\n    //     // log('pull', scrollContainer.scrollTop, g.pullY, g.pulling);\n\n    //     if(g.pulling !== 0)\n    //     {\n    //         if(g.pullY < 0 && g.pulling > 0 && scrollTop > 0)\n    //         {\n    //             //log('cancel pulling');\n    //             g.element('panePull').style.visibility = 'hidden';\n    //             g.element('panePullBox').style.visibility = 'hidden';\n    //             g.element('panePullMessageA').style.visibility = 'hidden';\n    //             g.element('panePullMessageB').style.visibility = 'hidden';\n    //             g.pulling = 0;\n    //             g.pullingStartY = e.clientY;\n    //             g.pullingReadyToAddItem = false;\n    //             return;\n    //         }\n\n    //         // g.keyboardToolbar.hide();\n\n    //         // g.element('phoneMenu').style.visibility = 'hidden';\n    //         // g.element('searchDivPhone').style.visibility = 'hidden';\n    //         g.element('panePull').style.visibility = 'visible';\n    //         g.element('panePullBox').style.visibility = 'visible';\n\n    //         if(g.pullY >= g.pullMax)\n    //         {\n    //             g.element('panePullMessageA').style.visibility = 'hidden';\n    //             g.element('panePullMessageB').style.visibility = 'visible';\n    //             // panePullBox.style.visibility = 'visible';\n    //             g.pullingReadyToAddItem = true;\n    //         }\n    //         else\n    //         {\n    //             g.element('panePullMessageA').style.visibility = 'visible';\n    //             g.element('panePullMessageB').style.visibility = 'hidden';\n    //             // panePullBox.style.visibility = 'hidden';\n    //             g.pullingReadyToAddItem = false;\n    //         }\n\n\n    //         // e.preventDefault();\n    //     }\n    // },\n    // addToTop: function (e)\n    // {\n    //     // Add the item\n\n    //     var item = platform.app ? this.addItemToPane('', 0) : g.getFirstPaneItem(g.focusedPane);\n\n    //     g.selectChildren(item, item.getParsedText().length, 0);\n    //     g.enforceScroll();\n\n    //     if (!platform.app)\n    //     {\n    //         setTimeout(function ()\n    //         {\n    //             var newItem = this.addItemToPane('', 0);\n\n    //             g.selectChildren(newItem, newItem.getParsedText().length, 0);\n    //             g.enforceScroll();\n    //         }.bind(this), 200);\n    //     }\n    // },\n    // pullPaneEnd: function (e)\n    // {\n    //     g.Assert(!platform.android && !platform.ie);\n\n    //     if (g.pullY !== 0 && !g.revealingMenu && !g.dragging)\n    //     {\n    //         //log('pullY = ', g.pullY);\n    //         if(g.pullY >= g.pullMax && g.pullingReadyToAddItem)\n    //         {\n    //             g.keyboardToolbar.preShow();\n\n    //             // Select the item\n    //             if(platform.keyboardOpenTime)\n    //             {\n    //                 g.setSelection(g.element('tempInput'), 0, 0);\n    //                 setTimeout(this.addToTop.bind(this), platform.keyboardOpenTime);\n    //             }\n    //             else\n    //             {\n    //                 this.addToTop();\n    //             }\n    //         }\n    //         // else\n    //         // {\n    //         //     // if(g.phoneMenu.isSearchOut())\n    //         //     // {\n    //         //     //     g.element('searchDivPhone').style.visibility = 'visible';\n    //         //     // }\n\n    //         //     // if(g.isKeyboardOpen && !g.phoneMenu.isSearchOut())\n    //         //     // {\n    //         //     //     g.keyboardToolbar.show();\n    //         //     // }\n    //         //     // else\n    //         //     // {\n    //         //     //     g.element('phoneMenu').style.visibility = 'visible';\n    //         //     // }\n    //         // }\n\n    //         log('hiding pull');\n\n    //         g.pullY = 0;\n    //         g.pulling = 0;\n    //         g.pullingStartY = undefined;\n    //         g.pullingReadyToAddItem = false;\n    //         setTimeout(function(){\n    //             g.element('panePull').style.visibility = 'hidden';\n    //             g.element('panePullMessageA').style.visibility = 'hidden';\n    //             g.element('panePullMessageB').style.visibility = 'hidden';\n    //             g.element('panePullBox').style.visibility = 'hidden';\n    //         }, 1000);\n    //     }\n    // },\n\n    //\n    // Forward events to VMLI code\n    //\n    onTap: {\n        onStart: function (e)\n        {\n            if (!platform.mobile || !g.ScreenManager.checkSwipeStart(e))\n            {\n                if (platform.phone)\n                {\n                    // g.phoneMenu.paneTapped();\n                    // g.menus.paneTapped();\n                }\n\n                if (g.menus && g.phoneMenu)\n                {\n                    g.menus.startedInMultiSelectMode = g.phoneMenu.multiSelectMode();\n                }\n\n                g.vmMain.setFocusedPane(this);\n\n                if (platform.isTouchDevice && !platform.app && !platform.ie && !platform.bodyscroll)\n                {\n                    var ele = this.scrollElement;\n\n                    if (!g.preventScrollPropagation(ele))\n                    {\n                        e.preventDefault();\n                        return false;\n                    }\n                }\n\n                if (!android.isEnabled() || !android.isTargetBox(e))\n                {\n                    var target = ko.dataFor(e.srcElement);\n                    if (platform.mobile && target === this)\n                    {\n                        target = g.getLastVisibleItem(g.focusedPane.item());\n                    }\n\n                    if (target && target.onStart)\n                    {\n                        target.onStart(e);\n                    }\n                }\n            }\n        },\n        onMove: function (e)\n        {\n            if (g.autocomplete && platform.mobile)\n            {\n                g.autocomplete.hide();\n            }\n\n            if (g.dragStartTimeout)\n            {\n                clearTimeout(g.dragStartTimeout);\n                g.dragStartTimeout = undefined;\n            }\n\n            var sendMove = true;\n\n            if(platform.mobile)\n            {\n                if(g.menus.startedInMultiSelectMode)\n                {\n                }\n                else\n                {\n                    sendMove = !g.ScreenManager.checkSwipeMove(e);\n                }\n                // if(g.phoneMenu.multiSelectMode())\n                // {\n                //     g.menus.closeMultiSelect();\n                // }\n                // else\n                // {\n                // }\n            }\n\n            if (sendMove)\n            {\n                if (!android.isEnabled() || !android.isTargetBox(e))\n                {\n                    var target = ko.dataFor(e.startSrc);\n                    if(platform.mobile && target === this)\n                        target = g.getLastVisibleItem(g.focusedPane.item());\n\n                    if (target && target.onMove)\n                    {\n                        target.onMove(e);\n                    }\n                }\n            }\n\n            return false;\n        },\n        onClick: function (e)\n        {\n            if(!platform.mobile || !g.ScreenManager.checkSwipeClick(e))\n            {\n                if (!android.isEnabled() || !android.isTargetBox(e))\n                {\n                    var target = ko.dataFor(e.startSrc);\n                    if (platform.mobile && target === this)\n                        target = g.getLastVisibleItem(g.focusedPane.item());\n\n                    if (target && target.onClick)\n                    {\n                        target.onClick(e);\n                    }\n                    else\n                    {\n                        if (g.hasClass(this.paneContent, 'noItems'))\n                        {\n                            this.addItem(e);\n                        }\n                        else\n                        {\n                            e.preventDefault();\n                        }\n                    }\n                }\n            }\n        },\n        onEnd: function (e)\n        {\n            if (!platform.mobile || !g.ScreenManager.checkSwipeEnd(e))\n            {\n                if (!android.isEnabled() || !android.isTargetBox(e))\n                {\n                    var target = ko.dataFor(e.startSrc);\n                    if(platform.mobile && target == this)\n                        target = g.getLastVisibleItem(g.focusedPane.item());\n\n                    if (!target)\n                    {\n                        // DOM node has been removed: This could be caused by hitting tab while mouse is down\n                        return;\n                    }\n                    else if (e.startSrc.id === 'paneContent')\n                    {\n                        e.preventDefault();\n\n                        if (platform.ios)\n                        {\n                            g.preventClick();\n                        }\n                    }\n\n                    if(target && target.onEnd)\n                    {\n                        target.onEnd(e);\n                    }\n                }\n            }\n        },\n        onDblClick: function (e)\n        {\n            if (this.isTimeline())\n            {\n                var target = ko.dataFor(e.startSrc);\n\n                if(target && target.onDblClick)\n                    target.onDblClick(e);\n            }\n        },\n        // onMiddleClick: function (e)\n        // {\n        //     if (!android.isEnabled() || !android.isTargetBox(e))\n        //     {\n        //         var target = ko.dataFor(e.startSrc);\n        //         if(target && target.onMiddleClick)\n        //             target.onMiddleClick(e);\n        //     }\n        // },\n        onRightClick: function (e)\n        {\n            if (!g.isDisplayModeActive(DisplayMode.NoRightClick))\n            {\n                g.vmMain.setFocusedPaneFromElement(e.srcElement);\n\n                if (!android.isEnabled() || !android.isTargetBox(e))\n                {\n                    var target = ko.dataFor(e.srcElement);\n                    if(target && target.onRightClick)\n                        target.onRightClick(e);\n                }\n\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.RightClick,\n                    data:\n                    {\n                        element: undefined\n                    }\n                });\n            }\n        }\n    },\n    addItem: function(e)\n    {\n        var item = this.addItemToPane('', 0);\n\n        g.selectChildren(item, 0, 0);\n\n        g.sendEvent('Menu', 'AddItemButton');\n\n        if (platform.mobile)\n        {\n            g.openKeyboardOn(e, item.getSpan(), true);\n        }\n    },\n    onTapAddItem:\n    {\n        onStart: function (e)\n        {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n        },\n        onClick: function (e)\n        {\n            this.addItem(e);\n        }\n    },\n    onTapOutlineButton: function(e)\n    {\n        this.toggleOutlineVisibility();\n\n        if (this.outline.isVisible())\n        {\n            g.sendEvent('Menu', 'OpenOutline');\n        }\n        else\n        {\n            g.sendEvent('Menu', 'CloseOutline');\n        }\n    },\n    onTapSwitchList: function()\n    {\n        var oldMode = this.setMode(PaneMode.Normal);\n\n        tracker.performAction(TrackerType.UIAction, {\n            type: TrackerUIAction.SwitchPaneMode,\n            data: {\n                from: oldMode,\n                to: PaneMode.Normal\n            }\n        });\n\n        g.sendEvent('Menu', 'SwitchPaneMode');\n    },\n    onTapSwitchTimeline: function()\n    {\n        var oldMode = this.setMode(PaneMode.Timeline);\n\n        tracker.performAction(TrackerType.UIAction, {\n            type: TrackerUIAction.SwitchPaneMode,\n            data: {\n                from: oldMode,\n                to: PaneMode.Timeline\n            }\n        });\n\n        g.sendEvent('Menu', 'SwitchPaneMode');\n    },\n    onTapClosePane: function()\n    {\n        if (g.vmMain.panes().length > 1)\n        {\n            var index = g.vmMain.removePane(this);\n\n            tracker.performAction(TrackerType.UIAction, {\n                type: TrackerUIAction.RemovePane,\n                data: index\n            });\n\n            g.sendEvent('Menu', 'ClosePane');\n            g.tooltip.hideTip();\n        }\n    },\n    onTapArchiveCompleted: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            this.archiveCompleted();\n\n            g.sendEvent('Menu', 'ArchiveCompleted');\n        }\n    },\n    archiveCompleted: function()\n    {\n        var archivedItems = [ ];\n\n        // Find a mark all items that need to be archived\n        g.searchVMLIs({\n            item: this.item(),\n            includeArchived: false,\n            comparator: function(item)\n            {\n                return item.isComplete();\n            },\n            action: function(item)\n            {\n                archivedItems.push(item);\n            }\n        });\n\n        tracker.beginAction();\n\n        // Update the lists of archived and non-archived items\n        for (var i = archivedItems.length - 1; i >= 0; i--)\n        {\n            var item = archivedItems[i];\n\n            if (DEBUG) log('Archive Item: ', item.getParsedText());\n            item.parent().archiveChild(item);\n        }\n\n        tracker.endAction();\n\n        if (archivedItems.length > 0)\n        {\n            var z = (archivedItems.length > 1 ? ' items.' : ' item.');\n\n            g.messageQueue.pushMessage({\n                text: 'Successfully archived ' + archivedItems.length + z,\n                type: MessageType.Info,\n                action: MessageAction.Default,\n                timeout: 2000\n            });\n        }\n\n        g.sendEvent('Menu', 'ArchiveCompleted');\n    },\n    onTapViewArchived: function()\n    {\n        if (this.mode() === PaneMode.Timeline)\n        {\n            // In the timeline pane mode we simply want to ensure VMLIs are created and loaded for\n            // all archived items in the current view. These should be unloaded when they are no\n            // longer needed to display in the timeline.\n            this.showArchived(!this.showArchived());\n\n            g.vmMain.updatePaneState(this);\n\n            g.sendEvent('Menu', 'ShowArchivedTimeline');\n        }\n        else if (this.mode() === PaneMode.Normal)\n        {\n            // In the normal pane mode, we want to unarchive all archived items and display them.\n            var unarchivedItems = [ ];\n\n            g.searchVMLIs({\n                item: this.item(),\n                includeArchived: true,\n                comparator: function(item)\n                {\n                    return item.isArchived();\n                },\n                action: function(item)\n                {\n                    unarchivedItems.push(item);\n                }\n            });\n\n            for (var i = 0; i < unarchivedItems.length; ++i)\n            {\n                var item = unarchivedItems[i];\n\n                if (DEBUG) log('Unarchive Item: ', item.getParsedText());\n                item.parent().unarchiveChild(item);\n            }\n\n            g.sendEvent('Menu', 'UnarchiveItems');\n        }\n    },\n    // onTapToggleTimeline: function()\n    // {\n    //     if (this.mode() === PaneMode.Timeline)\n    //     {\n    //         this.mode(PaneMode.Normal);\n\n    //         g.sendEvent('Menu', 'PaneModeSwitchToNormal');\n    //     }\n    //     else\n    //     {\n    //         this.mode(PaneMode.Timeline);\n\n    //         g.sendEvent('Menu', 'PaneModeSwitchToTimeline');\n    //     }\n\n    //     g.vmMain.updatePaneState(this);\n\n    //     this.vmSearch.updateSearch(true);\n    // },\n    // titleExpanderEnter: function(e)\n    // {\n    //     this.titlesExpanded(true);\n    // },\n    // paneHeaderLeave: function(e)\n    // {\n    //     this.titlesExpanded(false);\n    // },\n    onScreenOpen: function()\n    {\n        // g.element('phoneMenuFloating').style.visibility = 'visible';\n    },\n    onScreenClose: function()\n    {\n        // g.element('phoneMenuFloating').style.visibility = 'hidden';\n    }\n};\n\ng.extend(VMPane.prototype, VMPane_Timeline);\n\nreturn VMPane;\n});\n","asserts":[{"tag":1319,"offset":2399},{"tag":1320,"offset":4091},{"tag":1321,"offset":4198},{"tag":1322,"offset":5068},{"tag":1323,"offset":7310},{"tag":1324,"offset":7374},{"tag":1325,"offset":11813},{"tag":1326,"offset":11868},{"tag":1327,"offset":15943},{"tag":1328,"offset":18843}]},"VMSearch":{"path":"F:/p/bce/Duchess/public/js/VMSearch.js","data":"define(['ko', 'globals', 'platform', 'data', 'VMLI', 'tracker'],\r\nfunction (ko, g, platform, d, VMLI, tracker) {\r\n\r\nfunction VMSearch(pane, searchStr)\r\n{\r\n    this.elSearch = undefined;\r\n    this.search = ko.observable(searchStr || '');\r\n    this.isFocused = ko.observable(false);\r\n    this.placeholderActive = ko.observable(true);\r\n    this.searchLoaded = false;\r\n    this.pane = pane;\r\n    //this.prevNoPadNonHeader = undefined;\r\n    this.searchArr = [ ];\r\n    this.matches = { };\r\n    this.hiddenItems = { };\r\n    this.numMatches = ko.observable(0);\r\n    this.previousSearch = '';\r\n    this.titles = ko.observableArray();\r\n    this.initialized = false;\r\n    this.isPaneTimeline = (pane.mode() == PaneMode.Timeline);\r\n    this.isSearchBoxSmall = ko.observable();\r\n    this.onUpdated = ko.observable();\r\n\r\n    if (DEBUG)\r\n    {\r\n        if (!window.itemChecks)\r\n        {\r\n            window.itemChecks = [ ];\r\n        }\r\n\r\n        window.itemChecks[this.pane.id] = { };\r\n    }\r\n}\r\n\r\nVMSearch.prototype = {\r\n    getSearchBox: function ()\r\n    {\r\n        return this.elSearch;\r\n    },\r\n    init: function ()\r\n    {\r\n        g.Assert(!this.initialized);\r\n\r\n        if(this.initialized)\r\n            return;\r\n\r\n        this.pane.showArchived.subscribe(function (newValue)\r\n        {\r\n            this.updateSearch();\r\n        }.bind(this));\r\n\r\n        this.pane.mode.subscribe(function (newValue)\r\n        {\r\n            this.isPaneTimeline = this.pane.isTimeline();\r\n        }.bind(this));\r\n\r\n        // g.events.on('itemAdded', function(item, force)\r\n        // {\r\n        //     if (force || g.focusedPane.id !== this.pane.id)\r\n        //     {\r\n        //         this.checkItem(item);\r\n        //     }\r\n        // }.bind(this));\r\n\r\n        window.addEventListener('itemAdded', function(e)\r\n        {\r\n            if (e.data.force || g.focusedPane.id !== this.pane.id)\r\n            {\r\n                var match = this.checkItem(e.data.item);\r\n                if(match === true)\r\n                    this.updateNumMatches(e.data.item, true);\r\n            }\r\n            else if(g.focusedPane.id === this.pane.id)\r\n            {\r\n                // Update match count when an item is added\r\n                this.updateNumMatches(e.data.item, true);\r\n            }\r\n        }.bind(this), true);\r\n\r\n        // g.events.on('itemTextChanged', function(item, force)\r\n        // {\r\n        //     if (force || g.focusedPane.id !== this.pane.id)\r\n        //     {\r\n        //         this.checkItem(item);\r\n        //         this.checkChildren(item);\r\n        //     }\r\n        // }.bind(this));\r\n\r\n        window.addEventListener('itemTextChanged', function(e)\r\n        {\r\n            if (e.data.force || g.focusedPane.id !== this.pane.id)\r\n            {\r\n                // Check whether the new text matches the search\r\n                var item = e.data.item;\r\n                var oldValue = this.matches[item.id];\r\n                var newValue = this.checkItem(item);\r\n                if((newValue === true && oldValue !== true) ||\r\n                    (newValue !== true && oldValue === true))\r\n                {\r\n                    this.updateNumMatches(item, newValue === true);\r\n                }\r\n\r\n                this.checkChildren(item, false, true);\r\n            }\r\n        }.bind(this), true);\r\n\r\n        if (!platform.mobile)\r\n        {\r\n            window.addEventListener('windowResize', this.checkSearchBoxSize.bind(this));\r\n        }\r\n\r\n        if(this.search())\r\n        {\r\n            this.updateSearch();\r\n        }\r\n        else\r\n        {\r\n            // Set number of search results to be the number of items in the pane\r\n            var num = 0;\r\n            var includeArchived = this.isPaneTimeline && this.pane.showArchived();\r\n            g.searchVMLIs({\r\n                'item': this.pane.item(),\r\n                'includeArchived': includeArchived,\r\n                each: function(item)\r\n                {\r\n                    var newNum = this.amountIncrementNumMatches(item, true);\r\n                    if(newNum)\r\n                        num += newNum;\r\n                }.bind(this)\r\n            });\r\n\r\n            this.setNumMatches(num);\r\n        }\r\n\r\n        this.initialized = true;\r\n    },\r\n    onLoad: function(element)\r\n    {\r\n        this.elSearch = element;\r\n        this.elSearchWrap = element.parentNode;\r\n        this.elAutocomplete = g.getElementByClassName('searchAutocomplete', this.elSearchWrap);\r\n\r\n        // if (platform.phone)\r\n        // {\r\n            // this.elSearch.addEventListener('focus', g.vmMain.onfocus, false);\r\n            this.elSearch.addEventListener('focus', this.onfocus.bind(this), false);\r\n            // this.elSearch.addEventListener('blur', g.vmMain.onblur, false);\r\n            this.elSearch.addEventListener('blur', this.onblur.bind(this), false);\r\n        // }\r\n\r\n        if (this.search())\r\n        {\r\n            setTimeout(function()\r\n            {\r\n                this.setDisplayText(this.search());\r\n                this.searchLoaded = true;\r\n            }.bind(this), 0);\r\n        }\r\n        else\r\n        {\r\n            setTimeout(function()\r\n            {\r\n                this.searchLoaded = true;\r\n            }.bind(this), 0);\r\n        }\r\n    },\r\n    checkSearchBoxSize: function()\r\n    {\r\n        g.Assert(!platform.mobile, 'Only update search box size on non-mobile platforms');\r\n\r\n        if(!this.isFocused())\r\n            return;\r\n\r\n        var autocompleteBox = this.elAutocomplete.getBoundingClientRect();\r\n        var box = this.elSearchWrap.getBoundingClientRect();\r\n        var paneBox = this.pane.scrollElement.getBoundingClientRect();\r\n        if(paneBox.right - box.left - 10 < autocompleteBox.width)\r\n        {\r\n            // Right\r\n            this.elAutocomplete.style.right = 0;\r\n            this.elAutocomplete.style.left = 'auto';\r\n        }\r\n        else if(box.left < 40) // 40 for outline button\r\n        {\r\n            // Left\r\n            this.elAutocomplete.style.left = 0;\r\n            this.elAutocomplete.style.right = 'auto';\r\n        }\r\n        else\r\n        {\r\n            // Neither\r\n            this.elAutocomplete.style.left = 'auto';\r\n            this.elAutocomplete.style.right = 'auto';\r\n        }\r\n    },\r\n    onfocus: function()\r\n    {\r\n        this.isFocused(true);\r\n\r\n        g.vmMain.setFocusedPane(this.pane);\r\n\r\n        if (platform.phone)\r\n        {\r\n            g.sendEvent('SearchFocus', 'Mobile');\r\n        }\r\n        else\r\n        {\r\n            this.clearPlaceholder();\r\n\r\n            this.checkSearchBoxSize();\r\n\r\n            g.sendEvent('SearchFocus', 'Desktop');\r\n        }\r\n    },\r\n    onblur: function()\r\n    {\r\n        this.isFocused(false);\r\n        g.fireCustomEvent('closeKeyboard');\r\n\r\n        if(this.getDisplayText() === '')\r\n        {\r\n            this.setDisplayText(TextSpace);\r\n        }\r\n        else if (this.getDisplayText() === TextSpace)\r\n        {\r\n            this.setDisplayToPlaceholder();\r\n        }\r\n\r\n        g.clearSavedSelection('StoredSearch');\r\n    },\r\n    focusBox: function()\r\n    {\r\n        g.vmMain.setFocusedPane(this.pane);\r\n\r\n        // The keyboard toolbar is only available on mobile devices\r\n        if (g.keyboardToolbar)\r\n        {\r\n            g.keyboardToolbar.preShow();\r\n        }\r\n\r\n        this.getSearchBox().focus();\r\n        g.enforceScroll();\r\n\r\n        if (g.keyboardToolbar)\r\n        {\r\n            g.keyboardToolbar.show();\r\n        }\r\n    },\r\n    blurBox: function()\r\n    {\r\n        this.getSearchBox().blur();\r\n    },\r\n    focusAndSelectEnd: function()\r\n    {\r\n        this.focusBox();\r\n        g.selectElement(this.elSearch, /*selectEnd*/true);\r\n    },\r\n    resetSearch: function ()\r\n    {\r\n        this.search('');\r\n        this.setDisplayText(TextSpace);\r\n\r\n        for (var item in this.matches)\r\n        {\r\n            this.updateMatchState(d.getModel(item), /*newValue*/undefined, /*outline*/undefined);\r\n        }\r\n\r\n        this.matches[this.pane.item().id] = false;\r\n        //this.hideItem(this.pane.item());\r\n\r\n        this.updateSearch();\r\n    },\r\n    setSearch: function (text)\r\n    {\r\n        this.setDisplayText(text || TextSpace);\r\n        this.search(text);\r\n\r\n        this.updateSearch();\r\n    },\r\n    addToSearch: function (text)\r\n    {\r\n        if (text)\r\n        {\r\n            var newText = this.search() + ' ' + text;\r\n\r\n            this.setDisplayText(newText || TextSpace);\r\n            this.search(newText);\r\n\r\n            this.updateSearch();\r\n        }\r\n    },\r\n    isSearching: function()\r\n    {\r\n        return this.search().length > 0;\r\n    },\r\n    isShowing: function()\r\n    {\r\n        return this.isFocused() || this.isSearching();\r\n    },\r\n    isMatched: function (item)\r\n    {\r\n        // TODO: Document possible values for matches and make this better at detecting matches vs negated items\r\n        return ((this.matches[item.id] === undefined) || !!this.matches[item.id]) && this.matches[item.id] !== -1;\r\n    },\r\n    isVisible: function (item)\r\n    {\r\n        return !this.hiddenItems[item.id];\r\n    },\r\n    hideItem: function (item, outline)\r\n    {\r\n        if(outline)\r\n        {\r\n            var outlineElement = item.getOutlineElement(this.pane.id);\r\n            if(outlineElement)\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Hiding Outline Item (', this.search, '): ', item.getSearchText());\r\n                g.addClass(outlineElement, 'hidden');\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var element = item.getElement(this.pane.id);\r\n\r\n            if (element)\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Hiding Item (', this.search, '): ', item.getSearchText());\r\n\r\n                g.addClass(element, 'hidden');\r\n                this.hiddenItems[item.id] = true;\r\n            }\r\n            else\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Hiding Item MISSED (', this.search, '): ', item.getSearchText());\r\n            }\r\n        }\r\n\r\n    },\r\n    showItem: function (item, outline)\r\n    {\r\n        if(outline)\r\n        {\r\n            var outlineElement = item.getOutlineElement(this.pane.id);\r\n            if(outlineElement)\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Showing Outline Item (', this.search, '): ', item.getSearchText());\r\n                g.removeClass(outlineElement, 'hidden');\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var element = item.getElement(this.pane.id);\r\n\r\n            if (element)\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Showing Item (', this.search, '): ', item.getSearchText());\r\n\r\n                this.hiddenItems[item.id] = false;\r\n                g.removeClass(element, 'hidden');\r\n            }\r\n            else\r\n            {\r\n                if (DEBUG) log('[', this.pane.id, '] Showing Item MISSED (', this.search, '): ', item.getSearchText());\r\n            }\r\n        }\r\n    },\r\n    updateMatchState: function (item, newValue, outline)\r\n    {\r\n        var wasChanged = false;\r\n        if(item == this.pane.item.peek() || item == g.vmMain.root.peek())\r\n            return;\r\n\r\n        if (item)\r\n        {\r\n            var oldValue = this.matches[item.id];\r\n            this.matches[item.id] = newValue;\r\n\r\n            if (oldValue !== newValue && (oldValue !== undefined || newValue !== true))\r\n            {\r\n                wasChanged = true;\r\n\r\n                if (this.isPaneTimeline)\r\n                {\r\n                    this.pane.notifySearchStateChanged(item, newValue);\r\n                }\r\n            }\r\n        }\r\n\r\n        return wasChanged;\r\n    },\r\n    amountIncrementNumMatches: function(item, newValue)\r\n    {\r\n        if (item == this.pane.item.peek() || item == g.vmMain.root.peek())\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return newValue ? 1 : -1;\r\n    },\r\n    updateNumMatches: function(item, newValue)\r\n    {\r\n        var newNum = this.amountIncrementNumMatches(item, newValue);\r\n        if(newNum)\r\n        {\r\n            this.setNumMatches(this.numMatches() + newNum);\r\n        }\r\n\r\n        g.Assert(this.numMatches() >= 0);\r\n    },\r\n    setNumMatches: function(val)\r\n    {\r\n        var oldValue = this.numMatches();\r\n\r\n        if (oldValue !== val)\r\n        {\r\n            this.numMatches(val);\r\n\r\n            if (this.pane.paneContent && !!oldValue !== !!val)\r\n            {\r\n                this.pane.setNoItems(!!val);\r\n            }\r\n        }\r\n    },\r\n    isMatch: function(item, lower, s)\r\n    {\r\n        var found = true;\r\n        // Match priority\r\n        if(s.indexOf('!') >= 0)\r\n        {\r\n            found = item.priority() >= VMLIFlag.P2;\r\n            if(s.indexOf('!!') >= 0)\r\n            {\r\n                found = item.priority() >= VMLIFlag.P1;\r\n                if(s.indexOf('!!!') >= 0)\r\n                {\r\n                    found = item.priority() >= VMLIFlag.P0;\r\n                }\r\n            }\r\n            s = s.replace(/!/g, '');\r\n        }\r\n\r\n        // Match flagged\r\n        if(s.indexOf('\\'\\'') >= 0 && found)\r\n        {\r\n            found = item.isFlagged() && !item.isComplete();\r\n            s = s.replace(/\\'/g, '');\r\n        }\r\n\r\n        // Match complete\r\n        if(s.indexOf('//') >= 0 && found)\r\n        {\r\n            found = item.isComplete();\r\n            s = s.replace(/\\//g, '');\r\n        }\r\n\r\n        // Match text\r\n        if(s.length > 0 && found)\r\n        {\r\n            found = lower.indexOf(s) >= 0;\r\n        }\r\n        return found;\r\n    },\r\n    checkItem: function(item, outline, onLoad)\r\n    {\r\n        var searchRoot = outline ? g.vmMain.root.peek() : this.pane.item.peek();\r\n        if (DEBUG)\r\n        {\r\n            window.itemChecks[this.pane.id][item.id] = (window.itemChecks[this.pane.id][item.id] ? window.itemChecks[this.pane.id][item.id] + 1 : 1);\r\n        }\r\n        // if (!this.searchLoaded)\r\n        // {\r\n        //     return true;\r\n        // }\r\n\r\n        if (DEBUG) log('[', this.pane.id, '] Check Item (', this.search(), '): ', item.getSearchText());\r\n\r\n        var isMatch = true;\r\n        var parent;\r\n\r\n        // TODO: Use different strategy for string compare and avoid toLowerCase calls\r\n        var lower = item.getSearchText();\r\n\r\n        // First search negations because it should definitely not match if negated and doesn't need to\r\n        // go through parents\r\n        for(var i = 0; i < this.searchArr.length; i ++)\r\n        {\r\n            var termEntry = this.searchArr[i];\r\n\r\n            var negate = termEntry.isNegated;\r\n            if(negate)\r\n            {\r\n                var s = termEntry.text;\r\n\r\n                g.Assert(s, 'Each value in the search array should be valid at this point');\r\n\r\n                var found = this.isMatch(item, lower, s);\r\n\r\n                if(found)\r\n                {\r\n                    isMatch = -1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Search non-negations to find matches\r\n        if(isMatch === true)\r\n        {\r\n            for(var i = 0; i < this.searchArr.length; i ++)\r\n            {\r\n                var termEntry = this.searchArr[i];\r\n\r\n                var negate = termEntry.isNegated;\r\n                var s = termEntry.text;\r\n\r\n                g.Assert(s, 'Each value in the search array should be valid at this point');\r\n\r\n                if(!negate)\r\n                {\r\n                    var found = this.isMatch(item, lower, s);\r\n                    // Not a match\r\n                    if (!found)\r\n                    {\r\n                        // This word doesn't match this item so check whether this word matches a parent\r\n                        parent = item;\r\n                        while (parent)\r\n                        {\r\n                            parent = parent.parent();\r\n\r\n                            // TODO: Cache whether the path up to the root matches so it doesn't have to be\r\n                            // checked for each item\r\n                            // if (!parent || parent == searchRoot)\r\n                            if (!parent || parent == d.getRootModel())\r\n                            {\r\n                                isMatch = false;\r\n                                break;\r\n                            }\r\n                            if (this.isMatch(parent, parent.getSearchText(), s))\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Early out if this doesn't match\r\n                if (isMatch !== true)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Note: Elements can be undefined if search is opened on load or items are\r\n        //       added while in timeline view\r\n        // This item matches. Show it and all of its parents.\r\n        if (isMatch === true && item.isLoaded)\r\n        {\r\n            var model = item;\r\n            var oldMatchState = this.matches[item.id];\r\n\r\n            var wasChanged = this.updateMatchState(item, /*newValue*/true, outline);\r\n\r\n            //if (wasChanged)\r\n            {\r\n                // Early exit from the loop if a parent is explicitly hidden or is already shown.\r\n                while (model)\r\n                {\r\n                    if(this.matches[model.id] === -1)\r\n                    {\r\n                        this.matches[item.id] = false;\r\n                        break;\r\n                    }\r\n                    if (model.isLoaded)\r\n                    {\r\n                        this.showItem(model, outline);\r\n                    }\r\n\r\n                    if (model == searchRoot)\r\n                    {\r\n                        break;\r\n                    }\r\n\r\n                    model = model.parent();\r\n\r\n                    if (model)\r\n                    {\r\n                        if (this.matches[model.id] === true)\r\n                        {\r\n                            break;\r\n                        }\r\n\r\n                        oldMatchState = this.matches[model.id];\r\n                    }\r\n                }\r\n            }\r\n            if(onLoad && !outline && this.search())\r\n                this.updateNumMatches(item, true);\r\n        }\r\n        else if(item.isLoaded) // This item does not match\r\n        {\r\n            var wasChanged = this.updateMatchState(item, /*newValue*/isMatch, outline);\r\n            //if (wasChanged)\r\n            {\r\n                this.hideItem(item, outline);\r\n            }\r\n        }\r\n\r\n        return this.matches[item.id];\r\n    },\r\n    checkChildren: function(item, countItems, countChanged)\r\n    {\r\n        var num = this.numMatches();\r\n        if(countItems)\r\n        {\r\n            num = 0;\r\n        }\r\n        var includeArchived = this.isPaneTimeline && this.pane.showArchived();\r\n        g.searchVMLIs({\r\n            'item': item,\r\n            'includeArchived': includeArchived,\r\n            each: function(item)\r\n            {\r\n                var oldValue = this.matches[item.id];\r\n                var newValue = this.checkItem(item);\r\n                if((countItems && newValue === true) ||\r\n                   (countChanged &&\r\n                        ((newValue === true && oldValue !== true) ||\r\n                         (newValue !== true && oldValue === true))))\r\n                {\r\n                    var newNum = this.amountIncrementNumMatches(item, newValue === true);\r\n                    if(newNum)\r\n                        num += newNum;\r\n                }\r\n            }.bind(this)\r\n        });\r\n        this.setNumMatches(num);\r\n    },\r\n    checkChildrenOutline: function()\r\n    {\r\n        var includeArchived = this.isPaneTimeline && this.pane.showArchived();\r\n        g.searchVMLIs({\r\n            'headers': true,\r\n            each: function(item)\r\n            {\r\n                this.checkItem(item, true);\r\n            }.bind(this)\r\n        });\r\n    },\r\n    updateSearch: function(force)\r\n    {\r\n        // TODO: Can this function be optimizaed?\r\n\r\n        if (DEBUG) log('Updating Search [', this.pane.id, ']: ', this.search());\r\n\r\n        if (force !== true && this.search() == this.previousSearch)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.searchLoaded)\r\n        {\r\n            g.vmMain.updatePaneState(this.pane);\r\n        }\r\n\r\n        // Remove extra whitespace from search string\r\n        var textArray = this.search().toLowerCase().trim().split(/\\s+/);\r\n\r\n        textArray = textArray.filter(function (str)\r\n        {\r\n            return !!(str && str !== '-');\r\n        });\r\n\r\n        this.searchArr = [ ];\r\n        for (var i = 0; i < textArray.length; ++i)\r\n        {\r\n            var isNegated = textArray[i].startsWith('-');\r\n            var itemText = (isNegated ? textArray[i].substr(1) : textArray[i]);\r\n\r\n            this.searchArr.push({\r\n                text: itemText,\r\n                isNegated: isNegated\r\n            });\r\n        }\r\n\r\n        if(this.search())\r\n        {\r\n            this.pane.isSearching = true;\r\n            if(platform.mobile)\r\n            {\r\n                this.clearPlaceholder();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.pane.isSearching = false;\r\n            if(platform.mobile)\r\n            {\r\n                this.setDisplayToPlaceholder();\r\n            }\r\n        }\r\n\r\n        // if(this.prevNoPadNonHeader)\r\n        // {\r\n        //     this.prevNoPadNonHeader.$elements[this.pane.id].removeClass('noPadNonHeader');\r\n        //     this.prevNoPadNonHeader = undefined;\r\n        // }\r\n\r\n        this.previousSearch = this.search();\r\n\r\n        // var firstItem;\r\n        // var firstFoundItem;\r\n\r\n        // Ensure the current pane item is always not matched\r\n        this.matches[this.pane.item().id] = false;\r\n        //this.hideItem(this.pane.item());\r\n\r\n        if(this.initialized)\r\n        {\r\n            this.checkChildren(this.pane.item(), true);\r\n            this.checkChildrenOutline();\r\n        }\r\n\r\n        // When searching, ensure that the itemOptions are reset to a valid position. This is to ensure that the current pane\r\n        // doesn't stay scrolled down to the bottom with a bunch of blank content.\r\n        //g.vmMain.hideOptions();\r\n\r\n        // if (this.pane.mode() == PaneMode.Normal && firstFoundItem && !firstItem.isHeader() && firstFoundItem != firstItem)\r\n        // {\r\n        //     firstFoundItem.$elements[this.pane.id].addClass('noPadNonHeader');\r\n        //     this.prevNoPadNonHeader = firstFoundItem;\r\n        // }\r\n        this.onUpdated.valueHasMutated();\r\n\r\n        //g.fireCustomEvent('searchUpdated');\r\n        //g.events.emit('searchUpdated');\r\n    },\r\n    keydown: function(item, e)\r\n    {\r\n        if (e.normCode === KeyCode.Enter)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // Don't let get text get set to empty string or it will make\r\n        // the elements move up a few pixels\r\n        if (e.normCode === KeyCode.BackSpace)\r\n        {\r\n            var text = this.getDisplayText();\r\n            if (text === '' || text === TextSpace)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            if (e.metaKey)\r\n            {\r\n                this.setDisplayText(TextSpace);\r\n            }\r\n            else\r\n            {\r\n                // Check if the entirety of the text is selected\r\n                var range = g.getSelectionRange();\r\n                if (range.startOffset === 0 && range.endOffset === text.length)\r\n                {\r\n                    this.setDisplayText(TextSpace);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n    keyup: function(item, e)\r\n    {\r\n        var text = this.getDisplayText();\r\n\r\n        if (!platform.mobile && text === '')\r\n        {\r\n            this.setDisplayText(TextSpace);\r\n        }\r\n\r\n        if (e.normCode === KeyCode.Escape)\r\n        {\r\n            //this.resetSearch();\r\n            g.selectElement(this.elSearch, /*selectEnd*/false);\r\n        }\r\n        else\r\n        {\r\n            var newText = text.replace(TextSpace, '').replace('\\n', '');\r\n\r\n            this.search(newText);\r\n\r\n            tracker.miscAction({\r\n                type: TrackerType.Misc,\r\n                misc: TrackerMisc.SearchChanged,\r\n                data: [\r\n                {\r\n                    pane: this.pane.id,\r\n                    text: newText\r\n                }]\r\n            });\r\n\r\n            var forceUpdate = (e.normCode === KeyCode.Enter);\r\n\r\n            this.updateSearch(forceUpdate);\r\n            if (!platform.mobile)\r\n            {\r\n                this.checkSearchBoxSize();\r\n            }\r\n\r\n            if (e.normCode === KeyCode.Enter)\r\n            {\r\n                if (platform.android && g.keyboardToolbar)\r\n                {\r\n                    g.clearSavedSelection('StoredSearch');\r\n\r\n                    g.clearSelection();\r\n                }\r\n                else if (!g.restoreSavedSelection('StoredSearch', g.focusedPane))\r\n                {\r\n                    var firstChild = g.focusedItem.getFirstChild();\r\n\r\n                    if (firstChild)\r\n                    {\r\n                        g.selectChildren(firstChild, 0, 0);\r\n\r\n                        g.scrollIntoView(firstChild.getSpan(), 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n    insert: function(ch, withSpace)\r\n    {\r\n        var range = g.getSelectionRange();\r\n        var start = range.startOffset;\r\n\r\n        if(start === 1 && this.getDisplayText() === TextSpace)\r\n        {\r\n            start --; // To compensate for TextSpace\r\n        }\r\n\r\n        g.Assert(this.search().indexOf(TextSpace) < 0, 'TextSpace should never be in the search string');\r\n        var text = this.search().replace(TextSpace, '');\r\n\r\n        if (withSpace && text.length > 0)\r\n        {\r\n            var prevChar = text[start - 1];\r\n            if(prevChar !== ' ' & prevChar !== '-')\r\n            {\r\n                ch = ' ' + ch;\r\n            }\r\n        }\r\n\r\n        var len = ch.length;\r\n\r\n        var newSearch = text.substr(0, range.startOffset) + ch + text.substr(range.endOffset);\r\n        this.search(newSearch);\r\n\r\n        tracker.miscAction({\r\n            type: TrackerType.Misc,\r\n            misc: TrackerMisc.SearchChanged,\r\n            data: [\r\n            {\r\n                pane: this.pane.id,\r\n                text: newSearch\r\n            }]\r\n        });\r\n\r\n        this.setDisplayText(newSearch);\r\n\r\n        this.updateSearch();\r\n\r\n        g.setSelection(this.elSearch, start + len, start + len);\r\n    },\r\n    onTapAutocomplete:\r\n    {\r\n        onStart: function(e)\r\n        {\r\n            // Prevent taking focus from search box\r\n            e.preventDefault();\r\n        }\r\n    },\r\n    onTapSearchInsert:\r\n    {\r\n        onStart: function(e)\r\n        {\r\n            // Prevent taking focus from search box\r\n            e.preventDefault();\r\n        },\r\n        onClick: function(e)\r\n        {\r\n            var className = e.srcElement.className;\r\n            if (className.indexOf('search') !== 0)\r\n            {\r\n                className = e.srcElement.parentNode.className;\r\n            }\r\n\r\n            switch (className)\r\n            {\r\n                case 'searchNegate':\r\n                    var range = g.getSelectionRange();\r\n\r\n                    if (range.startOffset !== range.endOffset)\r\n                    {\r\n                        var start = range.startOffset;\r\n                        var end = range.endOffset;\r\n                        if (this.getDisplayText[0] === TextSpace)\r\n                        {\r\n                            if (start > 0) { start--; }\r\n\r\n                            end--;\r\n                        }\r\n\r\n                        var sText = this.search();\r\n\r\n                        if (sText[start] !== '-')\r\n                        {\r\n                            var newText = sText.substring(0, start) + '-' + sText.substring(start);\r\n\r\n                            this.setSearch(newText);\r\n                            g.setSelection(this.elSearch, start, end + 1);\r\n                        }\r\n                        else\r\n                        {\r\n                            var newText = sText.substring(0, start) + sText.substring(start + 1);\r\n\r\n                            this.setSearch(newText);\r\n                            g.setSelection(this.elSearch, start, Math.max(0, end - 1));\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        this.insert('-', true);\r\n                    }\r\n                    break;\r\n                case 'searchP2':\r\n                    this.insert('!', true);\r\n                    break;\r\n                case 'searchP1':\r\n                    this.insert('!!', true);\r\n                    break;\r\n                case 'searchP0':\r\n                    this.insert('!!!', true);\r\n                    break;\r\n                case 'searchFlagged':\r\n                    this.insert(\"''\", true);\r\n                    break;\r\n                case 'searchComplete':\r\n                    this.insert('//', true);\r\n                    break;\r\n            }\r\n\r\n            g.sendEvent('Menu', className);\r\n        }\r\n    },\r\n    requestFocusBoxForEvent: function(e)\r\n    {\r\n        var activeElement = document.activeElement;\r\n        if (!activeElement || activeElement.id != 'searchPhone')\r\n        {\r\n            this.open();\r\n\r\n            e.preventDefault();\r\n        }\r\n    },\r\n    onTapBox: {\r\n        onClick: function(e)\r\n        {\r\n            if(platform.mobile)\r\n            {\r\n                // log(e.srcElement);\r\n                if(g.phoneMenu.activeScreen() !== Screens.Settings && g.phoneMenu.mode() == g.phoneMenu.Modes.Normal)\r\n                {\r\n                    if(this.open())\r\n                    {\r\n                        e.stopImmediatePropagation();\r\n                    }\r\n                }\r\n                e.preventDefault();\r\n            }\r\n            else\r\n            {\r\n                this.requestFocusBoxForEvent(e);\r\n            }\r\n        }\r\n    },\r\n    onTapX: {\r\n        onStart: function(e)\r\n        {\r\n            e.handled = true;\r\n            e.preventDefault();\r\n        },\r\n        onClick: function(e)\r\n        {\r\n            if (this.isSearchActive())\r\n            {\r\n                this.resetSearch();\r\n                e.preventDefault();\r\n\r\n                g.sendEvent('Menu', 'ClearSearch');\r\n            }\r\n            else\r\n            {\r\n                this.requestFocusBoxForEvent(e);\r\n\r\n                g.sendEvent('Menu', 'FocusSearch');\r\n            }\r\n        }\r\n    },\r\n    isSearchActive: function()\r\n    {\r\n        return (this.search().length !== 0);\r\n    },\r\n    getTitleText: function()\r\n    {\r\n        return this.isSearchActive() ? 'Clear Search' : 'Search';\r\n    },\r\n    getSearchIcon: function()\r\n    {\r\n        return this.isSearchActive() ? 'icon-remove' : 'icon-search';\r\n    },\r\n    open: function()\r\n    {\r\n        if(!this.isFocused())\r\n        {\r\n            if (platform.mobile)\r\n            {\r\n                this.focusAndSelectEnd();\r\n            }\r\n            else\r\n            {\r\n                this.focusBox();\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n    getDisplayText: function()\r\n    {\r\n        return this.elSearch.textContent;\r\n    },\r\n    setDisplayText: function(text)\r\n    {\r\n        g.Assert(text !== undefined && text !== '' || platform.mobile, 'Search text should always be defined, either with a TextSpace or actual text');\r\n        this.elSearch.textContent = text;\r\n        if(text === TextSpace && platform.mobile)\r\n        {\r\n            this.placeholderActive(true);\r\n        }\r\n        else\r\n        {\r\n            this.placeholderActive(false);\r\n        }\r\n    },\r\n    setDisplayToPlaceholder: function()\r\n    {\r\n        this.placeholderActive(true);\r\n        this.elSearch.textContent = TextSpace;\r\n    },\r\n    clearPlaceholder: function()\r\n    {\r\n        this.placeholderActive(false);\r\n    }\r\n};\r\n\r\nreturn VMSearch;\r\n});\r\n","asserts":[{"tag":1300,"offset":1124},{"tag":1301,"offset":5287},{"tag":1302,"offset":12089},{"tag":1303,"offset":14611},{"tag":1304,"offset":15238},{"tag":1305,"offset":25662},{"tag":1306,"offset":31459}]},"VMTitle":{"path":"F:/p/bce/Duchess/public/js/VMTitle.js","data":"define(['ko', 'globals', 'data', 'tracker', 'platform'],\nfunction (ko, g, d, tracker, platform) {\nfunction VMTitle(p)\n{\n    this.text = p.text;\n    this.item = p.item;\n    this.home = p.home;\n    this.isTruncated = ko.observable(false);\n    this.pane = p.pane;\n\n    this.init(p);\n}\n\nVMTitle.prototype = {\n    init: function()\n    {\n        this.text = this.item.getParsedText();\n        if(this.text.length > 25)\n        {\n            this.text = this.text.substr(0,25);\n            this.isTruncated(true);\n        }\n    },\n    onTap:\n    {\n        onStart: function(e) {\n            e.handled = true;\n            g.vmMain.setFocusedPane(this.pane);\n        },\n        onClick: function(e) {\n            g.focusedPane.onTapTitle.onClick.call(g.focusedPane, e, this.item);\n        }\n    }\n};\n\nreturn VMTitle;\n});","asserts":[]},"VMPane_Timeline":{"path":"F:/p/bce/Duchess/public/js/VMPane_Timeline.js","data":"define(['ko', 'globals', 'data', 'VMTimelineBlock'],\nfunction (ko, g, d, VMTimelineBlock) {\nvar VMPane_Timeline =\n{\n    initTimeline: function()\n    {\n        this.blocks = ko.observableArray();\n        this.blockImportant = undefined;\n        this.blockStarred = undefined;\n        this.days = { };\n        this.updateNextTimeout = 0;\n        this.datesByItem = { };\n        this.flaggedItems = { };\n        this.priorityItems = { };\n        this.isLoading = false;\n        this.deferModelUpdates = 0;\n\n        var self = this;\n        this.showArchived.subscribe(function(newValue)\n        {\n            if (DEBUG) log('Timeline Changed Archived Mode: ', newValue);\n\n            self.reloadTimeline();\n        });\n\n        if (DEBUG)\n        {\n            window.dumpBlocks = this.dumpBlocks.bind(this);\n        }\n    },\n    hasBlocks: function()\n    {\n        var count = 0;\n        for(var i = 0; i < this.blocks().length; i ++)\n        {\n            count += this.blocks()[i].searchCount();\n        }\n\n        return count > 0;\n    },\n    reasonEmpty: function()\n    {\n        if(this.vmSearch && this.vmSearch.search().length > 0)\n        {\n            return 'No search results';\n        }\n        else\n        {\n            return 'Nothing on the agenda';\n        }\n    },\n    blockCompare: function(left, right)\n    {\n        if(left.isNow && right.isToday)\n            return -1;\n        if(left.isToday && right.isNow)\n            return 1;\n        return Date.compare(left.date, right.date);\n    },\n    // sortDates: function()\n    // {\n    //     this.blocks.sort(blockCompare);\n    // },\n    removeDate: function(item)\n    {\n        //console.log('Remove Date: ', item.text);\n\n        var vmDate = this.datesByItem[item.id];\n        vmDate.removeItem(item);\n\n        this.datesByItem[item.id] = undefined;\n\n        // TODO: Re-enable retirement of old blocks when they are no longer needed\n        // if (vmDate.items().length === 0)\n        // {\n        //     this.blocks.remove(vmDate);\n\n        //     var dateKey = vmDate.dateKey;\n        //     this.days[dateKey] = undefined;\n        // }\n    },\n    addBlock: function(block)\n    {\n        block.setSearchProvider(this.vmSearch);\n\n        //log('Add Block: ', this.blocks().length);\n\n        if (this.deferModelUpdates)\n        {\n            this.blocks().insertSorted(block, this.blockCompare);\n        }\n        else\n        {\n            this.blocks.insertSorted(block, this.blockCompare);\n        }\n    },\n    dumpBlocks: function()\n    {\n        log('Dump Timeline Blocks:');\n\n        for (var i = 0; i < this.blocks().length; ++i)\n        {\n            var block = this.blocks()[i];\n\n            log('  Block: ', block.text);\n            log('  Count: ', block.searchCount);\n\n            for (var j = 0; j < block.items().length; ++j)\n            {\n                var item = block.items()[j];\n\n                log('    Item: ', item.getParsedText());\n            }\n        }\n    },\n    findNextBlock: function()\n    {\n        var now = new Date();\n        for(var i = 0; i < this.blocks().length; i ++)\n        {\n            var block = this.blocks()[i];\n\n            if(block.isToday || block.isFlagged || block.isImportant || block.date > now)\n            {\n                return block;\n            }\n        }\n    },\n    hideDescendants: function(parent)\n    {\n        for(var i = 0; i < parent.items().length; i ++)\n        {\n            var item = parent.items()[i];\n            if (this.datesByItem[item.id])\n            {\n                this.removeDate(item);\n            }\n\n            if(this.flaggedItems[item.id])\n            {\n                this.blockStarred.removeItem(item);\n                this.flaggedItems[item.id] = undefined;\n            }\n\n            if(this.priorityItems[item.id])\n            {\n                this.blockImportant.removeItem(item);\n                this.priorityItems[item.id] = undefined;\n            }\n\n            if(item.items().length > 0)\n            {\n                this.hideDescendants(item);\n            }\n        }\n    },\n    notifyDescendants: function(parent)\n    {\n        for(var i = 0; i < parent.items().length; i ++)\n        {\n            var item = parent.items()[i];\n\n            this.notifyStateChanged(item);\n\n            if(item.items().length > 0)\n            {\n                this.notifyDescendants(item);\n            }\n        }\n    },\n    // TODO: Is this not actually used?\n    notifyPositionChanged: function(item)\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        if (this.isLoading)\n        {\n            // Ignore event until load is complete\n            return;\n        }\n\n        if (this.datesByItem[item.id])\n            this.datesByItem[item.id].updateItem(item);\n\n        if(this.flaggedItems[item.id])\n            this.blockStarred.updateItem(item);\n\n        if(this.priorityItems[item.id])\n            this.blockImportant.updateItem(item);\n    },\n    notifySearchStateChanged: function(item, newValue)\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        if (this.isLoading)\n        {\n            // Ignore event until load is complete\n            return;\n        }\n\n        if (this.datesByItem[item.id])\n            this.datesByItem[item.id].notifySearchStateChanged(item, newValue);\n\n        if(this.flaggedItems[item.id])\n            this.blockStarred.notifySearchStateChanged(item, newValue);\n\n        if(this.priorityItems[item.id])\n            this.blockImportant.notifySearchStateChanged(item, newValue);\n    },\n    notifyStateChanged: function(item, changeType)\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        if (this.isLoading)\n        {\n            // Ignore event until load is complete\n            return;\n        }\n\n        if(item.hasCompletedAncestor())\n        {\n            return;\n        }\n\n        // console.log('Timeline Item State Changed: ', item._rawText);\n\n        //log(item._rawText);\n\n        var dataItem = d.getItem(item.id);\n        g.Assert(!dataItem || !!dataItem.isDeleted === !!item.isDeleted || g.isDemoMode(), 'isDeleted should match loaded item and item info');\n        this.vmSearch.checkItem(item);\n\n        if (dataItem && dataItem.isDeleted)\n        {\n            var block = this.datesByItem[item.id];\n\n            if (block)\n            {\n                block.removeItem(item);\n            }\n\n            if (item.isImportant())\n            {\n                this.updateSpecialBlock(item, this.priorityItems, this.blockImportant, /*matches*/false);\n            }\n\n            if (item.isFlagged())\n            {\n                this.updateSpecialBlock(item, this.flaggedItems, this.blockStarred, /*matches*/false);\n            }\n        }\n        else\n        {\n            // Update date if the date or completed state has changed\n            if (!changeType || g.isAtLeastOneFlagSet(changeType, PropChangeType.Date | PropChangeType.Complete | PropChangeType.Archive))\n            {\n                if (item.date() || item.isComplete())\n                {\n                    var date = (item.date() ? item.date() : item.dateCompleted);\n\n                    this.dateUpdated(item, date);\n                }\n                else\n                {\n                    var oldBlock = this.datesByItem[item.id];\n\n                    if (oldBlock)\n                    {\n                        this.removeDate(item);\n                    }\n                }\n            }\n\n            // Notify all children if isComplete or isArchived has changed\n            if (g.isAtLeastOneFlagSet(changeType, PropChangeType.Complete | PropChangeType.Archive))\n            {\n                if (item.isComplete() || item.isArchived())\n                {\n                    this.hideDescendants(item);\n                }\n                else\n                {\n                    this.notifyDescendants(item);\n                }\n            }\n\n            // Update Important block\n            if (!changeType || g.isAtLeastOneFlagSet(changeType, PropChangeType.Priority | PropChangeType.Complete | PropChangeType.Archive))\n            {\n                this.updateSpecialBlock(item, this.priorityItems, this.blockImportant, item.isImportant() && !item.isComplete());\n            }\n\n            // Update Flagged block\n            if (!changeType || g.isAtLeastOneFlagSet(changeType, PropChangeType.Flagged | PropChangeType.Complete | PropChangeType.Archive))\n            {\n                this.updateSpecialBlock(item, this.flaggedItems, this.blockStarred, item.isFlagged() && !item.isComplete());\n            }\n        }\n    },\n    updateSpecialBlock: function(item, items, block, matches)\n    {\n        if(matches && !item.isDeleted && !(item.isArchived() && !this.showArchived()))\n        {\n            // New item\n            if(!items[item.id])\n            {\n                block.addItem(item);\n                items[item.id] = item;\n            }\n            // Existing item's state changed\n            else\n            {\n                block.updateItem(item);\n            }\n        }\n        // Item no longer matches\n        else if(items[item.id])\n        {\n            block.removeItem(item);\n            items[item.id] = undefined;\n        }\n    },\n    dateUpdated: function(item, date, skipSort)\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        if (this.isLoading)\n        {\n            // Ignore event until load is complete\n            return;\n        }\n\n        if (item.isArchived() && !this.showArchived())\n        {\n            if (this.datesByItem[item.id])\n            {\n                this.removeDate(item);\n            }\n\n            return;\n        }\n\n        // if (item.isComplete() && date)\n        // {\n        //     console.log('Item Completed [', date, ']: ', item.text;\n        // }\n        // else if (!item.isComplete())\n        // {\n            // console.log('Timeline Updating Date: ', date);\n        // }\n\n        this.vmSearch.checkItem(item);\n\n        // The date may be either updated or removed, handle each case separately.\n        if (date /*&& (date >= Date.today())*/)\n        {\n            var dateKey;\n            var isSoft = g.isDateSoft(item.dateText);\n            if(isSoft)\n            {\n                dateKey = item.dateText.toUpperCase();\n            }\n            else\n            {\n                dateKey = date.clone().clearTime().getTime();\n            }\n\n            var vmDate = this.days[dateKey];\n            if (!vmDate && !this.days[dateKey])\n            {\n                var options = {\n                    'owner': this,\n                    'date': date.clone().clearTime(),\n                    'dateKey': dateKey\n                };\n                if(isSoft)\n                {\n                    options.name = dateKey;\n                }\n                var vmDate = new VMTimelineBlock(options);\n\n                this.days[dateKey] = vmDate;\n\n                this.addBlock(vmDate, skipSort);\n            }\n\n            if (vmDate)\n            {\n                var oldEntry = this.datesByItem[item.id];\n\n                // If this item hass previously been inserted into the dates array it needs to be removed\n                if (oldEntry)\n                {\n                    if (oldEntry.dateKey !== dateKey)\n                    {\n                        this.removeDate(item);\n                        this.datesByItem[item.id] = vmDate;\n                    }\n                }\n                else\n                {\n                    this.datesByItem[item.id] = vmDate;\n                }\n\n                this.days[dateKey].addItem(item);\n            }\n        }\n        else\n        {\n            if (this.datesByItem[item.id])\n            {\n                this.removeDate(item);\n            }\n        }\n    },\n    ensureSpecialBlocks: function()\n    {\n        if (!this.blockStarred)\n        {\n            this.blockStarred = new VMTimelineBlock({owner: this, name: 'Flagged', date: Date.today().add({hour: 1}), isFlagged: true});\n            this.addBlock(this.blockStarred);\n        }\n\n        if (!this.blockImportant)\n        {\n            this.blockImportant = new VMTimelineBlock({owner: this, name: 'Important', date: Date.today().add({hour: 2}), isImportant: true});\n            this.addBlock(this.blockImportant);\n        }\n    },\n    loadTimeline: function()\n    {\n        if (DEBUG) log('Load Timeline');\n\n        g.Assert(this.mode() == PaneMode.Timeline);\n\n        g.Assert(this.blocks().length === 0, 'When loading the timeline we expect it to be empty');\n\n        this.setDeferUpdates(true);\n\n        this.ensureSpecialBlocks();\n\n        g.searchVMLIs({\n            item: this.item(),\n            includeArchived: this.showArchived(),\n            each: this.notifyStateChanged.bind(this)\n        });\n\n        this.setDeferUpdates(false);\n        this.vmSearch.onUpdated.valueHasMutated();\n\n        // setTimeout(function ()\n        // {\n        //     var idx = self.blocks().findInsertIndex({'date': Date.today()}, self.blockCompare);\n\n        //     var focusBlock = self.blocks()[idx];\n\n        //     //log('FOCUS BLOCK: ', focusBlock);\n\n        //     if (focusBlock && focusBlock.element)\n        //     {\n        //         g.scrollIntoView(focusBlock.element);\n        //     }\n\n        //     // TODO: Infinite Scrolling\n        // }, 0);\n\n        //dumpBlocks();\n    },\n    unloadTimeline: function ()\n    {\n        // g.Assert(this.mode() == PaneMode.Timeline);\n\n        if (DEBUG) log('Unload Timeline');\n\n        this.datesByItem = { };\n        this.flaggedItems = { };\n        this.priorityItems = { };\n        this.days = { };\n\n        if (this.deferModelUpdates)\n        {\n            this.blocks().splice(0, this.blocks().length);\n        }\n        else\n        {\n            this.blocks([ ]);\n        }\n\n        this.blockStarred = undefined;\n        this.blockImportant = undefined;\n    },\n    reloadTimeline: function ()\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        if (DEBUG) log('[', this.id, '] Reload Timeline');\n\n        this.reloading = true;\n\n        this.unloadTimeline();\n\n        this.loadTimeline();\n\n        this.reloading = false;\n    },\n    setDeferUpdates: function (value)\n    {\n        g.Assert(this.mode() == PaneMode.Timeline);\n\n        this.deferModelUpdates += (value ? 1 : -1);\n        g.Assert(this.deferModelUpdates >= 0, 'Mismatching defer update calls');\n\n        if (this.deferModelUpdates === 0)\n        {\n            //log('Processing Deferred Timeline Updates');\n\n            var numBlocks = this.blocks().length;\n            for (var i = 0; i < numBlocks; ++i)\n            {\n                this.blocks()[i].processDeferredUpdates();\n            }\n\n            this.blocks.valueHasMutated();\n        }\n    },\n    startLoading: function ()\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        g.Assert(!this.isLoading, 'Should only notify the timeline a single time when loading starts');\n\n        this.isLoading = true;\n    },\n    endLoading: function ()\n    {\n        if (this.mode() !== PaneMode.Timeline)\n        {\n            return;\n        }\n\n        g.Assert(this.isLoading, 'Must have started loading the timeline to stop loading it');\n\n        this.isLoading = false;\n\n        this.setDeferUpdates(true);\n\n        this.reloadTimeline();\n\n        this.setDeferUpdates(false);\n    }\n};\n\nreturn VMPane_Timeline;\n});\n","asserts":[{"tag":1311,"offset":6085},{"tag":1312,"offset":12509},{"tag":1313,"offset":12562},{"tag":1314,"offset":13528},{"tag":1315,"offset":14379},{"tag":1316,"offset":14484},{"tag":1317,"offset":15048},{"tag":1318,"offset":15313}]},"VMTimelineBlock":{"path":"F:/p/bce/Duchess/public/js/VMTimelineBlock.js","data":"define(['ko', 'globals', 'data', 'VMLI'],\nfunction (ko, g, d, VMLI) {\nfunction VMTimelineBlock(p)\n{\n    this.owner = p.owner;\n    this.date = p.date;\n    this.dateKey = p.dateKey;\n    this.text = p.text;\n    this.name = p.name;\n    this.searchProvider = undefined;\n    this.items = ko.observableArray();\n    this.searchCount = ko.observable(0);\n    this.hasDeferredUpdate = false;\n    this.element = undefined;\n    this.timeCount = ko.observable(0);\n    this.isFlagged = p.isFlagged;\n    this.isImportant = p.isImportant;\n    this.isToday = false;\n\n    this.init(p);\n}\n\nVMTimelineBlock.prototype = {\n    showBlock: function ()\n    {\n        return ((this.items().length > 0) && this.searchCount() > 0);\n    },\n    specialClass: function ()\n    {\n        if(this.isFlagged)\n            return 'flaggedBlock';\n        if(this.isImportant)\n            return 'importantBlock';\n        if(this.isToday || this.isNow)\n            return 'todayBlock';\n    },\n    showTime: function(ctx)\n    {\n        var item = ctx.$data;\n        var index = ctx.$index;\n        if(this.isNow)\n            return false;\n\n        // Force evaluation of showTime every time search is updated\n        var tempValue = this.searchProvider.onUpdated();\n\n        // Don't show time if no items in this block have a time\n        if(this.timeCount() === 0 || this.isFlagged || this.isImportant || !this.searchProvider.isVisible(item))\n            return false;\n\n        var previousVisible = index() - 1;\n        while(previousVisible > 0 && !this.searchProvider.isVisible(this.items()[previousVisible]))\n        {\n            previousVisible --;\n        }\n        // Show time if this is the first item\n        if(previousVisible < 0)\n            return true;\n\n        var prevItem = this.items()[previousVisible];\n\n        if(item.hasTime())\n        {\n            // Don't show time if same time as same time as previous\n            if(this.compareDate(prevItem, item) === 0)\n            {\n                return false;\n            }\n        }\n        else\n        {\n            // Don't show time if this and previous have no time\n            if(!prevItem.hasTime())\n                return false;\n        }\n\n        return true;\n    },\n    processDeferredUpdates: function()\n    {\n        if (this.hasDeferredUpdate)\n        {\n            this.hasDeferredUpdate = false;\n            //this.items.valueHasMutated();\n        }\n    },\n    init: function(p)\n    {\n        g.Assert(this.date);\n\n        if (!this.dateKey)\n        {\n            this.dateKey = this.date.clone().clearTime().getTime();\n\n            if (p.name)\n            {\n                this.dateKey = this.dateKey + p.name;\n            }\n        }\n\n        if (this.name)\n        {\n            this.text = this.name.toUpperCase();\n            if(this.name == 'NOW')\n                this.isNow = true;\n        }\n        else\n        {\n            this.text = '';\n            if (this.date)\n            {\n                var timeDiff = Math.floor((this.date - Date.today()) / 86400000);\n\n                switch (timeDiff)\n                {\n                    case -1:\n                        this.text = 'YESTERDAY ';\n                        break;\n                    case 0:\n                        this.text = 'TODAY ';\n                        this.isToday = true;\n                        break;\n                    case 1:\n                        this.text = 'TOMORROW ';\n                        break;\n                    default:\n                        this.text = this.date.toString('dddd').toUpperCase();\n                        break;\n                }\n            }\n\n            this.text = this.text + ' ' + this.date.toString('M/d');\n        }\n    },\n    comparePriority: function(left, right)\n    {\n        var lPri = left.priority();\n        var rPri = right.priority();\n\n        if (lPri > rPri)\n        {\n            return -1;\n        }\n        else if (lPri < rPri)\n        {\n            return 1;\n        }\n\n        // if (left.getRawText().startsWith(ImportantPrefix))\n        // {\n        //     if (right.getRawText().startsWith(ImportantPrefix))\n        //     {\n        //         return 0;\n        //     }\n\n        //     return -1;\n        // }\n        // else if (right.getRawText().startsWith(ImportantPrefix))\n        // {\n        //     return 1;\n        // }\n\n        return 0;\n    },\n    compareDate: function(left, right)\n    {\n        if (left.isComplete() && !right.isComplete())\n        {\n            return -1;\n        }\n        else if (!left.isComplete() && right.isComplete())\n        {\n            return 1;\n        }\n\n        if (left.isComplete() && right.isComplete())\n        {\n            return (left.dateCompleted > right.dateCompleted) ? 1 : -1;\n        }\n\n        // log(left._rawText, right._rawText, left.date(), right.date());\n        if(left.date() && !right.date())\n        {\n            return -1;\n        }\n        else if(!left.date() && right.date())\n        {\n            return 1;\n        }\n\n        var leftDate = new Date(left.date());\n        var leftTime = leftDate.toString('h:mmtt');\n\n        var rightDate = new Date(right.date());\n        var rightTime = rightDate.toString('h:mmtt');\n\n\n        if (leftTime != '12:00am' && rightTime != '12:00am')\n        {\n            if(isNaN(leftDate.getYear()) || isNaN(rightDate.getYear()))\n            {\n                return 0;\n            }\n\n            return Date.compare(leftDate, rightDate);\n        }\n        else if (leftTime != '12:00am')\n        {\n            return -1;\n        }\n        else if (rightTime != '12:00am')\n        {\n            return 1;\n        }\n\n        return 0;\n    },\n    compareOrder: function(left, right)\n    {\n        // TODO: Should use a more specific version of getFirstItem that returns -1, 0, 1\n        var first = g.getFirstItem(left, right);\n\n        g.Assert(first !== undefined);\n\n        return ((first.id == left.id) ? -1 : 1);\n    },\n    compareItems: function(left, right)\n    {\n        // Sort by date if not a special block\n        var cDate = !(this.isFlagged || this.isImportant) ? this.compareDate(left, right) : 0;\n\n        if (cDate === 0)\n        {\n            var cPriority = !this.isFlagged ? this.comparePriority(left, right) : 0;\n            if (cPriority === 0)\n            {\n                var cOrder = this.compareOrder(left, right);\n\n                g.Assert(cOrder !== 0, \"This should always result in a tie break\");\n\n                return cOrder;\n            }\n            else\n            {\n                return cPriority;\n            }\n        }\n        else\n        {\n            return cDate;\n        }\n    },\n    // sortItems: function()\n    // {\n    //     this.items.sort(this.compareItems.bind(this));\n    // },\n    addItem: function(item)\n    {\n        if (this.items.indexOf(item) >= 0)\n        {\n            this.updateItem(item);\n\n            return;\n        }\n\n        if (this.searchProvider.isMatched(item))\n        {\n            this.searchCount(this.searchCount() + 1);\n            if(item.hasTime())\n                this.timeCount(this.timeCount() + 1);\n\n            if (DEBUG) log(item.id, ': New Count [', this.searchCount, ']');\n        }\n\n        //console.log('Insert Item: ', item.text);\n\n        if (this.owner.deferModelUpdates)\n        {\n            this.items().insertSorted(item, this.compareItems.bind(this));\n            this.hasDeferredUpdate = true;\n        }\n        else\n        {\n            this.items.insertSorted(item, this.compareItems.bind(this));\n        }\n    },\n    removeItem: function(item)\n    {\n        if (this.searchProvider.isMatched(item))\n        {\n            this.searchCount(this.searchCount() - 1);\n            if(item.hasTime())\n                this.timeCount(this.timeCount() - 1);\n\n            if (DEBUG) log(item.id, ': New Count [', this.searchCount, ']');\n        }\n\n        if (this.owner.deferModelUpdates)\n        {\n            this.items().remove(item);\n            this.hasDeferredUpdate = true;\n        }\n        else\n        {\n            this.items.remove(item);\n        }\n    },\n    updateItem: function(item)\n    {\n        // console.log('Update Item: ', item._rawText);\n\n        if (this.owner.deferModelUpdates)\n        {\n            this.items().remove(item);\n            this.items().insertSorted(item, this.compareItems.bind(this));\n            this.hasDeferredUpdate = true;\n        }\n        else\n        {\n            this.items.remove(item);\n            this.items.insertSorted(item, this.compareItems.bind(this));\n        }\n\n        var timeCount = 0;\n        for(var i = 0; i < this.items().length; i ++)\n        {\n            if(this.items()[i].hasTime())\n            {\n                timeCount ++;\n            }\n        }\n        this.timeCount(timeCount);\n    },\n    onLoad: function(element)\n    {\n        this.element = element;\n    },\n    notifySearchStateChanged: function(item, newValue)\n    {\n        // TODO: Does this really need to handle an invalid newValue?\n        g.Assert(newValue !== undefined || this.searchProvider, 'Must supply a value or a valid search provider');\n\n        // If no new value is given, grab the latest from the search provider. This should only occur when\n        // adding or removing items to this block.\n        if (newValue === undefined)\n        {\n            newValue = this.searchProvider.isMatched(item);\n        }\n\n        if (DEBUG) log(item.id, ': Search State Changed to ', newValue);\n\n        if (newValue === true)\n        {\n            this.searchCount(this.searchCount() + 1);\n\n            if (item.hasTime())\n            {\n                this.timeCount(this.timeCount() + 1);\n            }\n        }\n        else\n        {\n            this.searchCount(this.searchCount() - 1);\n\n            if (item.hasTime())\n            {\n                this.timeCount(this.timeCount() - 1);\n            }\n        }\n\n        if (DEBUG) log('  : New Count [', this.searchCount, ']');\n    },\n    setSearchProvider: function(vmSearch)\n    {\n        this.searchProvider = vmSearch;\n    }\n};\n\nreturn VMTimelineBlock;\n});\n","asserts":[{"tag":1307,"offset":2440},{"tag":1308,"offset":5841},{"tag":1309,"offset":6363},{"tag":1310,"offset":8983}]},"VMOutline":{"path":"F:/p/bce/Duchess/public/js/VMOutline.js","data":"define(['ko', 'globals', 'data', 'gdata', 'VMSearch', 'platform', 'tracker'],\nfunction (ko, g, d, gdata, VMSearch, platform, tracker) {\nfunction VMOutline(pane)\n{\n    this.pane = pane;\n    this.root = g.vmMain.root();\n    if(!platform.mobile)\n    {\n        this.isVisible = ko.observable(false);\n    }\n    this.init();\n}\n\nVMOutline.prototype = {\n    init: function()\n    {\n        g.outline = this;\n\n        if (platform.mobile)\n        {\n            g.ScreenManager.addScreen(this, Screens.Outline);\n        }\n    },\n    getTopElement: function()\n    {\n        return document.getElementsByClassName('paneOutline')[0];\n    },\n    onTap:\n    {\n        onStart: function(e)\n        {\n            g.ScreenManager.checkSwipeStart(e);\n        },\n        onMove: function(e)\n        {\n            g.ScreenManager.checkSwipeMove(e);\n        },\n        onClick: function(e)\n        {\n            if (!platform.mobile || !g.ScreenManager.checkSwipeClick(e))\n            {\n                if (g.hasClass(e.srcElement, 'outlineText') || g.hasClass(e.srcElement.parentElement, 'outlineText'))\n                {\n                    var item = ko.dataFor(e.srcElement);\n\n                    if(!platform.mobile)\n                    {\n                        g.vmMain.setFocusedPane(this.pane);\n                    }\n\n                    g.vmMain.zoomin(item);\n\n                    if (platform.mobile)\n                    {\n                        g.ScreenManager.scrollToScreen(Screens.List);\n                    }\n                    else\n                    {\n                        g.focusedPane.toggleOutlineVisibility();\n                    }\n\n                    e.preventDefault();\n\n                    g.sendEvent('Menu', 'OutlineZoom');\n                }\n            }\n        },\n        onEnd: function(e)\n        {\n            g.ScreenManager.checkSwipeEnd(e);\n        }\n    },\n    onTapCollapse:\n    {\n        onStart: function(e)\n        {\n            if (g.hasClass(e.srcElement, 'outlineArrow'))\n            {\n                var li = e.srcElement.parentNode;\n\n                if (g.hasClass(li, 'collapsed'))\n                {\n                    g.removeClass(li, 'collapsed');\n\n                    g.sendEvent('Menu', 'OutlineMinimize');\n                }\n                else\n                {\n                    g.addClass(li, 'collapsed');\n\n                    g.sendEvent('Menu', 'OutlineMaximize');\n                }\n\n                e.handled = true;\n                e.preventDefault();\n            }\n        }\n    },\n    onScreenStartOpen: function()\n    {\n    },\n    onScreenOpen: function()\n    {\n        if (g.isKeyboardOpen && !g.vmSearchPhone.isFocused())\n        {\n            g.blurActiveElement();\n        }\n\n        // g.vmMain.menuState(MenuState.Context);\n\n        // Show context\n        // g.vmMain.setTransform(g.contextX(), 180);\n\n        // Animate context in\n        //paneOutline.style.visibility = 'visible';\n\n        // Workaround chrome on android rendering bug where the scrollbar stays visible on the pane\n        // after the context pane is opened and hidden again. After hiding the pane, the overflowY\n        // property is set to 'hidden' to prevent the scrollbar from staying visible on screen.\n        // if (platform.android)\n        // {\n        //     var paneOutline = document.getElementsByClassName('paneOutline')[0];\n\n        //     paneOutline.style.overflowY = 'scroll';\n        //     //paneList.style.overflowY = 'hidden';\n        // }\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.ToggleOutline,\n            data:\n            {\n                element: this.getTopElement()\n            }\n        });\n    },\n    onScreenUpdate: function(diff)\n    {\n\n    },\n    onScreenClose: function()\n    {\n        // g.vmMain.menuState(MenuState.Main);\n        // Hide context\n        // g.vmMain.setTransform(0, 180);\n        // Animate context out\n        // g.setTransform(paneOutline, (-g.contextX() / 2), 0, 200, 'in');\n        // setTimeout(function()\n        // {\n            //paneOutline.style.visibility = 'hidden';\n\n        // if (platform.android)\n        // {\n        //     var paneOutline = document.getElementsByClassName('paneOutline')[0];\n\n        //     paneOutline.style.overflowY = 'hidden';\n        //     //paneList.style.overflowY = 'scroll';\n        // }\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.ToggleOutline,\n            data:\n            {\n                element: this.getTopElement()\n            }\n        });\n\n        // }, 200);\n    },\n    toggleDesktop: function()\n    {\n        var paneWidth = g.width(this.pane.element);\n        var time = 150;\n\n        if (this.isVisible())\n        {\n            g.setTransform(this.pane.outlineElement, -paneWidth * 1, 0, time, 'ease-out');\n            g.setTransform(this.pane.paneContent, 0, 0, time, 'ease-out');\n            setTimeout(function()\n            {\n                this.isVisible(!this.isVisible());\n                this.pane.outlineElement.style.visibility = 'hidden';\n            }.bind(this), time);\n        }\n        else\n        {\n            this.isVisible(!this.isVisible());\n            this.pane.outlineElement.style.visibility = 'visible';\n            g.setTransform(this.pane.outlineElement, -paneWidth * 1, 0);\n            requestAnimationFrame((function(){\n                g.setTransform(this.pane.outlineElement, 0, 0, time, 'ease-in-out');\n                g.setTransform(this.pane.paneContent, paneWidth, 0, time, 'ease-in-out');\n            }).bind(this));\n        }\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.ToggleOutline,\n            data:\n            {\n                element: this.getTopElement()\n            }\n        });\n    }\n    // toggle: function()\n    // {\n    //     if(g.vmMain.isOutlineOut())\n    //     {\n    //         this.close();\n    //     }\n    //     else\n    //     {\n    //         this.open();\n    //     }\n    // },\n};\n\ng.VMOutline = VMOutline;\nreturn VMOutline;\n});\n","asserts":[]},"VMMenus":{"path":"F:/p/bce/Duchess/public/js/VMMenus.js","data":"define(['ko', 'globals', 'data', 'gdata', 'VMSearch', 'VMTitle', 'edit', 'VMLI', 'tracker', 'platform', 'VMDocument'],\nfunction (ko, g, d, gdata, VMSearch, VMTitle, edit, VMLI, tracker, platform, VMDocument) {\nfunction VMMenus()\n{\n    this.linkAddress = ko.observable();\n    this.linkTitle = ko.observable('temporary title');\n    this.itemMenuPhoneWidth = -60 * 4;\n    this.rightMenuWidth = 50;\n    this.phoneLastTop = 0;\n    this.itemMenuPhone = undefined;\n    this.itemMenuBG = undefined;\n    this.itemMenuPhoneMode = ko.observable(0); // 0: Disabled, 1: Complete, 2: Archive, 3: Delete\n    this.rightMenuPhone = undefined;\n    this.rightMenuPhoneBG = undefined;\n    this.lastSwipeMove = 0;\n    this.lastSwipeMoveTime = 0;\n    this.canClosePane = ko.observable(false);\n    this.showArchivedMenuOption = ko.observable(false);\n    this.archivedMenuText = ko.observable('');\n    this.itemIsHeader = ko.observable(false);\n    this.itemHasChildren = ko.observable(false);\n    this.itemIsCollapsed = ko.observable(false);\n    this.itemIsArchived = ko.observable(false);\n    this.itemCanIndent = ko.observable(false);\n    this.itemCanUnindent = ko.observable(false);\n    this.itemCanZoom = ko.observable(false);\n    this.lastZIndex = 37;\n    this.contextMenuOpenedOn = ko.observable(undefined);\n    this.isModalVisible = ko.observable(false);\n    this.isModalOpen = ko.observable(false);\n    this.modalOpened = undefined;\n    this.modalOpenedBound = undefined;\n    this.modalsBound = false;\n    this.menusBound = false;\n\n    this.init();\n}\n\nVMMenus.prototype = {\n    init: function()\n    {\n        window.addEventListener('closeKeyboard', this.onCloseKeyboard.bind(this));\n        g.addCustomEventListener('keyEscape', this.onEscapeKey.bind(this), 100);\n\n        if(!platform.mobile)\n        {\n            this.isModalOpen.subscribe(function(newValue)\n            {\n                if(newValue)\n                {\n                    requestAnimationFrame(function()\n                    {\n                        requestAnimationFrame(function()\n                        {\n                            g.addClass(g.element('main'), 'modalOpen');\n                            g.addClass(g.element('desktopMenu'), 'modalOpen');\n                            g.addClass(g.element('desktopSidebar'), 'modalOpen');\n                        });\n                    });\n                }\n\n                else\n                {\n                    requestAnimationFrame(function()\n                    {\n                        g.removeClass(g.element('main'), 'modalOpen');\n                        g.removeClass(g.element('desktopMenu'), 'modalOpen');\n                        g.removeClass(g.element('desktopSidebar'), 'modalOpen');\n                    });\n                }\n            });\n        }\n    },\n    bind: function()\n    {\n        if (!this.menusBound)\n        {\n            this.menusBound = true;\n\n            g.applyBindings(this, 'contextMenus');\n\n            if (platform.mobile)\n            {\n                this.itemMenuPhone = g.element('itemMenuPhone');\n                this.rightMenuPhoneBG = g.element('rightMenuPhoneBG');\n                this.rightMenuPhone = g.element('rightMenuPhone');\n                this.rightMenuPhoneItems = g.element('rightMenuPhoneItems');\n                this.itemMenuBG = g.element('itemMenuBG');\n\n                g.applyBindings(this, 'itemMenuPhone');\n                g.applyBindings(this, 'rightMenuPhoneItems');\n            }\n        }\n    },\n    onEscapeKey: function()\n    {\n        if (this.isModalOpen())\n        {\n            return this.closeModalInternal(false);\n        }\n    },\n    itemMenuPhoneClass: function()\n    {\n        var mode = this.itemMenuPhoneMode();\n        if(mode === 0)\n            return 'complete completeDisabled';\n        else if(mode == 1)\n            return 'complete';\n        else if(mode == 2)\n            return 'notVisible';\n        // else if(mode == 2)\n        //     return 'archive';\n        // else\n        //     return 'delete';\n    },\n    selectionHasChildren: function()\n    {\n        for(var i = 0; i < g.vmMain.selected().length; i ++)\n        {\n            if(g.vmMain.selected()[i].hasChildren())\n                return true;\n        }\n        return false;\n    },\n    selectionIsHeader: function()\n    {\n        return g.vmMain.selected().length === 1 &&\n                g.vmMain.selected()[0].isHeader();\n    },\n    openLinkMenu: function(target, address, left, top)\n    {\n        this.linkAddress(address);\n        g.menuOnItem = target;\n\n        var menuLink = document.getElementById('contextMenuLink');\n        menuLink.style.left = left + 'px';\n        menuLink.style.top = top + 'px';\n        menuLink.style.display = 'block';\n\n        g.vmMain.handleFullscreenClick((function()\n        {\n            this.closeLinkMenu();\n        }).bind(this));\n    },\n    closeLinkMenu: function()\n    {\n        g.menuOnItem = undefined;\n        this.linkAddress('');\n\n        var menuLink = document.getElementById('contextMenuLink');\n        menuLink.style.display = 'none';\n\n        g.vmMain.cancelFullscreenClick();\n    },\n    onTapLink: {\n        onClick: function(e)\n        {\n            // Link navigation is handled by the <a> itself so just close the menu here.\n            this.closeLinkMenu();\n        }\n    },\n    closeAllMenus: function()\n    {\n        this.linkAddress('');\n\n        var menuLink = document.getElementById('contextMenuLink');\n        menuLink.style.display = 'none';\n\n        g.menuOnItem = undefined;\n    },\n    setupItemMenu: function(target)\n    {\n        g.element('menuGoto').style.display = g.focusedPane.isSearching ? 'block' : 'none';\n    },\n    onTapHover: {\n        onStart: function(e) {\n            e.preventDefault();\n        },\n        onClick: function(e) {\n            var id = e.srcElement.id;\n\n            g.sendEvent('Menu', id);\n        }\n    },\n    // onToolbarOver: function(m, e)\n    // {\n    //     var text;\n    //     switch(e.target.id)\n    //     {\n    //         case 'hoverPriority':\n    //             text = 'Important (' + platform.cmdChar + ' + 1)';\n    //             break;\n    //         case 'hoverComplete':\n    //             text = 'Complete (' + platform.cmdChar + ' + 6)';\n    //             break;\n    //         case 'hoverStar':\n    //             text = 'Star (' + platform.cmdChar + ' + 8)';\n    //             break;\n    //         case 'hoverComment':\n    //             text = 'Note (' + platform.cmdChar + ' + /)';\n    //             break;\n    //         case 'hoverHeader':\n    //             text = 'Header';\n    //             break;\n    //         case 'hoverBold':\n    //             text = 'Bold (' + platform.cmdChar + ' + B)';\n    //             break;\n    //         case 'hoverItalic':\n    //             text = 'Italic (' + platform.cmdChar + ' + I)';\n    //             break;\n    //         case 'hoverUnderline':\n    //             text = 'Underline (' + platform.cmdChar + ' + U)';\n    //             break;\n    //         case 'hoverOutdent':\n    //             text = 'Unindent (Shift + Tab)';\n    //             break;\n    //         case 'hoverIndent':\n    //             text = 'Indent (Tab)';\n    //             break;\n    //         case 'hoverArchive':\n    //             text = 'Archive';\n    //             break;\n    //         case 'hoverDelete':\n    //             text = 'Delete';\n    //             break;\n    //     }\n\n    //     if(text)\n    //         g.vmMain.showTooltip(e.target, text);\n    //     else\n    //         g.vmMain.hideTooltip();\n    // },\n    // onToolbarLeave: function(m, e)\n    // {\n    //     g.vmMain.hideTooltip();\n    // },\n    multiSelect: function(item)\n    {\n        item.isSelected(!item.isSelected());\n        if(item.isSelected())\n        {\n            g.vmMain.selected.push(item);\n        }\n        else\n        {\n            g.vmMain.selected.splice(g.vmMain.selected.indexOf(item), 1);\n        }\n    },\n    revealGestureMenu: function(item, e)\n    {\n        g.Assert(g.revealingMenu === false, 'Must not have already started a gesture');\n        g.revealingMenu = true;\n\n        this.startedInMultiSelectMode = g.phoneMenu.multiSelectMode();\n\n        g.menuOnItem = item;\n\n        {\n            var menuSpan = item.getSpan();\n\n            var height = 40;\n\n            var offsetTop = g.offset(menuSpan).top;\n\n            var top = offsetTop - g.phoneMainY; // The 4 is from the padding-top\n\n            // Center vertically with span\n            var spanHeight = g.height(menuSpan) + 8; // 4 padding on top and bottom\n            top += (spanHeight - height) / 2;\n\n            var paneTop = top;\n\n            // If top is different, set the style\n            if (this.phoneLastTop !== paneTop)\n            {\n                this.phoneLastTop = paneTop;\n            }\n        }\n\n        this.itemMenuPhone.style[platform.transition.style] = '';\n\n        g.setTransformStyle(this.itemMenuPhone, 0, this.phoneLastTop);\n\n        if (!this.startedInMultiSelectMode)\n        {\n            g.setTransformStyle(this.rightMenuPhone, 0, 0);\n        }\n\n        this.rightMenuThresh = (this.rightMenuWidth / 200) * platform.windowWidth.peek();\n    },\n    updateRevealGestureMenu: function (e)\n    {\n        g.Assert(g.revealingMenu === true, 'Must have already started a gesture to perform an update');\n\n        var xOffset = e.diffX;\n\n        this.lastSwipeMove = e.xThisFrame;\n        this.lastSwipeMoveTime = e.timeStamp;\n\n        if (this.startedInMultiSelectMode)\n        {\n            xOffset -= this.rightMenuWidth;\n\n            var offset = g.clamp(xOffset, -this.rightMenuWidth, 0);\n\n            g.setTransformStyle(this.rightMenuPhone, offset, 0);\n        }\n        else\n        {\n            // Move menu into place\n            var clampedOffset = g.clamp(xOffset, -this.rightMenuWidth, 0);\n            g.setTransformStyle(this.itemMenuPhone, platform.windowWidth.peek() + clampedOffset, this.phoneLastTop);\n\n            var multPoint = -this.rightMenuWidth - this.rightMenuThresh;\n\n            // Scale the right menu background\n            var scalePerc = g.clamp((-xOffset - this.rightMenuWidth) / this.rightMenuThresh, 0, 1);\n            this.itemMenuBG.style[platform.transform.style] = 'scale3d(1,' + scalePerc + ', 1)';\n\n            var offset = g.clamp(xOffset + this.rightMenuWidth + this.rightMenuThresh, -this.rightMenuWidth, 0);\n            g.setTransformStyle(this.rightMenuPhone, offset, 0);\n\n            var opacityPerc = g.clamp((-xOffset + multPoint) / (this.rightMenuWidth * 0.75), 0, 1);\n            this.itemMenuPhone.style.opacity = (1 - opacityPerc);\n\n            if(!g.isKeyboardOpen)\n            {\n                g.vmMain.setSelected( [ g.menuOnItem ] );\n            }\n\n            // Set complete icon color\n\n            // if (xOffset < multPoint)\n            // {\n            //     log('set to 0', offset, multPoint);\n            //     if (this.itemMenuPhoneMode.peek() !== 0)\n            //     {\n            //         this.itemMenuPhoneMode(0);\n            //     }\n            // }\n            if (xOffset <= -this.rightMenuWidth)\n            {\n                if (this.itemMenuPhoneMode.peek() !== 1)\n                {\n                    this.itemMenuPhoneMode(1);\n                }\n            }\n            else\n            {\n                if (this.itemMenuPhoneMode.peek() !== 0)\n                {\n                    this.itemMenuPhoneMode(0);\n                }\n            }\n        }\n    },\n    stopRevealGestureMenu: function (e)\n    {\n        g.Assert(g.revealingMenu === true, 'Must have already started a gesture');\n\n        var transitionTime = 200;\n        var xOffset = e.diffX;\n\n        g.revealingMenu = false;\n\n        var timeSinceMove = e.timeStamp - this.lastSwipeMoveTime;\n\n        if (!this.startedInMultiSelectMode)\n        {\n            if (xOffset <= -this.rightMenuWidth - this.rightMenuThresh)\n            {\n                g.setTransform(this.rightMenuPhone, -this.rightMenuWidth, 0, 200, 'ease-out');\n\n                g.phoneMenu.multiSelectMode(true);\n                g.blurActiveElement(true);\n                g.vmMain.setSelected( [ g.menuOnItem ] );\n            }\n            else\n            {\n                if (xOffset <= -this.rightMenuWidth)\n                {\n                    g.menuOnItem.isComplete(!g.menuOnItem.isComplete());\n                }\n\n                g.setTransform(this.rightMenuPhone, 0, 0, 200, 'ease-out');\n                if(!g.isKeyboardOpen)\n                {\n                    g.vmMain.clearSelected();\n                }\n            }\n        }\n        else\n        {\n            xOffset -= this.rightMenuWidth;\n            var offset = g.clamp(xOffset, -this.rightMenuWidth, 0);\n            if(offset <= -this.rightMenuWidth / 2)\n            {\n                g.setTransform(this.rightMenuPhone, -this.rightMenuWidth, 0, 200, 'ease-out');\n            }\n            else\n            {\n                this.closeMultiSelect();\n                g.vmMain.clearSelected();\n            }\n        }\n\n        this.closePhoneMenu(transitionTime);\n    },\n    closeMultiSelect: function ()\n    {\n        // this.rightMenuPhoneBG.style.opacity = 0;\n        g.setTransform(this.rightMenuPhone, 0, 0, 200, 'ease-out');\n        g.phoneMenu.multiSelectMode(false);\n\n        g.vmMain.clearSelected();\n    },\n    closePhoneMenu: function ()\n    {\n        var transitionTime = 200;\n\n        // Move menu to right side of screen\n        g.setTransform(this.itemMenuPhone, platform.windowWidth(), this.phoneLastTop, transitionTime, 'ease-out');\n\n        g.menuOnItem = undefined;\n    },\n    onResize: function ()\n    {\n        if (!g.menuOnItem)\n        {\n            g.setTransform(this.itemMenuPhone, platform.windowWidth(), this.phoneLastTop);\n        }\n    },\n    onTapMenuPhone: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            if (g.vmMain.selected().length === 0)\n                return;\n\n            var id = e.srcElement.id;\n            var fn;\n            var val;\n            switch (id)\n            {\n                case 'phoneMenuComplete':\n                    fn = 'isComplete';\n                    val = !g.vmMain.getFirstSelectedItem().isComplete();\n                    break;\n                case 'phoneMenuFlag':\n                    fn = 'isFlagged';\n                    val = !g.vmMain.getFirstSelectedItem().isFlagged();\n                    break;\n                case 'phoneMenuPriorityNone':\n                    fn = 'priority';\n                    val = VMLIFlag.None;\n                    break;\n                case 'phoneMenuPriorityHigh':\n                    fn = 'priority';\n                    val = g.vmMain.getFirstSelectedItem().priority() == VMLIFlag.P0 ? VMLIFlag.None : VMLIFlag.P0;\n                    break;\n                case 'phoneMenuPriorityMed':\n                    fn = 'priority';\n                    val = g.vmMain.getFirstSelectedItem().priority() == VMLIFlag.P1 ? VMLIFlag.None : VMLIFlag.P1;\n                    break;\n                case 'phoneMenuPriorityLow':\n                    fn = 'priority';\n                    val = g.vmMain.getFirstSelectedItem().priority() == VMLIFlag.P2 ? VMLIFlag.None : VMLIFlag.P2;\n                    break;\n                case 'phoneMenuZoom':\n                    g.vmMain.zoomin(g.vmMain.getFirstSelectedItem());\n                    this.closeMultiSelect();\n                    break;\n                case 'phoneMenuDelete':\n                    fn = 'deleteSelf';\n                    break;\n                case 'phoneMenuCollapse':\n                    if (this.selectionHasChildren())\n                    {\n                        for (var i = 0; i < g.vmMain.selected().length; i ++)\n                        {\n                            if (g.vmMain.selected()[i].hasChildren())\n                            {\n                                if (!val)\n                                {\n                                    val = !g.vmMain.selected()[i].isCollapsed();\n                                }\n\n                                g.vmMain.selected()[i].isCollapsed(val);\n                            }\n                        }\n                    }\n                    break;\n            }\n\n            if (fn)\n            {\n                for (var i = 0; i < g.vmMain.selected().length; i ++)\n                {\n                    g.vmMain.selected()[i][fn](val);\n                }\n            }\n\n            if (id === 'phoneMenuDelete')\n            {\n                g.vmMain.clearSelected();\n            }\n        }\n    },\n\n    onTapComplete: {\n        onClick: function(e) {\n            g.menuOnItem.isComplete(!g.menuOnItem.isComplete());\n       }\n    },\n    onTapPriority: {\n        onClick: function(e) {\n            var prevPri = g.menuOnItem.priority();\n\n            var newPri = (prevPri !== VMLIFlag.None) ? VMLIFlag.None : VMLIFlag.P0;\n\n            g.menuOnItem.priority(newPri);\n       }\n    },\n    onTapCollapse: {\n        onClick: function(e) {\n            g.menuOnItem.toggleCollapsed();\n       }\n    },\n    onTapDelete: {\n        onClick: function(e) {\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            g.menuOnItem.deleteSelf();\n\n            tracker.endAction(); // END TRACKER <----\n       }\n    },\n    paneTapped: function()\n    {\n        if(g.menuOnItem)\n        {\n            this.closePhoneMenu(100);\n        }\n    },\n    openContextMenu: function(offset, menu, toLeft)\n    {\n        if (g.autocomplete)\n        {\n            g.autocomplete.hide();\n        }\n\n        var styles = {\n            visibility: 'visible',\n            top: offset.top\n        };\n\n        var menuWidth = g.width(menu);\n        if (!toLeft)\n        {\n            if (offset.left + menuWidth > platform.windowWidth())\n            {\n                toLeft = true;\n            }\n        }\n\n        if (!toLeft)\n        {\n            styles['left'] = offset.left + 2;\n        }\n        else\n        {\n            styles['left'] = offset.left - menuWidth - 2;\n        }\n\n        var menuHeight = g.height(menu);\n        if (offset.top + menuHeight > platform.windowHeight())\n        {\n            styles.top -= menuHeight;\n        }\n\n        g.css(menu, styles);\n\n        // Move the right click menu into bounds if possible.\n        var windowBounds = document.documentElement.getBoundingClientRect();\n        var rect = menu.getBoundingClientRect();\n\n        var autoRect = { left: rect.left, right: rect.right, top: rect.top, bottom: rect.bottom };\n\n        var origin = g.adjustOriginToBeInsideBounds(windowBounds, autoRect);\n\n        if (origin.x !== autoRect.left || origin.y !== autoRect.top)\n        {\n            // Grab the element offset from the completion element element\n            menu.style.left = origin.x + 'px';\n            menu.style.top = origin.y + 'px';\n        }\n\n        g.vmMain.handleFullscreenClick((function()\n        {\n            this.closeContextMenu(menu);\n        }).bind(this));\n    },\n    closeContextMenu: function(menu)\n    {\n        g.css(menu, {visibility: 'hidden'});\n        g.vmMain.cancelFullscreenClick();\n    },\n    registerModal: function(menu, bind, openFn, closeFn)\n    {\n        g.Assert(menu && bind, 'Must have a valid name and object to bind modal to');\n\n        this[menu + 'Item'] = ko.observable(bind);\n\n        this[menu + 'Visible'] = ko.observable(false);\n        this[menu + 'Loading'] = ko.observable(false);\n\n        if (openFn)\n        {\n            this[menu + 'OpenFn'] = openFn;\n        }\n        if (closeFn)\n        {\n            this[menu + 'CloseFn'] = closeFn;\n        }\n    },\n    openModal: function(menu)\n    {\n        g.Assert(!this.modalOpened, 'Only a single modal should be opened at a time');\n\n        if (this[menu + 'OpenFn'])\n        {\n            this[menu + 'OpenFn'].apply(this[menu + 'Item'](), Array.prototype.slice.call(arguments, 1));\n        }\n\n        if (!this.modalsBound)\n        {\n            g.applyBindings(this, 'modals');\n            this.modalsBound = true;\n        }\n\n        var visibleVar = this[menu + 'Visible'];\n        g.Assert(visibleVar, 'Visible variable does not exist');\n\n        this.modalOpened = menu;\n        this.modalOpenedBound = this[menu + 'Item']();\n\n        visibleVar(true);\n\n        this.isModalVisible(true);\n        this.isModalOpen(true);\n    },\n    closeModal: function(menu)\n    {\n        // Modals fade out when closed so multiple clicks could occurr\n        if(!this.modalOpened)\n            return;\n\n        g.Assert(!menu || menu === this.modalOpened, 'Tried to close the wrong modal');\n\n        if (arguments.length > 1)\n        {\n            this.closeModalInternal.apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n        else\n        {\n            this.closeModalInternal();\n        }\n    },\n    closeModalInternal: function()\n    {\n        // Modals fade out when closed so multiple clicks could occurr\n        if(!this.modalOpened)\n            return;\n\n        g.Assert(this.modalOpened, 'Tried to close when no modal was open');\n\n        var visibleVar = this[this.modalOpened + 'Visible'];\n        g.Assert(visibleVar, 'Visible variable does not exist');\n\n        var currentModal = this.modalOpened;\n\n        visibleVar(false);\n        this.isModalOpen(false);\n\n        this.isModalVisible(false);\n\n        this.modalOpened = undefined;\n        this.modalOpenedBound = undefined;\n        this.modalInputOn = undefined;\n\n        g.fireCustomEvent('closeKeyboard');\n\n        if (this[currentModal + 'CloseFn'])\n        {\n            this[currentModal + 'CloseFn'].apply(this[currentModal + 'Item'](), arguments);\n        }\n\n        return false;\n    },\n    focusModalInputMobile: function(e, element)\n    {\n        g.Assert(platform.mobile, 'Should not call this from non-mobile');\n\n        if (!this.modalInputOn)\n        {\n            g.openKeyboardOn(e, element, false, function()\n            {\n                if(platform.app)\n                {\n                    this.modalOpenedBound.onKeyboardOpened(e);\n                    requestAnimationFrame(function(){\n                        requestAnimationFrame(function(){\n                            element.focus();\n                            g.enforceScroll();\n                        });\n                    });\n                }\n                else\n                {\n                    element.focus();\n                }\n            }.bind(this));\n        }\n        else if(this.modalInputOn != element)\n        {\n            element.focus();\n\n            if(this.modalOpenedBound.onKeyboardOpened)\n            {\n                requestAnimationFrame(function(){\n                    this.modalOpenedBound.onKeyboardOpened(e);\n                }.bind(this));\n            }\n\n            e.preventDefault();\n            e.stopPropagation();\n            g.enforceScroll();\n        }\n        else\n        {\n            g.enforceScroll();\n        }\n    },\n    onTapModal: {\n        onStart: function(e)\n        {\n            if (platform.mobile && e.srcElement != this.modalInputOn && (g.isKeyboardInputElement(e.srcElement) || g.hasClass(e.srcElement, 'input')))\n            {\n                log('start', g.isKeyboardOpen);\n                if (!g.isKeyboardOpen)\n                {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n            }\n        },\n        onClick: function(e)\n        {\n            var prevent = true;\n            if (e.srcElement.id == 'modals')\n            {\n                this.closeModal();\n                this.modalInputOn = undefined;\n            }\n            else if (e.srcElement == this.modalInputOn)\n            {\n                prevent = false;\n            }\n            else if (g.isKeyboardInputElement(e.srcElement) || g.hasClass(e.srcElement, 'input'))\n            {\n                if(platform.mobile)\n                {\n                    this.focusModalInputMobile(e, e.srcElement);\n                }\n                this.modalInputOn = e.srcElement;\n            }\n            else\n            {\n                this.modalInputOn = undefined;\n            }\n            if (prevent && platform.mobile)\n            {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    },\n    onCloseKeyboard: function()\n    {\n        this.modalInputOn = undefined;\n    },\n    paneIsTimeline: function()\n    {\n        if (!this.contextMenuOpenedOn())\n            return false;\n\n        return this.contextMenuOpenedOn().isTimeline && this.contextMenuOpenedOn().isTimeline();\n    },\n    openItemMenu: function(item, e)\n    {\n        this.openContextMenu({ left: e.pageX, top: e.pageY }, g.element('contextMenuItem'), false);\n\n        this.contextMenuOpenedOn(g.getPaneForElement(e.srcElement));\n\n        var firstItem;\n        var foundZoomCandidate = false;\n        g.vmMain.applyToSelection(function(item, index, total)\n        {\n            g.Assert(item, 'Item must be defined');\n\n            if (item && index === 0)\n            {\n                firstItem = item;\n\n                this.itemIsHeader(item.isHeader());\n                this.itemHasChildren(item.isHeader() || item.hasChildren());\n                this.itemIsCollapsed(item.isCollapsed());\n                this.itemIsArchived(item.isArchived());\n\n                this.itemCanIndent(item.getIndex() !== 0);\n                this.itemCanUnindent(item.parent() !== g.focusedItem);\n            }\n\n            if (!foundZoomCandidate)\n            {\n                if (item.canZoom())\n                {\n                    foundZoomCandidate = true;\n\n                    this.itemCanZoom(true);\n                }\n            }\n\n            // If we've reached the end of the selection and did not find a valid item to zoom disable the option.\n            if (!foundZoomCandidate && index === total - 1)\n            {\n                this.itemCanZoom(false);\n            }\n\n            return !foundZoomCandidate;\n        }.bind(this), { passExtraInfo: true });\n    },\n    closeItemMenu: function()\n    {\n        this.closeContextMenu(g.element('contextMenuItem'));\n        this.contextMenuOpenedOn(undefined);\n    },\n    itemContextText: function()\n    {\n        return this.itemIsCollapsed() ? 'Expand': 'Collapse';\n    },\n    itemArchivedText: function()\n    {\n        return this.itemIsArchived() ? 'Unarchive' : 'Archive';\n    },\n    hotkeyText: function(key)\n    {\n        return platform.windows ? (platform.cmdChar + '+' + key) : (platform.cmdChar + '' + key);\n    },\n    onTapItemMenu: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            var id = e.srcElement.id;\n            if (!id)\n            {\n                id = e.srcElement.parentNode.id;\n            }\n\n            switch (id)\n            {\n                case 'itemComplete':\n                    g.vmMain.applyFnToSelection('isComplete', /*toggle*/true);\n                    break;\n                case 'itemFlag':\n                    g.vmMain.applyFnToSelection('isFlagged', /*toggle*/true);\n                    break;\n\n                case 'itemIndent':\n                    g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: false});\n                    break;\n                case 'itemUnindent':\n                    g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: true});\n                    break;\n\n                case 'itemPriorityNone':\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.None);\n                    break;\n                case 'itemPriorityLow':\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P2);\n                    break;\n                case 'itemPriorityMed':\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P1);\n                    break;\n                case 'itemPriorityHigh':\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P0);\n                    break;\n\n                // case 'itemFormatBold':\n                //     g.vmMain.applyFormatToSelection('b');\n                //     break;\n                // case 'itemFormatItalic':\n                //     g.vmMain.applyFormatToSelection('i');\n                //     break;\n                // case 'itemFormatUnderline':\n                //     g.vmMain.applyFormatToSelection('u');\n                //     break;\n\n                case 'itemCollapse':\n                    g.vmMain.applyToSelection(function(item)\n                    {\n                        item.toggleCollapsed();\n                    });\n                    break;\n                case 'itemZoom':\n                    g.vmMain.applyToSelection(function(item)\n                    {\n                        if (item.canZoom())\n                        {\n                            g.vmMain.zoomin(item);\n                            return false;\n                        }\n\n                        return true;\n                    });\n                    break;\n\n                case 'itemCopy':\n\n                    break;\n                case 'itemPaste':\n\n                    break;\n                case 'itemUndo':\n\n                    break;\n                case 'itemRedo':\n\n                    break;\n\n                case 'itemArchive':\n                    var numChanged = 0;\n\n                    var numChecked = g.vmMain.applyToSelection(function(item)\n                    {\n                        if (this.itemIsArchived())\n                        {\n                            if (item.parent().unarchiveChild(item))\n                            {\n                                numChanged++;\n                            }\n                        }\n                        else\n                        {\n                            if (item.parent().archiveChild(item))\n                            {\n                                numChanged++;\n                            }\n                        }\n                    }.bind(this));\n\n                    if (numChanged > 0)\n                    {\n                        var z = (numChanged > 1 ? ' items.' : ' item.');\n                        var verb = this.itemIsArchived() ? 'unarchived' : 'archived';\n\n                        g.messageQueue.pushMessage({\n                            text: 'Successfully ' + verb + ' ' + numChanged + z,\n                            type: MessageType.Info,\n                            action: MessageAction.Default,\n                            timeout: 2000\n                        });\n                    }\n                    break;\n\n                case 'itemDelete':\n                    g.vmMain.applyToSelection(function(item)\n                    {\n                        item.deleteSelf();\n                    });\n                    break;\n                case 'contextMenuItem':\n                    // Click on a disabled item\n                    break;\n                default:\n                    g.Assert(false, 'Unknown context menu item: ', id);\n                    break;\n            }\n\n            g.sendEvent('ContextMenu', id);\n\n            this.closeItemMenu();\n        }\n    }\n};\n\nreturn VMMenus;\n});\n","asserts":[{"tag":1338,"offset":7990},{"tag":1339,"offset":9228},{"tag":1340,"offset":11521},{"tag":1341,"offset":19199},{"tag":1342,"offset":19663},{"tag":1343,"offset":20096},{"tag":1344,"offset":20511},{"tag":1345,"offset":20987},{"tag":1346,"offset":21126},{"tag":1347,"offset":21742},{"tag":1348,"offset":24950},{"tag":1349,"offset":30931}]},"VMDocument":{"path":"F:/p/bce/Duchess/public/js/VMDocument.js","data":"define(['ko', 'globals', 'platform', 'data', 'goog', 'tracker'],\nfunction (ko, g, platform, d, goog, tracker) {\nfunction VMDocument(p)\n{\n    this.file = p;\n    this.id = p && p.id;\n    this.title = ko.observable(p && p.title || '');\n    this.shared = p && p.shared;\n    this.isOpen = undefined;\n    //this.isEditable = ko.observable(false);\n    this.isOwned = ko.observable(false);\n\n    this.init();\n}\n\nVMDocument.prototype =\n{\n    init: function()\n    {\n        if(!this.file)\n        {\n            return;\n        }\n\n        if (this.file.userPermission.id === 'me' && this.file.userPermission.role === 'owner')\n        {\n            this.isOwned(true);\n        }\n    },\n    onTapMenu: function()\n    {\n        this.openSharing();\n\n        g.sendEvent('Menu', 'OpenSharing');\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.OpenDocSharing,\n            data: [\n            {\n                value: true\n            }]\n        });\n    },\n    openSharing: function(callback)\n    {\n        g.menus.openModal('shareDoc', this, callback);\n    },\n    closeMenu: function()\n    {\n        g.menus.closeContextMenu(g.element('contextMenuDocument'));\n    },\n    onTapContextMenu: function(e)\n    {\n        var id = e.srcElement.id;\n        if (!id)\n        {\n            id = e.srcElement.parentNode.id;\n        }\n        switch (id)\n        {\n            case 'documentDelete':\n\n                break;\n            case 'documentShare':\n\n                break;\n        }\n        this.closeMenu();\n    },\n};\n\nreturn VMDocument;\n});\n","asserts":[]},"VMSettings":{"path":"F:/p/bce/Duchess/public/js/VMSettings.js","data":"define(['ko', 'data', 'globals', 'util', 'goog', 'platform', 'tracker', 'VMPicker'],\nfunction (ko, d, g, util, goog, platform, tracker, VMPicker) {\nfunction VMSettings(vmMain)\n{\n    // this.calendarsImport = ko.observableArray();\n    // this.calendarsExport = ko.observableArray();\n\n    //this.enabledExport = ko.observable('');\n    this.enabledSyncContacts = ko.observable(false);\n    this.enabledSounds = ko.observable(false);\n    this.enabledNotifications = ko.observable(false);\n    this.enabledMobileUI = ko.observable(false);\n\n    this.syncContactsEnabledOnOpen = ko.observable(false);\n\n    this.refreshingContacts = false;\n    this.refreshContactsSuccess = ko.observable(undefined);\n\n    this.init();\n}\n\nVMSettings.prototype = {\n    init: function()\n    {\n        g.menus.registerModal('settings', this, this.open.bind(this), this.close.bind(this));\n\n        this.loadSettings();\n\n        if (platform.mobile)\n        {\n            var saveFn = this.save.bind(this);\n\n            this.enabledSyncContacts.subscribe(saveFn);\n            this.enabledSounds.subscribe(saveFn);\n            this.enabledNotifications.subscribe(saveFn);\n            this.enabledMobileUI.subscribe(saveFn);\n        }\n\n        if (platform.isTouchDevice && !platform.app)\n        {\n            var paneSettings = document.getElementById('paneSettings');\n\n            if (paneSettings)\n            {\n                paneSettings.addEventListener(platform.touchStartEvent, function (e)\n                {\n                    if (!g.preventScrollPropagation(paneSettings))\n                    {\n                        if (e.srcElement.id == 'paneSettings')\n                        {\n                            e.preventDefault();\n\n                            return false;\n                        }\n                    }\n                });\n            }\n        }\n\n        if (platform.mobile)\n        {\n            g.ScreenManager.addScreen(this, Screens.Settings);\n        }\n\n        window.addEventListener('settingsChange_' + Settings.syncContacts, this.onSyncContactsChange.bind(this));\n    },\n    isLocal: function()\n    {\n        return window.location.hostname === 'localhost';\n    },\n    showMobileUIOptionOnDesktop: function()\n    {\n        try\n        {\n            return !!util.storage.getItem('forceFullUI');\n        }\n        catch (err)\n        {\n            return false;\n        }\n    },\n    showMobileUIOptionOnMobile: function()\n    {\n        return parseInt(window.innerWidth) > 767;\n    },\n    onEnableNotificationsChange: function()\n    {\n        // g.settings.set(Settings.disableNotifications, !this.enabledNotifications());\n\n        if (!this.enabledNotifications())\n        {\n            g.timeline.clearNotifications();\n        }\n        else\n        {\n            g.timeline.updateNotifications();\n        }\n    },\n    onSyncContactsChange: function(e)\n    {\n        this.enabledSyncContacts(e.data);\n    },\n    getTopElement: function()\n    {\n        return document.getElementById('paneSettings');\n    },\n    // createNew: function(array, id, summary, checked)\n    // {\n    //     var item = {id: id, summary: ko.observable(summary), checked: ko.observable(checked)};\n\n    //     if (array == this.calendarsExport) // Push \"Don't Export\" to the end\n    //     {\n    //         this.calendarsExport.splice(array().length-1, 0, item);\n    //     }\n    //     else\n    //     {\n    //         array.push(item);\n    //     }\n\n    //     return item;\n    // },\n    // addIfDoesntExist: function(array, id, summary)\n    // {\n    //     var match = ko.utils.arrayFirst(array(), function(item) {\n    //         return id === item.id;\n    //     });\n    //     if(!match)\n    //         match = this.createNew(array, id, summary, false);\n    //     else\n    //         match.summary(summary);\n\n    //     return match;\n    // },\n    // onClickExport: function ()\n    // {\n    //     goog.runAuthenticate([GScope.Calendar], /*runImmediate*/false, /*retry*/false);\n\n    //     return true;\n    // },\n    // function loadCalendars()\n    // {\n    //     // TODO: Do something smarter if offline\n    //     goog.updateCalendarList(function (calendars)\n    //     {\n    //         for (var calID in calendars)\n    //         {\n    //             var calendar = calendars[calID];\n    //             this.addIfDoesntExist(this.calendarsImport, calID, calendar.summary);\n    //             this.addIfDoesntExist(this.calendarsExport, calID, calendar.summary);\n    //         }\n    //     });\n    // }\n    open: function()\n    {\n        if (this.isClosing)\n        {\n            return;\n        }\n\n        //this.checkedSyncGoogle(this.checkedSyncGoogle());\n\n        this.refreshContactsSuccess(undefined);\n\n        this.loadSettings();\n\n        this.syncContactsEnabledOnOpen(this.enabledSyncContacts());\n\n        //loadCalendars();\n    },\n    close: function(save)\n    {\n        if (save)\n        {\n            this.save();\n        }\n        else\n        {\n            //var checkSync = g.settings.get(Settings.syncGoogle);\n            var checkSyncContacts = !!g.settings.get(Settings.syncContacts);\n\n            this.enabledSyncContacts(checkSyncContacts);\n            this.enabledSounds(!g.settings.get(Settings.noSounds));\n        }\n    },\n    onScreenStartOpen: function()\n    {\n        this.loadSettings();\n    },\n    enableSyncContacts: function()\n    {\n        g.sendEvent('Settings', 'EnableContacts');\n\n        function handleContactsLoaded(numContacts)\n        {\n            if (numContacts < 0)\n            {\n                g.messageQueue.pushMessage({\n                    text: 'There was an error syncing your contacts, please try again using the \"Refresh Contacts\" button in settings.',\n                    type: MessageType.Error\n                });\n            }\n            else if (numContacts > 0)\n            {\n                g.messageQueue.pushMessage({\n                    text: 'Your contacts were successfully syncd with Moo.do.',\n                    type: MessageType.Info\n                });\n\n                g.vmMain.runParseWorker();\n            }\n        }\n\n        goog.runAuthenticate([GScope.Contacts], /*runImmediate*/false, /*retry*/false, function (token)\n        {\n            if (token && !token.error)\n            {\n                goog.loadContacts(handleContactsLoaded);\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.SyncContacts,\n                    data: [\n                    {\n                        value: true\n                    }]\n                });\n            }\n            else\n            {\n                this.enabledSyncContacts(!this.enabledSyncContacts());\n\n                g.settings.set(Settings.syncContacts, this.enabledSyncContacts());\n\n                g.messageQueue.pushMessage({\n                    text: 'If you would like to sync your contacts we need permission to access them, please try again.',\n                    type: MessageType.Error,\n                    timeout: 10000\n                });\n            }\n        }.bind(this));\n    },\n    loadSettings: function()\n    {\n        this.enabledSyncContacts(!!g.settings.get(Settings.syncContacts));\n        this.enabledSounds(!g.settings.get(Settings.noSounds));\n        this.enabledNotifications(!g.settings.get(Settings.disableNotifications));\n        try { this.enabledMobileUI(!util.storage.getItem('forceFullUI')); } catch (err) { this.enabledMobileUI(false); }\n\n        if (DEBUG) { log('Settings Loaded: ' + this.enabledSyncContacts(), this.enabledSounds(), this.enabledNotifications(), this.enabledMobileUI()); }\n    },\n    save: function()\n    {\n        var changedContacts = this.enabledSyncContacts() !== !!g.settings.get(Settings.syncContacts);\n        var changedSounds = this.enabledSounds() !== !g.settings.get(Settings.noSounds);\n        var changedNotifications = this.enabledNotifications() !== !g.settings.get(Settings.disableNotifications);\n\n        var changedMobileUI;\n        try { changedMobileUI = this.enabledMobileUI() !== !util.storage.getItem('forceFullUI'); } catch (err) { changedMobileUI = false; }\n\n        if (changedContacts)\n        {\n            g.settings.set(Settings.syncContacts, this.enabledSyncContacts());\n\n            if (!this.enabledSyncContacts())\n            {\n                g.sendEvent('Settings', 'DisableContacts');\n\n                goog.loadedContacts = false;\n\n                d.clearContacts();\n            }\n            else\n            {\n                this.enableSyncContacts();\n            }\n        }\n\n        if (changedSounds)\n        {\n            g.settings.set(Settings.noSounds, !this.enabledSounds());\n        }\n\n        if (changedNotifications)\n        {\n            g.settings.set(Settings.disableNotifications, !this.enabledNotifications());\n        }\n\n        if (changedMobileUI && g.shouldWriteLocal())\n        {\n            if (this.enabledMobileUI())\n            {\n                util.storage.removeItem('forceFullUI')\n            }\n            else\n            {\n                util.storage.setItem('forceFullUI', true);\n            }\n        }\n\n        // Old calendar code\n        // setTimeout((function() // Don't delay before closing\n        // {\n        //     var calendarsImport = [];\n\n        //     for (var i = 0; i < this.calendarsImport().length; i ++)\n        //     {\n        //         if(this.calendarsImport()[i].checked())\n        //         {\n        //             calendarsImport.push(this.calendarsImport()[i].id);\n        //         }\n        //     }\n\n        //     //var checkfoync = g.settings.get(Settings.syncGoogle);\n        //     var checkSyncContacts = g.settings.get(Settings.syncContacts);// && checkSync;\n\n        //     // g.settings.set(Settings.syncGoogle, this.checkedSyncGoogle());\n\n        //     //g.settings.set(Settings.calendarsImport, calendarsImport);\n        //     //g.settings.set(Settings.calendarExport, this.checkedExport());\n\n        //     log('Sync Contacts: ' + this.checkedSyncContacts());\n\n        //     // If the only import calendar is the same as the export calendar, don't sync\n        //     // if (!(calendarsImport.length == 1 && calendarsImport[0] == this.checkedExport()))\n        //     // {\n        //     //     goog.syncCalendarEvents(/*skipExport*/true);\n        //     // }\n\n        //     //goog.exportCalendarEvents();\n        // }).bind(this), 0);\n    },\n    isDemo: function()\n    {\n        return g.isDemoMode();\n    },\n    onTapSave: function(e)\n    {\n        g.menus.closeModal('settings', true);\n    },\n    onTapCancel: function(e)\n    {\n        g.menus.closeModal('settings', false);\n    },\n    onScreenOpen: function()\n    {\n        if (g.isKeyboardOpen)\n        {\n            g.blurActiveElement();\n        }\n    },\n    onScreenClose: function()\n    {\n        this.save();\n    },\n    onTapLogout: function(e)\n    {\n        g.vmSetup.logoutClicked();\n\n        g.sendEvent('Menu', 'Logout');\n\n        e.preventDefault();\n    },\n    onTapRunPicker: function (e)\n    {\n        //VMPicker.init();\n        //g.vmMain.hideMenu();\n    },\n    onTapFeedback: function (e)\n    {\n        g.menus.openModal('reportBug');\n\n        g.sendEvent('Menu', 'GiveFeedback');\n\n        e.preventDefault();\n    },\n    onTapLeaveDemo: function(e)\n    {\n        util.removeURLParam('demo');\n    },\n    // introductionText: function()\n    // {\n    //     return g.isDemoMode() ? 'Leave Introduction' : 'Introduction';\n    // },\n    onTapRestartClient: function(e)\n    {\n        g.reload();\n        e.preventDefault();\n    },\n    // onTapReset: function(e)\n    // {\n    //     var r = confirm(\"This will erase all of your data. Are you sure you want to do that?\");\n\n    //     if (r === true)\n    //     {\n    //         var docID = goog.getDocId();\n\n    //         d.clearData(function ()\n    //         {\n    //             goog.reset(docID, function()\n    //             {\n    //                 g.reload();\n    //             });\n    //         });\n\n    //         g.sendEvent('Menu', 'Reset');\n    //     }\n    // },\n    onTapPromptResetClient: function(e)\n    {\n        g.messageQueue.pushMessage(MessageID.CacheReset);\n        e.preventDefault();\n    },\n    onTapResetClient: function(e)\n    {\n        d.clearData(function ()\n        {\n            g.reload();\n        });\n\n        g.sendEvent('Menu', 'ResetClient');\n    },\n    onForceReloadDoc: function(e)\n    {\n        var skipSettings = [ Settings.docSharing, Settings.authScopes, Settings.shownTutorial, Settings.gdocId, Settings.gdocTitle ];\n\n        d.clearData(function ()\n        {\n            g.reload();\n        }, skipSettings);\n\n        g.sendEvent('Menu', 'ReloadDoc');\n    },\n    onTapSettings: function(e)\n    {\n        g.menus.openModal('settings');\n\n        // TODO: Can this be removed, we should never be able to click a button with the fullscreen click handler open.\n        g.vmMain.cancelFullscreenClick();\n\n        g.sendEvent('Menu', 'Settings');\n    },\n    onTapHelp: function(e)\n    {\n        g.vmMain.showHelp(HelpMode.Normal);\n\n        g.sendEvent('Menu', 'HelpSidebar');\n    },\n    onlineStatusToggle: function ()\n    {\n        platform.offline ? util.removeURLParam('offline') : util.insertURLParam('offline', 'true');\n    },\n    logoutButtonText: function()\n    {\n        return g.vmSetup.logoutButtonText();\n    },\n    isLoggedIn: function()\n    {\n        return (g.vmSetup.loginState() == LoginState.LOGGED_IN);\n    },\n    showAppDebugInfo: function()\n    {\n        return platform.debugApp;\n    },\n    getHostName: function()\n    {\n        return 'Host: ' + window.location.host;\n    },\n    getAppDebugText: function()\n    {\n        return 'LowMem: ' + (g.hasSentLowMemoryWarning() ? 'TRUE' : 'FALSE');\n    },\n    onTapRefreshContacts: function()\n    {\n        if (!this.refreshingContacts)\n        {\n            this.refreshingContacts = true;\n            this.refreshContactsSuccess(undefined);\n\n            d.clearLocalContacts();\n\n            goog.loadedContacts = false;\n            goog.authAndLoadContacts(function (success)\n            {\n                this.refreshContactsSuccess(success);\n\n                setTimeout(function ()\n                {\n                    this.refreshingContacts = false;\n                }.bind(this), 1000);\n            }.bind(this));\n\n            g.sendEvent('Menu', 'RefreshContacts');\n        }\n    },\n    contactsRefreshSuccessTest: function()\n    {\n        if (this.refreshContactsSuccess() === undefined)\n        {\n            return '';\n        }\n        else if (this.refreshContactsSuccess() === true)\n        {\n            return 'Success!';\n        }\n        else if (this.refreshContactsSuccess() === false)\n        {\n            return 'Failure!';\n        }\n    },\n    onTapImport: function(e)\n    {\n        g.menus.openModal('importData');\n\n        g.sendEvent('Menu', 'ImportData');\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.OpenImport,\n            data: [\n            {\n                value: true\n            }]\n        });\n    },\n    onTapExport: function(e)\n    {\n        g.menus.openModal('exportData');\n\n        g.sendEvent('Menu', 'ExportData');\n\n        tracker.miscAction({\n            type: TrackerType.Misc,\n            misc: TrackerMisc.OpenExport,\n            data: [\n            {\n                value: true\n            }]\n        });\n    },\n};\n\nreturn VMSettings;\n});\n","asserts":[]},"VMPicker":{"path":"F:/p/bce/Duchess/public/js/VMPicker.js","data":"define(['ko', 'globals', 'util', 'platform', 'data', 'goog', 'VMDocument', 'VMDocSharing', 'tracker'],\nfunction (ko, g, util, platform, d, goog, VMDocument, VMDocSharing, tracker) {\nfunction VMPicker()\n{\n    this.files = ko.observableArray();\n    this.permissions = ko.observableArray();\n    this.isPublic = ko.observable();\n    this.fileMap = { };\n    this.isLoading = ko.observable(false);\n    this.needPermission = ko.observable(false);//ko.observable(!goog.hasPermission(GScope.DriveFull));\n    this.showError = ko.observable(false);\n\n    this.loadCallbacks = [ ];\n\n    this.init();\n}\n\nVMPicker.prototype =\n{\n    init: function()\n    {\n        var docShare = new VMDocSharing();\n\n        g.menus.registerModal('shareDoc', docShare, docShare.open.bind(docShare), docShare.onClose.bind(docShare));\n    },\n    refreshFiles: function ()\n    {\n        if (DEBUG)\n        {\n            this.setFiles(g.test.files, 0);\n\n            this.isLoading(false);\n            //this.needPermission(false);\n        }\n        else\n        {\n            this.runOnFileLoad(this.markFileProperties.bind(this));\n\n            gapi.client.load('drive', 'v2', function ()\n            {\n                this.loadFileList();\n            }.bind(this));\n\n            //this.needPermission(!goog.hasPermission(GScope.DriveFull));\n        }\n    },\n    // If files == undefined, just populate observables\n    setFiles: function(files, selectedIndex)\n    {\n        this.files.removeAll();\n\n        for (var i = 0; i < files.length; i ++)\n        {\n            var file = files[i];\n            var vmDoc = new VMDocument(file);\n\n            vmDoc.isOpen = (i === selectedIndex);\n\n            this.files.push(vmDoc);\n        }\n        this.setMinHeight();\n    },\n    loadFileList: function (cb)\n    {\n        if (!this.isLoading())\n        {\n            this.isLoading(true);\n            this.showError(false);\n\n            gapi.client.load('drive', 'v2', function ()\n            {\n                gapi.client.drive.files.list(\n                {\n                    // TODO: Specify required fields\n                    'fields': 'items(appDataContents,createdDate,description,editable,etag,exportLinks,iconLink,id,indexableText,kind,labels,md5Checksum,mimeType,ownerNames,owners,parents,permissions,properties,quotaBytesUsed,shared,sharedWithMeDate,sharingUser,title,userPermission,version,writersCanShare),kind,nextLink,nextPageToken',\n                    'q': \"trashed=false and mimeType='\" + goog.REALTIME_MIMETYPE + '.' + goog.APP_ID + \"'\"\n                }).execute(function (results)\n                {\n                    // if (DEBUG)\n                    // {\n                    //     log('Picker Results: ', results);\n                    // }\n\n                    if (!results.items || results.error)\n                    {\n                        this.showError('Load Documents');\n                    }\n                    else\n                    {\n                        var selectIndex = 0;\n                        var currentId = goog.getDocId();\n\n                        for (var i = 0; i < results.items.length; ++i)\n                        {\n                            var item = results.items[i];\n\n                            this.fileMap[item.id] = item;\n\n                            if (currentId === item.id)\n                            {\n                                selectIndex = i;\n                            }\n                        }\n\n                        this.setFiles(results.items, selectIndex);\n                    }\n\n                    this.isLoading(false);\n\n                    if (cb)\n                    {\n                        cb(results);\n                    }\n\n                    this.onFilesLoaded(results);\n                }.bind(this));\n            }.bind(this));\n        }\n        else\n        {\n            if (DEBUG) log('Skipping file load due to already loading');\n        }\n    },\n    markFileProperties: function(res)\n    {\n        if (res && res.items)\n        {\n            for (var i = 0; i < res.items.length; ++i)\n            {\n                var fileInfo = res.items[i];\n\n                // Check if the previous default file has been marked.\n                if (!fileInfo.properties && fileInfo.title === goog.LEGACY_DefaultDriveDocTitle)\n                {\n                    // Ensure the current user is the owner of their default file\n                    if (fileInfo.userPermission.id === 'me' && fileInfo.userPermission.role === 'owner')\n                    {\n                        gapi.client.drive.properties.insert({\n                            'fileId': fileInfo.id,\n                            'resource':\n                            {\n                                'key': goog.DefaultProperty,\n                                'value': goog.DefaultPropertyValue,\n                                'visibility': 'PRIVATE'\n                            }\n                        }).execute(function (result)\n                        {\n                            if (result.error || result.kind !== 'drive#property')\n                            {\n                                // Ignore, if this fails we will update again later.\n                                if (ShouldLog(LogLevels.Error)) log('Error adding default file property: ', result);\n\n                                debugger;\n                            }\n                        });\n\n                        break;\n                    }\n                }\n            }\n        }\n    },\n    onFilesLoaded: function(res)\n    {\n        if (this.loadCallbacks.length > 0)\n        {\n            for (var i = 0; i < this.loadCallbacks.length; ++i)\n            {\n                if (this.loadCallbacks[i])\n                {\n                    this.loadCallbacks[i](res);\n                }\n            }\n\n            this.loadCallbacks = [ ];\n        }\n    },\n    runOnFileLoad: function(cb)\n    {\n        this.loadCallbacks.push(cb);\n    },\n    requestOpenDocument: function(id)\n    {\n        var doc = this.getFile(id);\n\n        if (doc)\n        {\n            this.openDocument(doc);\n        }\n        else\n        {\n            if (this.needPermission())\n            {\n                this.doRequestPermission(function ()\n                {\n                    this.openDocumentFromId(id);\n                }.bind(this));\n            }\n            else\n            {\n                this.onFilesLoaded(function ()\n                {\n                    this.openDocumentFromId(id);\n                }.bind(this));\n            }\n        }\n    },\n    openDocumentFromId: function(id, title)\n    {\n        var currentDoc = goog.getDocId();\n\n        if (currentDoc !== id)\n        {\n            var skipSettings = [ Settings.docSharing, Settings.authScopes, Settings.shownTutorial, Settings.lastMessageSync ];\n\n            d.clearData(function ()\n            {\n                goog.setDocInfo(id, title);\n\n                if (util.hasURLParam('file'))\n                {\n                    util.removeURLParam('file', /*noReload*/true);\n                }\n                else if (util.hasURLParam('state'))\n                {\n                    util.removeURLParam('state', /*noReload*/true);\n                }\n\n                // TODO: Remove timeout?\n                setTimeout(function ()\n                {\n                    g.reload();\n                }, 500);\n            }, skipSettings);\n        }\n        else\n        {\n            if (DEBUG) log('Currently open file selected to reopen.', currentDoc);\n        }\n    },\n    openDocument: function(doc)\n    {\n        g.localDocChangeRequested = true;\n\n        this.openDocumentFromId(doc.id, doc.title);\n    },\n    doRequestPermission: function(cb)\n    {\n        // goog.runAuthenticate([GScope.DriveFull], /*runImmediate*/false, /*retry*/false, function (token)\n        // {\n        //     this.needPermission(!goog.hasPermission(GScope.DriveFull));\n\n        //     if (token && !token.error)\n        //     {\n        //         g.settings.set(Settings.docSharing, true);\n\n        //         this.loadFileList(cb);\n        //     }\n        //     else\n        //     {\n        //         // TODO: Error Handling\n        //     }\n        // }.bind(this));\n    },\n    onRequestPermission: function(e)\n    {\n        this.doRequestPermission();\n    },\n    onTapReloadDocuments: function(e)\n    {\n        this.loadFileList();\n    },\n    // onTapDocument: function(doc)\n    // {\n    //     this.openDocument(doc);\n    // },\n    onTapDocument: {\n        onClick: function(e)\n        {\n            var doc = ko.dataFor(e.srcElement);\n\n            if (g.hasClass(e.srcElement, 'documentTitle'))\n            {\n                this.openDocument(doc);\n\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.OpenDocument,\n                    data: [\n                    {\n                        value: true\n                    }]\n                });\n            }\n            else\n            {\n                if (doc instanceof VMDocument)\n                {\n                    doc.onTapMenu();\n\n                    e.stopImmediatePropagation();\n                }\n                else\n                {\n                    g.reportError('Incorrect document type: ' + g.elementToString(e.srcElement));\n                }\n            }\n        }\n    },\n    onTapAdd: {\n        onStart: g.handlerPreventStop,\n        onClick: function()\n        {\n            if (g.vmMain && g.vmMain.isOnline())\n            {\n                var doc = new VMDocument();\n\n                doc.isOwned(true);\n\n                this.files.push(doc);\n                this.setMinHeight();\n\n                g.sendEvent('Menu', 'AddDocument');\n\n                doc.openSharing(function(saved)\n                {\n                    if(!saved)\n                    {\n                        this.files.remove(doc);\n                        this.setMinHeight();\n                    }\n                }.bind(this));\n\n                tracker.miscAction({\n                    type: TrackerType.Misc,\n                    misc: TrackerMisc.AddDocument,\n                    data: [\n                    {\n                        value: true\n                    }]\n                });\n            }\n            else\n            {\n                g.messageQueue.pushMessage({\n                    text: 'You must be online to create a new document',\n                    type: MessageType.Warning,\n                    timeout: 8000\n                });\n            }\n        }\n    },\n    getFile: function(id)\n    {\n        return this.fileMap[id];\n    },\n    removeFile: function(doc)\n    {\n        this.files.remove(doc);\n        this.setMinHeight();\n\n        if (doc.isOpen)\n        {\n            d.clearData(function ()\n            {\n                setTimeout(function ()\n                {\n                    g.reload();\n                }, 0);\n            });\n        }\n    },\n    setMinHeight: function()\n    {\n        if(platform.mobile)\n            return;\n        var documentsList = document.getElementById('documentsList');\n        if(!documentsList)\n        {\n            setTimeout(this.setMinHeight.bind(this), 0);\n            return;\n        }\n        //log('o', documentsList.clientHeight);\n        var height = documentsList.clientHeight;\n        g.element('sidebarDocumentContainer').style.minHeight = (height + 50) + 'px';\n    }\n};\n\nreturn VMPicker;\n});","asserts":[]},"VMDocSharing":{"path":"F:/p/bce/Duchess/public/js/VMDocSharing.js","data":"define(['ko', 'globals', 'platform', 'data', 'goog'],\nfunction (ko, g, platform, d, goog) {\n\nfunction VMDocSharing()\n{\n    this.doc = ko.observable({ isOwned: function () { return false }});\n    this.isLoading = ko.observable(false);\n    this.isCreating = ko.observable(false);\n    this.permissions = ko.observableArray();\n    this.permissionsNew = ko.observableArray();\n    this.permissionsRemove = [ ];\n    this.newEmail = ko.observable('');\n    this.errorGlobal = ko.observable(false);\n    this.errorName = ko.observable(false);\n    this.errorInvite = ko.observable(false);\n    this.isSaving = ko.observable(false);\n    this.editing = ko.observable('');\n    this.closeCallback = undefined;\n    this.justCreated = false;\n}\n\nVMDocSharing.prototype =\n{\n    open: function(doc, callback)\n    {\n        this.doc(doc);\n        this.closeCallback = callback;\n\n        this.permissions.removeAll();\n        this.permissionsNew.removeAll();\n        this.permissionsRemove = [ ];\n        this.newEmail('');\n        this.editing('');\n        this.isLoading(true);\n        this.errorGlobal(false);\n        this.errorName(false);\n        this.errorInvite(false);\n        this.isSaving(false);\n        this.isCreating(!this.doc().file);\n        this.justCreated = false;\n        this.inputName = document.getElementById('shareNameInput');\n        this.inputName.value = this.doc().title();\n\n        this.shareLink = document.getElementById('shareLinkInput');\n        if (this.shareLink)\n        {\n            this.shareLink.value = 'moo.do/#file=' + this.doc().id;\n        }\n\n        if (!platform.mobile)\n        {\n            setTimeout(function()\n            {\n                this.inputName.focus();\n            }.bind(this), 0);\n        }\n\n        if (!this.isCreating())\n        {\n            if(DEBUG)\n            {\n                this.permissionHandler(g.test.permissions);\n            }\n            else\n            {\n                gapi.client.drive.permissions.list({\n                    'fileId': this.doc().id\n                }).execute(this.permissionHandler.bind(this));\n            }\n        }\n        else\n        {\n            this.isLoading(false);\n        }\n    },\n    permissionHandler: function(response)\n    {\n        if (!response.error)\n        {\n            this.isLoading(false);\n\n            var permissions = [ ];\n            for (var i = 0; i < response.items.length; ++i)\n            {\n                var item = response.items[i];\n                if (item.emailAddress === g.getUserIdentifier())\n                {\n                    // Don't add self\n                    continue;\n                }\n\n                item.onRemove = this.onRemove.bind(this, item);\n\n                if (item.id != 'anyone')\n                {\n                    if (!item.emailAddress)\n                    {\n                        if (item.role === 'owner')\n                        {\n                            item.emailAddress = 'Owner';\n                        }\n                        else\n                        {\n                            item.emailAddress = '';\n                        }\n                    }\n\n                    if (item.role === 'owner')\n                    {\n                        permissions.splice(0, 0, item);\n                    }\n                    else\n                    {\n                        permissions.push(item);\n                    }\n                }\n                item.emailDisplay = '(' + item.emailAddress + ')';\n            }\n\n            this.permissions(permissions);\n        }\n    },\n    isOwned: function()\n    {\n        return this.doc().isOwned && this.doc().isOwned();\n    },\n    saveText: function()\n    {\n        if (!this.isCreating())\n        {\n            if(platform.mobile && this.editing())\n            {\n                return 'Close';\n            }\n            else if(this.newEmail().length > 0)\n            {\n                return 'Invite';\n            }\n            else if(this.isSaving())\n            {\n                return 'Saving...';\n            }\n            else\n            {\n                return 'Save';\n            }\n        }\n        else\n        {\n            if(this.isSaving())\n            {\n                return 'Creating...';\n            }\n            else\n            {\n                return 'Create';\n            }\n        }\n    },\n    titleText: function()\n    {\n        return (platform.mobile && this.editing()) ? this.editing() : (this.isCreating() ? 'Create Document' : 'Edit Document');\n    },\n    onkeydown: function(data, e)\n    {\n        platform.normalizeKeys(e);\n\n        if (e.normCode == KeyCode.Escape)\n        {\n            this.newEmail('');\n\n            e.preventDefault();\n            e.stopImmediatePropagation();\n\n            return false;\n        }\n        else if (e.normCode == KeyCode.Enter)\n        {\n            this.inviteUser();\n\n            g.scrollIntoView(g.element('inputShareInvite'), 0);\n\n            e.preventDefault();\n            e.stopImmediatePropagation(); // Don't let it go up to the global event handler\n\n            return false;\n        }\n\n        return true;\n    },\n    onKeyboardOpened: function(e)\n    {\n        this.editing(e.srcElement.title);\n    },\n    inviteUser: function()\n    {\n        if (this.newEmail().length === 0)\n        {\n            this.errorInvite('');\n            return;\n        }\n\n        if(!g.isEmail(this.newEmail()))\n        {\n            this.errorInvite('Please enter a valid email address.');\n            return false;\n        }\n\n        var user = { emailAddress: this.newEmail(), error: ko.observable(false) };\n        var contact = d.findContactByEmail(user.emailAddress.toLowerCase());\n\n        if (contact)\n        {\n            user.name = contact.text;\n        }\n        else\n        {\n            user.name = user.emailAddress;\n        }\n\n        user.onRemove = this.onRemoveNew.bind(this, user);\n        this.permissionsNew.push(user);\n        this.newEmail('');\n        this.errorInvite(false);\n\n        return true;\n    },\n    checkName: function()\n    {\n        var title = this.inputName.value.trim();\n\n        if (title.length > 0 && title.length < 255)\n        {\n            this.errorName(false);\n\n            return true;\n        }\n\n        this.errorName('Error: Document name must be >0 and <255 characters.');\n\n        return false;\n    },\n    rename: function()\n    {\n        var title = this.inputName.value.trim();\n\n        if (title != this.doc().title())\n        {\n            this.doc().title(title);\n\n            gapi.client.drive.files.patch({\n                'fileId': this.doc().id,\n                'resource':\n                {\n                    'title': title\n                }\n            }).execute(function (response)\n            {\n                if (!response.error)\n                {\n                    log('File renamed to', title);\n                }\n                else\n                {\n                    this.errorName('Error: Unable to update name on remote server.');\n                }\n            }.bind(this));\n\n        }\n    },\n    create: function(callback)\n    {\n        this.justCreated = true;\n        this.isSaving(true);\n\n        var title = this.inputName.value.trim();\n        this.tooltip = title;\n\n        this.isSaving(true);\n\n        gapi.client.drive.files.insert({\n            'resource':\n            {\n                'mimeType': goog.REALTIME_MIMETYPE,\n                'title': title,\n                'writersCanShare': false\n            }\n        }).execute(function (response)\n        {\n            if (!response.error)\n            {\n                this.doc().id = response.id;\n                this.doc().file = response;\n\n                this.isCreating(!this.doc().file);\n                this.isSaving(false);\n\n                if(callback)\n                {\n                    callback();\n                }\n            }\n            else\n            {\n                this.errorGlobal('Error: Unable to create new document.');\n            }\n        }.bind(this));\n    },\n    save: function()\n    {\n        if(this.isSaving() && !this.justCreated)\n            return;\n\n        if(this.editing())\n        {\n            g.blurActiveElement();\n            this.editing('');\n            return;\n        }\n\n        if (!goog.isDriveAPILoaded())\n        {\n            this.errorGlobal('Error communicating with Google Drive. Please reconnect and try again.');\n            return;\n        }\n\n        //\n        // Check inputs\n        //\n\n        if (!this.checkName())\n        {\n            // If the doucment name is not valid, display error.\n            return;\n        }\n\n        if (this.isCreating())\n        {\n            this.create(this.save.bind(this));\n            return;\n        }\n\n        if (this.newEmail().length > 0)\n        {\n            if (!this.inviteUser())\n            {\n                // If the users being invited are not valid, display error.\n                return;\n            }\n        }\n        else\n        {\n            this.errorInvite(false);\n        }\n\n        // Assume inputs are valid after here\n\n        this.rename();\n\n        var count = 0;\n        function handleResponse(index, response)\n        {\n            if (DEBUG) log('Permission Response: ', response);\n\n            if (response.error)\n            {\n                console.error('UH OH', response);\n                this.permissionsNew()[i].error(true);\n                this.errorInvite('Some people could not be invited.');\n                this.isSaving(false);\n            }\n            else\n            {\n                count --;\n                if (count <= 0)\n                {\n                    g.menus.closeModal('shareDoc', false);\n                }\n            }\n        }\n\n        for (var i = 0; i < this.permissionsNew().length; i ++)\n        {\n            var newPermission = this.permissionsNew()[i];\n            if(newPermission.error())\n                continue;\n\n            count ++;\n\n            if (DEBUG) log('Adding Writer Permission: ', newPermission);\n\n            var body =\n            {\n                'value': newPermission.emailAddress,\n                'type': 'user',\n                'role': 'writer',\n                'withLink': false\n            };\n\n            var message = 'Come collaborate with me at Moo.do!\\r\\nhttp://www.moo.do/#login=true&file=' + this.doc().id;\n\n            gapi.client.drive.permissions.insert({\n                'fileId': this.doc().id,\n                'emailMessage': message,\n                'resource': body\n            }).execute(handleResponse.bind(this, i));\n        }\n\n        for (var i = 0; i < this.permissionsRemove.length; i ++)\n        {\n            var permission = this.permissionsRemove[i];\n\n            gapi.client.drive.permissions.delete(\n            {\n                'fileId': this.doc().id,\n                'permissionId': permission.id\n            }).execute(function (response)\n            {\n                // TODO: Error Handling\n                if (DEBUG) log('Remove Permission Response: ', response);\n            });\n        }\n\n        if (this.errorInvite() || this.errorName())\n        {\n            return;\n        }\n        else if (count === 0)\n        {\n            g.menus.closeModal('shareDoc', true);\n        }\n        else\n        {\n            this.isSaving(true);\n\n            this.onClose(true);\n        }\n    },\n    onClose: function (isSave)\n    {\n        if (this.closeCallback)\n        {\n            this.closeCallback(isSave);\n            this.closeCallback = undefined;\n        }\n    },\n    onTapInviteMessage: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            var el = g.element('inputShareInvite');\n            if(platform.mobile)\n            {\n                g.menus.focusModalInputMobile(e, el);\n            }\n            else\n            {\n                el.focus();\n            }\n        }\n    },\n    onTapSave: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            this.save();\n\n            g.sendEvent('Menu', 'SharingSave');\n        }\n    },\n    onTapCancel: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            g.menus.closeModal('shareDoc', false);\n\n            g.sendEvent('Menu', 'SharingCancel');\n        }\n    },\n    onTapDelete: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            g.sendEvent('Menu', 'SharingDelete');\n\n            // Do this in a timeout because prompt causes a touchstart with no touchend\n            // on hitting cancel. This timeout can be removed when we have a custom confirmation\n            // popup.\n            setTimeout(function()\n            {\n                var result = prompt('This will delete the file. Type DELETE to confirm.');\n                if(result && result.trim().toLowerCase() == 'delete')\n                {\n                    gapi.client.drive.files.delete({\n                        'fileId': this.doc().id\n                    }).execute(function (response)\n                    {\n                        log('Document Delete Response: ', response);\n\n                        if (response.error)\n                        {\n                            g.messageQueue.pushMessage({\n                                text: 'Unable to delete document on the remote server.',\n                                type: MessageType.Error\n                            });\n                        }\n                    }.bind(this));\n\n                    g.vmMain.vmPicker.removeFile(this.doc());\n                    g.menus.closeModal('shareDoc', false);\n                }\n            }.bind(this), 0);\n        }\n    },\n    onRemove: function(user)\n    {\n        //log('remove', user);\n        this.permissionsRemove.push(user);\n        this.permissions.remove(user);\n\n        g.sendEvent('Menu', 'SharingRemoveUser');\n    },\n    onRemoveNew: function(user)\n    {\n        this.permissionsNew.remove(user);\n    }\n};\n\nreturn VMDocSharing;\n});","asserts":[]},"VMPhoneMenu":{"path":"F:/p/bce/Duchess/public/js/VMPhoneMenu.js","data":"define(['ko', 'globals', 'data', 'platform', 'tracker', 'gdata'],\nfunction (ko, g, d, platform, tracker, gdata) {\n\nfunction VMPhoneMenu()\n{\n    g.Assert(platform.mobile, 'Should only initialize on mobile platforms');\n\n    this.searchScale = '';\n    this.searchTranslate = '';\n    this.search = g.vmSearchPhone;\n    this.mode = ko.observable(this.Modes.Normal);\n    this.multiSelected = g.vmMain.selected;\n    this.activeScreen = ko.observable(Screens.List);\n    // this.radialMenuList = undefined;\n\n    this.init();\n}\n\nVMPhoneMenu.prototype = {\n    Modes: {\n        Normal: 0,\n        Multiselect: 1,\n        Contact: 2,\n        Date: 3\n    },\n    init: function()\n    {\n        g.Assert(g.vmSearchPhone, 'Phone search must be initialized at this point');\n\n        g.applyBindings(this, 'phoneMenu');\n\n        // ko.applyBindings(this, g.element('phoneMenuBottom'));\n\n        // g.vmMain.menuState.subscribe(this.onMenuStateChanged, this);\n\n        // this.radialMenuList = new RadialMenu(g.element('phoneMenuList'), {\n        //     radius: 80,\n        //     time: 300,\n        //     closeTime: 100,\n        //     positions: [180, 225, 270]\n        // });\n        // this.radialMenuList.setPosition({left: 10, top: 10});\n        window.appEvents = this.appEvents;\n\n        if(platform.app)\n        {\n            platform.sendToApp('kbsize');\n        }\n\n        this.mode.subscribe(function(newValue)\n        {\n            if(newValue == this.Modes.Multiselect)\n            {\n                g.addClass(g.focusedPane.element, 'multiSelectMode');\n            }\n            else\n            {\n                g.removeClass(g.focusedPane.element, 'multiSelectMode');\n            }\n        }.bind(this));\n\n        window.addEventListener('screenScroll', function ()\n        {\n            this.activeScreen(g.ScreenManager.activeScreen);\n        }.bind(this));\n    },\n    _modeHelper: function(val, mode)\n    {\n        if(val !== undefined)\n        {\n            this.mode(val ? mode : this.Modes.Normal);\n        }\n\n        return this.mode() === mode;\n    },\n    activeScreenClass: function()\n    {\n        var scr = this.activeScreen();\n        var name = '';\n        if(scr == Screens.List)\n        {\n            name = 'listActive';\n        }\n        else if(scr == Screens.Outline)\n        {\n            name = 'outlineActive';\n        }\n        else if(scr == Screens.Settings)\n        {\n            name = 'settingsActive';\n        }\n        if(this.search.isShowing())\n            name += ' searchShowing';\n        if(this.search.isFocused())\n            name += ' searchFocused';\n\n        return name;\n    },\n    normalMode: function(val)\n    {\n        return this._modeHelper(val, this.Modes.Normal);\n    },\n    multiSelectMode: function(val)\n    {\n        return this._modeHelper(val, this.Modes.Multiselect);\n    },\n    contactMode: function(val)\n    {\n        return this._modeHelper(val, this.Modes.Contact);\n    },\n    dateMode: function(val)\n    {\n        return this._modeHelper(val, this.Modes.Date);\n    },\n    isSaved: function()\n    {\n        log('IsSaved DriveStatus: ', g.vmMain.gdriveStatus());\n\n        return platform.offline || g.vmMain.gdriveStatus() === DriveStatus.Saved;\n    },\n    showSearchSeparator: function()\n    {\n        // TODO: Know the difference between keyboard open on search\n        // and on regular text\n        return this.search.showSearchSeparator();\n    },\n    isTimeline: function() {\n        return g.focusedPane.mode() == PaneMode.Timeline;\n    },\n    titleText: function() {\n        var displayItem = g.focusedPane.item();\n        var text = displayItem.getParsedText();\n\n        return text;\n    },\n    isMenuMain: function() {\n        return g.ScreenManager.isScreenOpen(Screens.List);\n    },\n    isMenuContext: function() {\n        return g.ScreenManager.isScreenOpen(Screens.Outline);\n    },\n    isMenuSettings: function() {\n        return g.ScreenManager.isScreenOpen(Screens.Settings);\n    },\n    // onMenuStateChanged: function(newValue) {\n    //     var x;\n    //     if (newValue !== MenuState.Settings)\n    //     {\n    //         x = (newValue !== MenuState.Main) ? -25 : 0;\n\n    //         var isFocused = this.search.isFocused();\n\n    //         // if (this.search.isSearching() || isFocused)\n    //         // {\n    //         //     this.updateSearchDOM();\n\n    //         //     if (isFocused && (this.isMenuMain() || this.isMenuContext()))\n    //         //     {\n    //         //         g.focusedPane.vmSearch.focusAndSelectEnd();\n    //         //     }\n    //         // }\n\n    //         // this.searchTranslate = 'translateX(' + x + 'px)';\n    //         // g.element('searchButton').style[platform.transform.style] = 'translateX(' + x + 'px)';\n\n    //         // this.updateSearchTransform();\n    //     }\n\n    //     if (platform.iphone)\n    //     {\n    //         if (newValue !== MenuState.Main)\n    //         {\n    //             x = (newValue === MenuState.Settings) ? 95 : 0;\n\n    //             // g.element('phoneSettingsButton').style[platform.transform.style] = 'translateX(' + x + 'px)';\n    //         }\n    //     }\n    // },\n    updateSearchDOM: function() {\n        // var searchEle = document.getElementById('phoneSearchContainer');\n\n        // var targetSearch;\n        // if (this.isMenuMain())\n        // {\n        //     targetSearch = document.getElementById('listHeader');\n        // }\n        // else if (this.isMenuContext())\n        // {\n        //     targetSearch = document.getElementById('outlineHeader');\n        // }\n\n        // if (targetSearch)\n        // {\n        //     if (searchEle.parentNode !== targetSearch)\n        //     {\n        //         searchEle.parentNode.style.zIndex = 'auto';\n        //         // searchEle.parentNode.removeChild(searchEle);\n\n        //         targetSearch.style.zIndex = '10';\n        //         targetSearch.insertBefore(searchEle, null);\n        //     }\n        // }\n    },\n    // onTapMenu: {\n    //     onClick: function(e)\n    //     {\n    //         g.vmSettings.openPhone();\n    //         e.preventDefault();\n    //     }\n    // },\n    // onTapMenuRight: {\n    //     onClick: function(e)\n    //     {\n    //         g.Assert(!g.ScreenManager.isScreenOpen(Screens.List), \"Shouldn't be able to hit right button when not in menu\");\n\n    //         if (g.ScreenManager.isScreenOpen(Screens.Settings))\n    //         {\n    //             g.vmSettings.closePhone();\n    //         }\n    //         else if (g.ScreenManager.isScreenOpen(Screens.Outline))\n    //         {\n    //             g.outline.close();\n    //         }\n\n    //         e.preventDefault();\n    //     }\n    // },\n    // onTapContext: {\n    //     onClick: function(e)\n    //     {\n    //         g.outline.open();\n    //         e.preventDefault();\n    //     }\n    // },\n    onTapMultiSelectCancel: {\n        onClick: function(e)\n        {\n            g.menus.closeMultiSelect();\n            g.handlerPreventStop(e);\n        }\n    },\n    onTapContactCancel: {\n        onClick: function(e)\n        {\n            g.autocomplete.hide();\n            g.handlerPreventStop(e);\n        }\n    },\n    onTapList: {\n        onClick: function(e)\n        {\n            // if(g.ScreenManager.activeScreen == Screens.Outline)\n            // {\n            //     g.ScreenManager.scrollToScreen(Screens.List);\n            // }\n            // else\n            // {\n                g.ScreenManager.scrollToScreen(Screens.List);\n            // }\n\n            g.handlerPreventStop(e);\n\n            g.sendEvent('PhoneMenu', 'CloseOutline');\n        }\n    },\n    onTapOutline: {\n        onClick: function(e)\n        {\n            // if(g.ScreenManager.activeScreen == Screens.Outline)\n            // {\n            //     g.ScreenManager.scrollToScreen(Screens.List);\n            // }\n            // else\n            // {\n                g.ScreenManager.scrollToScreen(Screens.Outline);\n            // }\n\n            g.handlerPreventStop(e);\n\n            g.sendEvent('PhoneMenu', 'OpenOutline');\n        }\n    },\n    onTapSettings: {\n        onClick: function(e)\n        {\n            log('tap settings');\n            if(g.ScreenManager.activeScreen == Screens.Settings)\n            {\n                g.ScreenManager.scrollToScreen(Screens.Outline);\n            }\n            else\n            {\n                g.ScreenManager.scrollToScreen(Screens.Settings);\n            }\n\n            g.handlerPreventStop(e);\n\n            g.sendEvent('PhoneMenu', 'OpenSettings');\n        }\n    },\n    onTapMode: {\n        onClick: function(e)\n        {\n            log('mode', e);\n            this.toggleMode();\n\n            g.handlerPreventStop(e);\n\n            g.sendEvent('PhoneMenu', 'SwitchMode');\n        }\n    },\n    onTapArchive: {\n        onClick: function(e)\n        {\n            g.focusedPane.archiveCompleted();\n\n            g.sendEvent('PhoneMenu', 'ArchiveCompleted');\n\n            g.handlerPreventStop(e);\n        }\n    },\n    onTapHeader: {\n        onStart: function(e)\n        {\n            g.ScreenManager.checkSwipeStart(e);\n        },\n        onMove: function(e)\n        {\n            g.ScreenManager.checkSwipeMove(e);\n        },\n        onEnd: function(e)\n        {\n            g.ScreenManager.checkSwipeEnd(e);\n        }\n    },\n    paneTapped: function()\n    {\n        // if(this.radialMenuList.isOpen())\n        // {\n        //     this.radialMenuList.close();\n        // }\n    },\n    updateSearchTransform: function()\n    {\n        g.element('searchDivPhone').style[platform.transform.style] = this.searchTranslate + ' ' + this.searchScale;\n    },\n    toggleMode: function()\n    {\n        g.blurActiveElement();\n        g.focusedPane.initialOffset = undefined;\n        if(g.focusedPane.mode() == PaneMode.Normal)\n        {\n            g.vmMain.clearSelected();\n            // Switch to timeline\n            g.focusedPane.mode(PaneMode.Timeline);\n        }\n        else\n        {\n            // Switch to normal\n            g.focusedPane.mode(PaneMode.Normal);\n        }\n\n        g.focusedPane.vmSearch.updateSearch(true);\n\n        g.vmMain.updatePaneState(g.focusedPane);\n    },\n    appEvents:\n    {\n        undo: function(e)\n        {\n            log('shake to undo');\n            tracker.undoAction();\n        },\n        redo: function()\n        {\n            log('shake to redo');\n            tracker.redoAction();\n        },\n        kbsize: function(e)\n        {\n            platform.kbsize = e;\n        },\n        enterBackground: function()\n        {\n            g.onunload();\n        },\n        enterForeground: function()\n        {\n            // Re-establish connection with realtime API\n            gdata.poke();\n\n            // Update any remote data that the client could need\n            g.checkForRemoteChanges();\n        },\n        reportLowMemory: function(msg)\n        {\n            g.handleLowMemory(msg);\n        },\n        statusBarTap: function()\n        {\n            var firstItem = g.getFirstPaneItem(g.focusedPane);\n\n            g.scrollToTop(firstItem.getSpan(), 200);\n        }\n    }\n};\n\nreturn VMPhoneMenu;\n});","asserts":[{"tag":1350,"offset":144},{"tag":1351,"offset":679},{"tag":1352,"offset":6180}]},"VMKeyboardToolbar":{"path":"F:/p/bce/Duchess/public/js/VMKeyboardToolbar.js","data":"define(['ko', 'globals', 'data', 'edit', 'platform'],\nfunction (ko, g, d, edit, platform) {\nfunction VMKeyboardToolbar()\n{\n    this.buttons = ko.observableArray();\n    this.priorityVisible = ko.observable();\n    this.isVisible = ko.observable(false);\n    this.element = undefined;\n    this.aboutToShow = undefined;\n    this.bottomPosition = undefined;\n\n    this.init();\n}\n\nVMKeyboardToolbar.prototype = {\n    init: function()\n    {\n        this.element = document.getElementById('mobileKeyboardToolbar');\n\n        g.applyBindings(this, 'mobileKeyboardToolbar');\n\n        window.addEventListener('closeKeyboard', this.hide.bind(this));\n    },\n    onTap: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            var id = e.srcElement.id;\n            if(id == 'mobileKeyboardToolbar')\n            {\n                e.preventDefault();\n                e.returnFalse = true;\n            }\n\n            if(id == 'closeKeyboardButton')\n            {\n                g.blurActiveElement();\n                g.vmMain.clearSelected();\n            }\n            else if(g.vmSearchPhone.isFocused())\n            {\n                var ch;\n                if(id == 'priorityButton')\n                    ch = '!';\n                else if(id == 'dateButton')\n                    ch = '@';\n                else if(id == 'contactButton')\n                    ch = '+';\n                else if(id == 'tagButton')\n                    ch = '#';\n                g.vmSearchPhone.insert(ch);\n            }\n            else\n            {\n                if(id == 'outdentButton')\n                    g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: true});\n                else if(id == 'indentButton')\n                    g.fireKeyEvent(/*ele*/undefined, {normCode: KeyCode.Tab, shiftKey: false});\n                // else if(id == 'headerButton')\n                //     g.vmMain.makeSelectionHeader();\n                else if(id == 'priorityButton')\n                    this.priorityVisible(!this.priorityVisible());\n                else if(id == 'pNoneButton')\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.None, /*toggle*/false);\n                else if(id == 'p0Button')\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P0, /*toggle*/true);\n                else if(id == 'p1Button')\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P1, /*toggle*/true);\n                else if(id == 'p2Button')\n                    g.vmMain.applyPriorityToSelection(VMLIFlag.P2, /*toggle*/true);\n                else if(id == 'pStarButton')\n                    g.vmMain.applyFnToSelection('isFlagged', /*toggle*/true);\n                else if(id == 'dateButton')\n                {\n                    g.vmMain.insertCharacter('@', true);\n                }\n                else if(id == 'contactButton')\n                {\n                    g.vmMain.insertCharacter('+', true);\n                }\n                else if(id == 'tagButton')\n                {\n                    g.vmMain.insertCharacter('#', true);\n                }\n            }\n\n            e.stopImmediatePropagation(); //stops event bubbling\n            e.preventDefault();\n            e.returnFalse = true;\n        }\n    },\n    preShow: function()\n    {\n        // Show sometimes has a timeout so this hides the floating menu immediately\n        // g.element('phoneMenuFloating').style.visibility = 'hidden';\n\n        if (DEBUG) log('Pre-Show Keyboard Menu');\n\n        //console.profile('ShowKeyboard');\n\n        // This prevents the toolbar being hidden by the blur event before it is shown\n        // in the case where focus changes between the pane and search\n        this.aboutToShow = true;\n        this.priorityVisible(false);\n\n        // TODO: Since we no longer have pull-to-add can this be removed?\n\n        // If pull-to-add adds an item it does not blur/focus so we need to clear this\n        // state manually\n        setTimeout(function()\n        {\n            this.aboutToShow = false;\n        }.bind(this), 100);\n    },\n    show: function ()\n    {\n        this.aboutToShow = false;\n\n        if (DEBUG) log('Show Keyboard Menu');\n\n        this.updatePosition();\n\n        g.isKeyboardOpen = true;\n\n        if (!platform.ie/* || (platform.ie && (platform.mobro || platform.winphone))*/)\n        {\n            this.isVisible(true);\n        }\n        // g.element('phoneMenuFloating').style.visibility = 'hidden';\n        this.hideTopBarIfLandscape();\n\n\n        if (g.vmSearchPhone.isFocused())\n        {\n            g.addClass(this.element, 'kbsearch');\n        }\n        else\n        {\n            g.removeClass(this.element, 'kbsearch');\n        }\n    },\n    hide: function ()\n    {\n        if (this.aboutToShow || !g.isKeyboardOpen)\n        {\n            if (DEBUG) log('Hide Keyboard Menu [SKIPPED]');\n\n            return;\n        }\n\n        //console.profileEnd();\n\n        if (DEBUG) log('Hide Keyboard Menu');\n\n        this.priorityVisible(false);\n\n        g.isKeyboardOpen = false;\n\n        this.hideTopBarIfLandscape();\n\n        this.isVisible(false);\n        // g.element('phoneMenuFloating').style.visibility = 'visible';\n    },\n    hideTopBarIfLandscape: function()\n    {\n        if(platform.orientation === Orientation.Landscape && g.isKeyboardOpen)\n        {\n            g.setTransform(g.element('container'), 0, -40);\n            g.setTransform(g.element('phoneMenuTopWrapper'), 0, -40);\n\n            if(g.vmMain.selected().length > 0)\n            {\n                var item = g.vmMain.selected()[0];\n                g.scrollToTop(item.getSpan());\n            }\n        }\n        else\n        {\n            g.setTransform(g.element('container'), 0, 0);\n            g.setTransform(g.element('phoneMenuTopWrapper'), 0, 0);\n        }\n    },\n    // virtualKeyboardHeight: function ()\n    // {\n    //     // It looks like this code is in a very specific ordering especially with setting scroll offsets\n    //     // on window... don't change unless you're going to re-comment and know what this is actually doing.\n    //     var sx = document.body.scrollLeft, sy = document.body.scrollTop;\n    //     var naturalHeight = window.innerHeight;\n\n    //     window.scrollTo(sx, document.body.scrollHeight);\n\n    //     var keyboardHeight = naturalHeight - window.innerHeight + sy;\n\n    //     log(sy, naturalHeight, window.innerHeight, keyboardHeight);\n    //     window.scrollTo(sx, 0);\n\n    //     return keyboardHeight;\n    // },\n    updatePosition: function (byResize)\n    {\n        // if(!platform.app)\n        // {\n        //     if (byResize && g.isKeyboardOpen)\n        //     {\n        //         document.activeElement.blur();\n        //     }\n        //     else\n        //     {\n                // var bottom;\n                if(!platform.app)\n                {\n                    // bottom = this.virtualKeyboardHeight();\n                    // bottom = 0;\n                    // debugger;\n                    if(platform.orientation == Orientation.Portrait)\n                    {\n                        // if(!platform.kbsizePortrait)\n                        // {\n                        //     platform.kbsizePortrait = bottom;\n                        // }\n                        platform.kbsize = platform.kbsizePortrait;\n                    }\n                    else\n                    {\n                        // if(!platform.kbsizeLandscape)\n                        // {\n                        //     platform.kbsizeLandscape = bottom;\n                        // }\n                        platform.kbsize = platform.kbsizeLandscape;\n                    }\n\n                    // // iOS 7 hides the address and navigation bars in landscape but only if it has ever been\n                    // // in portrait, so add extra padding\n                    // if(!byResize && platform.ios7 && platform.orientation === Orientation.Landscape && platform.hasBeenPortrait)\n                    // {\n                    //     bottom += 44;\n                    // }\n                }\n                // else\n                // {\n                    // bottom = platform.kbsize;\n                // }\n\n                var bottom = platform.kbsize;\n\n\n                // Set bottom position on keyboard\n                if (bottom != this.bottomPosition)\n                {\n                    this.bottomPosition = bottom;\n                    g.element('mobileKeyboardToolbar').style.bottom = this.bottomPosition + 'px';\n                    // Toolbar is at the wrong place and lags a little bit before layout, so hide it and\n                    // show it again in a little bit\n                    if(byResize)\n                    {\n                        this.isVisible(false);\n                        setTimeout(function() {\n                            this.isVisible(true);\n                        }.bind(this), 400);\n                    }\n                }\n        //     }\n        // }\n    }\n};\n\nreturn VMKeyboardToolbar;\n});","asserts":[]},"VMHelp":{"path":"F:/p/bce/Duchess/public/js/VMHelp.js","data":"define(['ko', 'globals'],\nfunction (ko, g) {\n\nfunction VMHelp()\n{\n    this.isVisible = ko.observable(false);\n\n    this.helpContentEle = undefined;\n    this.iframe = undefined;\n\n    this.init();\n}\n\nVMHelp.prototype = {\n    init: function()\n    {\n        g.menus.registerModal('help', this);\n    },\n    onLoad: function(ele)\n    {\n        this.helpContentEle = ele;\n\n        if (!this.iframe)\n        {\n            this.iframe = document.createElement('iframe');\n\n            this.iframe.id = 'helpContentFrame';\n            this.iframe.src = 'help.html';\n            this.iframe.setAttribute('seamless', 'seamless');\n        }\n\n        this.helpContentEle.insertBefore(this.iframe, this.helpContentEle.firstElementChild);\n    },\n    onTapClose: function()\n    {\n        g.menus.closeModal('help');\n    }\n}\n\nreturn VMHelp;\n});","asserts":[]},"parseWorker":{"path":"F:/p/bce/Duchess/public/js/parseWorker.js","data":"\nif (!this.document)\n{\n    importScripts('lib/date.js');\n    importScripts('DuchessHelpers.js');\n}\n\nfunction parseWorkerWrapper()\n{\n\nif (DuchessHelpersWrapper && !this.helperLibLoaded)\n{\n    DuchessHelpersWrapper(this.DuchessHelpers = this.DuchessHelpers || {});\n}\n\nif (dateWrapper && !this.dateLibLoaded)\n{\n    dateWrapper();\n}\n\nlog = postMessage;\n\nvar contacts;\n\nonmessage = function(e)\n{\n    if (e.data.contacts)\n    {\n        contacts = e.data.contacts;\n    }\n\n    if (e.data.items)\n    {\n        var startTime = Date.now();\n\n        var results = new Array(e.data.items.length);\n        for (var i = 0; i < e.data.items.length; i++)\n        {\n            var entry = e.data.items[i];\n\n            results[i] = DuchessHelpers.parseText(\n                entry.text,\n                entry.prevDate,\n                entry.isUpdate,\n                contacts\n                );\n        }\n\n        postMessage({ 'id': e.data.id, 'styles': results, 'done': true, 'start': startTime, 'end': Date.now() });\n    }\n    else\n    {\n        postMessage({ 'id': e.data.id, 'done': false, 'msg': 'ERROR: No items passed to the worker' });\n    }\n};\n\n}\n\nif (this.document)\n{\n    window.parseWorkerWrapper = parseWorkerWrapper;\n}\nelse\n{\n    parseWorkerWrapper();\n}","asserts":[]},"VMIntro":{"path":"F:/p/bce/Duchess/public/js/VMIntro.js","data":"define(['ko', 'globals', 'util', 'platform', 'data', 'VMIntroSection'],\nfunction (ko, g, util, platform, d, VMIntroSection)\n{\n\nwindow.HelpMode =\n{\n    None:   0,\n    Normal: 1,\n    Intro:  2,\n};\n\nfunction VMIntro(initState)\n{\n    g.Assert(initState !== undefined, 'Must pass in a valid display state');\n    this.mode = ko.observable(initState);\n\n    this.sections = ko.observableArray();\n    this.introSection = undefined;\n\n    this.init();\n\n    g.intro = this;\n}\n\nVMIntro.prototype =\n{\n    init: function()\n    {\n        if (this.isIntroMode())\n        {\n            this.initIntro();\n        }\n        else\n        {\n            this.initHelp();\n        }\n\n        this.loadState();\n    },\n    checkContactsEnable: function()\n    {\n        this.itemContactsEnable.isChecked(true);\n        this.saveState();\n    },\n    setMode: function(mode)\n    {\n        this.mode(mode);\n\n        g.settings.set(Settings.helpPaneState, mode);\n\n        g.vmMain.helpButtonHidden(mode === HelpMode.Intro);\n    },\n    isIntroMode: function()\n    {\n        return this.mode() === HelpMode.Intro;\n    },\n    modeClass: function()\n    {\n        return this.isIntroMode() ? 'helpIntro' : 'helpNormal';\n    },\n    loadState: function()\n    {\n        if (g.shouldWriteLocal())\n        {\n            try\n            {\n                var stateString = util.storage.getItem(this.modeClass());\n\n                if (stateString)\n                {\n                    var state = JSON.parse(stateString);\n\n                    if (DEBUG) log('StateLoad: ', state);\n\n                    if (state)\n                    {\n                        for (var i = 0; i < this.sections().length; ++i)\n                        {\n                            var section = this.sections()[i];\n\n                            var secHash = section.getHash();\n\n                            if (state[secHash])\n                            {\n                                section.loadFromSaveData(state[secHash]);\n                            }\n                        }\n                    }\n                }\n            }\n            catch (err)\n            {\n                g.reportError(err);\n            }\n        }\n    },\n    saveState: function()\n    {\n        if (g.shouldWriteLocal())\n        {\n            try\n            {\n                var state = this.getState();\n\n                if (DEBUG) log('StateSave: ', state);\n\n                util.storage.setItem(this.modeClass(), JSON.stringify(state));\n            }\n            catch (err)\n            {\n                g.reportError(err);\n            }\n        }\n    },\n    getState: function()\n    {\n        var saveData = { };\n        for (var i = 0; i < this.sections().length; ++i)\n        {\n            var section = this.sections()[i];\n\n            if (!section.isComplete())\n            {\n                var sectionData = [ ];\n\n                for (var j = 0; j < section.items.length; ++j)\n                {\n                    g.Assert(section.items[j], 'Item entries must exist');\n\n                    if (section.items[j].isChecked())\n                    {\n                        var entryData = section.getStepHash(j);\n\n                        sectionData.push(entryData);\n                    }\n                }\n\n                if (sectionData.length > 0)\n                {\n                    saveData[section.getHash()] = sectionData;\n                }\n            }\n            else\n            {\n                saveData[section.getHash()] = true;\n            }\n        }\n\n        return saveData;\n    },\n    notifyOfChange: function(change)\n    {\n        this.saveState();\n    },\n    addSection: function(section)\n    {\n        section.owner = this;\n\n        this.sections.push(section);\n    },\n    initIntro: function()\n    {\n        this.introSection = new VMIntroSection('Welcome to Moo.do!', 'We\\'ll walk you through the basics to get you started.');\n\n        this.introSection.inOrder = true;\n\n        this.introSection.addStep(this.itemAddItem);\n        this.introSection.addStep(this.itemIndent);\n        this.introSection.addStep(this.itemOutdent);\n        this.introSection.addStep(this.itemDateTime);\n        this.introSection.addStep(this.itemRightClick);\n        this.introSection.addStep(this.itemAddAgenda);\n\n        this.addSection(this.introSection);\n    },\n    itemAddItem: {\n        text: 'Write a list header and press enter to add a new item',\n        check: function(e)\n        {\n            if(e.type === TrackerType.Create)\n            {\n                // As long as it's not the + button it must have been enter\n                var item = d.itemsById[e.data[0].itemID].model;\n                if(!(item.parent() == d.getRootModel() && e.data[0].position === 0))\n                {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    },\n    itemIndent: {\n        text: 'Press the Tab key to add an item into a list',\n        check: function(e)\n        {\n            if(e.type === TrackerType.Move)\n            {\n                // Old parent has new parent as a child\n                var oldParentItem = d.itemsById[e.data[0].oldParent].data;\n                if(oldParentItem.items.indexOf(e.data[0].newParent) >= 0)\n                {\n                    return true;\n                }\n            }\n        }\n    },\n    itemOutdent: {\n        text: 'Press Shift + Tab to remove an item out of a list',\n        check: function(e)\n        {\n            if(e.type === TrackerType.Move)\n            {\n                // New parent has old parent as a child\n                var newParentItem = d.itemsById[e.data[0].newParent].data;\n\n                if(newParentItem.items.indexOf(e.data[0].oldParent) >= 0)\n                {\n                   return true;\n                }\n            }\n        }\n    },\n    itemDateTime: {\n        text: 'Add a date/time by typing @ in the text of an item',\n        check: function(e)\n        {\n            return e.type === TrackerType.Insert && e.data[0].text === '@';\n        }\n    },\n    itemRightClick: {\n        text: 'Right click an item to explore more options',\n        check: function(e)\n        {\n            return e.type === TrackerType.Misc && e.misc === TrackerMisc.RightClick;\n        }\n    },\n    itemAddAgenda: {\n        text: 'Click <i class=\"icon-calendar2 f22 gd\"></i> in the top right to add an Agenda pane',\n        check: function(e)\n        {\n            if(e.type === TrackerType.UIAction && e.data[0].type === TrackerUIAction.AddPane)\n            {\n                var pane = g.vmMain.panes()[e.data[0].data];\n                if(pane.mode() === PaneMode.Timeline)\n                {\n                    return true;\n                }\n            }\n        }\n    },\n    itemContactsEnable: {\n        text: '<div id=\"buttonHelpEnableContacts\" class=\"button bBlue\" style=\"margin-right: 3px;\">Enable</div> syncing contacts with your Google account',\n        check: function(e)\n        {\n            return e.type === TrackerType.Misc && e.misc === TrackerMisc.SyncContacts && e.data[0].value;\n        }\n    },\n    initHelp: function()\n    {\n        var org = new VMIntroSection('Organization', 'Moo.do works like a text editor so you can organize like you\\'re writing a document.');\n        org.addStep(this.itemAddItem);\n        org.addStep(this.itemIndent);\n        org.addStep(this.itemOutdent);\n        org.addStep({\n            text: 'Click and drag on the left edge of an item to move it around',\n            check: function(e)\n            {\n                if (e.type === TrackerType.Misc && e.misc === TrackerMisc.DropItem && g.vmMain.isLoaded)\n                {\n                    return true;\n                }\n            }\n        });\n        org.addStep({\n            text: 'Press ' + cmdChar + ' + Z to undo and ' + cmdChar + ' + Y to redo',\n            check: function(e)\n            {\n                if (e.type === TrackerType.Misc && e.misc === TrackerMisc.UndoRedo)\n                {\n                    return true;\n                }\n            }\n        });\n        org.addStep({\n            text: 'To collapse an item and hide its children press ' + cmdChar + ' + , or select collapse from the right click menu',\n            check: function(e)\n            {\n                var v = e.data[0];\n                return e.type === TrackerType.Update && v.field === 'isCollapsed' && v.newValue;\n            }\n        });\n        this.addSection(org);\n\n        var dates = new VMIntroSection('Dates', 'Scheduling items automatically puts them on your Agenda.');\n        dates.addStep(this.itemDateTime);\n        dates.addStep({\n            text: 'Write dates in plain English like <span class=\"date\">@tomorrow</span>',\n            check: function(e)\n            {\n                if (e.type === TrackerType.Misc && e.misc === TrackerMisc.ChangeDate && g.vmMain.isLoaded)\n                {\n                    var date = e.data[0].date;\n                    return !!date;\n                }\n            }\n        });\n        dates.addStep({\n            text: 'Schedule a full date and time like <span class=\"date\">@today 2:30pm</span> or <span class=\"date\">@5/25 6:00</span>',\n            check: function(e)\n            {\n                if (e.type === TrackerType.Misc && e.misc === TrackerMisc.ChangeDate && g.vmMain.isLoaded)\n                {\n                    var date = e.data[0].date;\n                    if(date)\n                    {\n                        return date._explicitTime;\n                    }\n                }\n            }\n        });\n        dates.addStep({\n            text: 'Describe urgency with <span class=\"date\">@now</span>, <span class=\"date\">@soon</span>, or <span class=\"date\">@later</span>',\n            check: function(e)\n            {\n                if (e.type === TrackerType.Misc && e.misc === TrackerMisc.ChangeDate && g.vmMain.isLoaded)\n                {\n                    var item = d.itemsById[e.data[0].itemID].model;\n                    return item ? g.isDateSoft(item.dateText) : false;\n                }\n            }\n        });\n        this.addSection(dates);\n\n        var priority = new VMIntroSection('Priority', 'Prioritizing items automatically puts them on your agenda and lets you manage what to do next.');\n        priority.addStep(this.itemRightClick);\n        priority.addStep({\n            text: 'Set a priority with the right click menu or ' + cmdChar + ' + 1/2/3',\n            check: function(e)\n            {\n                var v = e.data[0];\n                return e.type === TrackerType.Update && v.field === 'priority' && v.newValue > 0;\n            }\n        });\n        priority.addStep({\n            text: 'Click the left of an item or ' + cmdChar + ' + / to mark it complete',\n            check: function(e)\n            {\n                var v = e.data[0];\n                return e.type === TrackerType.Update && v.field === 'isComplete' && v.newValue;\n            }\n        });\n        priority.addStep({\n            text: 'Press ' + cmdChar + ' + \\' to flag an item which highlights it in yellow',\n            check: function(e)\n            {\n                var v = e.data[0];\n                return e.type === TrackerType.Update && v.field === 'isFlagged' && v.newValue;\n            }\n        });\n        this.addSection(priority);\n\n        var contacts = new VMIntroSection('Contacts', 'Add a contact to an item to easily start a call or email.');\n        contacts.addStep(this.itemContactsEnable);\n        g.waitForElement('buttonHelpEnableContacts', function(el)\n        {\n            el.onclick = function()\n            {\n                g.vmSettings.enableSyncContacts();\n            };\n        }, 100);\n\n        contacts.addStep({\n            text: 'Add a contact by typing + in the text of an item',\n            check: function(e)\n            {\n                return e.type === TrackerType.Insert && e.data[0].text === '+';\n            }\n        });\n        contacts.addStep({\n            text: 'Select a contact\\'s name from the list or start typing a name to narrow the search',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.AddContact;\n            }\n        });\n        contacts.addStep({\n            text: 'Click on a <span class=\"contact\">+contact</span> to start a call or email',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.OpenContact;\n            }\n        });\n        this.addSection(contacts);\n\n        var panes = new VMIntroSection('Panes', 'There are two types of panes: List and Agenda. The List pane is where you write and organize while the Agenda pane is organized automatically by time and priority.');\n        panes.addStep({\n            text: 'Click <i class=\"icon-align-left f22 gd\"></i> in the top right to add a List pane',\n            check: function(e)\n            {\n                if(e.type === TrackerType.UIAction && e.data[0].type === TrackerUIAction.AddPane)\n                {\n                    var pane = g.vmMain.panes()[e.data[0].data];\n                    if(pane.mode() === PaneMode.Normal)\n                    {\n                        return true;\n                    }\n                }\n            }\n        });\n        panes.addStep(this.itemAddAgenda);\n        panes.addStep({\n            text: 'Click <i class=\"icon-remove gd\"></i> in the top right of a pane to close it',\n            check: function(e)\n            {\n                return e.type === TrackerType.UIAction && e.data[0].type === TrackerUIAction.RemovePane;\n            }\n        });\n        this.addSection(panes);\n\n        var focus = new VMIntroSection('Focus', 'Focus on an item to show only the items under it');\n        focus.addStep({\n            text: 'To focus on an item, right click on it and select zoom or press ' + cmdChar + ' + Enter',\n            check: function(e)\n            {\n                return e.type === TrackerType.Zoom && !e.data[0].zoomOut;\n            }\n        });\n        focus.addStep({\n            text: 'To bring focus back out, click the <span class=\"titleWrapper\"><span class=\"titleOpen\">title of the list</span></span> you want to focus on',\n            check: function(e)\n            {\n                return e.type === TrackerType.Zoom && e.data[0].zoomOut;\n            }\n        });\n        focus.addStep({\n            text: 'Press <i class=\"outlineButtonNormal icon-list\"></i> in the top left of a pane to open the outline',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.ToggleOutline;\n            }\n        });\n        focus.addStep({\n            text: 'Click the title of a list in the outline to focus on it',\n            check: function(e)\n            {\n                return e.type === TrackerType.Zoom && !e.data[0].zoomOut && g.focusedPane.outline.isVisible();\n            }\n        });\n        this.addSection(focus);\n\n        var search = new VMIntroSection('Search', 'Filter for only the items you want to see right now');\n        search.addStep({\n            text: 'Filter for a keyword by searching for that word',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged;\n            }\n        });\n        search.addStep({\n            text: 'Mark similar items with a <span class=\"tag\">#tag</span> to easily search for all items matching that tag',\n            check: function(e)\n            {\n                return e.type === TrackerType.Insert && e.data[0].text === '#';\n            }\n        });\n        // search.addStep({\n        //     text: 'Search for a <span class=\"tag\">#tag</span> to focus on only items that match that <span class=\"tag\">#tag</span>',\n        //     check: function(e)\n        //     {\n        //         return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged && e.data[0].text.indexOf('#') >= 0;\n        //     }\n        // });\n        search.addStep({\n            text: 'Filter by priority by searching for !, !!, or !!!',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged && e.data[0].text.indexOf('!') >= 0;\n            }\n        });\n        search.addStep({\n            text: 'Show only flagged items by searching for \\'\\' (two apostrophes)',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged && e.data[0].text.indexOf('\\'\\'') >= 0;\n            }\n        });\n        search.addStep({\n            text: 'Hide items you\\'re not interested in by starting a search with - (dash)',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged && e.data[0].text.indexOf('-') >= 0;\n            }\n        });\n        search.addStep({\n            text: 'Hide completed items by searching for -// (dash, two slashes)',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.SearchChanged && e.data[0].text.indexOf('-//') >= 0;\n            }\n        });\n        this.addSection(search);\n\n        var documents = new VMIntroSection('Collaboration', 'Collaborate with others by sharing documents with different groups of people');\n        documents.addStep({\n            text: 'Click <i class=\"icon-reorder f22 gd\"></i> in the top left to open the sidebar',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.ToggleSidebar && e.data[0].value;\n            }\n        });\n        documents.addStep({\n            text: 'Click <i class=\"icon-plus f18 g\"></i> to create a new document',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.AddDocument && e.data[0].value;\n            }\n        });\n        documents.addStep({\n            text: 'Open your new document by clicking on it in the list of documents',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.OpenDocument && e.data[0].value;\n            }\n        });\n        documents.addStep({\n            text: 'Click <i class=\"icon-user f18 c g\"></i> to change the sharing settings',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.OpenDocSharing && e.data[0].value;\n            }\n        });\n        this.addSection(documents);\n\n        var data = new VMIntroSection('Data', 'Import data from another app to use in Moo.do or export your data out of Moo.do');\n        data.addStep({\n            text: 'Paste into Moo.do by pressing ' + cmdChar + ' + V or finding Paste in your browser\\s edit menu',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.Paste && e.data[0].value;\n            }\n        });\n        data.addStep({\n            text: 'Copy the selected text by pressing ' + cmdChar + ' + C or finding Copy in your browser\\s edit menu',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.Copy && e.data[0].value;\n            }\n        });\n        data.addStep({\n            text: 'Click on Import Data in the sidebar, then choose the app to import from and follow the instructions. If you do not see your app, try using copy and paste to paste it in to Moo.do. If that does not work, please <a href=\"mailto:support@moo.do?subject=Import Request\">contact us</a> and tell us what app you want to import from.',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.OpenImport && e.data[0].value;\n            }\n        });\n        data.addStep({\n            text: 'Click on Export Data in the sidebar, then choose the format you\\'d like. You can see your data in a new tab so you may copy or download it.',\n            check: function(e)\n            {\n                return e.type === TrackerType.Misc && e.misc === TrackerMisc.OpenExport && e.data[0].value;\n            }\n        });\n        this.addSection(data);\n\n        if(!this.itemContactsEnable.isChecked() && g.settings.get(Settings.syncContacts))\n        {\n            this.checkContactsEnable();\n        }\n        window.addEventListener('settingsChange', function(e)\n        {\n            if(e.data.property == 'syncContacts')\n            {\n                this.checkContactsEnable();\n            }\n        }.bind(this));\n    },\n    onAction: function(e)\n    {\n        try\n        {\n            for (var i = 0; i < this.sections().length; i ++)\n            {\n                this.sections()[i].check(e);\n            }\n        }\n        catch (err)\n        {\n            g.reportError(err);\n        }\n    },\n    onClosePane: function(e)\n    {\n        g.tooltip.hideTip();\n        g.vmMain.closeHelp();\n    },\n    introComplete: function()\n    {\n        return this.introSection && this.introSection.isComplete();\n    },\n    switchToHelp: function()\n    {\n        this.initHelp();\n\n        this.setMode(HelpMode.Normal);\n\n        this.sections.splice(0, 1);\n        delete this.introSection;\n\n        this.saveState();\n    }\n};\n\nreturn VMIntro;\n});\n\n// Where to put hotkeys?\n\n/*\n\nIntroduction:\n1. It's just text ????\n2. Hit enter to add another item\n3. Press tab to indent into a list\n4. Press shift + tab to outdent\n5. Schedule an item by typing the @ character\n6. Right click to show options for items\n\n\n\nStart with placeholder text - Write the title of a list\n\nOrganization\n// ?\n1. Hit enter to add another item\n2. Press tab to indent into a list\n3. Press shift + tab to outdent\n4. Press and hold on the left side of an item to drag and drop it\n5. Right click to show options for items\n\nDates\n// Dates will appear on your agenda\n1. Schedule an item by typing the @ character\n2. Write dates in plain English like @tomorrow\n2. Set a full date and time like @5/25 4pm\n4. Describe urgency like @now or @soon\n\nContacts\n1.\n\nPriority\n1. Right click to show options for items\n2. Select a priority\n3. Prioritized items will appear on your agenda\n4. Click the left of an item to mark it complete.\n\nPanes\n1. There are two types of panes: List and Agenda.\n2. The List pane is where you write and organize.\n3. The Agenda pane is organized automatically to show you the most important things to do next.\n4. Press the buttons in the top right to add panes.\n\nFocus\n1. Focus on any item to show only the items under it\n2. To focus in, right click and click zoom or press Cmd + Enter\n3. To focus back out, click the name of the list you want to focus on.\n4. Use the outline to find a list to focus on\n\nSearch\n1. Filter for only the items you want to see right now\n2. Search by word, priority level, or whether you've flagged it.\n3. Hide items by starting with -, like \"-not\".\n\n\n\n*/\n\n/*\n\nOrganization\n    To make a list...\n\n\n*/\n\n/*\n\nLarge blocks with icons\n\n*/\n\n/*\n\nHierarchy\nDates\nContacts\nSearch\n    Tags\n    Not\nAgenda pane\nRight click\nPriority\nFlag\nComplete\n\n\n*/\n\n/*\ntext: '<div class=\"header\">Welcome to Moo.do!</div><p>We\\'re going to walk through a few common operations before you get started. You can click these messages to hide them, they will reappear if you get stuck.<br/>Click here to continue.</p>',\ntext: '<div class=\"header\">Introduction</div><p>Create a new list header by typing some text. [Example: <i>Things I need to do</i>]</p>',\ntext: '<p>Press <i>Enter</i> to add another item.</p>',\ntext: '<p>Press <i>tab</i> to indent the item you just created.</p>',\n\ntext: '<div class=\"header\">Dates</div><p>Add an item with a date by having \\'@today\\' in the text. [Example: <i>Pick up Bob at the airport @today 3:00pm</i>]</p>',\ntext: '<div class=\"header\">Priority</div><p>Mark the item you just created as high priority by right-clicking it and selecting <i>!!</i>.</p>',\ntext: '<p>Press <i>Enter</i> at the end of the item you just marked as high priority.</p>',\ntext: '<p>Add another list header by creating a new item. [Example: <i>Places to Visit</i>]</p>',\ntext: '<p>Add a few more items under the header you just created by pressing enter and then tab.</p>',\ntext: '<div class=\"header\">Hierarchy</div><p>Un-indent the list header that you created previously by clicking on it then pressing <i>shift+tab</i>.</p>',\ntext: '<div class=\"header\">Navigation</div><p>Zoom into the list header you just un-indented by right-clicking it and selecting <i>Zoom</i>.</p>',\ntext: '<div class=\"header\">Completing Items</div><p>Complete an item by right-clicking one and selecting <i>Complete</i>.</p>',\ntext: '<div class=\"header\">The Outline</div><p>Zoom back out by clicking the <i>Outline</i> button and clicking <i>Home</i>.</p>',\n*/","asserts":[{"tag":1354,"offset":230},{"tag":1355,"offset":2954}]},"VMIntroSection":{"path":"F:/p/bce/Duchess/public/js/VMIntroSection.js","data":"define(['ko', 'globals', 'platform', 'data'],\nfunction (ko, g, platform, d) {\n\nfunction VMIntroSection(text, note)\n{\n    this.text = text;\n    this.note = note;\n    this.items = [];\n    this.inOrder = false;\n\n    this.owner = undefined;\n\n    this.numComplete = 0;\n    this.next = 0;\n    this.isComplete = ko.observable(false);\n}\n\nVMIntroSection.prototype =\n{\n    getHash: function()\n    {\n        return g.introHash(this.text);\n    },\n    getStepHash: function(index)\n    {\n        return g.introHash(this.items[index].text);\n    },\n    loadFromSaveData: function(data)\n    {\n        if (data === true)\n        {\n            for (var i = 0; i < this.items.length; ++i)\n            {\n                this.items[i].isChecked(true);\n            }\n\n            this.numComplete = this.items.length;\n            this.isComplete(true);\n        }\n        else\n        {\n            for (var i = 0; i < data.length; ++i)\n            {\n                for (var j = 0; j < this.items.length; ++j)\n                {\n                    if (data[i] === this.getStepHash(j))\n                    {\n                        this.items[j].isChecked(true);\n                        this.numComplete++;\n                    }\n                }\n            }\n\n            if (this.numComplete === this.items.length)\n            {\n                this.isComplete(true);\n            }\n        }\n    },\n    addStep: function(item)\n    {\n        // TODO: Put in this assert after all help items are filled out\n        // g.Assert(item.text && item.check, 'Invalid help step');\n        if(!item.check)\n            item.check = function(){};\n\n        if(!item.isChecked)\n            item.isChecked = ko.observable(false);\n        if(this.inOrder)\n        {\n            if(!item.isDisabled)\n                item.isDisabled = ko.observable(this.items.length > 0);\n        }\n        else\n        {\n            item.isDisabled = g.fFalse;\n        }\n        this.items.push(item);\n        return item;\n    },\n    complete: function(item)\n    {\n        item.isChecked(true);\n        this.owner.notifyOfChange(item);\n    },\n    check: function(e)\n    {\n        for(var i = 0; i < this.items.length; i ++)\n        {\n            if (!this.items[i].isChecked() && this.items[i].check(e))\n            {\n                this.complete(this.items[i]);\n\n                if(this.inOrder)\n                {\n                    this.numComplete ++;\n                    if(i === this.next)\n                    {\n                        this.next ++;\n                        if(this.next < this.items.length)\n                        {\n                            this.items[this.next].isDisabled(false);\n                        }\n                    }\n                }\n            }\n        }\n        if(this.numComplete === this.items.length)\n        {\n            this.isComplete(true);\n        }\n    }\n};\n\nreturn VMIntroSection;\n});","asserts":[{"tag":1353,"offset":1495}]},"VMDebug":{"path":"F:/p/bce/Duchess/public/js/VMDebug.js","data":"define(['ko', 'globals', 'platform', 'data', 'FileSaver', 'goog', 'dimport'],\r\nfunction (ko, g, platform, d, FileSaver, goog, dimport) {\r\nfunction VMDebug ()\r\n{\r\n    this.bugDescription = ko.observable('');\r\n\r\n    this.mode = ko.observable('html');\r\n    this.exportedContent = '';\r\n    this.exportedPreview = ko.observable('');\r\n    this.exportArchived = ko.observable(true);\r\n\r\n    this.importName = ko.observable('JSON');\r\n    this.importDisplayMessage = ko.observable('');\r\n    this.importing = false;\r\n    this.importer = new dimport();\r\n\r\n    this.init();\r\n}\r\n\r\nVMDebug.prototype = {\r\n    init: function()\r\n    {\r\n        this.exportArchived.subscribe(this.exportData.bind(this));\r\n\r\n        g.menus.registerModal('reportBug', this, this.reportBug);\r\n        g.menus.registerModal('importData', this);\r\n        g.menus.registerModal('exportData', this, this.openExport.bind(this), this.closeExport.bind(this));\r\n\r\n        if (DEBUG)\r\n        {\r\n            window.__exportCoverage = function(redirect)\r\n            {\r\n                if (window.__coverage__)\r\n                {\r\n                    g.XHR({\r\n                        type: 'POST',\r\n                        url: window.location.protocol + '//localhost:8000/debug/sendCoverage',\r\n                        data: JSON.stringify(__coverage__),\r\n                        cb: function (xhr)\r\n                        {\r\n                            log('Coverage Response: ', xhr);\r\n\r\n                            if (redirect)\r\n                            {\r\n                                window.location = window.location.protocol + '//localhost:8000/report';\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                else\r\n                {\r\n                    log('No code coverage information found');\r\n                }\r\n            };\r\n        }\r\n    },\r\n    reportBug: function ()\r\n    {\r\n        setTimeout(function ()\r\n        {\r\n            document.getElementById('bugDescription').focus();\r\n        });\r\n    },\r\n    onTapSaveBug: function ()\r\n    {\r\n        var appInfo = { };\r\n        g.getAppInfo(appInfo);\r\n\r\n        var notes = this.bugDescription() + '\\r\\n\\r\\n\\r\\n' + JSON.stringify(appInfo, undefined, 3);\r\n\r\n        var indexOfNewline = this.bugDescription().indexOf('\\n');\r\n        var name = this.bugDescription().substr(0, indexOfNewline >= 0 ?\r\n                                indexOfNewline :\r\n                                Math.min(this.bugDescription().length, 120));\r\n\r\n        var bug =\r\n            {\r\n                'name': name,\r\n                'notes': notes\r\n            };\r\n\r\n        bug.email = g.getUserIdentifier();\r\n\r\n        // if (bugForm['sendData'].checked)\r\n        // {\r\n        //     bug.userData = d.toJSON(d.getRootItem());\r\n        // }\r\n\r\n        var sendBug = function ()\r\n        {\r\n            g.XHR({\r\n                type: 'POST',\r\n                url: window.location.protocol + '//api.moo.do/debug/reportIssue',\r\n                data: bug,\r\n                cb: function (xhr)\r\n                {\r\n                    log('XHR Response: ', xhr);\r\n\r\n                    this.bugDescription('');\r\n                }.bind(this)\r\n            });\r\n        }.bind(this);\r\n\r\n        if (bug.email !== 'Unknown')\r\n        {\r\n            sendBug();\r\n        }\r\n        else\r\n        {\r\n            g.getClientInfo(function (info)\r\n            {\r\n                if (info)\r\n                {\r\n                    bug.email = info.ip;\r\n                }\r\n\r\n                sendBug();\r\n            });\r\n        }\r\n\r\n        g.menus.closeModal('reportBug');\r\n\r\n        g.messageQueue.pushMessage({\r\n            text: 'Thanks for taking the time to send us feedback!',\r\n            type: MessageType.Info,\r\n            action: MessageAction.Default,\r\n            timeout: 1500\r\n        });\r\n\r\n        g.blurActiveElement();\r\n        g.vmMain.clearSelected();\r\n    },\r\n    onTapCancelBug: function()\r\n    {\r\n        g.menus.closeModal('reportBug');\r\n\r\n        g.blurActiveElement();\r\n        g.vmMain.clearSelected();\r\n    },\r\n    openExport: function()\r\n    {\r\n        this.exportData();\r\n\r\n        this.exportKeyHandler = this.onExportKeydown.bind(this);\r\n\r\n        document.addEventListener('keydown', this.exportKeyHandler, true);\r\n    },\r\n    closeExport: function()\r\n    {\r\n        document.removeEventListener('keydown', this.exportKeyHandler, true);\r\n\r\n        this.exportKeyHandler = undefined;\r\n    },\r\n    onTapCloseExport: function()\r\n    {\r\n        g.menus.closeModal('exportData');\r\n    },\r\n    exportData: function()\r\n    {\r\n        var content;\r\n        var preview;\r\n        var root = d.getRootItem();\r\n\r\n        if (this.mode() == 'html')\r\n        {\r\n            content = d.toHtml(root, this.exportArchived());\r\n            preview = content;\r\n        }\r\n        else if (this.mode() == 'plain')\r\n        {\r\n            var tab = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';\r\n            content = d.toPlainText(root, /*indent*/0, this.exportArchived());\r\n            preview = content.replace(/\\n/g, '<br>').replace(/\\t/g, tab);\r\n        }\r\n        else if (this.mode() == 'json')\r\n        {\r\n            content = d.toJSON(root, /*hasPrev*/false, this.exportArchived());\r\n            preview = content;\r\n        }\r\n\r\n        this.exportedContent = content;\r\n        this.exportedPreview(preview);\r\n    },\r\n    onTapHTML: function(e)\r\n    {\r\n        this.mode('html');\r\n        this.exportData();\r\n        this.highlightExportButton(e);\r\n    },\r\n    onTapPlain: function(e)\r\n    {\r\n        this.mode('plain');\r\n        this.exportData();\r\n        this.highlightExportButton(e);\r\n    },\r\n    onTapJSON: function(e)\r\n    {\r\n        this.mode('json');\r\n        this.exportData();\r\n        this.highlightExportButton(e);\r\n    },\r\n    highlightExportButton: function(e)\r\n    {\r\n        if (!e.srcElement)\r\n        {\r\n            e.srcElement = e.target;\r\n        }\r\n\r\n        var btnParent = document.getElementById('exportTypes');\r\n\r\n        if (btnParent)\r\n        {\r\n            for (var i = 0; i < btnParent.children.length; ++i)\r\n            {\r\n                var btn = btnParent.children[i];\r\n\r\n                if (g.hasClass(btn, 'button'))\r\n                {\r\n                    if (btn !== e.srcElement)\r\n                    {\r\n                        g.removeClass(btn, 'bSelected');\r\n                    }\r\n                    else\r\n                    {\r\n                        g.addClass(btn, 'bSelected');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n    onTapOpen: function()\r\n    {\r\n        var content = this.mode() == 'plain' ? this.exportedPreview() : this.exportedContent;\r\n        var newWin = open('url');\r\n\r\n        newWin.document.write(content);\r\n    },\r\n    onTapSelect: function()\r\n    {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(document.getElementById('exportedContent'));\r\n\r\n        var sel = window.getSelection();\r\n\r\n        sel.removeAllRanges();\r\n        sel.addRange(range);\r\n    },\r\n    onTapSaveExport: function()\r\n    {\r\n        var ext;\r\n        if (this.mode() == 'html')\r\n        {\r\n            ext = 'html';\r\n        }\r\n        else if (this.mode() == 'plain')\r\n        {\r\n            ext = 'txt';\r\n        }\r\n        else if (this.mode() == 'json')\r\n        {\r\n            ext = 'json';\r\n        }\r\n\r\n        try\r\n        {\r\n            var blob = new Blob([this.exportedContent], {type: \"text/plain;charset=utf-8\"});\r\n            saveAs(blob, 'moodo.' + ext);\r\n        }\r\n        catch (err)\r\n        {\r\n            g.reportError(err);\r\n        }\r\n    },\r\n    onExportKeydown: function(e)\r\n    {\r\n        platform.normalizeKeys(e);\r\n\r\n        if (platform.mac && e.metaKey || !platform.mac && e.ctrlKey)\r\n        {\r\n            if (e.normCode === KeyCode.A)\r\n            {\r\n                this.onTapSelect();\r\n\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n\r\n                return false;\r\n            }\r\n        }\r\n    },\r\n    // showImportLogin: function()\r\n    // {\r\n    //     g.removeClass(document.getElementById('importLoginArea'), 'none');\r\n    //     g.addClass(document.getElementById('importTextArea'), 'none');\r\n    //     g.addClass(document.getElementById('importUploadArea'), 'none');\r\n    // },\r\n    // showImportText: function()\r\n    // {\r\n    //     g.addClass(document.getElementById('importLoginArea'), 'none');\r\n    //     g.removeClass(document.getElementById('importTextArea'), 'none');\r\n    //     g.addClass(document.getElementById('importUploadArea'), 'none');\r\n    // },\r\n    // showImportUpload: function()\r\n    // {\r\n    //     g.addClass(document.getElementById('importLoginArea'), 'none');\r\n    //     g.addClass(document.getElementById('importTextArea'), 'none');\r\n    //     g.removeClass(document.getElementById('importUploadArea'), 'none');\r\n    // },\r\n    closeImport: function ()\r\n    {\r\n        g.menus.closeModal('importData');\r\n    },\r\n    isAreaVisible: function(area)\r\n    {\r\n        switch (this.importName())\r\n        {\r\n            case 'Wunderlist':\r\n                return (area === 'LoginArea');\r\n            case 'Workflowy':\r\n                return (area === 'LoginArea');\r\n            case 'OPML':\r\n                return (area === 'UploadArea');\r\n            case 'JSON':\r\n                return (area === 'UploadArea');\r\n            case 'Text':\r\n                return (area === 'TextArea');\r\n            case 'Google Tasks':\r\n                return (area === 'OAuthArea');\r\n            case 'Trello':\r\n                return (area === 'LoginArea');\r\n            case 'Toodledo':\r\n                return (area === 'OAuthArea');\r\n            default:\r\n                g.Assert(false, 'Must add valid importer');\r\n                break;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    highlightImportButton: function(e)\r\n    {\r\n        if (!e.srcElement)\r\n        {\r\n            e.srcElement = e.target;\r\n        }\r\n\r\n        var btnParent = document.getElementById('importLocations');\r\n\r\n        if (btnParent)\r\n        {\r\n            for (var i = 0; i < btnParent.children.length; ++i)\r\n            {\r\n                var btn = btnParent.children[i];\r\n\r\n                if (btn !== e.srcElement)\r\n                {\r\n                    g.removeClass(btn, 'bSelected');\r\n                }\r\n                else\r\n                {\r\n                    g.addClass(btn, 'bSelected');\r\n                }\r\n            }\r\n        }\r\n    },\r\n    onTapRunImportWunderlist: function(e)\r\n    {\r\n        this.importName('Wunderlist');\r\n        this.highlightImportButton(e);\r\n        //this.showImportLogin();\r\n    },\r\n    onTapRunImportWorkflowy: function(e)\r\n    {\r\n        this.importName('Workflowy');\r\n        this.highlightImportButton(e);\r\n        //this.showImportLogin();\r\n    },\r\n    onTapRunImportOPML: function(e)\r\n    {\r\n        this.importName('OPML');\r\n        this.highlightImportButton(e);\r\n        //this.showImportUpload();\r\n    },\r\n    onTapRunImportJSON: function(e)\r\n    {\r\n        this.importName('JSON');\r\n        this.highlightImportButton(e);\r\n    },\r\n    onTapRunImportText: function(e)\r\n    {\r\n        this.importName('Text');\r\n        this.highlightImportButton(e);\r\n    },\r\n    onTapRunImportGTasks: function(e)\r\n    {\r\n        this.importName('Google Tasks');\r\n        this.highlightImportButton(e);\r\n        //this.showImportOAuth();\r\n    },\r\n    onTapRunImportTrello: function(e)\r\n    {\r\n        this.importName('Trello');\r\n        this.highlightImportButton(e);\r\n    },\r\n    onTapRunImportToodledo: function(e)\r\n    {\r\n        this.importName('Toodledo');\r\n        this.highlightImportButton(e);\r\n    },\r\n    onTapRunImport: function()\r\n    {\r\n        if (this.importing)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var onImportError = function (msg, err)\r\n        {\r\n            try\r\n            {\r\n                var message = msg;\r\n\r\n                if (!message || !g.isString(message))\r\n                {\r\n                    message = 'There was an unexpected error, please double check your data';\r\n                }\r\n\r\n                this.importing = false;\r\n\r\n                this.importDisplayMessage(message);\r\n\r\n                g.reportError(err || msg, msg);\r\n            }\r\n            catch (errErr)\r\n            {\r\n                g.reportError(errErr);\r\n            }\r\n        }.bind(this);\r\n\r\n        var loginName = document.getElementById('importEmail').value;\r\n        var loginPW = document.getElementById('importPW').value;\r\n\r\n        var importFn = undefined;\r\n        switch (this.importName())\r\n        {\r\n            case 'Wunderlist':\r\n                importFn = this.importer.wunderlist;\r\n                break;\r\n            case 'Workflowy':\r\n                importFn = this.importer.workflowy;\r\n                break;\r\n            case 'OPML':\r\n                importFn = this.importer.opml;\r\n                break;\r\n            case 'JSON':\r\n                importFn = this.importer.json;\r\n                break;\r\n            case 'Text':\r\n                importFn = this.importer.text;\r\n                break;\r\n            case 'Google Tasks':\r\n                importFn = this.importer.gtasks;\r\n                break;\r\n            case 'Trello':\r\n                importFn = this.importer.trello;\r\n                break;\r\n            case 'Toodledo':\r\n                importFn = this.importer.toodledo;\r\n                break;\r\n            default:\r\n                g.Assert(false, 'Must add valid importer');\r\n                break;\r\n        }\r\n\r\n        if (importFn)\r\n        {\r\n            this.importing = true;\r\n\r\n            importFn.login(loginName, loginPW, function ()\r\n            {\r\n                importFn.import(function (data)\r\n                {\r\n                    importFn.save(data, function ()\r\n                    {\r\n                        this.importDisplayMessage('Your data was imported successfully!');\r\n\r\n                        this.importing = false;\r\n\r\n                        setTimeout(function ()\r\n                        {\r\n                            g.menus.closeModal('importData');\r\n                        }.bind(this), 2000);\r\n                    }.bind(this), onImportError);\r\n                }.bind(this), onImportError);\r\n            }.bind(this), onImportError);\r\n        }\r\n    },\r\n    importTitle: function()\r\n    {\r\n        var name = this.importName();\r\n\r\n        if (name !== 'OPML' && name !== 'JSON' && name !== 'Text')\r\n        {\r\n            return \"Importing data from \" + this.importName();\r\n        }\r\n        else\r\n        {\r\n            return 'Upload ' + name + ' File';\r\n        }\r\n    },\r\n    importMessage: function()\r\n    {\r\n        return this.importDisplayMessage();\r\n    }\r\n};\r\n\r\nreturn VMDebug;\r\n});\r\n","asserts":[{"tag":1449,"offset":9739},{"tag":1450,"offset":13505}]},"FileSaver":{"path":"F:/p/bce/Duchess/public/js/lib/FileSaver.js","data":"/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 2013-01-23\n *\n * By Eli Grey, http://eligrey.com\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs\n  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))\n  || (function(view) {\n\t\"use strict\";\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, URL = view.URL || view.webkitURL || view\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = doc.createEvent(\"MouseEvents\");\n\t\t\tevent.initMouseEvent(\n\t\t\t\t\"click\", true, false, view, 0, 0, 0, 0, 0\n\t\t\t\t, false, false, false, false, 0, null\n\t\t\t);\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, webkit_req_fs = view.webkitRequestFileSystem\n\t\t, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem\n\t\t, throw_outside = function (ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t, fs_min_size = 0\n\t\t, deletion_queue = []\n\t\t, process_deletion_queue = function() {\n\t\t\tvar i = deletion_queue.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar file = deletion_queue[i];\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tURL.revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeletion_queue.length = 0; // clear queue\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, FileSaver = function(blob, name) {\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, blob_changed = false\n\t\t\t\t, object_url\n\t\t\t\t, target_view\n\t\t\t\t, get_object_url = function() {\n\t\t\t\t\tvar object_url = get_URL().createObjectURL(blob);\n\t\t\t\t\tdeletion_queue.push(object_url);\n\t\t\t\t\treturn object_url;\n\t\t\t\t}\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (blob_changed || !object_url) {\n\t\t\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (target_view) {\n\t\t\t\t\t\ttarget_view.location.href = object_url;\n\t\t\t\t\t} else {\n                        window.open(object_url, \"_blank\");\n                    }\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t}\n\t\t\t\t, abortable = function(func) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif (filesaver.readyState !== filesaver.DONE) {\n\t\t\t\t\t\t\treturn func.apply(this, arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t, create_if_not_found = {create: true, exclusive: false}\n\t\t\t\t, slice\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\tif (!name) {\n\t\t\t\tname = \"download\";\n\t\t\t}\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\tsave_link.href = object_url;\n\t\t\t\tsave_link.download = name;\n\t\t\t\tclick(save_link);\n\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\tdispatch_all();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Object and web filesystem URLs have a problem saving in Google Chrome when\n\t\t\t// viewed in a tab, so I force save with application/octet-stream\n\t\t\t// http://code.google.com/p/chromium/issues/detail?id=91158\n\t\t\tif (view.chrome && type && type !== force_saveable_type) {\n\t\t\t\tslice = blob.slice || blob.webkitSlice;\n\t\t\t\tblob = slice.call(blob, 0, blob.size, force_saveable_type);\n\t\t\t\tblob_changed = true;\n\t\t\t}\n\t\t\t// Since I can't be sure that the guessed media type will trigger a download\n\t\t\t// in WebKit, I append .download to the filename.\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=65440\n\t\t\tif (webkit_req_fs && name !== \"download\") {\n\t\t\t\tname += \".download\";\n\t\t\t}\n\t\t\tif (type === force_saveable_type || webkit_req_fs) {\n\t\t\t\ttarget_view = view;\n\t\t\t}\n\t\t\tif (!req_fs) {\n\t\t\t\tfs_error();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfs_min_size += blob.size;\n\t\t\treq_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {\n\t\t\t\tfs.root.getDirectory(\"saved\", create_if_not_found, abortable(function(dir) {\n\t\t\t\t\tvar save = function() {\n\t\t\t\t\t\tdir.getFile(name, create_if_not_found, abortable(function(file) {\n\t\t\t\t\t\t\tfile.createWriter(abortable(function(writer) {\n\t\t\t\t\t\t\t\twriter.onwriteend = function(event) {\n\t\t\t\t\t\t\t\t\ttarget_view.location.href = file.toURL();\n\t\t\t\t\t\t\t\t\tdeletion_queue.push(file);\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t\tdispatch(filesaver, \"writeend\", event);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\twriter.onerror = function() {\n\t\t\t\t\t\t\t\t\tvar error = writer.error;\n\t\t\t\t\t\t\t\t\tif (error.code !== error.ABORT_ERR) {\n\t\t\t\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\"writestart progress write abort\".split(\" \").forEach(function(event) {\n\t\t\t\t\t\t\t\t\twriter[\"on\" + event] = filesaver[\"on\" + event];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\twriter.write(blob);\n\t\t\t\t\t\t\t\tfilesaver.abort = function() {\n\t\t\t\t\t\t\t\t\twriter.abort();\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.WRITING;\n\t\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t};\n\t\t\t\t\tdir.getFile(name, {create: false}, abortable(function(file) {\n\t\t\t\t\t\t// delete file if it already exists\n\t\t\t\t\t\tfile.remove();\n\t\t\t\t\t\tsave();\n\t\t\t\t\t}), abortable(function(ex) {\n\t\t\t\t\t\tif (ex.code === ex.NOT_FOUND_ERR) {\n\t\t\t\t\t\t\tsave();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}), fs_error);\n\t\t\t}), fs_error);\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name) {\n\t\t\treturn new FileSaver(blob, name);\n\t\t}\n\t;\n\tFS_proto.abort = function() {\n\t\tvar filesaver = this;\n\t\tfilesaver.readyState = filesaver.DONE;\n\t\tdispatch(filesaver, \"abort\");\n\t};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\tview.addEventListener(\"unload\", process_deletion_queue, false);\n\treturn saveAs;\n}(self));\n","asserts":[]},"dimport":{"path":"F:/p/bce/Duchess/public/js/dimport.js","data":"define(['globals', 'data', 'tracker', 'VMLI', 'parse', 'goog'],\nfunction (g, d, tracker, VMLI, parser, goog) {\n\nvar importData = { };\nfunction dimport()\n{\n    this.workflowy =\n    {\n        'login': this.workflowyLogin.bind(this),\n        'import': this.workflowyImport.bind(this),\n        'save': this.workflowySave.bind(this)\n    };\n\n    this.wunderlist =\n    {\n        'login': this.wunderlistLogin.bind(this),\n        'import': this.wunderlistImport.bind(this),\n        'save': this.wunderlistSave.bind(this)\n    };\n\n    this.opml =\n    {\n        'login': this.opmlLogin.bind(this),\n        'import': this.opmlImport.bind(this),\n        'save': this.opmlSave.bind(this)\n    };\n\n    this.json =\n    {\n        'login': this.jsonLogin.bind(this),\n        'import': this.jsonImport.bind(this),\n        'save': this.jsonSave.bind(this)\n    };\n\n    this.text =\n    {\n        'login': this.textLogin.bind(this),\n        'import': this.textImport.bind(this),\n        'save': this.textSave.bind(this)\n    };\n\n    this.gtasks =\n    {\n        'login': this.gtasksLogin.bind(this),\n        'import': this.gtasksImport.bind(this),\n        'save': this.gtasksSave.bind(this)\n    };\n\n    this.trello =\n    {\n        'login': this.trelloLogin.bind(this),\n        'import': this.trelloImport.bind(this),\n        'save': this.trelloSave.bind(this)\n    };\n\n    this.toodledo =\n    {\n        'login': this.toodledoLogin.bind(this),\n        'import': this.toodledoImport.bind(this),\n        'save': this.toodledoSave.bind(this)\n    };\n}\n\ndimport.prototype = {\n    workflowyLogin: function (username, password, cb, error)\n    {\n        g.Assert(cb, 'Workflowy requires a success callback');\n        g.Assert(error, 'Workflowy requires an error callback');\n\n        g.XHR({\n            type: 'POST',\n            url: window.location.protocol + '//api.moo.do/oauth/workflowy',\n            data: { username: username, password: password },\n            cb: function (xhr)\n            {\n                log('Login Response: ', xhr);\n\n                if (xhr.status === 200)\n                {\n                    this.workflowy.data = JSON.parse(xhr.response);\n\n                    cb();\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    workflowyImport: function (cb, error)\n    {\n        g.Assert(cb, 'Workflowy requires a success callback');\n        g.Assert(error, 'Workflowy requires an error callback');\n\n        cb(this.workflowy.data);\n    },\n    workflowyIterateItem: function (item, parentVMLI)\n    {\n        var IS_COMPLETE_VALUE = 673732;\n        var IS_DEFAULT_VALUE = 139527;\n        var IS_UNKNOWN_VALUE0 = 139529;\n        var IS_UNKNOWN_VALUE1 = 204343;\n        var IS_UNKNOWN_VALUE2 = 673731;\n\n        g.Assert(item && item.lm !== undefined && item.nm !== undefined, 'All items must exist and have flags and text, children and notes are optional', item);\n\n        g.Assert(item.lm === IS_COMPLETE_VALUE || item.lm === IS_DEFAULT_VALUE || item.lm === IS_UNKNOWN_VALUE0 || item.lm === IS_UNKNOWN_VALUE1, 'Unexpected lm value for workflowy import: ' + item.lm);\n\n        g.Assert(parentVMLI, 'A valid parent must always be defined');\n\n        if (item && parentVMLI)\n        {\n            var isComplete = (item.lm === IS_COMPLETE_VALUE);\n\n            var itemVMLI = new VMLI({ text: item.nm, isComplete: isComplete }, { parent: parentVMLI, parse: true, forceSave: true });\n            parentVMLI.insertItem(itemVMLI);\n\n            // Items may have notes\n            if (item.no)\n            {\n                var noteVMLI = new VMLI({ text: item.no }, { parent: itemVMLI, parse: true, forceSave: true });\n                itemVMLI.insertItem(noteVMLI);\n            }\n\n            // Items may also have children\n            if (item.ch)\n            {\n                for (var i = 0; i < item.ch.length; ++i)\n                {\n                    var entry = item.ch[i];\n\n                    this.workflowyIterateItem(entry, itemVMLI);\n                }\n            }\n        }\n    },\n    workflowySave: function (data, cb, error)\n    {\n        g.Assert(data, 'Workflowy requires having valid data');\n        g.Assert(cb, 'Workflowy requires a success callback');\n        g.Assert(error, 'Workflowy requires an error callback');\n\n        var project = data.projectTreeData.mainProjectTreeInfo;\n\n        try\n        {\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            var docRoot = d.getRootModel();\n            g.Assert(docRoot, 'Root item must exist in order to import');\n\n            var impRoot = new VMLI({ text: 'Workflowy Import:' }, { parent: docRoot, parse: true, forceSave: true });\n            docRoot.insertItem(impRoot);\n\n            for (var i = 0; i < project.rootProjectChildren.length; ++i)\n            {\n                var entry = project.rootProjectChildren[i];\n\n                this.workflowyIterateItem(entry, impRoot);\n            }\n\n            g.vmMain.runParseWorker(impRoot);\n\n            tracker.endAction(); // END TRACKER <----\n\n            cb();\n        }\n        catch (err)\n        {\n            error(undefined, err);\n        }\n    },\n    wunderlistLogin: function (username, password, cb, error)\n    {\n        g.Assert(cb, 'Wunderlist requires a success callback');\n        g.Assert(error, 'Wunderlist requires an error callback');\n\n        g.XHR({\n            type: 'POST',\n            url: 'https://api.wunderlist.com/login',\n            data: { email: username, password: password },\n            cb: function (xhr)\n            {\n                log('Login Response: ', xhr);\n\n                if (xhr.status === 200)\n                {\n                    var data = JSON.parse(xhr.response);\n\n                    this.wunderlist.token = data.token;\n\n                    cb(data);\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    wunderlistImport: function (cb, error)\n    {\n        g.Assert(cb, 'Wunderlist requires a success callback');\n        g.Assert(error, 'Wunderlist requires an error callback');\n\n        this.wunderlistGetLists(function (lists)\n        {\n            if (DEBUG) log('Get ListData Response: ', lists);\n\n            this.wunderlistGetTasks(function (tasks)\n            {\n                if (DEBUG) log('Get TaskData Response: ', tasks);\n\n                var data =\n                {\n                    'inbox':\n                    {\n                        title: 'inbox',\n                        items: { },\n                        p: 0\n                    }\n                };\n\n                for (var i = 0; i < lists.length; ++i)\n                {\n                    var list = lists[i];\n\n                    data[list.id] =\n                    {\n                        title: list.title,\n                        items: { },\n                        p: list.position\n                    };\n                }\n\n                for (var i = 0; i < tasks.length; ++i)\n                {\n                    var task = tasks[i];\n\n                    if (task.parent_id)\n                    {\n                        var taskParent = data[task.list_id].items[task.parent_id];\n\n                        if (taskParent)\n                        {\n                            if (!taskParent.items)\n                            {\n                                taskParent.items = [ ];\n                            }\n\n                            taskParent.items.push(task);\n                        }\n                        else\n                        {\n                            data[task.list_id].items[task.parent_id] = { items: [ task ] };\n                        }\n                    }\n                    else\n                    {\n                        var prevData = data[task.list_id].items[task.id];\n\n                        data[task.list_id].items[task.id] = task;\n\n                        if (prevData)\n                        {\n                            data[task.list_id].items[task.id].items = prevData.items;\n                        }\n                    }\n                }\n\n                cb(data);\n            }.bind(this), error);\n        }.bind(this), error);\n    },\n    wunderlistGetLists: function (cb, error)\n    {\n        g.Assert(cb, 'Wunderlist requires a success callback');\n        g.Assert(error, 'Wunderlist requires an error callback');\n\n        g.XHR({\n            type: 'GET',\n            url: 'https://api.wunderlist.com/me/lists',\n            headers: { 'Authorization': this.wunderlist.token },\n            cb: function (xhr)\n            {\n                if (xhr.status === 200)\n                {\n                    var data = JSON.parse(xhr.response);\n\n                    cb(data);\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    wunderlistGetTasks: function (cb, error)\n    {\n        g.Assert(cb, 'Wunderlist requires a success callback');\n        g.Assert(error, 'Wunderlist requires an error callback');\n\n        g.XHR({\n            type: 'GET',\n            url: 'https://api.wunderlist.com/me/tasks',\n            headers: { 'Authorization': this.wunderlist.token },\n            cb: function (xhr)\n            {\n                if (xhr.status === 200)\n                {\n                    var data = JSON.parse(xhr.response);\n\n                    cb(data);\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    wunderlistSave: function (data, cb, error)\n    {\n        g.Assert(cb, 'Wunderlist requires a success callback');\n        g.Assert(error, 'Wunderlist requires an error callback');\n\n        try\n        {\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            var docRoot = d.getRootModel();\n            g.Assert(docRoot, 'Root item must exist in order to import');\n\n            var impRoot = new VMLI({ text: 'Wunderlist Import:' }, { parent: docRoot, parse: true, forceSave: true });\n            docRoot.insertItem(impRoot);\n\n            for (var listId in data)\n            {\n                var list = data[listId];\n                if (DEBUG) log('List: ', list);\n\n                var listText = list.title + (list.title[list.title.length - 1] !== ':' ? ':' : '');\n\n                var listVMLI = new VMLI(\n                {\n                    text: listText\n                },\n                {\n                    parent: impRoot,\n                    parse: true,\n                    forceSave: true\n                });\n                impRoot.insertItem(listVMLI);\n\n                for (var taskId in list.items)\n                {\n                    var task = list.items[taskId];\n                    if (DEBUG) log('  Task: ', task);\n\n                    var taskVMLI = new VMLI(\n                    {\n                        text: task.title,\n                        isComplete: !!task.completed_at,\n                        dateCompleted: task.completed_at,\n                        isFlagged: task.starred\n                    },\n                    {\n                        parent: listVMLI,\n                        parse: true,\n                        forceSave: true\n                    });\n                    listVMLI.insertItem(taskVMLI);\n\n                    if (task.note)\n                    {\n                        var noteVMLI = new VMLI(\n                        {\n                            text: task.note\n                        },\n                        {\n                            parent: taskVMLI,\n                            parse: true,\n                            forceSave: true\n                        });\n                        taskVMLI.insertItem(noteVMLI);\n                    }\n\n                    if (task.items)\n                    {\n                        for (var j = 0; j < task.items.length; ++j)\n                        {\n                            var subtask = task.items[j];\n                            if (DEBUG) log('    SubTask: ', subtask);\n\n                            var subtaskVMLI = new VMLI(\n                            {\n                                text: subtask.title,\n                                isComplete: !!subtask.completed_at,\n                                dateCompleted: subtask.completed_at,\n                                isFlagged: subtask.starred\n                            },\n                            {\n                                parent: taskVMLI,\n                                parse: true,\n                                forceSave: true\n                            });\n                            taskVMLI.insertItem(subtaskVMLI);\n                        }\n                    }\n                }\n            }\n\n            g.vmMain.runParseWorker(impRoot);\n\n            tracker.endAction(); // END TRACKER <----\n\n            cb();\n        }\n        catch (err)\n        {\n            error(undefined, err);\n        }\n    },\n    opmlLogin: function (user, pw, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        cb();\n    },\n    opmlImport: function (cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        try\n        {\n            var fReader = new FileReader();\n\n            var fileImport = document.forms['importFileUpload']['importFile'].files[0];\n\n            if (!fileImport)\n            {\n                error('You must select a file before importing');\n            }\n            else\n            {\n                fReader.onload = function(e)\n                {\n                    var data = e.target.result;\n\n                    var xml;\n                    if (data.startsWith('<?xml ') || data.startsWith('<opml '))\n                    {\n                        xml = g.loadXML(data);\n                    }\n\n                    if (xml)\n                    {\n                        var res = parser.parseOPML(xml, fileImport.name);\n\n                        if (res)\n                        {\n                            cb();\n                        }\n                        else\n                        {\n                            error('Error parsing OPML, please validate your data');\n                        }\n                    }\n                    else\n                    {\n                        error('Unable to load XML lib, please update or try another browser');\n                    }\n                };\n\n                fReader.onerror = error;\n\n                fReader.readAsText(fileImport);\n            }\n        }\n        catch (err)\n        {\n            error(undefined, err);\n        }\n    },\n    opmlSave: function (data, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        log('OPML Save: ', data);\n\n        cb();\n    },\n    jsonLogin: function (user, pw, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        cb();\n    },\n    jsonImport: function (cb, error)\n    {\n        try\n        {\n            var fReader = new FileReader();\n\n            var fileImport = document.forms['importFileUpload']['importFile'].files[0];\n\n            if (!fileImport)\n            {\n                error('You must select a file before importing');\n            }\n            else\n            {\n\n                fReader.onload = function(e)\n                {\n                    var data = e.target.result;\n\n                    if (data)\n                    {\n                        try\n                        {\n                            var parsedObj = JSON.parse(data);\n\n                            var res = parser.parseJSON(parsedObj);\n\n                            if (res)\n                            {\n                                cb();\n                            }\n                            else\n                            {\n                                error('Error parsing JSON, please validate your data');\n                            }\n                        }\n                        catch (errParse)\n                        {\n                            error(undefined, errParse);\n                        }\n                    }\n                    else\n                    {\n                        error('Unable to import your requested file, please try agani');\n                    }\n                };\n\n                fReader.onerror = error;\n\n                fReader.readAsText(fileImport);\n            }\n        }\n        catch (err)\n        {\n            error(undefined, err);\n        }\n    },\n    jsonSave: function (data, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        log('JSON Save: ', data);\n\n        cb();\n    },\n    textLogin: function (user, pw, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        cb();\n    },\n    textImport: function (cb, error)\n    {\n        var data = document.getElementById('importFileDataBox').textContent;\n\n        var xml;\n        if (data.startsWith('<?xml ') || data.startsWith('<opml '))\n        {\n            try\n            {\n                xml = g.loadXML(data);\n\n                if (xml)\n                {\n                    var res = parser.parseOPML(xml, fileImport.name);\n\n                    if (res)\n                    {\n                        cb();\n\n                        return;\n                    }\n                }\n            }\n            catch (errParse)\n            {\n                // Do Nothing\n            }\n        }\n\n        if (data.startsWith('{') && data.endsWith('}'))\n        {\n            try\n            {\n                var parsedObj = JSON.parse(data);\n\n                var res = parser.parseJSON(parsedObj);\n\n                if (res)\n                {\n                    cb();\n\n                    return;\n                }\n            }\n            catch (errParse)\n            {\n                // Do Nothing\n            }\n        }\n\n        error('Text Import Not Supported');\n        // TODO: Refactor copypaste code to allow reuse of text import\n    },\n    textSave: function (data, cb, error)\n    {\n        g.Assert(cb, 'OPML requires a success callback');\n        g.Assert(error, 'OPML requires an error callback');\n\n        log('Text Save: ', data);\n\n        cb();\n    },\n    gtasksLogin: function (username, password, cb, error)\n    {\n        g.Assert(cb, 'GTasks requires a success callback');\n        g.Assert(error, 'GTasks requires an error callback');\n\n        goog.runAuthenticate([ GScope.TasksRO ], false, false, function(token)\n        {\n            if (token && !token.error)\n            {\n                this.gtasks.token = token;\n\n                cb(token);\n            }\n            else\n            {\n                error('Unable to authenticate with Google, please try again', token);\n            }\n        }.bind(this));\n    },\n    gtasksImport: function (cb, error)\n    {\n        g.Assert(cb, 'GTasks requires a success callback');\n        g.Assert(error, 'GTasks requires an error callback');\n\n        var info = { \n            roots: [ ],\n            remoteItems: { },\n            unassigned: [ ]\n        };\n\n        this.gtasksGetLists(function (listData)\n        {\n            g.Assert(g.isArray(listData), 'List data must be an array');\n\n            //log('GTask List Data: ', listData);\n\n            for (var i = 0; i < listData.length; ++i)\n            {\n                var list = listData[i];\n\n                //log(' -- List: ' + list.title + ' --');\n\n                info.remoteItems[list.id] =\n                {\n                    id: list.id,\n                    text: list.title,\n                    isComplete: false,\n                    dateCompleted: undefined,\n                    isArchived: false,\n                    due: undefined,\n                    notes: undefined,\n                    parent: undefined,\n                    items: [ ]\n                };\n\n                info.roots.push(list.id);\n\n                this.gtasksGetTasks(list, function (taskData)\n                {\n                    g.Assert(g.isArray(taskData), 'List data must be an array');\n\n                    for (var j = 0; j < taskData.length; ++j)\n                    {\n                        var task = taskData[j];\n\n                        info.remoteItems[task.id] =\n                        {\n                            id: task.id,\n                            text: task.title,\n                            isComplete: task.status === 'completed',\n                            dateCompleted: task.completed ? new Date(task.completed) : undefined,\n                            isArchived: task.hidden,\n                            due: task.due ? new Date(task.due) : undefined,\n                            notes: task.notes,\n                            parent: task.parent || list.id,\n                            items: [ ]\n                        };\n\n                        var parent = info.remoteItems[task.parent || list.id];\n\n                        if (parent)\n                        {\n                            parent.items.push(task.id);\n                        }\n                        else\n                        {\n                            info.unassigned.push(task.id);\n                        }\n\n                        //log('  Task: ', task);\n                    }\n\n                    cb(info);\n                }.bind(this), error);\n            }\n        }.bind(this), error);\n    },\n    gtasksGetLists: function (cb, error)\n    {\n        g.Assert(cb, 'GTasks requires a success callback');\n        g.Assert(error, 'GTasks requires an error callback');\n\n        var maxResults = 2000;\n        g.XHR({\n            type: 'GET',\n            url: 'https://www.googleapis.com/tasks/v1/users/@me/lists?maxResults=' + maxResults + '&key=' + window.gapiKey + '&access_token=' + goog.getAccessToken(),\n            cb: function (xhr)\n            {\n                if (xhr.status === 200)\n                {\n                    var data = JSON.parse(xhr.response);\n                    g.Assert(data.items, 'Must have a valid array of lists');\n\n                    cb(data.items);\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    gtasksGetTasks: function (list, cb, error)\n    {\n        g.Assert(list, 'GTasks requires a valid list to get tasks from');\n        g.Assert(cb, 'GTasks requires a success callback');\n        g.Assert(error, 'GTasks requires an error callback');\n\n        var maxResults = 5000;\n        g.XHR({\n            type: 'GET',\n            url: 'https://www.googleapis.com/tasks/v1/lists/' + list.id + '/tasks?maxResults=' + maxResults + '&key=' + window.gapiKey + '&access_token=' + goog.getAccessToken(),\n            cb: function (xhr)\n            {\n                if (xhr.status === 200)\n                {\n                    var data = JSON.parse(xhr.response);\n                    g.Assert(data.items, 'Must have a valid array of tasks');\n\n                    cb(data.items);\n                }\n                else\n                {\n                    log('XHR Status: ' + xhr.status);\n\n                    error('Error contacting remote server.');\n                }\n            }.bind(this)\n        });\n    },\n    gtasksSave: function (data, cb, error)\n    {\n        g.Assert(cb, 'GTasks requires a success callback');\n        g.Assert(error, 'GTasks requires an error callback');\n\n        try \n        {\n            g.Assert(data.unassigned.length === 0, 'We should never have unassigned tasks');\n\n            tracker.beginAction(); // BEGIN TRACKER <----\n\n            var docRoot = d.getRootModel();\n            g.Assert(docRoot, 'Root item must exist in order to import');\n\n            var impRoot = new VMLI({ text: 'Google Tasks Import:' }, { parent: docRoot, parse: true, forceSave: true });\n            docRoot.insertItem(impRoot);\n\n            function traverse(node, parentVMLI)\n            {\n                var itemText = node.text;\n\n                if (node.due)\n                {\n                    itemText += ' ' + node.due.toString('MM/dd h:mm');\n                }\n\n                var itemVMLI = new VMLI(\n                {\n                    text: itemText,\n                    isComplete: node.isComplete,\n                    dateCompleted: node.dateCompleted ? node.dateCompleted.getTime() : node.dateCompleted,\n                    isArchived: node.isArchived\n                },\n                {\n                    parent: parentVMLI,\n                    parse: true,\n                    forceSave: true\n                });\n                parentVMLI.insertItem(itemVMLI);\n\n                if (node.notes)\n                {\n                    var notesVMLI = new VMLI(\n                    {\n                        text: node.notes\n                    },\n                    {\n                        parent: itemVMLI,\n                        parse: true,\n                        forceSave: true\n                    });\n                    itemVMLI.insertItem(notesVMLI);\n                }\n\n                for (var i = 0; i < node.items.length; ++i)\n                {\n                    traverse(data.remoteItems[node.items[i]], itemVMLI);\n                }\n            }\n\n            for (var i = 0; i < data.roots.length; ++i)\n            {\n                traverse(data.remoteItems[data.roots[i]], impRoot);\n            }\n\n            g.vmMain.runParseWorker(impRoot);\n\n            tracker.endAction(); // END TRACKER <----\n\n            cb();\n        }\n        catch (err)\n        {\n            error(undefined, err);\n        }\n    },\n    trelloLogin: function (username, password, cb, error)\n    {\n        var appKey = '667ecf0c3d3e029c51d205b7173f6c38';\n\n        function trelloAuthSuccess()\n        {\n            debugger;\n\n            Trello.members('me', function ()\n            {\n\n            }, error);\n        }\n\n        function trelloAuthError()\n        {\n            debugger;\n\n            error();\n        }\n\n        g.addScript('http://code.jquery.com/jquery-1.7.1.min.js', 'jqueryScript', function ()\n        {\n            g.addScript('https://api.trello.com/1/client.js?key=' + appKey, 'trelloScript', function()\n            {\n                g.Assert(Trello, 'The Trello client lib musthave been loaded correctly');\n\n                Trello.authorize({\n                    type: 'popup',\n                    name: 'Moo.do',\n                    persist: false,\n                    expiration: '1hour',\n                    success: trelloAuthSuccess,\n                    error: trelloAuthError\n                });\n            }.bind(this));\n        }.bind(this));\n    },\n    trelloImport: function (cb, error)\n    {\n\n    },\n    trelloSave: function (data, cb, error)\n    {\n\n    },\n    toodledoLogin: function (username, password, cb, error)\n    {\n        var clientID = 'DuchessToodledoClientID';\n\n        var state = 'Dchs' + (new Date()).getTime();\n\n        var url = 'https://api.toodledo.com/3/account/authorize.php?response_type=code&client_id=' + clientID + '&state=' + state + '&scope=basic%20tasks%20notes%20outlines%20lists';\n\n        var popup = window.open(url, 'toodledo', 'height=600,width=550');\n\n        var handleRelayMessage = function (e)\n        {\n            // TODO: Fix location.origin to work cross platform.\n            var validOrigin = (e.origin === location.origin);\n\n            if (validOrigin)\n            {\n                window.removeEventListener('message', handleRelayMessage);\n\n                if (e.data.error)\n                {\n                    error(e.data.error);\n                }\n                else\n                {\n                    this.toodledo.token = e.data.access_token;\n\n                    cb();\n                }\n            }\n        }.bind(this);\n\n        window.addEventListener('message', handleRelayMessage);\n    },\n    toodledoImport: function (cb, error)\n    {\n\n    },\n    toodledoSave: function (data, cb, error)\n    {\n\n    }\n};\n\nreturn dimport;\n});","asserts":[{"tag":1395,"offset":1618},{"tag":1396,"offset":1681},{"tag":1397,"offset":2456},{"tag":1398,"offset":2519},{"tag":1399,"offset":2885},{"tag":1400,"offset":3047},{"tag":1401,"offset":3251},{"tag":1402,"offset":4225},{"tag":1403,"offset":4289},{"tag":1404,"offset":4352},{"tag":1405,"offset":4612},{"tag":1406,"offset":5345},{"tag":1407,"offset":5409},{"tag":1408,"offset":6210},{"tag":1409,"offset":6274},{"tag":1410,"offset":8502},{"tag":1411,"offset":8566},{"tag":1412,"offset":9273},{"tag":1413,"offset":9337},{"tag":1414,"offset":10046},{"tag":1415,"offset":10110},{"tag":1416,"offset":10306},{"tag":1417,"offset":13491},{"tag":1418,"offset":13549},{"tag":1419,"offset":13674},{"tag":1420,"offset":13732},{"tag":1421,"offset":15275},{"tag":1422,"offset":15333},{"tag":1423,"offset":15502},{"tag":1424,"offset":15560},{"tag":1425,"offset":17279},{"tag":1426,"offset":17337},{"tag":1427,"offset":17506},{"tag":1428,"offset":17564},{"tag":1429,"offset":18912},{"tag":1430,"offset":18970},{"tag":1431,"offset":19151},{"tag":1432,"offset":19211},{"tag":1433,"offset":19707},{"tag":1434,"offset":19767},{"tag":1435,"offset":20008},{"tag":1436,"offset":20853},{"tag":1437,"offset":22294},{"tag":1438,"offset":22354},{"tag":1439,"offset":22828},{"tag":1440,"offset":23220},{"tag":1441,"offset":23294},{"tag":1442,"offset":23354},{"tag":1443,"offset":23840},{"tag":1444,"offset":24228},{"tag":1445,"offset":24288},{"tag":1446,"offset":24378},{"tag":1447,"offset":24575},{"tag":1448,"offset":27149}]},"VMTimeline":{"path":"F:/p/bce/Duchess/public/js/VMTimeline.js","data":"define(['ko', 'globals', 'platform', 'data'],\nfunction (ko, g, platform, d) {\nfunction VMTimeline(p)\n{\n    // this.nextItemVisible = false;\n    // this.nextItem = ko.observable();\n    this.itemsToSchedule = {};\n    this.scheduleTimeout = 0;\n}\n\nVMTimeline.prototype = {\n    // isItemNexter: function(item, oldItem)\n    // {\n    //     if (this.nextItemVisible)\n    //     {\n    //         // Complete is invalid\n    //         if(item.isComplete())\n    //             return false;\n\n    //         var date = item.date();\n\n    //         // No date is invalid\n    //         if(date === undefined)\n    //             return false;\n    //         // Explicit date in past is invalid\n    //         if(date._explicitTime && date < Date.now())\n    //             return false;\n    //         // Day in past is invalid\n    //         if(!date._explicitTime && date < Date.today())\n    //             return false;\n\n    //         // No old item\n    //         if(!oldItem)\n    //             return true;\n\n    //         var oldDate = oldItem.date();\n\n    //         // No date means the new item is nexter\n    //         if (oldDate === undefined)\n    //             return true;\n\n    //         // New and old are the same day but new has explicit time\n    //         if(date._explicitTime && !oldDate._explicitTime && date.isSameDay(oldDate))\n    //             return true;\n    //         // New is a day and old is a time and new is newer\n    //         if(!date._explicitTime && oldDate._explicitTime && !date.isSameDay(oldDate) && date < oldDate)\n    //             return true;\n    //         // New is newer than old\n    //         if(date._explicitTime == oldDate._explicitTime && date < oldDate)\n    //             return true;\n    //     }\n\n    //     return false;\n    // },\n    // findNextItem: function()\n    // {\n    //     if (this.nextItemVisible)\n    //     {\n    //         var self = this;\n    //         // Search all items for the best match\n    //         var bestMatch;\n    //         g.searchVMLIs({\n    //             item: g.vmMain.root(),\n    //             includeArchived: false,\n    //             each: function(item)\n    //             {\n    //                 if(self.isItemNexter(item, bestMatch))\n    //                 {\n    //                     bestMatch = item;\n    //                 }\n    //             }\n    //         });\n\n    //         this.nextItem(bestMatch);\n    //     }\n    // },\n    // updateNextItem: function(item)\n    // {\n    //     if (this.nextItemVisible)\n    //     {\n    //         // Next item is changing so we need to check against all\n    //         // TODO: Could cache the next best item so we don't have to search again\n    //         if(item == this.nextItem())\n    //         {\n    //             this.findNextItem();\n    //         }\n    //         // Compare against next item\n    //         else if(this.isItemNexter(item, this.nextItem()))\n    //         {\n    //             this.nextItem(item);\n    //         }\n    //     }\n    // },\n    // itemToJSON: function(item)\n    // {\n    //     return '{\"id\":\"' + item.id + '\",' +\n    //             '\"text\":\"' + item.getRawText() + '\",' +\n    //             '\"date\":\"' + item.date().toJSON() + '\"}';\n    // },\n    shouldNotify: function(item, now)\n    {\n        if(!now)\n            now = new Date();\n\n        return !item.isComplete() && item.date() && item.date() > now && !item.allDayDate && !item.isArchived();\n    },\n    updateNotifications: function(item)\n    {\n        if ((platform.ios || platform.android) && platform.app && !g.isDemoMode() && g.vmSettings.enabledNotifications())\n        {\n            var num = 0;\n            var now = new Date();\n            if (item)\n            {\n                if(this.shouldNotify(item, now))\n                {\n                    this.itemsToSchedule[item.id] = item;\n                    num = 1;\n                }\n            }\n            else\n            {\n                var self = this;\n\n                g.searchVMLIs({\n                    item: g.vmMain.root(),\n                    includeArchived: false,\n                    comparator: function(item)\n                    {\n                        return self.shouldNotify(item, now);\n                    },\n                    action: function(item)\n                    {\n                        num ++;\n                        self.itemsToSchedule[item.id] = item;\n                    }\n                });\n            }\n\n            if (this.scheduleTimeout)\n            {\n                clearTimeout(this.scheduleTimeout);\n            }\n\n            if (num > 0)\n            {\n                this.scheduleTimeout = setTimeout(this.sendNotifications.bind(this), 500);\n            }\n        }\n    },\n    clearNotifications: function()\n    {\n        platform.sendToApp('scheduledItems', '[]');\n    },\n    sendNotifications: function()\n    {\n        var json = '[';\n        var first = true;\n\n        for (var prop in this.itemsToSchedule)\n        {\n            if (this.itemsToSchedule.hasOwnProperty(prop))\n            {\n                var item = this.itemsToSchedule[prop];\n\n                if (item.date())\n                {\n                    //log('schedule', item.date(), item.allDayDate);\n\n                    if (!first)\n                    {\n                        json += ',';\n                    }\n\n                    json += item.getBasicJSON();\n                    first = false;\n                }\n            }\n        }\n\n        json += ']';\n        platform.sendToApp('scheduledItems', json);\n        this.itemsToSchedule = {};\n    },\n    notifyPositionChanged: function(item)\n    {\n        for (var i = 0; i < g.vmMain.panes().length; ++i)\n        {\n            g.vmMain.panes()[i].notifyPositionChanged(item);\n        }\n    },\n    notifyStateChanged: function(item, type)\n    {\n        if (item.date() && type == PropChangeType.Date)\n        {\n            this.dateUpdated(item);\n        }\n        else\n        {\n            for (var i = 0; i < g.vmMain.panes().length; ++i)\n            {\n                g.vmMain.panes()[i].notifyStateChanged(item, type);\n            }\n        }\n    },\n    dateUpdated: function(item)\n    {\n        //console.log('Date Updated: ', model.date());\n\n        // If we are removing the current next item, ensure that we replaced it with something\n        if (g.vmMain.root())\n        {\n            // this.updateNextItem(item);\n            this.updateNotifications(item);\n        }\n\n        for (var i = 0; i < g.vmMain.panes().length; i ++)\n        {\n            g.vmMain.panes()[i].notifyStateChanged(item, PropChangeType.Date);\n        }\n    },\n    reloadTimelines: function()\n    {\n        for (var i = 0; i < g.vmMain.panes().length; i ++)\n        {\n            g.vmMain.panes()[i].reloadTimeline();\n        }\n    },\n    load: function()\n    {\n        // if (document.getElementById('timelineNext'))\n        // {\n        //     g.Assert(!platform.mobile, 'Timeline should never be updated on mobile');\n        //     ko.applyBindings(this, document.getElementById('timelineNext'));\n        //     this.nextItemVisible = true;\n\n            // this.findNextItem();\n        // }\n    },\n    // onTapNext: {\n    //     onStart: function(e) {\n    //         // Ignore has to be reset to false since it was set to true in VMLI or it won't fire the end event.\n    //         // e.ignore = false;\n    //         // this.capture = self;\n    //     },\n    //     onClick: function(e) {\n    //         g.scrollIntoView(this.nextItem().getSpan(), 200);\n    //         this.nextItem().highlight();\n    //     }\n    // },\n    startLoading: function()\n    {\n        for (var i = 0; i < g.vmMain.panes().length; i ++)\n        {\n            g.vmMain.panes()[i].startLoading();\n        }\n    },\n    endLoading: function()\n    {\n        for (var i = 0; i < g.vmMain.panes().length; i ++)\n        {\n            g.vmMain.panes()[i].endLoading();\n        }\n    }\n};\n\nreturn VMTimeline;\n});\n","asserts":[{"tag":1451,"offset":6917}]},"VMMessageQueue":{"path":"F:/p/bce/Duchess/public/js/VMMessageQueue.js","data":"define(['ko', 'globals', 'util', 'platform', 'data', 'VMMessage'],\nfunction (ko, g, util, platform, d, VMMessage) {\n\n//\n// Messages can contain the following fields and are a plan object. They should not contain a 'clear' field\n// as this is used internally. At some point we should switch to using a 'createMessage' function on the queue\n// which would return a valid message object instead of directly passing in any old object.\n//\n// text: The message text to display.\n// type: The type of message, defined in window.MessageType. This affects the styling of the message.\n// action: What to do when the message itself is clicked/tapped (not ignored).\n// block: Prevent further interaction with the app until the user has refreshed the page.\n//\n\nfunction VMMessageQueue()\n{\n\tthis.queue = ko.observableArray();\n    this.remoteMessages = { };\n\n    this.defaultMessages = [ ];\n    this.defaultMessages[MessageID.Undefined] = undefined;\n\n\n    this.hasConnectionError = false;\n    this.hasFatalError = false;\n    this.hasDocChange = false;\n    this.hasOfflineWarning = false;\n    this.hasOnlineInfo = false;\n    this.hasCacheReset = false;\n    this.hasRequiredUpdate = false;\n\n    this.currentFilter = 0x0;\n\n    this.FilterType =\n    {\n        Mobile:         0x1,\n        Desktop:        0x2,\n        App:            0x4,\n    };\n\n    this.init();\n}\n\nVMMessageQueue.prototype = {\n    init: function ()\n    {\n        // setTimeout(function ()\n        // {\n            //g.removeClass(document.getElementById('overlayArea'), 'notVisible');\n\n            // this.pushMessage({\n            //     text: 'Debug message to test the message queue.',\n            //     type: MessageType.Fatal,\n            //     action: MessageAction.Refresh\n            // });\n        //}.bind(this), 100);\n\n        g.applyBindings(this, 'overlayArea');\n\n        if (!platform.demo && !DEBUG && !platform.offline)\n        {\n            setTimeout(this.updateRemoteMessages.bind(this), 5000);\n        }\n\n        this.computeFilter();\n    },\n    getMessageById: function(id)\n    {\n        if (this.defaultMessages[id] === undefined)\n        {\n            this.initMessageByid(id);\n        }\n\n        g.Assert(this.defaultMessages[id] !== undefined, 'After init message should always be defined');\n\n        return this.defaultMessages[id];\n    },\n    testMessageById: function(id)\n    {\n        return !!this.defaultMessages[id];\n    },\n    initMessageByid: function(id)\n    {\n        switch (id)\n        {\n            case MessageID.ConnectionError:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'Connection error detected, ' + platform.actionVerb() + ' here to reconnect.',\n                    type: MessageType.Error,\n                    action: MessageAction.Reload\n                }, this);\n                break;\n            case MessageID.OfflineUndo:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'Offline undo/redo has been disabled temporarily',\n                    type: MessageType.Info\n                }, this);\n                break;\n\n            case MessageID.DriveError:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'There was an error connecting to Google Drive. Moo.do will reconnect automatically when Google Drive is available.',\n                    type: MessageType.Error,\n                    action: MessageAction.None\n                }, this);\n                break;\n\n            case MessageID.FatalError:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'There was a fatal error in the application, ' + platform.actionVerb() + ' here to restart.',\n                    type: MessageType.Error,\n                    action: MessageAction.Reload\n                }, this);\n                break;\n            case MessageID.DocChange:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'The active document was changed in another tab, ' + platform.actionVerb() + ' here to restart.',\n                    type: MessageType.Fatal,\n                    action: MessageAction.Reload,\n                    block: true\n                }, this);\n                break;\n\n            case MessageID.OfflineWarn:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'You are offline and not saving your changes locally or remotely, you must reconnect before closing the window or you will lose your changes.',\n                    type: MessageType.Warning\n                }, this);\n                break;\n\n            case MessageID.OnlineInfo:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'You have gone back online, your changes have been saved.',\n                    type: MessageType.Info,\n                    timeout: 10000\n                }, this);\n                break;\n\n            case MessageID.CacheReset:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'To fix your issues we are going to clear the local cache. This will reload the page and your data, ' + platform.actionVerb() + ' here to continue.',\n                    type: MessageType.Info,\n                    action: MessageAction.ResetClient\n                }, this);\n                break;\n\n            case MessageID.RequiredUpdate:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'A software update is required to continue, ' + platform.actionVerb() + ' to update.',\n                    type: MessageType.RequiredUpdate,\n                    action: MessageAction.Reload,\n                    block: true\n                }, this);\n                break;\n\n            case MessageID.Updated:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'An update was installed. ' + platform.actionVerbCaps() + ' to reload.',\n                    type: MessageType.RequiredUpdate,\n                    action: MessageAction.Reload,\n                    bottom: true\n                }, this);\n                break;\n\n            case MessageID.MobileOffline:\n                this.defaultMessages[id] = new VMMessage({\n                    text: 'OFFLINE',\n                    type: MessageType.MobileOffline,\n                    action: MessageAction.None,\n                    bottom: true\n                }, this);\n                break;\n            default:\n                g.Assert(false, 'Invalid MessageID');\n                break;\n        }\n    },\n    pushMessage: function (msg)\n    {\n        var vmMsg;\n        if (msg instanceof VMMessage)\n        {\n            vmMsg = msg;\n        }\n        else if (g.isObject(msg))\n        {\n            vmMsg = new VMMessage(msg, this);\n        }\n        else if (g.isString(msg))\n        {\n            vmMsg = new VMMessage({ text: msg }, this);\n        }\n        else\n        {\n            vmMsg = this.getMessageById(msg);\n\n            if (!vmMsg)\n            {\n                g.Assert(false, 'Invalid data passed to message creation');\n\n                log('Message not created properly', msg);\n            }\n        }\n\n        if (vmMsg)\n        {\n            vmMsg.show();\n        }\n\n        return vmMsg;\n    },\n    clearMessage: function(msg)\n    {\n        var vmMsg;\n        if (msg instanceof VMMessage)\n        {\n            vmMsg = msg;\n        }\n        else\n        {\n            if (this.testMessageById(msg))\n            {\n                vmMsg = this.getMessageById(msg);\n            }\n        }\n\n        if (vmMsg)\n        {\n            vmMsg.hide();\n        }\n\n        return vmMsg;\n    },\n    onMessageShow: function(msg)\n    {\n        this.queue.push(msg);\n    },\n    onMessageHide: function(msg)\n    {\n        g.Assert(msg, 'Must pass in a valid message to be removed from the queue');\n\n        var index = this.queue.indexOf(msg);\n        if (index < 0)\n        {\n            g.Assert(false, 'Trying to remove an invalid message from the queue');\n            return;\n        }\n\n        this.queue.splice(index, 1);\n    },\n    // clearMessages: function ()\n    // {\n    //     var q = this.queue();\n    //     for (var i = 0; i < q.length; ++i)\n    //     {\n    //         q[i].hide(/*noNotify*/true);\n    //     }\n\n    //     this.queue([]);\n    // },\n    // replaceMessagesWith: function(msg)\n    // {\n    //     var q = this.queue();\n\n    //     for (var i = 0; i < q.length; ++i)\n    //     {\n    //         q[i].hide(/*noNotify*/true);\n    //     }\n\n    //     this.queue([msg]);\n\n    //     return msg;\n    // },\n\n    //\n    // Remote Messages\n    //\n\n    computeFilter: function ()\n    {\n        if (platform.isMobile) { this.currentFilter |= this.FilterType.Mobile; }\n        if (!platform.isMobile) { this.currentFilter |= this.FilterType.Desktop; }\n        if (platform.app) { this.currentFilter |= this.FilterType.App; }\n    },\n\n    updateRemoteMessages: function()\n    {\n        if (!g.isDemoMode())\n        {\n            var lastMessageSync = g.settings.get(Settings.lastMessageSync);\n\n            var syncDateString = '';\n            if (lastMessageSync)\n            {\n                syncDateString = '?lastSync=' + new Date(lastMessageSync).toString(\"yyyy-MM-ddTHH:mm:ss\");\n            }\n\n            var newSyncTime = new Date();\n\n            g.XHR({\n                type: 'GET',\n                url: window.location.protocol + '//api.moo.do/debug/getMessages' + syncDateString,\n                cb: function (xhr)\n                {\n                    if (xhr.status === 200)\n                    {\n                        g.settings.set(Settings.lastMessageSync, newSyncTime);\n\n                        var messageData = JSON.parse(xhr.responseText);\n\n                        if (messageData)\n                        {\n                            var messages = messageData.m;\n                            for (var i = 0; messages && i < messages.length; ++i)\n                            {\n                                var newMsg = messages[i];\n\n                                var currentMessage = this.remoteMessages[newMsg.id];\n\n                                if (!currentMessage)\n                                {\n                                    var showMessage = true;\n\n                                    if (newMsg.filter)\n                                    {\n                                        showMessage = ((newMsg.filter & this.currentFilter) !== 0);\n\n                                        log('Remote Message Filter: ' + newMsg.filter + ' ' + this.currentFilter + ' ' + showMessage);\n                                    }\n\n                                    if (showMessage)\n                                    {\n                                        this.pushMessage({\n                                            text: newMsg.data,\n                                            type: newMsg.type,\n                                            action: MessageAction.Default\n                                        });\n                                    }\n\n                                    this.remoteMessages[newMsg.id] = newMsg;\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        log('Unable to get remote messages', xhr);\n                    }\n                }.bind(this)\n            });\n        }\n    }\n};\n\nreturn VMMessageQueue;\n});","asserts":[{"tag":1454,"offset":2171},{"tag":1455,"offset":6480},{"tag":1456,"offset":7032},{"tag":1457,"offset":7784},{"tag":1458,"offset":7951}]},"VMMessage":{"path":"F:/p/bce/Duchess/public/js/VMMessage.js","data":"define(['ko', 'globals', 'util', 'data'],\nfunction (ko, g, util, d)\n{\n\nfunction VMMessage(info, queue)\n{\n    this.id = info.id;\n\n    this.owner = queue;\n\n    this.text = info.text;\n    this.type = info.type || MessageType.Info;\n    this.action = info.action || MessageAction.Default;\n    this.block = info.block || false;\n    this.bottom = info.bottom || false;\n\n    this.onCloseFn = info.onClose;\n\n    this.timeout = info.timeout;\n    this.clearTimeout = undefined;\n\n    this._isVisible = false;\n}\n\nVMMessage.prototype =\n{\n    show: function()\n    {\n        if (!this._isVisible)\n        {\n            this._isVisible = true;\n\n            if (this.timeout)\n            {\n                this.clearTimeout = setTimeout(this.hide.bind(this), this.timeout);\n            }\n\n            if (this.block)\n            {\n                g.removeClass(document.getElementById('overlayBlocker'), 'none');\n            }\n\n            this.owner.onMessageShow(this);\n        }\n    },\n    hide: function(noNotify)\n    {\n        if (this._isVisible)\n        {\n            this._isVisible = false;\n\n            clearTimeout(this.clearTimeout);\n            this.clearTimeout = undefined;\n\n            if (this.onCloseFn)\n            {\n                this.onCloseFn(this);\n            }\n\n            if (!noNotify)\n            {\n                this.owner.onMessageHide(this);\n            }\n        }\n    },\n    isVisible: function()\n    {\n        return this._isVisible;\n    },\n    getClass: function()\n    {\n        var cls;\n\n        switch (this.type)\n        {\n            case MessageType.Info:\n                cls = 'messageInfo'; break;\n            case MessageType.Intro:\n                cls = 'messageIntro'; break;\n            case MessageType.Warning:\n                cls = 'messageWarning'; break;\n            case MessageType.Error:\n                cls = 'messageError'; break;\n            case MessageType.Fatal:\n                cls = 'messageFatal'; break;\n            case MessageType.Subtitle:\n                cls = 'messageSubtitle'; break;\n            case MessageType.RequiredUpdate:\n                cls = 'messageRequiredUpdate'; break;\n            case MessageType.InfoGray:\n                cls = 'messageInfoGray'; break;\n                case MessageType.MobileOffline:\n                cls = 'messageMobileOffline'; break;\n            default:\n                g.Assert(false, 'Invalid message type, add to globals.js');\n                cls = 'messageInfo'; break;\n        }\n\n        if (this.bottom)\n        {\n            cls += ' bottom';\n        }\n\n        return cls;\n    },\n    doAction: function(e)\n    {\n        if (this.isVisible())\n        {\n            if (g.isFunction(this.action))\n            {\n                this.action();\n            }\n            else\n            {\n                switch (this.action)\n                {\n                    case MessageAction.Default:\n                        this.hide();\n                        break;\n                    case MessageAction.Reload:\n                        g.reload();\n                        this.hide();\n                        break;\n                    case MessageAction.Login:\n                        util.removeURLParam('demo');\n                        this.hide();\n                        break;\n                    case MessageAction.Demo:\n                        util.insertURLParam('demo', 'true');\n                        this.hide();\n                        break;\n                    case MessageAction.ResetClient:\n                        d.clearData(function ()\n                        {\n                            g.reload();\n                        });\n                        this.hide();\n                        break;\n                    case MessageAction.None:\n                        // Do Nothing\n                        break;\n                    default:\n                        g.Assert(false, 'Invalid message action, add a new case here or pass in a function', this.action);\n                        this.hide();\n                        break;\n                }\n            }\n\n            e.preventDefault();\n            e.stopImmediatePropagation();\n\n            e.returnFalse = true;\n        }\n    },\n    onTapIgnore:\n    {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            if (this.isVisible())\n            {\n                this.hide();\n\n                e.preventDefault();\n                e.stopImmediatePropagation();\n\n                e.returnFalse = true;\n            }\n        }\n    }\n};\n\nreturn VMMessage;\n\n});","asserts":[{"tag":1452,"offset":2366},{"tag":1453,"offset":3881}]},"TemplateCache":{"path":"F:/p/bce/Duchess/public/js/TemplateCache.js","data":"'use strict';\ndefine(['ko', 'globals'],\nfunction (ko, g) {\n    window.__TOTAL_TEMPLATES = 0;\n\n    var self = { };\n\n    var cachedTemplatesDomDataKey = \"__cached_template__\";\n\n    //\n    // When rendering a template, a source is what returns either the text or the already-created DOM\n    // nodes to clone. The default implementation of a template source in knockout doesn't cache the\n    // DOM nodes that it creates, and instead requests the text of the <script> tag the template is\n    // defined in and parses it as HTML. This is inefficient, and it is much better to cache and clone\n    // the nodes.\n    //\n    // This part is responsible for cahing the DOM nodes on the <script> tag that corresponds with the\n    // template definition the first time the template is requested.\n    //\n    self.templateSources = function (domElem)\n    {\n        // Note: This inherits from the domElement template source. This gives basic storage of the\n        //       corresponding dom element for the template.\n        var templateSources = {\n            'elem': domElem,\n            '__proto__': new ko.templateSources.domElement(domElem)\n        };\n\n        // Return the HTML of the template directly, used the first time that DOM nodes are requested\n        // to be parsed and create the nodes.\n        templateSources.text = function (value)\n        {\n            if (arguments.length === 0)\n            {\n                return templateSources.elem.text;\n            }\n            else\n            {\n                templateSources.elem.text = value;\n            }\n        };\n\n        // Return the DOM nodes that correspond to this template source. The first time this is called,\n        // the text of the <script> tag for the template is parsed and the DOM nodes are generated and\n        // cached on the element.\n        templateSources.nodes = function (value)\n        {\n            g.Assert(arguments.length === 0);\n\n            if (arguments.length === 0)\n            {\n                // Grab the cached data from the <script> tag. This may not exist yet.\n                var templateData = ko.utils.domData.get(templateSources.elem, cachedTemplatesDomDataKey);\n\n                // If the cached data doesn't exist yet, create it.\n                if (!templateData)\n                {\n                    //console.log('Creating Cached Template: ', templateSources.elem);\n\n                    // Strip all endlines and spaces before < characters\n                    var templateText = templateSources.text().replace(/(\\r\\n|\\n|\\r|\\s*(?=<)|\\s*$)/gm,'');\n                    var parsedNodes = ko.utils.parseHtmlFragment(templateText);\n\n                    // Wrap the parsed DOM nodes in a div. This can be any element type, but the topmost node\n                    // in the tree is consumed by KO and not rendered as part of the template.\n                    var compiledNodes = document.createElement(\"div\");\n                    for(var i = 0; i < parsedNodes.length; i ++)\n                    {\n                        compiledNodes.appendChild(parsedNodes[i]);\n                    }\n\n                    ko.utils.domData.set(templateSources.elem, cachedTemplatesDomDataKey, {cachedNodes: compiledNodes});\n\n                    return compiledNodes;\n                }\n\n                return templateData.cachedNodes;\n            }\n        };\n\n        return templateSources;\n    };\n\n    //\n    // Since we want to use the caching template source above for all of our templates, ensure that\n    // when the rendering engine creates the input DOM nodes to render the template, that it uses\n    // the caching source that we defined above. Additionally, this is responsible for caching the\n    // document and template nodes to avoid multiple lookups in the DOM every time a template is\n    // rendered.\n    //\n    self.templateEngine = function ()\n    {\n        // Note: This inherits all the default behavior of the template engine that comes with KO except\n        //       for how the template sources are created..\n        var templateEngine = {\n            '__proto__': new ko.nativeTemplateEngine()\n        };\n\n        templateEngine.cachedDoc = undefined;\n\n        // The returned templateSource is used to render the template.\n        templateEngine.makeTemplateSource = function (template, templateDocument)\n        {\n            g.Assert(typeof template == \"string\");\n\n            var incomingDoc = templateDocument || document;\n\n            var cachedDoc = templateEngine.cachedDoc;\n            if (!templateEngine.cachedDoc)\n            {\n                g.Assert(incomingDoc);\n\n                // If this is the first time we are being called, cache the doc. This assumes that all\n                // templates are loaded from the same document!\n                cachedDoc = {\n                    'doc': incomingDoc,\n                    'cachedTemplates': { }\n                };\n\n                templateEngine.cachedDoc = cachedDoc;\n            }\n\n            g.Assert(cachedDoc);\n\n            // See if we have previously cached the <script> element that corresponds with this template, if\n            // we haven't, cache it, create a new source for it, and continue.\n            var elem = cachedDoc.cachedTemplates[template];\n            if (!elem)\n            {\n                var domElem = cachedDoc.doc.getElementById(template);\n                g.Assert(domElem);\n\n                if (!domElem)\n                {\n                    g.reportError(new Error('Unable to find element for template \"' + template + '\". ' + domElem));\n                }\n                else\n                {\n                    try\n                    {\n                        elem = new self.templateSources(domElem);\n                        g.Assert(elem);\n                    }\n                    catch (err)\n                    {\n                        g.reportError(err);\n                    }\n                }\n\n                cachedDoc.cachedTemplates[template] = elem;\n\n                __TOTAL_TEMPLATES++;\n            }\n\n            return elem;\n        };\n\n        return templateEngine;\n    };\n\n    // Let KO know that we are supplying our own template engine (though most of the behavior comes from the\n    // default KO template engine).\n    var engine = self.templateEngine();\n    if (engine instanceof ko.templateEngine)\n    {\n        ko.setTemplateEngine(engine);\n    }\n\n    return self;\n});","asserts":[{"tag":1459,"offset":1890},{"tag":1460,"offset":4347},{"tag":1461,"offset":4575},{"tag":1462,"offset":4980},{"tag":1463,"offset":5373},{"tag":1464,"offset":5750}]},"VMAutocomplete":{"path":"F:/p/bce/Duchess/public/js/VMAutocomplete.js","data":"define(['ko', 'data', 'globals', 'platform', 'VMContact', 'VMAutocompleteItem', 'AutocompleteDates', 'tracker'],\nfunction (ko, d, g, platform, VMContact, VMAutocompleteItem, AutocompleteDates, tracker) {\nfunction VMAutocomplete()\n{\n    this.items = ko.observableArray();\n    this.isVisible = ko.observable(false);\n    this.element = undefined;\n    this.trackingItem = undefined;\n    this.trackingTag = undefined;\n    this.selectedIndex = ko.observable(-1);\n    this.exactMatch = ko.observable(false);\n    this.text = ko.observable('');\n\n    this.autocompleteDates = new AutocompleteDates();\n\n    this.nextDateWord = ko.observable(this.autocompleteDates.NextWordOptions.None);\n\n    this.lastX = 0;\n    this.lastY = 0;\n\n    this.Modes = { Contact: 0, Date: 1 };\n    this.mode = ko.observable(-1);\n\n    this.init();\n}\nVMAutocomplete.prototype =\n{\n    getDateText: function(index)\n    {\n        switch(index)\n        {\n            case 1:\n                return index + 'st ';\n            case 2:\n                return index + 'nd ';\n            case 3:\n                return index + 'rd ';\n            default:\n                return index + 'th ';\n        }\n    },\n    getMinWidth: function()\n    {\n        return (this.mode() === this.Modes.Contact) ? '350px' : '180px';\n    },\n    showAllDates: function()\n    {\n        return this.text() === '';\n    },\n    showDate: function()\n    {\n        return this.nextDateWord() == this.autocompleteDates.NextWordOptions.None ||\n               this.nextDateWord() == this.autocompleteDates.NextWordOptions.DayName;\n    },\n    showDays: function()\n    {\n        return this.nextDateWord() == this.autocompleteDates.NextWordOptions.Days;\n    },\n    showTime: function()\n    {\n        return this.nextDateWord() == this.autocompleteDates.NextWordOptions.Time;\n    },\n    showDates: function()\n    {\n        return platform.mobile && platform.app && this.mode() == this.Modes.Date && (this.text() === '' || this.nextDateWord());\n    },\n    showList: function()\n    {\n        return !this.exactMatch() && !this.showDates();\n    },\n    showPreview: function()\n    {\n        return this.selectedItem() && this.mode() == this.Modes.Contact && (!platform.mobile || this.exactMatch);\n    },\n    hasContent: function()\n    {\n        return this.showDates() || this.showList() || this.showPreview();\n    },\n    templatePreview: function(self, b)\n    {\n        return 'template-contact';// self.items()[this.selectedIndex()].templateName;\n    },\n    selectedItem: function()\n    {\n        if(this.selectedIndex() < 0)\n            return undefined;\n        else\n            return this.items()[this.selectedIndex()];\n    },\n    init: function()\n    {\n        this.onkeydown = this.onkeydown.bind(this);\n\n        this.onMouseover = this.onMouseover.bind(this);\n\n        this.element = document.getElementById('autocomplete');\n\n        g.applyBindings(this, 'autocomplete');\n\n        window.addEventListener('closeKeyboard', this.hide.bind(this));\n    },\n    setMode: function(prefix)\n    {\n        if(prefix == DatePrefix)\n            this.mode(this.Modes.Date);\n        if(prefix == ContactPrefix)\n            this.mode(this.Modes.Contact);\n    },\n    show: function(item, completionElement)\n    {\n        if (!this.isVisible())\n        {\n            var sel;\n            if (!completionElement)\n            {\n                sel = document.getSelection();\n                if (sel && sel.baseNode)\n                {\n                    var isContact = g.findParent(sel.baseNode, 'contact', 2);\n\n                    completionElement =  isContact || g.findParent(sel.baseNode, 'date', 2);\n\n                    if (isContact)\n                    {\n                        tracker.miscAction({\n                            type: TrackerType.Misc,\n                            misc: TrackerMisc.OpenContact,\n                            data: [\n                            {\n                                info: item\n                            }]\n                        });\n                    }\n                }\n            }\n\n            var windowBounds = document.documentElement.getBoundingClientRect();\n            var rect = this.element.getBoundingClientRect();\n\n            var autoRect = { left: rect.left, right: rect.right, top: rect.top, bottom: rect.bottom };\n\n            if (rect.width === 0 && rect.height === 0)\n            {\n                autoRect.right = 350;\n                autoRect.bottom = 170;\n            }\n\n            if (completionElement)\n            {\n                var targetOrigin = completionElement.getBoundingClientRect();\n\n                g.setOrigin(autoRect, targetOrigin.left, targetOrigin.bottom);\n\n                var origin = g.adjustOriginToBeInsideBounds(windowBounds, autoRect, 20, 10, 10, 10);\n\n                // Grab the element offset from the completion element element\n                this.element.style.left = origin.x + 'px';\n                this.element.style.top = origin.y + 'px';\n            }\n            else if (sel.rangeCount > 0)\n            {\n                // Grab the selection offset from the cursor if adding to a new completion element\n                var targetOrigin = sel.getRangeAt(0).getClientRects()[0];\n                targetOrigin.left -= 20; // TODO: Magic number?\n\n                g.setOrigin(autoRect, targetOrigin.left, targetOrigin.bottom);\n\n                var origin = g.adjustOriginToBeInsideBounds(windowBounds, autoRect, 20, 10, 10, 10);\n\n                this.element.style.left = origin.x + 'px';\n                this.element.style.top = origin.y + 'px';\n            }\n            else\n            {\n                // Unable to properly setup the element\n                return;\n            }\n\n            this.isVisible(true);\n\n            this.element.scrollTop = 0;\n\n            if (platform.mobile && item)\n            {\n                var time = 150;\n                var amtMoved = g.scrollToTop(item.getSpan(), time);\n                var bounds = completionElement ? completionElement.getBoundingClientRect() : item.getSpan().getBoundingClientRect();\n                var bottomOfItem = bounds.bottom - amtMoved;\n                this.element.style.top = (bottomOfItem - 2) + 'px';\n                if(this.mode() == this.Modes.Contact)\n                    g.phoneMenu.contactMode(true);\n                else if(this.mode() == this.Modes.Date)\n                    g.phoneMenu.dateMode(true);\n\n                g.keyboardToolbar.isVisible(false);\n\n                var trans = platform.windowHeight() - platform.kbsize - bottomOfItem;\n                g.setTransform(this.element, 0, trans);\n                requestAnimationFrame(function(){\n                    g.setTransform(this.element, 0, 0, time, 'ease-out');\n                }.bind(this));\n            }\n        }\n    },\n    clear: function()\n    {\n        this.items.removeAll();\n        this.trackingTag = false;\n    },\n    hide: function()\n    {\n        if (this.isVisible())\n        {\n            var time = 200;\n            if(platform.mobile)\n            {\n                var trans = platform.windowHeight() - platform.kbsize;\n                g.setTransform(this.element, 0, trans, time, 'ease-out');\n                setTimeout(function(){\n                    this.isVisible(false);\n                    g.phoneMenu.contactMode(false);\n                    if(g.isKeyboardOpen)\n                    {\n                        g.keyboardToolbar.isVisible(true);\n                    }\n                    this.clear();\n                }.bind(this), time);\n            }\n            else\n            {\n                this.isVisible(false);\n            }\n        }\n    },\n    onkeydown: function(e)\n    {\n        if (this.items().length === 0 || !this.isVisible() || (this.exactMatch() && e.normCode !== KeyCode.Escape))\n        {\n            return true;\n        }\n\n        if (e.normCode === KeyCode.UpArrow || e.normCode === KeyCode.DownArrow)\n        {\n            if (this.items().length > 1)\n            {\n                if (this.selectedIndex() >= 0)\n                {\n                    this.items()[this.selectedIndex()].isSelected(false);\n                }\n\n                var newIndex = this.selectedIndex() + ((e.normCode == KeyCode.DownArrow) ? 1 : -1);\n                if (newIndex < 0)\n                {\n                    this.selectedIndex(this.items().length + newIndex);\n                }\n                else if (newIndex >= this.items().length)\n                {\n                    this.selectedIndex(newIndex % this.items().length);\n                }\n                else\n                {\n                    this.selectedIndex(newIndex);\n                }\n\n                this.items()[this.selectedIndex()].isSelected(true);\n\n                return false;\n            }\n            else\n            {\n                this.hide();\n            }\n        }\n        else if (e.normCode === KeyCode.Enter)\n        {\n            if (this.selectedIndex() >= 0)\n            {\n                var item = this.items()[this.selectedIndex()];\n\n                this.onTapped(item.text, true);\n            }\n\n            this.hide();\n\n            return false;\n        }\n        else if (e.normCode === KeyCode.Escape)\n        {\n            this.hide();\n\n            return false;\n        }\n\n        return true;\n    },\n    onTap:\n    {\n        onClick: function(e)\n        {\n            var item = ko.dataFor(e.srcElement);\n\n            this.onTapped(item.text);\n        }\n    },\n    onTapped: function(text, hide)\n    {\n        this.text(text);\n\n        if (this.trackingItem)\n        {\n            this.trackingItem.onAutocompleteTapped(text, this.trackingTag);\n        }\n\n        if (hide || this.mode() === this.Modes.Contact || !platform.mobile)\n        {\n            this.hide();\n        }\n        // else if (!platform.mobile)\n        // {\n        //     var selection = g.getSelectionInfo();\n\n        //     var offset = g.getSelectOffsetsInSpan(this.trackingItem, this.trackingItem.getSpan(), selection.selection.getRangeAt(0));\n\n        //     this.update({ item: this.trackingItem, start: offset.start, fromArrows: false });\n        // }\n    },\n    find: function(words, start, num)\n    {\n        if (start + num > words.length - 1) // Out of range\n        {\n            return false;\n        }\n\n        var text = words[start];\n\n        if (isNaN(num)) // Initialize num to something valid\n        {\n            num = 0;\n        }\n\n        for (var i = 0; i < num; i ++) // Add subsequent words\n        {\n            if (!words[start+i+1])\n            {\n                break;\n            }\n\n            text += ' ' + words[start+i+1];\n        }\n\n        var compStr = (text.indexOf(':', text.length - 1) !== -1) ? text.substr(0, text.length - 1) : text;\n\n        var results;\n        if(this.mode() == this.Modes.Contact)\n            results = this.findContact(compStr);\n        else if(this.mode() == this.Modes.Date)\n            results = this.findDate(compStr);\n\n        if (results.length > 0)\n        {\n            // Check for matches including the next word\n            // If they don't match, this is the best result\n            return this.find(words, start, num + 1) ||\n                   {start: start, num: num + 1, text: compStr, results: results};\n        }\n\n        return false;\n    },\n    findContact: function(name)\n    {\n        return d.findContactsLike(name);\n    },\n    findDate: function(text)\n    {\n        return this.autocompleteDates.findDatesLike(text);\n    },\n    findExact: function(text)\n    {\n        if (this.mode() == this.Modes.Contact)\n        {\n            return this.findContactExact(text);\n        }\n        else if (this.mode() == this.Modes.Date)\n        {\n            return this.findDateExact(text);\n        }\n    },\n    findContactExact: function(name)\n    {\n        return d.findContactsExact(name);\n    },\n    findDateExact: function(text)\n    {\n        return this.autocompleteDates.findExact(text);\n    },\n    objectFromResult: function(result)\n    {\n        if (this.mode() == this.Modes.Contact)\n        {\n            return new VMContact(result);\n        }\n        else if (this.mode() == this.Modes.Date)\n        {\n            return new VMContact(result);\n        }\n    },\n    getMinWordLength: function()\n    {\n        if (this.mode() == this.Modes.Contact)\n        {\n            return 1;\n        }\n        else if (this.mode() == this.Modes.Date)\n        {\n            return 1;\n        }\n    },\n    getLineIndexFromWordIndex: function(words, wordIndex)\n    {\n        var lineIndex = 0;\n        for(var i = 0; i < wordIndex; i ++)\n        {\n            lineIndex += words[i].length + 1;\n        }\n        return lineIndex;\n    },\n    update: function(params)\n    {\n        var item = params.item || this.trackingItem;\n        var text = item.getParsedText();\n        var selectionStart = params.start;\n        var fromArrows = params.fromArrows;\n\n        this.trackingItem = item;\n\n        this.trackingTag = false;\n\n        var startOffset = 0,\n            i,\n            lineIndex = 0,\n            startWord = -1,\n            startChar = -1;\n\n        var words = text.split(' ');\n\n        if (startOffset > 0)\n        {\n            words[0] = words[0].substr(startOffset);\n        }\n\n        // Find the word that the cursor is in\n        for (i = 0; i < words.length; i ++)\n        {\n            // If this word is a tag and it's past selection start\n            if ((words[i].startsWith(ContactPrefix) || words[i].startsWith(DatePrefix)) && lineIndex <= selectionStart)\n            {\n                startWord = i;\n                startChar = lineIndex;\n                this.setMode(words[i][0]);\n            }\n\n            lineIndex += words[i].length + 1;\n        }\n\n        var minWordLength = this.getMinWordLength();\n\n        // Make sure selected word is longer than the minimum length for this type\n        if (startWord >= 0)\n        {\n            this.clear();\n\n            // Crop the tag character off the start word before searching\n            words[startWord] = words[startWord].substr(1);\n\n            var result = this.find(words, startWord);\n\n            var addAmount = 1;\n\n            // When pressing space (if typing more than just the first name of a contact) ensure that the\n            // autocomplete dialog is not hidden.\n            if (words[startWord + 1] === '')\n            {\n                addAmount++;\n            }\n\n            // If selection is within the range of the result word\n            if(result && startChar + addAmount + result.text.length >= selectionStart)\n            {\n                var exactMatch = this.findExact(result.text);\n                this.exactMatch(!!exactMatch);\n\n                if(exactMatch)\n                {\n                    var options = { index: -1, text: exactMatch.text };\n                    options.object = this.objectFromResult(exactMatch);\n                    item = new VMAutocompleteItem(options);\n                    this.items.push(item);\n                    this.selectedIndex(0);\n                    this.trackingTag = true;\n\n                    if(!fromArrows && !platform.mobile)\n                        this.show(this.trackingItem);\n                }\n                else\n                {\n                    // Valid matches either have multiple words, word length >= 3, or are an exact match\n                    if(result && (result.num > 0))\n                    {\n                        this.trackingTag = {text: result.text,\n                                           index: this.getLineIndexFromWordIndex(words, result.start) + 1,\n                                           length: result.text.length};\n\n\n                        // This is for autocomplete items to highlight the searched text\n                        this.text(result.text);\n\n                        var results = result.results;\n\n                        var u, item, id;\n                        for(i = 0; i < results.length; i ++)\n                        {\n                            var object = results[i].object;\n\n                            var options = { index: i, text: object.text };\n                            options.object = this.objectFromResult(object);\n                            item = new VMAutocompleteItem(options);\n                            this.items().push(item);\n                        }\n\n                        this.items.valueHasMutated();\n\n                        this.selectedIndex(0);\n                        this.items()[0].isSelected(true);\n                    }\n                    if(!fromArrows)\n                        this.show(this.trackingItem);\n                }\n            }\n        }\n\n        this.nextDateWord(this.autocompleteDates.NextWordOptions.None);\n\n        if(!this.trackingTag) // No results so remove all items\n            this.hide();\n    },\n    onMouseover: function(item)\n    {\n        if (this.selectedIndex() >= 0)\n        {\n            this.items()[this.selectedIndex()].isSelected(false);\n        }\n        var index = this.items.indexOf(item);\n        if(index >= 0)\n        {\n            this.selectedIndex(index);\n            item.isSelected(true);\n        }\n    },\n    onTapDate: {\n        onStart: g.handlerPreventStop,\n        onClick: function(e)\n        {\n            var el = e.srcElement;\n            if(el.nodeName == 'SPAN')\n            {\n                var parentDiv = el.parentNode;\n                if(g.hasClass(parentDiv, 'disabled'))\n                    return;\n\n                var text = el.id ? (el.id + ' ') : el.textContent;\n                var next = this.autocompleteDates.nextWordOptions(text);\n                this.nextDateWord(next);\n                log('next', next, this.trackingTag);\n                var hide = next == this.autocompleteDates.NextWordOptions.None;\n                this.onTapped(text, hide);\n                this.trackingTag.index += text.length;\n            }\n        }\n    }\n};\n\nreturn VMAutocomplete;\n});","asserts":[]},"VMContact":{"path":"F:/p/bce/Duchess/public/js/VMContact.js","data":"define(['ko', 'data', 'globals', 'goog', 'platform', 'tracker'],\nfunction (ko, d, g, goog, platform, tracker) {\nfunction VMContact(p)\n{\n    this.templateName = 'template-contact';\n    this.id = p.id;\n    this.isSelected = ko.observable(false);\n    this.text = p.text || '';\n    // this.avatar = p.avatar || '';\n    this.image = undefined;\n    this.phoneNumbers = p.phoneNumbers || [];\n    this.emails = p.emails || [];\n    this.dbItem = p;\n    this.phone = undefined;\n    this.phoneLink = undefined;\n    this.email = undefined;\n    this.emailLink = undefined;\n    this.item = undefined;\n\n    this.init();\n}\n\nVMContact.prototype = {\n    hasPreview: function()\n    {\n        return true;\n    },\n    init: function()\n    {\n        for (var i = 0; i < this.phoneNumbers.length; i ++)\n        {\n            this.phoneNumbers[i].link = this.formatPhone(this.phoneNumbers[i].number);\n        }\n\n        for (var i = 0; i < this.emails.length; i ++)\n        {\n            this.emails[i].link = 'mailto:' + this.emails[i].address;\n        }\n    },\n    onLoad: function(element)\n    {\n        this.element = element;\n    },\n    // delayedLoad: function()\n    // {\n    //     if (this.avatar)\n    //     {\n    //         this.loadImageForContact();\n    //     }\n    // },\n    formatPhone: function(phonenum)\n    {\n        var regexObj = /^(?:\\+?1[-. ]?)?(?:\\(?([0-9]{3})\\)?[-. ]?)?([0-9]{3})[-. ]?([0-9]{4})$/;\n        if (regexObj.test(phonenum))\n        {\n            var parts = phonenum.match(regexObj);\n            var phone = \"\";\n            if (parts[1]) { phone += \"(\" + parts[1] + \") \"; }\n            phone += parts[2] + \"-\" + parts[3];\n\n            var phoneLink = \"\";\n            if (parts[1]) { phoneLink += \"+1-\" + parts[1] + \"-\"; }\n            phoneLink += parts[2] + \"-\" + parts[3];\n\n            if (platform.iphone)\n            {\n                return 'tel:' + phoneLink;\n            }\n            else\n            {\n                return 'callto:' + phoneLink;\n            }\n        }\n    },\n    // loadImageForContact: function()\n    // {\n    //     if (!goog.isLoaded || platform.mobile)\n    //     {\n    //         return;\n    //     }\n\n    //     if (!this.image)\n    //     {\n    //         var url = this.avatar + '&access_token=' + goog.getAccessToken();\n    //         this.image = new Image();\n    //         this.image.width = 35;\n    //         this.image.height = 35;\n\n    //         this.image.onload = function()\n    //         {\n    //             this.element.insertBefore(this.image);\n    //         }.bind(this);\n\n    //         this.image.onerror = function(e, e2)\n    //         {\n    //             // TODO: The Contacts API gives a link even for contacts without photos. What's the most\n    //             // elegant way to catch the error and not try again? I tried just throwing away the saved\n    //             // avatar on error, but there were many false erros probably due to trying to download many at a time.\n\n    //             // this.dbItem.avatar = '';\n    //             // this.avatar = '';\n\n    //             // Set it to undefined so it'll try again. This is necessary because of the false errors.\n    //             // But obviously it's terrible for all the actual 404s.\n    //             this.image = undefined;\n    //         }.bind(this);\n\n    //         this.image.src = url;\n    //     }\n    // },\n    onTapNumber: function(e)\n    {\n        // tracker.miscAction({\n        //     type: TrackerType.Misc,\n        //     misc: TrackerMisc.CallContact,\n        //     data: [\n        //     {\n        //         id: this.id,\n        //         name: this.text\n        //     }]\n        // });\n    },\n    onTapEmail: function(e)\n    {\n        // tracker.miscAction({\n        //     type: TrackerType.Misc,\n        //     misc: TrackerMisc.EmailContact,\n        //     data: [\n        //     {\n        //         id: this.id,\n        //         name: this.text\n        //     }]\n        // });\n    },\n    onTap:\n    {\n        onClick: function(e)\n        {\n            log(e.srcElement, this.text);\n            if (g.hasClass(e.srcElement, 'contactPhone'))\n            {\n                // window.location = this.phone;\n            }\n            else if (g.hasClass(e.srcElement, 'contactEmail'))\n            {\n\n            }\n            else\n            {\n                g.autocomplete.onTapped(this.text);\n            }\n        }\n    }\n};\n\nreturn VMContact;\n});","asserts":[]},"VMAutocompleteItem":{"path":"F:/p/bce/Duchess/public/js/VMAutocompleteItem.js","data":"define(['ko', 'data', 'globals', 'platform'],\nfunction (ko, d, g, platform) {\nfunction VMAutocompleteItem(p)\n{\n    this.id = p.id;\n    this.text = p.text || '';\n    this.object = p.object;\n    this.index = p.index;\n    this.isSelected = ko.observable(false);\n    this.element = undefined;\n\n    this.init();\n}\n\nVMAutocompleteItem.prototype = {\n    init: function()\n    {\n    },\n    html: function()\n    {\n        // Wrap a <b> tag around the autocomplete search part of the text\n        var searchText = g.autocomplete.text();\n        var index = this.text.toLowerCase().indexOf(searchText.toLowerCase());\n\n        var newText = '';\n\n        if (index >= 0)\n        {\n            newText = this.text.substr(0, index) + '<b>' + this.text.substr(index, searchText.length) + '</b>' + this.text.substr(index + searchText.length);;\n        }\n\n        return newText;\n    },\n    onLoad: function(element)\n    {\n        this.element = element;\n    }\n    // onTap:\n    // {\n    //     onClick: function(e)\n    //     {\n    //         g.autocomplete.onTapped(this.text);\n    //     }\n    // }\n};\n\nreturn VMAutocompleteItem;\n});","asserts":[]},"AutocompleteDates":{"path":"F:/p/bce/Duchess/public/js/AutocompleteDates.js","data":"define(['ko', 'data', 'globals', 'platform'],\nfunction (ko, d, g, platform) {\nfunction AutocompleteDates(p)\n{\n    this.soft = ['now', 'soon', 'later'];\n    this.softDays = ['today', 'tomorrow'];\n    this.dayModifiers = ['next'];\n    this.days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n    this.months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\n\n    this.dict = this.soft.concat(this.softDays).concat(this.dayModifiers).concat(this.days).concat(this.months);\n\n    this.NextWordOptions = {\n        None: 0,\n        DayName: 1,\n        Days: 2,\n        Time: 4\n    };\n\n    this.init();\n}\n\nAutocompleteDates.prototype = {\n    init: function()\n    {\n    },\n    findDatesLike: function(like)\n    {\n        var lower = like.toLowerCase();\n        var results = [];\n\n        for (var i = 0; i < this.dict.length; ++i)\n        {\n            if (this.dict[i].indexOf(lower) === 0)\n            {\n                results.push({index: 0, object: {id: this.dict[i], text: this.dict[i]}});\n            }\n        }\n        return results;\n    },\n    findExact: function(text)\n    {\n        if(this.dict.indexOf(text) >= 0)\n        //     return {index: 0, id: text, text: text};\n            return this.nextWordOptions(text) == this.NextWordOptions.None;\n        return false;\n    },\n    nextWordOptions: function(text)\n    {\n        // if(text.lastIndexOf(' ') == text.length - 1)\n        // {\n        var words = text.split(' ');\n        var lastWord = words[words.length - 1];\n        if(lastWord == '')\n            lastWord = words[words.length - 2];\n        // log('last word', lastWord, words);\n\n        if(this.soft.indexOf(lastWord) >= 0)\n            return this.NextWordOptions.None;\n        if(this.softDays.indexOf(lastWord) >= 0)\n            return this.NextWordOptions.Time;\n        if(this.dayModifiers.indexOf(lastWord) >= 0)\n            return this.NextWordOptions.DayName;\n        if(this.days.indexOf(lastWord) >= 0)\n            return this.NextWordOptions.Time;\n        if(this.months.indexOf(lastWord) >= 0)\n            return this.NextWordOptions.Days;\n\n        var isInt = parseInt(lastWord, 10);\n        // log('is int', isInt);\n        if(!isNaN(isInt))\n            return this.NextWordOptions.Time;\n\n        if(lastWord.indexOf(':') >= 0)\n            return this.NextWordOptions.Time;\n        // }\n        return this.NextWordOptions.None;\n    }\n};\n\nreturn AutocompleteDates;\n});","asserts":[]},"ScreenManager":{"path":"F:/p/bce/Duchess/public/js/ScreenManager.js","data":"define(['ko', 'globals', 'platform'],\nfunction (ko, g, platform) {\nfunction ScreenManager(owner)\n{\n    this.snapPoints = [ ];\n    this.screens = [ ];\n\n    this.activeScreen = -1;\n    this.screenAtSwipeStart = -1;\n    this._isSwiping = false;\n\n    this.minOffset = 0;\n    this.maxOffset = 0;\n\n    this.owner = owner;\n\n    this.useScroll = false;\n\n    this.lastOffset = 0;\n\n    this.updateFunctions = [ ];\n\n    // this.snapComputed = false;\n\n    this.paneWidth = 0.85;\n\n    this.init();\n}\n\nif (platform.mobile)\n{\n    window.Screens =\n    {\n        Settings:   0,\n        Outline:    1,\n        List:       2,\n        MAX:        2\n    };\n}\nelse\n{\n    window.Screens =\n    {\n        Outline:    0,\n        List:       1,\n        MAX:        1\n    };\n}\n\nScreenManager.prototype = {\n    init: function()\n    {\n        this.activeScreen = Screens.MAX;\n    },\n    getActiveScreen: function()\n    {\n        return this.activeScreen;\n    },\n    setOwner: function(owner)\n    {\n        this.owner = owner;\n    },\n    isSwiping: function()\n    {\n        return this._isSwiping;\n    },\n    isScreenOpen: function(index)\n    {\n        return (this.activeScreen === index);\n    },\n    computeSnapPoints: function()\n    {\n        g.Assert(platform.mobile, 'Should only be computing snappoints on mobile');\n        g.Assert(this.owner, 'Must have a valid owner to compute snap points');\n\n        // if (this.snapComputed)\n        // {\n        //     return;\n        // }\n\n        var totalPercent = this.paneWidth * 3;\n        var snapPercents = [ 0, this.paneWidth, this.paneWidth * 2 ];\n\n        var scrollWidth = this.useScroll ? this.owner.scrollWidth : (parseInt(g.width(this.owner)) * totalPercent);\n\n        for (var i = 0; i < snapPercents.length; ++i)\n        {\n            this.snapPoints[i] = Math.round(snapPercents[i] * (scrollWidth / totalPercent));\n            if (DEBUG) log('SnapPoint: [' + i + ']:' + this.snapPoints[i]);\n        }\n\n        this.offsetMin = 0;\n        this.offsetMax = this.snapPoints[2];\n\n        // this.snapComputed = true;\n        this.lastOffset = this.offsetMax;\n    },\n    // snapToScreen: function(index)\n    // {\n    //     debugger;\n    //     //g.Assert(this.activeScreen !== index, 'Do not set the current screen to the one that is already displayed');\n    //     g.Assert(index <= Screens.MAX, 'Must be a valid screen type');\n\n    //     this.computeSnapPoints();\n\n    //     if (this.activeScreen !== index)\n    //     {\n    //         this.notifyScreenOfClose(this.activeScreen);\n    //         this.notifyScreenOfOpen(index);\n    //     }\n\n    //     var lastActive = this.activeScreen;\n\n    //     this.activeScreen = index;\n\n    //     if (lastActive < 0)\n    //     {\n    //         return;\n    //     }\n\n    //     var snapOffset = this.snapPoints[index];\n\n    //     if (DEBUG) log('Snapping To: ', snapOffset);\n\n    //     this.notifyScreenOfScroll(this.activeScreen, snapOffset, 0);\n\n    //     if (this.useScroll)\n    //     {\n    //         this.owner.scrollLeft = snapOffset;\n    //     }\n    //     else\n    //     {\n    //         for (var i = 0; i < this.screens.length; ++i)\n    //         {\n    //             var topEle = this.screens[i].getTopElement();\n\n    //             g.setTransform(topEle, -snapOffset, 0, 0);\n    //         }\n    //     }\n\n    //     this.lastOffset = snapOffset;\n    //     log(snapOffset);\n\n    //     return snapOffset;\n    // },\n    onResize: function()\n    {\n        if (platform.mobile)\n        {\n            var index = this.activeScreen;\n\n            this.computeSnapPoints();\n\n            var screenOffset = this.snapPoints[index];\n\n            this.updateScreenOffset(index, screenOffset, 0);\n            this.lastOffset = screenOffset;\n        }\n    },\n    scrollToScreen: function(index)\n    {\n        //g.Assert(this.activeScreen !== index, 'Do not set the current screen to the one that is already displayed');\n        g.Assert(index <= Screens.MAX, 'Must be a valid screen type');\n\n        // this.computeSnapPoints();\n\n        if (this.activeScreen !== index)\n        {\n            this.notifyScreenOfClose(this.activeScreen);\n            this.notifyScreenOfOpen(index);\n        }\n\n        var previousActiveScreen = this.activeScreen;\n\n        this.activeScreen = index;\n\n        var screenOffset = this.snapPoints[index];\n        if (DEBUG) log('Scrolling To: ', screenOffset);\n\n        this.notifyScreenOfScroll(previousActiveScreen, screenOffset, 200);\n\n        this.updateScreenOffset(index, screenOffset, 200);\n\n        this.lastOffset = screenOffset;\n\n        return screenOffset;\n    },\n    updateScreenOffset: function(index, offset, time)\n    {\n        time = time || 0;\n        if (this.useScroll)\n        {\n            if(time)\n            {\n                var screenOffset = this.snapPoints[index];\n                g.scrollTo(screenOffset, time, this.owner, /*horiz*/true);\n            }\n            else\n            {\n                this.owner.scrollLeft = offset;\n            }\n        }\n        else\n        {\n            // log('update', index, offset, offsetOnScreen);\n            for (var i = 0; i < this.screens.length; ++i)\n            {\n                var topEle = this.screens[i].getTopElement();\n\n                g.setTransform(topEle, -offset, 0, time, 'ease-out');\n\n                var offsetOnScreen = offset - ((i - 1) * platform.windowWidth() * this.paneWidth);\n                var perc = (offsetOnScreen / (platform.windowWidth() * this.paneWidth));\n                topEle.style.opacity = g.clamp(0.4 + perc * 0.6, 0, 1);\n            }\n        }\n\n        g.setTransform(g.element('headers'), -offset * (1/ this.paneWidth), 0, time);\n\n        this.lastOffset = offset;\n    },\n    getCurrentScreenOffset: function()\n    {\n        if (this.useScroll)\n        {\n            return this.owner.scrollLeft;\n        }\n        else\n        {\n            return this.lastOffset;\n        }\n    },\n    addScreen: function(scr, index)\n    {\n        g.Assert(index <= Screens.MAX, 'Must be a valid screen type');\n        g.Assert(this.screens[index] === undefined, 'Already have a screen at the given index');\n\n        if (DEBUG) log('Adding Screen: ', index);\n\n        this.screens[index] = scr;\n    },\n    getScreen: function(index)\n    {\n        var scr = this.screens[index];\n        g.Assert(scr, 'Must have a valid screen');\n\n        return scr;\n    },\n    notifyScreenOfClose: function(index)\n    {\n        if (index !== -1)\n        {\n            var scr = this.getScreen(index);\n\n            if (scr.onScreenClose)\n            {\n                scr.onScreenClose();\n            }\n        }\n    },\n    notifyScreenOfScroll: function(index, offset, time)\n    {\n        if (index !== -1)\n        {\n            for (var i = 0; i < this.screens.length; ++i)\n            {\n                var scr = this.getScreen(i);\n\n                if (scr.onScreenScroll)\n                {\n                    scr.onScreenScroll(offset, time);\n                }\n            }\n        }\n\n        g.fireCustomEvent('screenScroll');\n    },\n    notifyScreenOfStartOpen: function(index)\n    {\n        if (index !== -1)\n        {\n            var scr = this.getScreen(index);\n\n            if (scr.onScreenStartOpen)\n            {\n                scr.onScreenStartOpen();\n            }\n        }\n    },\n    notifyScreenOfOpen: function(index)\n    {\n        if (index !== -1)\n        {\n            var scr = this.getScreen(index);\n\n            if (scr.onScreenOpen)\n            {\n                scr.onScreenOpen();\n            }\n        }\n    },\n    startSwipe: function()\n    {\n        if (!this._isSwiping)\n        {\n            this._isSwiping = true;\n\n            if (this.activeScreen === 0)\n            {\n                this.notifyScreenOfStartOpen(1);\n            }\n            else if (this.activeScreen === Screens.MAX)\n            {\n                this.notifyScreenOfStartOpen(Screens.MAX - 1);\n            }\n            else\n            {\n                // Because we may not know the direction of the swipe, or it may change partway through,\n                // notify both of the adjacent panes that they may open so they can update their content.\n                this.notifyScreenOfStartOpen(this.activeScreen - 1);\n                this.notifyScreenOfStartOpen(this.activeScreen + 1);\n            }\n\n            if (DEBUG) log('Starting Swipe');\n        }\n    },\n    updateSwipe: function(diff)\n    {\n        g.Assert(this.isSwiping(), 'Must be swiping to perform an update');\n\n        if (platform.ios || platform.android || (platform.ie && platform.mobile))\n        {\n            var offset = this.getCurrentScreenOffset();\n\n            var newOffset = Math.max(Math.min(offset + diff, this.offsetMax), this.offsetMin);\n\n            // var offsetOnScreen = newOffset - (this.activeScreen * platform.windowWidth() * this.paneWidth);\n\n            // log(offset, newOffset);\n\n            if (offset !== newOffset)// && offsetOnScreen > 0)\n            {\n                this.updateScreenOffset(this.activeScreen, newOffset);\n            }\n\n            //console.log('Updating Swipe: ', newOffset, ' | ', e);\n        }\n    },\n    endSwipe: function()\n    {\n        g.Assert(this.isSwiping(), 'Must be swiping to end a swipe');\n\n        // this.computeSnapPoints();\n\n        var currentOffset = this.getCurrentScreenOffset(this.activeScreen);\n        var snapIndex = -1;\n\n        var minDiff = 100000;\n        for (var i = 0; i < this.snapPoints.length; ++i)\n        {\n            var snapDiff = Math.abs(this.snapPoints[i] - currentOffset);\n\n            if (snapDiff < minDiff)\n            {\n                snapIndex = i;\n                minDiff = snapDiff;\n            }\n        }\n\n        this.scrollToScreen(snapIndex);\n\n        if (platform.ios)\n        {\n            g.preventClick();\n        }\n\n        if (this._isSwiping)\n        {\n            this._isSwiping = false;\n\n            if (DEBUG) log('Ending Swipe');\n        }\n    },\n    checkSwipeStart: function(e)\n    {\n        var returnValue = false;\n        this.screenAtSwipeStart = this.activeScreen;\n\n        // if (this.activeScreen !== Screens.List)\n        // {\n            if (platform.ie && !platform.mobile)\n            {\n                // if (platform.mobile)\n                // {\n                //     // TODO: Correct swiping on mobile IE\n                //     return true;\n                // }\n            }\n            else if (platform.mobile)\n            {\n                if (this.activeScreen !== Screens.List && e.eventX > this.paneWidth * platform.windowWidth())\n                {\n                    // this.startSwipe();\n\n                    e.preventDefault();\n\n                    returnValue = true;\n                }\n            }\n        // }\n\n        return returnValue;\n    },\n    checkSwipeMove: function(e)\n    {\n        var returnValue = false;\n\n        // if (this._isSwiping)\n        {\n            if (platform.ie && !platform.mobile)\n            {\n                // if (platform.mobile)\n                // {\n                //     // TODO: Correct swiping on mobile IE\n                //     return true;\n                // }\n            }\n            else if (platform.mobile)\n            {\n                var hasHoriz = (this.activeScreen !== Screens.MAX && Math.abs(e.diffX) > 5) ||\n                               (this.activeScreen === Screens.MAX && e.diffX > 5);//(Math.abs(e.diffX) > 5 && this.activeScreen !== 0 && this.activeScreen !== Screens.MAX) ||\n                               // (e.diffX < 5 && this.activeScreen === 0) ||\n                               // (e.diffX > 5 && this.activeScreen === Screens.MAX);\n\n                if (DEBUG) log('SwipeMove: ', hasHoriz, this.isSwiping(), e.diffX, e.distanceY);\n\n                if (this.isSwiping() || (Math.abs(e.distanceY) < 5) && hasHoriz)\n                {\n                    if (!this.isSwiping())\n                    {\n                        this.startSwipe();\n                    }\n\n                    this.updateSwipe(-e.xThisFrame);\n\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n\n                    returnValue = true;\n                    // log('true', hasHoriz);\n                }\n            }\n        }\n\n        return returnValue;\n    },\n    checkSwipeClick: function(e)\n    {\n        if (this.activeScreen !== Screens.List && e.eventX > this.paneWidth * platform.windowWidth())\n        {\n            this._isSwiping = false;\n            this.scrollToScreen(this.activeScreen + 1);\n            return true;\n        }\n        return this._isSwiping;\n    },\n    checkSwipeEnd: function(e)\n    {\n        var returnValue = false;\n\n        if (this.activeScreen == this.screenAtSwipeStart)// && this.activeScreen !== Screens.List)\n        {\n            if (platform.ie && !platform.mobile)\n            {\n                // if (platform.mobile)\n                // {\n                //     // TODO: Correct swiping on mobile IE\n                //     return true;\n                // }\n            }\n            else if (platform.mobile)\n            {\n                if (this.isSwiping())\n                {\n                    this.endSwipe();\n                }\n            }\n        }\n        else if(this.activeScreen != this.screenAtSwipeStart)\n        {\n            returnValue = true;\n            log('return value is true');\n        }\n\n        return returnValue;\n    }\n};\n\nreturn ScreenManager;\n});\n","asserts":[{"tag":1465,"offset":1215},{"tag":1466,"offset":1299},{"tag":1467,"offset":2175},{"tag":1468,"offset":2295},{"tag":1469,"offset":3793},{"tag":1470,"offset":3910},{"tag":1471,"offset":5962},{"tag":1472,"offset":6033},{"tag":1473,"offset":6300},{"tag":1474,"offset":8418},{"tag":1475,"offset":9171}]},"VMTooltip":{"path":"F:/p/bce/Duchess/public/js/VMTooltip.js","data":"define(['ko', 'globals', 'platform'],\nfunction (ko, g, platform) {\n\nvar displayDelay = 300;\nvar extraDelay = 1000;\n\nfunction VMTooltip()\n{\n    this.listenerElement = undefined;\n    this.displayElement = undefined;\n    this.element = undefined;\n\n    this.displayTimeout = undefined;\n    this.extraTimeout = undefined;\n\n    this.displayText = ko.observable('');\n    this.displayExtra = ko.observable('');\n\n    this.overTooltip = ko.observable(false);\n\n    this.tipExtras =\n    {\n        '#desktopMenuButton': 'Access your settings and documents, view help',\n        '.addPaneNormal': 'Open another editable view of your data',\n        '.addPaneTimeline': 'View your agenda',\n    };\n\n    g.applyBindings(this, 'tooltip');\n\n    this.init();\n}\n\nVMTooltip.prototype =\n{\n    init: function()\n    {\n\n    },\n    onLoad: function()\n    {\n        this.element = document.getElementById('tooltip');\n        if (this.element)\n        {\n            this.element.addEventListener('mouseover', this.handleSelfOver.bind(this), true);\n            this.element.addEventListener('mouseout', this.handleSelfOut.bind(this), true);\n        }\n\n        this.listenerElement = document.getElementById('outerWrapper');\n        if (this.listenerElement)\n        {\n            this.listenerElement.addEventListener('mouseover', this.handleEleOver.bind(this), true);\n            this.listenerElement.addEventListener('mouseout', this.handleEleOut.bind(this), true);\n        }\n    },\n    register: function(elem, text)\n    {\n        //log('Tooltip Register: ' + text);\n\n        // elem.addEventListener('mouseover', this.tipIn.bind(this), true);\n        // elem.addEventListener('mouseout', this.tipOut.bind(this), true);\n\n        // ko.utils.domNodeDisposal.addDisposeCallback(elem, function()\n        // {\n        //     log('Dispose');\n        // });\n\n        this.update(elem, text);\n    },\n    update: function(elem, text)\n    {\n        elem.setAttribute('tooltip', text);\n    },\n    tipIn: function(e)\n    {\n        if (this.displayElement !== e.srcElement)\n        {\n            this.displayElement = e.srcElement;\n\n            clearTimeout(this.displayTimeout);\n            this.displayTimeout = setTimeout(this.displayTip.bind(this), displayDelay);\n        }\n    },\n    adjustBounds: function()\n    {\n        var maxTooltipWidth = 200;\n        var horizAdjust = 0;\n\n        var windowBounds = document.documentElement.getBoundingClientRect();\n        var targetBounds = this.displayElement.getBoundingClientRect();\n\n        var boundsDiff = (windowBounds.right - targetBounds.right);\n\n        // Quick check to see if we may need to adjust the tooltip position based on its max size.\n        var displayOnLeft = boundsDiff < maxTooltipWidth;\n\n        // Ensure that the tooltip is kept on the screen\n        if (displayOnLeft)\n        {\n            var actualWidth = g.width(this.element);\n\n            if (boundsDiff < actualWidth)\n            {\n                horizAdjust += actualWidth - (windowBounds.right - targetBounds.right) + 10;\n            }\n        }\n\n        var x = targetBounds.left + targetBounds.width / 2;\n\n        g.setTransform(this.element, x - horizAdjust, targetBounds.bottom + 5);\n    },\n    displayTip: function()\n    {\n        this.displayTimeout = undefined;\n\n        if (this.displayElement)\n        {\n            var infoText = this.displayElement.getAttribute('tooltip');\n\n            g.Assert(infoText, 'When display a tooltip, elements should always have valid data set');\n\n            if (infoText)\n            {\n                this.displayText(infoText);\n\n                this.adjustBounds();\n\n                this.extraTimeout = setTimeout(this.showExtra.bind(this), extraDelay);\n            }\n        }\n    },\n    tipOut: function(e)\n    {\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var isAncestor = false;\n        var newTarget = e.toElement || e.relatedTarget;\n\n        if (newTarget)\n        {\n            isAncestor = g.isAncestor(newTarget, e.srcElement);\n        }\n\n        // If the new target is a descendant of the tooltip or the user is now mouseover on the tooltip, do not\n        // hide the tooltip text.\n        if (!isAncestor && e.srcElement !== newTarget && newTarget !== this.element)\n        {\n            this.hideTip();\n        }\n    },\n    handleEleOver: function(e)\n    {\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var infoText = e.srcElement.getAttribute('tooltip');\n\n        if (infoText)\n        {\n            this.tipIn(e);\n        }\n    },\n    handleEleOut: function(e)\n    {\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var infoText = e.srcElement.getAttribute('tooltip');\n\n        if (infoText)\n        {\n            this.tipOut(e);\n        }\n    },\n    handleSelfOver: function(e)\n    {\n        if (this.displayElement)\n        {\n            this.overTooltip(true);\n\n            this.showExtra();\n        }\n    },\n    handleSelfOut: function(e)\n    {\n        if (!e.srcElement)\n        {\n            e.srcElement = e.target;\n        }\n\n        var isAncestor = false;\n        var newTarget = e.toElement || e.relatedTarget;\n\n        if (newTarget)\n        {\n            isAncestor = g.isAncestor(newTarget, e.srcElement);\n        }\n\n        if (!isAncestor && e.srcElement !== newTarget)\n        {\n            this.overTooltip(false);\n\n            if (newTarget !== this.displayElement)\n            {\n                this.hideTip();\n            }\n        }\n    },\n    showExtra: function()\n    {\n        var extraString = undefined;\n\n        g.Assert(this.displayElement, 'There should be a display element when showing extra information');\n\n        if(this.displayElement)\n        {\n            // First check if there is extra tooltip info associated with the element's ID\n            if (this.displayElement.id)\n            {\n                var idString = '#' + this.displayElement.id;\n\n                if (this.tipExtras[idString])\n                {\n                    extraString = idString;\n                }\n            }\n\n            // Then check if any of the element's classes match.\n            if (!extraString)\n            {\n                for (var i = 0; i < this.displayElement.classList.length; ++i)\n                {\n                    var classString = '.' + this.displayElement.classList[i];\n\n                    if (this.tipExtras[classString])\n                    {\n                        extraString = classString;\n                        break;\n                    }\n                }\n            }\n\n            if (extraString)\n            {\n                var extraInfo = this.tipExtras[extraString];\n\n                if (extraInfo)\n                {\n                    this.displayExtra(extraInfo);\n\n                    this.adjustBounds();\n                }\n            }\n\n            clearTimeout(this.extraTimeout);\n            this.extraTimeout = undefined;\n        }\n    },\n    hideTip: function()\n    {\n        if (this.displayElement)\n        {\n            this.displayElement = undefined;\n\n            clearTimeout(this.displayTimeout);\n            this.displayTimeout = undefined;\n\n            clearTimeout(this.extraTimeout);\n            this.extraTimeout = undefined;\n\n            this.displayText('');\n            this.displayExtra('');\n        }\n    }\n};\n\nreturn VMTooltip;\n\n});","asserts":[{"tag":1476,"offset":3394},{"tag":1477,"offset":5637}]},"AppCache":{"path":"F:/p/bce/Duchess/public/js/AppCache.js","data":"define(['ko', 'globals', 'platform'],\nfunction (ko, g, platform) {\n\nfunction AppCache()\n{\n    this.minTimeShowUpdate = 2000;\n    this.timeToCancelButton = 2000;\n\tthis.notifiedOfNew = false;\n    this.isFinished = false;\n    this.timeShownUpdatingMessage = undefined;\n    // this.isVisible = ko.observable(true);\n    this.showCancel = ko.observable(false);\n    this.downloadingTimeout = 0;\n\n    this.startStatus = window.applicationCache.status;\n    this.continuedUpdate = false;\n    this.updateActionDone = false;\n\n    this.fnToRun = [ ];\n\n    // Once the page has loaded and there was no appcache update on load, we periodically check\n    // for updates on the fly. These updates should always post a new message instead of refreshing\n    // the page to avoid interrupting the user's experience.\n    this.dynamicUpdateCheck = false;\n\n    // When doing a dynamic update check, some updates (those to data version) will require the user\n    // to do an update. This will force them to reload their client.\n    this.requiredUpdate = false;\n\n    // Once an app update is found, keep track of whether there is a pending update that the user\n    // has ignored.\n    this.appUpdatePending = false;\n\n    this.isShowingProgress = false;\n\n\tthis.init();\n}\n\nAppCache.prototype = {\n\tinit: function()\n\t{\n        log('Cache Status: ' + this.startStatus);\n\n        window.applicationCache.addEventListener('noupdate', this.onCacheLoadFinished.bind(this));\n        window.applicationCache.addEventListener('cached', this.onFirstUpdateReady.bind(this));\n        window.applicationCache.addEventListener('downloading', this.onUpdateDownloading.bind(this));\n        window.applicationCache.addEventListener('updateready', this.onUpdateReady.bind(this));\n        window.applicationCache.addEventListener('obsolete', this.onCacheLoadFinished.bind(this));\n        window.applicationCache.addEventListener('error', this.onUpdateError.bind(this));\n        // window.applicationCache.addEventListener('progress', this.onProgress.bind(this));\n\n        if (window.applicationCache.status >= window.applicationCache.UPDATEREADY)\n        {\n            // this.notifyOfUpdate();\n            // this.onUpdateReady();\n        }\n        else if (!document.documentElement.attributes.getNamedItem('manifest'))\n        {\n            this.onCacheLoadFinished();\n        }\n\t},\n    isVisible: function(value)\n    {\n        if (!g.isDemoMode())\n        {\n            g.messageQueue.pushMessage(MessageID.Updated);\n        }\n        else\n        {\n            if (value)\n            {\n                g.reload();\n            }\n        }\n    },\n    update: function()\n    {\n        if (window.applicationCache.status === window.applicationCache.IDLE)\n        {\n            applicationCache.update();\n        }\n    },\n    checkForUpdate: function(forceUpdate)\n    {\n        this.requiredUpdate = !!forceUpdate;\n\n        if (!this.appUpdatePending)\n        {\n            this.dynamicUpdateCheck = true;\n\n            this.update();\n        }\n    },\n    runOnFinish: function(cb, isTerminal)\n    {\n        g.Assert(this.fnToRun.length === 0, 'Only a single callback is allowed to be run at this point.');\n\n        // Either delay running the given callback until the app cache has finished updating or\n        // run the callback async to give the same program execution to the calling API.\n        if (!this.isFinished)\n        {\n            this.fnToRun.push(cb);\n        }\n        else\n        {\n            setTimeout(cb, 0);\n        }\n    },\n    onUpdateReady: function()\n    {\n        log('Cache: New version available');\n        this.appUpdatePending = true;\n\n        if (this.startStatus === window.applicationCache.UNCACHED)\n        {\n            log('Cache Update from UNCACHED state. ERROR.');\n        }\n\n        // if (this.downloadingTimeout)\n        // {\n        //     clearTimeout(this.downloadingTimeout);\n        // }\n\n        this.onCacheLoadFinished();\n\n        // var timeSinceUpdating = this.timeShownUpdatingMessage ? (Date.now() - this.timeShownUpdatingMessage) : 0;\n        // if (timeSinceUpdating < this.minTimeShowUpdate)\n        // {\n        //     setTimeout(this.updateAction.bind(this), (this.minTimeShowUpdate - timeSinceUpdating));\n        // }\n        // else\n        // {\n            this.updateAction();\n        // }\n    },\n    onFirstUpdateReady: function()\n    {\n        log('Cache: first update');\n        // if (platform.mobile)\n        // {\n        //     this.closeMessage();\n        // }\n\n        // this.onCacheLoadFinished();\n        // this.unNotifyOfUpdate();\n    },\n    onUpdateError: function(ev)\n    {\n        if (!platform.demo && (!g.vmMain || g.vmMain.isOnline()))\n        {\n            log('Update Error: ', ev);\n\n            g.reportError(new Error('Error during app update'), ev);\n\n            function pushMessage()\n            {\n                if (g.messageQueue)\n                {\n                    g.messageQueue.pushMessage({\n                        text: 'Error updating app, ' + platform.actionVerb() + ' to retry.',\n                        type: MessageType.Error,\n                        action: MessageAction.Reload\n                    });\n                }\n            }\n\n            if (g.messageQueue)\n            {\n                pushMessage();\n            }\n            else\n            {\n                setTimeout(pushMessage, 5000);\n            }\n        }\n\n        // if (platform.mobile)\n        // {\n        //     this.closeMessage();\n        // }\n\n        this.isVisible(false);\n        this.onCacheLoadFinished();\n    },\n    onUpdateDownloading: function()\n    {\n        log('Cache: New version downloading');\n\n        // this.notifyOfUpdate();\n    },\n    onCacheLoadFinished: function()\n    {\n        //g.Assert(!this.isFinished, 'Should only call cache load finished once.');\n\n        log('Cache: No update');\n\n        if (!this.isFinished)\n        {\n            this.isFinished = true;\n\n            // g.setAppCacheUpdateState(false);\n\n            for (var i = 0; i < this.fnToRun.length; ++i)\n            {\n                this.fnToRun[i]();\n            }\n        }\n    },\n    // onProgress: function(e)\n    // {\n    //     if(e.lengthComputable)\n    //     {\n    //         if(!this.isShowingProgress)\n    //         {\n    //             this.isShowingProgress = true;\n    //             g.removeClass(g.element('updateProgress'), 'hidden');\n    //         }\n\n    //         var perc = (e.loaded / e.total) * 100;\n    //         g.element('updateProgress').value = perc;\n    //     }\n    // },\n    notifyOfUpdate: function()\n    {\n        if (this.notifiedOfNew)\n        {\n            return;\n        }\n\n        this.notifiedOfNew = true;\n\n        g.setAppCacheUpdateState(true);\n\n        // Ensure that the onUpdateReady handler will be called after the downloading starts\n        if (this.startStatus !== window.applicationCache.UNCACHED)\n        {\n            g.StopSpinner();\n\n            // g.element('outerWrapper').style.display = 'none';\n            // g.element('setupWrapper').style.display = 'none';\n\n            this.isVisible(true);\n\n            // this.timeShownUpdatingMessage = Date.now();\n\n            // this.downloadingTimeout = setTimeout(function()\n            // {\n            //     this.downloadingTimeout = 0;\n            //     this.showCancel(true);\n            // }.bind(this), this.timeToCancelButton);\n        }\n    },\n    // unNotifyOfUpdate: function()\n    // {\n    //     log('unNotify');\n    //     // g.element('outerWrapper').style.display = '';\n    //     // g.element('setupWrapper').style.display = '';\n\n    //     this.isVisible(false);\n    // },\n    updateAction: function()\n    {\n        // if (this.dynamicUpdateCheck)\n        // {\n            if (this.requiredUpdate)\n            {\n                g.messageQueue.pushMessage(MessageID.RequiredUpdate);\n            }\n            else\n            {\n                this.isVisible(true);\n                // g.messageQueue.pushMessage({\n                //     text: 'New version available, ' + platform.actionVerb() + ' to load.',\n                //     type: MessageType.Warning,\n                //     action: MessageAction.Reload\n                // });\n            }\n        // }\n        // else\n        // {\n            // if (this.updateActionDone)\n            // {\n            //     return;\n            // }\n\n            // this.updateActionDone = true;\n\n            // if (!this.continuedUpdate)\n            // {\n            //     g.reload();\n            // }\n            // else\n            // {\n                // this.isVisible(true);\n                // g.messageQueue.pushMessage({\n                //     text: 'New version available, ' + platform.actionVerb() + ' to load.',\n                //     type: MessageType.Warning,\n                //     action: MessageAction.Reload\n                // });\n            // }\n        // }\n\n        g.sendEvent('AppCache', 'Update');\n    },\n    // closeMessage: function()\n    // {\n    //     g.element('outerWrapper').style.display = '';\n    //     g.element('setupWrapper').style.display = '';\n\n    //     this.isVisible(false);\n    // },\n};\n\nreturn AppCache;\n});","asserts":[{"tag":1478,"offset":3060},{"tag":1479,"offset":5743}]}}}